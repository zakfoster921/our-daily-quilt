<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Quilt</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* ===== SCREENS ===== */
    .screen {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 3rem 0 10px 0;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      opacity: 1;
      pointer-events: auto;
      position: relative;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 900;
      font-size: clamp(2rem, 5vw, 3rem);
      margin-bottom: 0.1rem;
      letter-spacing: -0.02em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.2rem, 3vw, 1.6rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.5rem;
      margin: 3rem auto 2rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 150px;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(1rem, 2.5vw, 1.2rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem 0;
    }
    
    #colorWheelCanvas {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      /* Fallback for browsers that don't support conic-gradient */
      background: hsl(0, 95%, 55%);
      /* Modern browsers with conic-gradient support */
      background: conic-gradient(
        hsl(0, 100%, 55%),
        hsl(30, 100%, 55%),
        hsl(60, 100%, 55%),
        hsl(90, 100%, 55%),
        hsl(120, 100%, 55%),
        hsl(150, 100%, 55%),
        hsl(180, 100%, 55%),
        hsl(210, 100%, 55%),
        hsl(240, 100%, 55%),
        hsl(270, 100%, 55%),
        hsl(300, 100%, 55%),
        hsl(330, 100%, 55%),
        hsl(360, 100%, 55%)
      );
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      /* Add a subtle overlay to tone down the visual intensity */
      position: relative;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
  

    
    #colorWheelCanvas:hover {
      transform: scale(1.02);
    }
    
    #colorWheelCanvas:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; align-items: center;
      margin-top: 2rem;
      width: 100%;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    

    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
      }
      
      .css-color-wheel {
        width: 280px;
        height: 280px;
        /* Ensure conic-gradient works on mobile */
        background: hsl(0, 100%, 55%);
        background: -webkit-conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
        background: conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }
    
    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: center;
    }
    
    .archive-placeholder {
      font-size: 1.5rem;
      color: #999;
      margin: 2rem 0;
      font-style: italic;
    }
    
    .archive-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
    }
    
    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */

    
    #quilt {
      width: 90vw; height: 90vw;
      max-width: 600px; max-height: 600px;
      margin: 2rem auto;
      background: transparent;
      position: relative;
      display: block;
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Fabric texture using CSS */
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .screen { 
        padding: 2rem 1rem 10px 1rem; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      #quilt { 
        width: 100vw; 
        height: 100vw; 
        margin: 0;
        display: block;
        position: relative;
        max-width: none;
        max-height: none;
      }
      
      #screen-quilt {
        padding: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }
  </style>
</head>
<body>
  <main id="app">
    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
      <button class="btn" data-next="screen-welcome" aria-label="Start the daily experience">LET'S BEGIN</button>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">↓</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="35" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
                <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">
        <div id="phase-indicator" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; color: #666;">Collection Phase (0/5)</div>
        <svg id="quilt" viewBox="-100 -100 800 800" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
              <p class="thank-you-message" aria-live="polite">Thank you for adding your block! Look what we're making together <3</p>
        <button id="testAddBlock" class="btn" style="background: #ff6b6b; color: white; margin: 0.5rem;">TEST: Add Random Block</button>
        <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white; margin: 0.5rem;">SHOW ME MY PIECE</button>
        <button id="testDifferentUserBtn" class="btn" style="background: #9C27B0; color: white; margin: 0.5rem;">TEST: Simulate Different User</button>
        <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button>
        <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
        <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <div class="archive-content">
        <p class="archive-placeholder">Archive coming soon...</p>
        <p class="archive-description">Browse through past community quilts and see how our collective creativity has grown over time.</p>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

  <!-- Toast notifications -->
  <div id="toast" class="toast" role="alert" aria-live="polite"></div>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    // Configuration
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '2.0.0',
        defaultColor: '#f7b733',
        quiltSize: 600,
        minBlockSize: 40,
        animationDuration: 2000,
        toastDuration: 3000
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      }
    };

    // Utility functions
    function debounce(func, delay) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(null, args), delay);
      };
    }

    function hslToHex(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      
      let r, g, b;
      
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      const toHex = (c) => {
        const hex = Math.round(c * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function validateHexColor(color) {
      const hexRegex = /^#[0-9A-F]{6}$/i;
      return hexRegex.test(color);
    }

    // User identification helper
    function getOrCreateUserId() {
      let userId = localStorage.getItem('ourDailyUserId');
      if (!userId) {
        userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('ourDailyUserId', userId);
      }
      return userId;
    }

    function getTodayKey() {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function formatDate(date = new Date()) {
      return date.toLocaleDateString(undefined, {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    }

    function showToast(message, duration = CONFIG.APP.toastDuration) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), duration);
    }

    function showLoading(show = true) {
      const loading = document.getElementById('loading');
      if (!loading) return;
      if (show) {
        loading.classList.add('show');
      } else {
        loading.classList.remove('show');
      }
    }

    function handleError(error, context = 'Unknown') {
      console.error(`Error in ${context}:`, error);
      const errorMessages = {
        'loadQuilt': 'Failed to load quilt data. Starting fresh.',
        'saveQuilt': 'Failed to save your color. Please try again.',
        'shareFlow': 'Failed to create share image. Saving instead.',
        'colorPicker': 'Color picker error. Please try again.'
      };
      const message = errorMessages[context] || 'Something went wrong. Please try again.';
      showToast(message);
    }

    // Main application class
    class OurDailyApp {
      constructor() {
        this.blocks = []; // Start with empty quilt - first user submission creates the first piece
        this.pieces = []; // New: Individual pieces before patch formation
        this.patches = []; // New: Patches before block formation
        this.submissionCount = 0; // New: Track submissions for phase transitions
        this.currentPhase = 'collection'; // New: 'collection', 'patch-formation', 'block-formation'
        this.lastAddedIndex = null;
        this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
        this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
        this.colorHasBeenSelected = false;
        this.db = null;
        this.quiltDoc = null;
        this.currentScreen = 'screen-portal';
        
        // User identification system
        this.currentUserId = this.getOrCreateUserId();
        this.userPiecesHighlighted = false;
        
        this.quotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "— Pablo Picasso" },
          { text: "Creativity takes courage.", author: "— Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "— Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "— Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "— Vincent Van Gogh" },
          { text: "You can't use up creativity. The more you use, the more you have.", author: "— Maya Angelou" }
        ];
        this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
      }

      getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      async initialize() {
        try {
          console.log('Starting initialization...');
          showLoading(true);
          await this.initializeFirebase();
          console.log('Firebase initialized');
          this.setupEventListeners();
          console.log('Event listeners setup');
          this.initializeUI();
          console.log('UI initialized');
          await this.loadQuilt();
          console.log('Quilt loaded');
          
          // Initialize quilt SVG reference
          this.quiltSVG = document.getElementById('quilt');
          console.log('Quilt SVG found:', this.quiltSVG);
          if (!this.quiltSVG) {
            // Try to show the quilt screen first
            this.showScreen('screen-quilt');
            this.quiltSVG = document.getElementById('quilt');
            console.log('Quilt SVG after showing screen:', this.quiltSVG);
          }
          if (!this.quiltSVG) {
            throw new Error('Quilt SVG element not found');
          }
          
          this.isInitialized = true; // Set initialization flag
          console.log('App initialized successfully - isInitialized set to true');
          
          // Force initial render with a small delay to ensure DOM is ready
          setTimeout(() => {
            console.log('Delayed renderBlocks call - isInitialized:', this.isInitialized);
            // Double-check that quiltSVG is still available
            if (!this.quiltSVG) {
              this.quiltSVG = document.getElementById('quilt');
              console.log('Re-checking quiltSVG:', this.quiltSVG);
            }
            this.renderBlocks();
          }, 100);
          
          showLoading(false);
        } catch (error) {
          handleError(error, 'App initialization');
          showLoading(false);
        }
      }

      async initializeFirebase() {
        try {
          // Disable Firebase for easier testing
          console.log('Firebase disabled for testing');
          this.db = null;
          this.quiltDoc = null;
        } catch (error) {
          handleError(error, 'Firebase initialization');
          throw error;
        }
      }

      setupEventListeners() {
        // Navigation
        document.querySelectorAll(".btn[data-next]").forEach(btn => {
          btn.addEventListener("click", e => {
            e.preventDefault();
            const targetId = btn.getAttribute("data-next");
            if (targetId) this.showScreen(targetId);
          });
        });

        // Add color button
        const addColorBtn = document.getElementById('addColorBtn');
        if (addColorBtn) {
          addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
        }

        // Share button
        const shareBtnCompleted = document.getElementById('shareBtnCompleted');
        if (shareBtnCompleted) {
          shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
        }

        // Test button
        const testAddBlock = document.getElementById('testAddBlock');
        if (testAddBlock) {
          testAddBlock.addEventListener('click', this.handleTestAddBlock.bind(this));
        }

        // Show my piece button
        const showMyPieceBtn = document.getElementById('showMyPieceBtn');
        if (showMyPieceBtn) {
          showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
        }

        // Test different user button
        const testDifferentUserBtn = document.getElementById('testDifferentUserBtn');
        if (testDifferentUserBtn) {
          testDifferentUserBtn.addEventListener('click', this.handleTestDifferentUser.bind(this));
        }

        // Color picker
        this.setupColorPicker();
        
        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
      }

      setupColorPicker() {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const valueSlider = document.getElementById('valueSlider');

        if (!colorWheel || !indicator || !valueSlider) return;
        
        // Remove any existing preview elements
        const previewElement = document.getElementById('selectedColorPreview');
        if (previewElement) {
          previewElement.remove();
        }

        // Draw color wheel
        this.drawColorWheel();
        this.updatePreview();
        
        // Set slider to default value
        valueSlider.value = this.selectedLightness;
        
        // Force slider value after a small delay to ensure DOM is ready
        setTimeout(() => {
          valueSlider.value = this.selectedLightness;
        }, 100);
        
        // Set initial indicator position
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const radius = rect.width / 2;
        // Convert hue to radians and adjust for coordinate system
        // CSS conic-gradient starts at top (12 o'clock), so subtract 90 degrees
        const angleRad = (this.selectedHue - 90) * Math.PI / 180;
        const x = centerX + radius * Math.cos(angleRad);
        const y = centerY + radius * Math.sin(angleRad);
        
        if (indicator) {
          // Position relative to the color wheel container
          const container = colorWheel.parentElement;
          const containerRect = container.getBoundingClientRect();
          const relativeX = x + rect.left - containerRect.left;
          const relativeY = y + rect.top - containerRect.top;
          indicator.style.left = `${relativeX}px`;
          indicator.style.top = `${relativeY}px`;
        }

        // Event listeners
        const debouncedSetHue = debounce(this.setHueFromCoords.bind(this), 16);
        
        colorWheel.addEventListener('click', e => {
          const rect = colorWheel.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          // Only update if click is within the wheel bounds
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
          const radius = rect.width / 2;
          
          if (distance <= radius) {
            this.setHueFromCoords(x, y);
          }
        });

        colorWheel.addEventListener('mousedown', e => {
          const rect = colorWheel.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          // Only update if click is within the wheel bounds
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
          const radius = rect.width / 2;
          
          if (distance <= radius) {
            this.setHueFromCoords(x, y);
          }
        });

        document.addEventListener('mousemove', e => {
          if (e.buttons === 1) {
            const rect = colorWheel.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Only update if mouse is within the wheel bounds
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            const radius = rect.width / 2;
            
            if (distance <= radius) {
              debouncedSetHue(x, y);
            }
          }
        });

        valueSlider.addEventListener('input', () => {
          this.selectedLightness = Number(valueSlider.value);
          this.updatePreview();
        });


      }

      drawColorWheel() {
        // CSS-based color wheel doesn't need drawing
        // The conic-gradient CSS handles the rendering
      }



      updatePreview() {
        const valueSlider = document.getElementById('valueSlider');
        

        
        const hslColor = `hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, ${this.selectedLightness}%)`;
        const hexColor = hslToHex(this.selectedHue, CONFIG.COLOR_PICKER.saturation, this.selectedLightness);
        
        // Update color screen background only after a color has been selected
        const colorScreen = document.getElementById('screen-color');
        if (colorScreen && this.colorHasBeenSelected) {
          colorScreen.style.backgroundColor = hexColor;
        }
        

        
        if (valueSlider) {
          valueSlider.style.background = `linear-gradient(to right,
            hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 20%), 
            hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 90%))`;
        }
      }

      setHueFromCoords(x, y) {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = rect.width / 2;

        if (distance > radius) {
          // Clamp to the edge of the wheel
          const clampedDistance = radius;
          const clampedX = centerX + (dx / distance) * clampedDistance;
          const clampedY = centerY + (dy / distance) * clampedDistance;
          
          let angle = Math.atan2(dy, dx) * 180 / Math.PI;
          if (angle < 0) angle += 360;
          // Adjust for CSS conic-gradient coordinate system (starts at top, not right)
          this.selectedHue = Math.round((angle + 90) % 360);
          

          
          if (indicator) {
            // Position relative to the color wheel container
            const container = colorWheel.parentElement;
            const containerRect = container.getBoundingClientRect();
            const relativeX = clampedX + rect.left - containerRect.left;
            const relativeY = clampedY + rect.top - containerRect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        } else {
          let angle = Math.atan2(dy, dx) * 180 / Math.PI;
          if (angle < 0) angle += 360;
          
          // Adjust for CSS conic-gradient coordinate system (starts at top, not right)
          this.selectedHue = Math.round((angle + 90) % 360);
          

          
          if (indicator) {
            // Position relative to the color wheel container
            const container = colorWheel.parentElement;
            const containerRect = container.getBoundingClientRect();
            const relativeX = x + rect.left - containerRect.left;
            const relativeY = y + rect.top - containerRect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        }
        
        // Mark that a color has been selected
        this.colorHasBeenSelected = true;
        this.updatePreview();
      }

      initializeUI() {
        const dateText = document.getElementById("date-text");
        if (dateText) {
          dateText.textContent = formatDate();
        }
        this.displayQuote();
        this.showScreen('screen-portal');
      }

      showScreen(screenId) {
        document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
        const target = document.getElementById(screenId);
        if (target) {
          target.classList.add("active");
          this.currentScreen = screenId;
          
          // Reset color selection when entering color screen
          if (screenId === 'screen-color') {
            this.colorHasBeenSelected = false;
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen) {
              colorScreen.style.backgroundColor = '#f6f4f1'; // Reset to default background
            }
          }
          
          // Scroll to top of the screen with multiple methods for better compatibility
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          
          // Also scroll the main container if it exists
          const app = document.getElementById('app');
          if (app) {
            app.scrollTop = 0;
          }
        }
      }

      async loadQuilt() {
        try {
          showLoading(true);
          // Disable Firestore for easier testing
          console.log('loadQuilt: Firestore disabled, starting with empty quilt');
          this.blocks = []; // Start with empty quilt - first user submission creates the first piece
          
          if (this.isInitialized) {
            this.renderBlocks();
          }
          showLoading(false);
        } catch (error) {
          handleError(error, 'loadQuilt');
          showLoading(false);
          this.blocks = []; // Start with empty quilt - first user submission creates the first piece
          if (this.isInitialized) {
            this.renderBlocks();
          }
        }
      }

      async saveQuilt() {
        try {
          // Disable Firestore for easier testing
          console.log('saveQuilt: Firestore disabled, skipping save');
        } catch (error) {
          handleError(error, 'saveQuilt');
          throw error;
        }
      }

      renderBlocks() {
        console.log('renderBlocks called, isInitialized:', this.isInitialized, 'quiltSVG:', !!this.quiltSVG);
        if (!this.isInitialized) {
          console.warn('QuiltManager not initialized - returning early');
          return;
        }
        
        if (!this.quiltSVG) {
          console.warn('Quilt SVG not found - returning early');
          return;
        }

        try {
          // Clear existing content
          this.quiltSVG.innerHTML = '';
          
          // Create SVG definitions for organic edges and user highlight
          const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          defs.innerHTML = `
            <filter id="organicEdges" x="0" y="0" width="200%" height="200%">
              <feTurbulence baseFrequency="0.015" numOctaves="2" result="turb"/>
              <feDisplacementMap in="SourceGraphic" in2="turb" scale="2"/>
            </filter>
            <filter id="userHighlight" x="0" y="0" width="200%" height="200%">
              <feGaussianBlur stdDeviation="3" result="blur"/>
              <feFlood flood-color="#FFD700" flood-opacity="0.6" result="glow"/>
              <feComposite in="glow" in2="blur" operator="in" result="glowBlur"/>
              <feMerge>
                <feMergeNode in="glowBlur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>`;
          this.quiltSVG.appendChild(defs);
          
          // Add viewBox border for debugging
          const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          border.setAttribute('x', '-100');
          border.setAttribute('y', '-100');
          border.setAttribute('width', '800');
          border.setAttribute('height', '800');
          border.setAttribute('fill', 'none');
          border.setAttribute('stroke', '#ff0000');
          border.setAttribute('stroke-width', '2');
          border.setAttribute('stroke-dasharray', '5,5');
          this.quiltSVG.appendChild(border);

          // Render based on current phase
          if (this.currentPhase === 'collection') {
            // Render pieces
            this.pieces.forEach((piece, i) => {
              this.renderPiece(piece, i);
            });
          } else if (this.currentPhase === 'patch-formation') {
            // Render patches
            this.patches.forEach((patch, i) => {
              this.renderPatch(patch, i);
            });
          } else {
            // Render blocks
            this.blocks.forEach((block, i) => {
              this.renderBlock(block, i);
            });
          }

          // Update phase indicator
          this.updatePhaseIndicator();
          
          this.lastAddedIndex = null;
        } catch (error) {
          handleError(error, 'renderBlocks');
        }
      }

      renderPiece(piece, index) {
        // Render individual piece with organic edges
        const pathData = this.createOrganicPath(piece);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('fill', piece.color);
        
        // Apply user highlight if this is the current user's piece and highlighting is active
        if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
          path.setAttribute('filter', 'url(#userHighlight)');
        } else {
          path.setAttribute('filter', 'url(#organicEdges)');
        }
        
        // Animate all pieces that are newly added (last 4 pieces for first 5 submissions, last 2 for others)
        const piecesToAnimate = this.submissionCount <= 5 ? 4 : 2;
        const startIndex = this.pieces.length - piecesToAnimate;
        if (index >= startIndex) {
          path.classList.add('new-block');
        }
        
        this.quiltSVG.appendChild(path);
      }

      renderPatch(patch, index) {
        // Render patch with organic edges
        const pathData = this.createOrganicPath(patch);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('fill', patch.color);
        path.setAttribute('filter', 'url(#organicEdges)');
        
        if (index === this.patches.length - 1) {
          path.classList.add('new-block');
        }
        
        this.quiltSVG.appendChild(path);
      }

      renderBlock(block, index) {
        // Render block with organic edges (existing logic)
        const jiggerX = (Math.random() - 0.5) * 8;
        const jiggerY = (Math.random() - 0.5) * 8;
        const jiggeredBlock = {
          x: block.x + jiggerX,
          y: block.y + jiggerY,
          width: block.width,
          height: block.height,
          color: block.color,
          rotation: (Math.random() - 0.5) * 4
        };

        const pathData = this.createOrganicPath(jiggeredBlock);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('fill', jiggeredBlock.color);
        path.setAttribute('filter', 'url(#organicEdges)');
        
        const centerX = jiggeredBlock.x + jiggeredBlock.width / 2;
        const centerY = jiggeredBlock.y + jiggeredBlock.height / 2;
        path.setAttribute('transform', `rotate(${jiggeredBlock.rotation} ${centerX} ${centerY})`);
        
        if (index === this.blocks.length - 1) {
          path.classList.add('new-block');
        }
        
        this.quiltSVG.appendChild(path);
      }

      createOrganicPath(item) {
        // Create organic path with slight edge variations
        const variation = 3;
        const x1 = item.x + (Math.random() - 0.5) * variation;
        const y1 = item.y + (Math.random() - 0.5) * variation;
        const x2 = item.x + item.width + (Math.random() - 0.5) * variation;
        const y2 = item.y + (Math.random() - 0.5) * variation;
        const x3 = item.x + item.width + (Math.random() - 0.5) * variation;
        const y3 = item.y + item.height + (Math.random() - 0.5) * variation;
        const x4 = item.x + (Math.random() - 0.5) * variation;
        const y4 = item.y + item.height + (Math.random() - 0.5) * variation;
        
        return `M ${x1},${y1} L ${x2},${y2} L ${x3},${y3} L ${x4},${y4} Z`;
      }

      updatePhaseIndicator() {
        // Update UI to show current phase
        const phaseIndicator = document.getElementById('phase-indicator');
        if (phaseIndicator) {
          const phaseText = {
            'collection': `Collection Phase (${this.submissionCount}/5)`,
            'patch-formation': 'Patch Formation Phase',
            'block-formation': 'Block Formation Phase'
          };
          phaseIndicator.textContent = phaseText[this.currentPhase] || 'Unknown Phase';
        }
      }

      addPieceToQuilt(newColor) {
        try {
          if (!validateHexColor(newColor)) {
            throw new Error(`Invalid color format: ${newColor}`);
          }

          this.submissionCount++;
          
          // Early bird special: First 5 users get 4 pieces each
          const piecesToCreate = this.submissionCount <= 5 ? 4 : 2;
          
          // Create pieces for this submission
          const startIndex = this.pieces.length;
          for (let i = 0; i < piecesToCreate; i++) {
            const currentIndex = startIndex + i;
            console.log(`Creating piece ${currentIndex} for submission ${this.submissionCount}`);
            const piece = this.createPiece(newColor, currentIndex);
            this.pieces.push(piece);
          }
          
          // Phase transitions
          if (this.submissionCount === 6) {
            // Trigger patch formation
            this.currentPhase = 'patch-formation';
            this.patches = this.formPatchesFromPieces();
            this.pieces = []; // Clear pieces after patch formation
            showToast('Patch formation phase activated!');
          } else if (this.submissionCount === 7) {
            // Trigger block formation
            this.currentPhase = 'block-formation';
            
            // Create 2 additional pieces from 6th and 7th submissions
            const additionalPieces = [];
            for (let i = 0; i < 2; i++) {
              const piece = this.createPiece(newColor);
              additionalPieces.push(piece);
            }
            
            // Form additional patches from 6th + 7th submissions
            const additionalPatches = this.formPatchesFromPieces();
            this.patches.push(...additionalPatches);
            
            // Form blocks from all patches
            this.blocks = this.formBlocksFromPatches();
            this.patches = []; // Clear patches after block formation
            showToast('Block formation phase activated!');
          }
          
          this.lastAddedIndex = this.blocks.length - 1;
          return true;
          
        } catch (error) {
          handleError(error, 'addPieceToQuilt');
          return false;
        }
      }







      async handleAddColor() {
        try {
          const saturationSlider = document.getElementById('saturationSlider');
          const selectedSaturation = saturationSlider ? parseInt(saturationSlider.value) : CONFIG.COLOR_PICKER.saturation;
          
          // Use the exact color the user selected (no warm cast)
          const selectedColor = hslToHex(this.selectedHue, selectedSaturation, this.selectedLightness);
          

          
          if (!selectedColor) {
            showToast('Please select a color first');
            return;
          }

          const success = this.addPieceToQuilt(selectedColor);
          
          if (success) {
            // Store the last added index for sharing before renderBlocks resets it
            this.lastAddedForShare = this.lastAddedIndex;
            

            
            await this.saveQuilt();
            if (this.isInitialized) {
              this.renderBlocks();
            }
            this.showScreen('screen-quilt');
          }
        } catch (error) {
          handleError(error, 'handleAddColor');
          showToast('Failed to add color. Please try again.');
        }
      }

      async handleTestAddBlock() {
        try {
          // Generate random color with warm cast within user picker limitations
          const randomHue = Math.floor(Math.random() * 360); // Full hue range
          const randomSaturation = CONFIG.COLOR_PICKER.saturation; // Fixed at 65% to match user picker
          const randomLightness = 35 + Math.floor(Math.random() * 56); // Between 35-90 lightness (same as user slider)
          
          // Apply warm cast by shifting hue towards warm colors and adjusting saturation
          const warmHue = (randomHue + 25) % 360; // Shift towards warmer hues
          const warmSaturation = Math.min(randomSaturation + 5, 100); // Slightly increase saturation for warmth
          const randomColor = hslToHex(warmHue, warmSaturation, randomLightness);
          

          
          const success = this.addPieceToQuilt(randomColor);
          
          if (success) {
            this.lastAddedForShare = this.lastAddedIndex;
            await this.saveQuilt();
            if (this.isInitialized) {
              this.renderBlocks();
            }
            
            // Show appropriate message based on current phase
            let message;
            if (this.currentPhase === 'collection') {
              message = `Added ${this.submissionCount <= 5 ? 4 : 2} pieces! (${this.pieces.length} total pieces)`;
            } else if (this.currentPhase === 'patch-formation') {
              message = `Added pieces! (${this.patches.length} patches formed)`;
            } else {
              message = `Added pieces! (${this.blocks.length} blocks formed)`;
            }
            showToast(message);
          }
        } catch (error) {
          handleError(error, 'handleTestAddBlock');
          showToast('Test add failed.');
        }
      }

      handleShowMyPiece() {
        try {
          // Toggle highlighting
          this.userPiecesHighlighted = !this.userPiecesHighlighted;
          
          console.log(`Current user ID: ${this.currentUserId}`);
          console.log(`Total pieces: ${this.pieces.length}`);
          console.log(`Total patches: ${this.patches.length}`);
          console.log(`Total blocks: ${this.blocks.length}`);
          
          // Count user's pieces
          const userPieces = this.pieces.filter(piece => piece.userId === this.currentUserId);
          const userPatches = this.patches.filter(patch => 
            patch.pieces && patch.pieces.some(piece => piece.userId === this.currentUserId)
          );
          const userBlocks = this.blocks.filter(block => 
            block.patches && block.patches.some(patch => 
              patch.pieces && patch.pieces.some(piece => piece.userId === this.currentUserId)
            )
          );
          
          console.log(`User pieces found: ${userPieces.length}`);
          console.log(`User patches found: ${userPatches.length}`);
          console.log(`User blocks found: ${userBlocks.length}`);
          
          const totalUserPieces = userPieces.length + userPatches.length + userBlocks.length;
          
          if (this.userPiecesHighlighted) {
            if (totalUserPieces > 0) {
              showToast(`Found ${totalUserPieces} of your pieces! ✨`);
            } else {
              showToast("You haven't added any pieces yet. Try adding your first color!");
            }
          } else {
            showToast('Highlighting turned off');
          }
          
          // Re-render to show/hide highlights
          if (this.isInitialized) {
            this.renderBlocks();
          }
          
        } catch (error) {
          handleError(error, 'handleShowMyPiece');
          showToast('Failed to highlight your pieces. Please try again.');
        }
      }

      handleTestDifferentUser() {
        try {
          // Temporarily change the user ID to simulate a different user
          const originalUserId = this.currentUserId;
          this.currentUserId = `test_user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          console.log(`Switched from user: ${originalUserId} to: ${this.currentUserId}`);
          showToast(`Now simulating user: ${this.currentUserId.substring(0, 20)}...`);
          
          // Add a test piece with the new user ID
          const randomColor = hslToHex(Math.floor(Math.random() * 360), 65, 50);
          const success = this.addPieceToQuilt(randomColor);
          
          if (success) {
            this.lastAddedForShare = this.lastAddedIndex;
            if (this.isInitialized) {
              this.renderBlocks();
            }
            showToast(`Added piece for different user! Now try "SHOW ME MY PIECE"`);
          }
          
          // Reset back to original user after a delay
          setTimeout(() => {
            this.currentUserId = originalUserId;
            console.log(`Switched back to original user: ${originalUserId}`);
            showToast('Switched back to original user');
          }, 5000); // 5 seconds
          
        } catch (error) {
          handleError(error, 'handleTestDifferentUser');
          showToast('Failed to simulate different user.');
        }
      }

      async handleShare() {
        try {
          const shareBtn = document.getElementById('shareBtnCompleted');
          if (shareBtn) shareBtn.disabled = true;
          
          showToast("Preparing flyer...");
          await this.shareFlow();
          
          if (shareBtn) shareBtn.disabled = false;
        } catch (error) {
          handleError(error, 'handleShare');
          showToast('Share failed. Saving instead.');
          
          const shareBtn = document.getElementById('shareBtnCompleted');
          if (shareBtn) shareBtn.disabled = false;
        }
      }

      async shareFlow() {
        try {
                      // Use the stored last added index for sharing
            const lastAddedIndex = this.lastAddedForShare;
            
            // Also store the index of the block that was split
            const splitBlockIndex = this.lastSplitBlockIndex;
          const quiltElement = document.getElementById('quilt');
          const clonedSVG = quiltElement.cloneNode(true);
          clonedSVG.removeAttribute('id');
          clonedSVG.setAttribute('width', '800');
          clonedSVG.setAttribute('height', '800');
          clonedSVG.style.transform = "rotate(-5deg)";
          
          // Expand viewBox by small fixed amount for all instances
          const originalViewBox = clonedSVG.getAttribute('viewBox');
          if (originalViewBox) {
            const [x, y, width, height] = originalViewBox.split(' ').map(Number);
            const fixedPadding = 20; // Small, consistent padding for all instances
            

            
            const newViewBox = `${x - fixedPadding} ${y - fixedPadding} ${width + fixedPadding * 2} ${height + fixedPadding * 2}`;
            clonedSVG.setAttribute('viewBox', newViewBox);
            
            // Add background rect FIRST (before any quilt blocks) to ensure it's behind everything
            const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bgRect.setAttribute('x', x - fixedPadding);
            bgRect.setAttribute('y', y - fixedPadding);
            bgRect.setAttribute('width', width + fixedPadding * 2);
            bgRect.setAttribute('height', height + fixedPadding * 2);
            bgRect.setAttribute('fill', '#f6f4f1');
            bgRect.setAttribute('stroke', 'none');
            bgRect.setAttribute('opacity', '1'); // Ensure fully opaque
            bgRect.setAttribute('filter', 'none'); // Explicitly disable any filters
            bgRect.setAttribute('style', 'filter: none !important;'); // Force no filters
            clonedSVG.insertBefore(bgRect, clonedSVG.firstChild);
            
            // Also set the SVG background color to match
            clonedSVG.style.backgroundColor = '#f6f4f1';
            

          }

          const wrapper = document.createElement('div');
          wrapper.style.width = '1080px';
          wrapper.style.height = '1920px';
          wrapper.style.background = '#f6f4f1';
          wrapper.style.display = 'flex';
          wrapper.style.flexDirection = 'column';
          wrapper.style.alignItems = 'center';
          wrapper.style.padding = '100px 60px 80px 60px';
          wrapper.style.fontFamily = "system-ui, sans-serif";

          const title = document.createElement('h1');
          title.textContent = "OUR DAILY";
          title.style.fontSize = '96px';
          title.style.fontWeight = '900';
          title.style.margin = '0';

          const date = document.createElement('p');
          date.textContent = formatDate();
          date.style.fontSize = '48px';
          date.style.margin = '0 0 40px 0';

          const quoteCard = document.createElement('div');
          quoteCard.style.border = '4px solid #000';
          quoteCard.style.borderRadius = '16px';
          quoteCard.style.padding = '20px 30px';
          quoteCard.style.marginBottom = '60px';
          quoteCard.style.maxWidth = '800px';
          quoteCard.style.textAlign = 'left';

          const quoteLine = document.createElement('p');
          quoteLine.textContent = `"${this.getTodayQuote().text}"`;
          quoteLine.style.fontSize = '60px';
          quoteLine.style.fontStyle = 'italic';
          quoteLine.style.fontWeight = '600';
          quoteLine.style.margin = '0 0 10px 0';
          quoteLine.style.lineHeight = '1.1';

          const quoteAuthor = document.createElement('p');
          quoteAuthor.textContent = this.getTodayQuote().author;
          quoteAuthor.style.fontSize = '60px';
          quoteAuthor.style.fontWeight = '500';
          quoteAuthor.style.margin = '0';
          quoteAuthor.style.lineHeight = '1.1';

          quoteCard.appendChild(quoteLine);
          quoteCard.appendChild(quoteAuthor);

          const quiltContainer = document.createElement('div');
          quiltContainer.style.width = '800px';
          quiltContainer.style.height = '800px';
          quiltContainer.style.transform = "rotate(-5deg)";
          quiltContainer.style.position = "relative";
          quiltContainer.appendChild(clonedSVG);
          
          // Identify the last added block by local user
          if (lastAddedIndex !== null && lastAddedIndex < this.blocks.length) {
            const lastAddedBlock = this.blocks[lastAddedIndex];
            
            // Find blocks with similar colors to the target
            const similarBlocks = this.blocks.filter(block => {
              const targetColor = lastAddedBlock.color;
              return block.color === targetColor || 
                     block.color.includes(targetColor.substring(1, 4)) ||
                     block.color.includes(targetColor.substring(4, 7));
            });

            
            // ADD VISUAL INDICATOR: Simple dot on the last added block
            const blockCenterX = lastAddedBlock.x + lastAddedBlock.width / 2;
            const blockCenterY = lastAddedBlock.y + lastAddedBlock.height / 2;
            

            
            // Create SVG circle element that encircles the block
            const blockWidth = lastAddedBlock.width;
            const blockHeight = lastAddedBlock.height;
            
            // Calculate circle radius to fit around the block with padding
            const padding = 8; // Padding around the block
            const radius = Math.max(blockWidth, blockHeight) / 2 + padding;
            
            const circleSVG = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleSVG.setAttribute('cx', blockCenterX);
            circleSVG.setAttribute('cy', blockCenterY);
            circleSVG.setAttribute('r', radius);
            circleSVG.setAttribute('fill', 'none'); // Transparent fill
            circleSVG.setAttribute('stroke', '#000000');
            circleSVG.setAttribute('stroke-width', '3');
            circleSVG.setAttribute('opacity', '0.6'); // Semi-transparent
            

            
            // Add the circle to the SVG
            clonedSVG.appendChild(circleSVG);
            
          }  

          const footer = document.createElement('div');
          footer.style.width = '100%';
          footer.style.display = 'flex';
          footer.style.flexDirection = 'column';
          footer.style.alignItems = 'flex-end';
          footer.style.marginTop = '60px';
          footer.style.paddingRight = '40px';

          const bigLine = document.createElement('span');
          bigLine.textContent = 'ADD YOUR COLOR';
          bigLine.style.fontSize = '55px';
          bigLine.style.fontWeight = '900';

          const smallLine = document.createElement('span');
          smallLine.innerHTML = 'Visit <strong>@zakfoster.quilts</strong> — link in bio';
          smallLine.style.fontSize = '44px';
          smallLine.style.fontWeight = '400';

          footer.appendChild(bigLine);
          footer.appendChild(smallLine);

          const headerGroup = document.createElement('div');
          headerGroup.style.alignSelf = 'flex-start';
          headerGroup.style.textAlign = 'left';
          headerGroup.style.marginLeft = '60px';

          headerGroup.appendChild(title);
          headerGroup.appendChild(date);
          headerGroup.appendChild(quoteCard);

          wrapper.appendChild(headerGroup);
          wrapper.appendChild(quiltContainer);
          wrapper.appendChild(footer);

          document.body.appendChild(wrapper);

          try {
            const canvas = await html2canvas(wrapper, {
              scale: 1, // Reduced scale for better performance
              backgroundColor: '#f6f4f1',
              useCORS: true,
              allowTaint: true,
              logging: false, // Disable logging to reduce noise
              width: 1080,
              height: 1920
            });

            document.body.removeChild(wrapper);

            // Use toDataURL instead of toBlob for better compatibility
            const dataURL = canvas.toDataURL('image/png', 0.9);

            // Try native sharing first
            if (navigator.canShare) {
              try {
                // Convert data URL to blob
                const response = await fetch(dataURL);
                const blob = await response.blob();
                
                const filesArray = [new File([blob], 'community-quilt.png', { type: 'image/png' })];
                const shareData = {
                  files: filesArray,
                  title: "Today's Community Quilt",
                  text: "Tag me on Instagram if you're sharing! @zakfoster.quilts 🌈✨"
                };

                await navigator.share(shareData);
                showToast("Thanks for sharing! Tag me @zakfoster.quilts 🌈✨");
                return;
              } catch (shareError) {
                // Fallback to download on share error
              }
            }

            // Fallback to download
            const link = document.createElement('a');
            link.download = 'community-quilt.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast("Image saved! Tag me @zakfoster.quilts 🌈✨");
            
          } catch (canvasError) {
            console.error('Error in html2canvas:', canvasError);
            if (document.body.contains(wrapper)) {
              document.body.removeChild(wrapper);
            }
            handleError(canvasError, 'shareFlow');
          }

        } catch (error) {
          handleError(error, 'shareFlow');
          throw error;
        }
      }

      getTodayQuote() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayString = `${year}-${month}-${day}`;
        const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        return this.quotes[quoteIndex];
      }

      displayQuote() {
        try {
          const { text, author } = this.getTodayQuote();
          const quoteLine = document.querySelector('.quote-line');
          const quoteAuthor = document.querySelector('.quote-author');
          
          if (quoteLine) quoteLine.textContent = text;
          if (quoteAuthor) quoteAuthor.textContent = author;
        } catch (error) {
          handleError(error, 'displayQuote');
        }
      }

      checkForOverlaps(currentBlock, currentIndex) {
        // Check if current block overlaps with any previous blocks
        for (let i = 0; i < currentIndex; i++) {
          const previousBlock = this.blocks[i];
          
          // Simple rectangle overlap detection
          const overlapX = Math.max(0, 
            Math.min(currentBlock.x + currentBlock.width, previousBlock.x + previousBlock.width) - 
            Math.max(currentBlock.x, previousBlock.x)
          );
          
          const overlapY = Math.max(0,
            Math.min(currentBlock.y + currentBlock.height, previousBlock.y + previousBlock.height) - 
            Math.max(currentBlock.y, previousBlock.y)
          );
          
          // If there's significant overlap (more than 20% of either block's area)
          const overlapArea = overlapX * overlapY;
          const currentArea = currentBlock.width * currentBlock.height;
          const previousArea = previousBlock.width * previousBlock.height;
          
          if (overlapArea > 0 && (overlapArea > currentArea * 0.2 || overlapArea > previousArea * 0.2)) {
            return true;
          }
        }
        return false;
      }

      checkEdgeAdjacency(currentBlock, edgePosition) {
        // Check if a specific edge of the current block is adjacent to other blocks
        const tolerance = 10; // Distance tolerance for adjacency
        
        for (let i = 0; i < this.blocks.length; i++) {
          const otherBlock = this.blocks[i];
          if (otherBlock === currentBlock) continue;
          
          let isAdjacent = false;
          
          switch (edgePosition) {
            case 'top':
              // Check if this block's top edge is near another block's bottom edge
              isAdjacent = Math.abs(currentBlock.y - (otherBlock.y + otherBlock.height)) < tolerance;
              break;
            case 'right':
              // Check if this block's right edge is near another block's left edge
              isAdjacent = Math.abs((currentBlock.x + currentBlock.width) - otherBlock.x) < tolerance;
              break;
            case 'bottom':
              // Check if this block's bottom edge is near another block's top edge
              isAdjacent = Math.abs((currentBlock.y + currentBlock.height) - otherBlock.y) < tolerance;
              break;
            case 'left':
              // Check if this block's left edge is near another block's right edge
              isAdjacent = Math.abs(currentBlock.x - (otherBlock.x + otherBlock.width)) < tolerance;
              break;
          }
          
          if (isAdjacent) return true;
        }
        
        return false;
      }

      isOuterEdge(currentBlock, edgePosition) {
        // Check if this edge is on the outer boundary of the quilt
        const quiltBounds = this.getQuiltBounds();
        const tolerance = 15; // Larger tolerance to allow more freedom
        
        switch (edgePosition) {
          case 'top':
            return Math.abs(currentBlock.y - quiltBounds.top) < tolerance;
          case 'right':
            return Math.abs((currentBlock.x + currentBlock.width) - quiltBounds.right) < tolerance;
          case 'bottom':
            return Math.abs((currentBlock.y + currentBlock.height) - quiltBounds.bottom) < tolerance;
          case 'left':
            return Math.abs(currentBlock.x - quiltBounds.left) < tolerance;
          default:
            return false;
        }
      }

      getQuiltBounds() {
        // Calculate the bounding box of all blocks
        if (this.blocks.length === 0) {
          // Return default bounds for empty quilt
          return { top: 0, right: 600, bottom: 600, left: 0 };
        }
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        this.blocks.forEach(block => {
          minX = Math.min(minX, block.x);
          minY = Math.min(minY, block.y);
          maxX = Math.max(maxX, block.x + block.width);
          maxY = Math.max(maxY, block.y + block.height);
        });
        
        return { top: minY, right: maxX, bottom: maxY, left: minX };
      }

      createOrganicQuiltBoundary(bounds) {
        // Create a fixed, large plastic dropcloth that doesn't change size
        const dropclothSize = 800; // Large fixed size
        const centerX = 300; // Center of 600px quilt area
        const centerY = 300;
        
        // Create fixed bounds for the dropcloth
        const expandedBounds = {
          top: centerY - dropclothSize / 2,
          right: centerX + dropclothSize / 2,
          bottom: centerY + dropclothSize / 2,
          left: centerX - dropclothSize / 2
        };
        
        // Organic edge variation for the dropcloth
        const variation = 25; // More organic edge variation
        
        // Create organic edge points for each side
        const createOrganicSide = (startX, startY, endX, endY, isVertical = false) => {
          const numPoints = 8; // More points for smoother curves
          const points = [];
          
          for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            const x = startX + (endX - startX) * t;
            const y = startY + (endY - startY) * t;
            
            // Add organic variation
            const variationAmount = (Math.random() - 0.5) * variation;
            const organicX = x + (isVertical ? variationAmount : 0);
            const organicY = y + (isVertical ? 0 : variationAmount);
            
            points.push({ x: organicX, y: organicY });
          }
          
          return points;
        };
        
        // Generate organic sides
        const topSide = createOrganicSide(expandedBounds.left, expandedBounds.top, expandedBounds.right, expandedBounds.top, false);
        const rightSide = createOrganicSide(expandedBounds.right, expandedBounds.top, expandedBounds.right, expandedBounds.bottom, true);
        const bottomSide = createOrganicSide(expandedBounds.right, expandedBounds.bottom, expandedBounds.left, expandedBounds.bottom, false);
        const leftSide = createOrganicSide(expandedBounds.left, expandedBounds.bottom, expandedBounds.left, expandedBounds.top, true);
        
        // Create path with organic boundary
        const pathData = `M ${topSide[0].x},${topSide[0].y}
                          ${topSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${topSide[topSide.length - 1].x},${topSide[topSide.length - 1].y}
                          ${rightSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${rightSide[rightSide.length - 1].x},${rightSide[rightSide.length - 1].y}
                          ${bottomSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${bottomSide[bottomSide.length - 1].x},${bottomSide[bottomSide.length - 1].y}
                          ${leftSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${leftSide[leftSide.length - 1].x},${leftSide[leftSide.length - 1].y} Z`;
        
        return pathData;
      }

      handleKeyDown(event) {
        if (event.key === 'Escape') {
          if (this.currentScreen === 'screen-quote') {
            this.showScreen('screen-portal');
          } else if (this.currentScreen === 'screen-color') {
            this.showScreen('screen-quote');
          } else if (this.currentScreen === 'screen-quilt') {
            this.showScreen('screen-color');
          }
        }
      }

      tryToJoinPatches(patch1, patch2) {
        // Check if patches can be joined along edges of similar length
        const tolerance = 0.2; // 20% tolerance for "similar" lengths
        
        // Check horizontal joining (patch1 right edge to patch2 left edge)
        if (Math.abs(patch1.height - patch2.height) / Math.max(patch1.height, patch2.height) < tolerance) {
          if (this.canJoinHorizontally(patch1, patch2)) {
            return this.joinPatchesHorizontally(patch1, patch2);
          }
        }
        
        // Check vertical joining (patch1 bottom edge to patch2 top edge)
        if (Math.abs(patch1.width - patch2.width) / Math.max(patch1.width, patch2.width) < tolerance) {
          if (this.canJoinVertically(patch1, patch2)) {
            return this.joinPatchesVertically(patch1, patch2);
          }
        }
        
        return null; // Cannot join
      }

      canJoinHorizontally(item1, item2) {
        // Check if items can be joined horizontally (right edge of item1 to left edge of item2)
        const gap = Math.abs((item1.x + item1.width) - item2.x);
        return gap < 20; // Allow small gap for organic feel
      }

      canJoinVertically(item1, item2) {
        // Check if items can be joined vertically (bottom edge of item1 to top edge of item2)
        const gap = Math.abs((item1.y + item1.height) - item2.y);
        return gap < 20; // Allow small gap for organic feel
      }

      joinPatchesHorizontally(patch1, patch2) {
        return {
          x: Math.min(patch1.x, patch2.x),
          y: Math.min(patch1.y, patch2.y),
          width: patch1.width + patch2.width,
          height: Math.max(patch1.height, patch2.height),
          color: patch2.color, // Use the newer patch's color
          type: 'block',
          patches: [patch1, patch2]
        };
      }

      joinPatchesVertically(patch1, patch2) {
        return {
          x: Math.min(patch1.x, patch2.x),
          y: Math.min(patch1.y, patch2.y),
          width: Math.max(patch1.width, patch2.width),
          height: patch1.height + patch2.height,
          color: patch2.color, // Use the newer patch's color
          type: 'block',
          patches: [patch1, patch2]
        };
      }

      createPiece(color, pieceIndex) {
        console.log('createPiece: LOOSE GRID PLACEMENT for piece', pieceIndex);
        
        // Simple sequential loose grid placement
        const viewBoxWidth = 800;
        const viewBoxHeight = 800; // Make it square
        const padding = 50;
        const gridCols = 5; // 5 pieces across
        const gridRows = 5; // 5 rows down (make it square grid)
        const gridJitter = 15; // Reduced jitter to prevent overlaps
        
        // Calculate grid cell size to fit within viewBox
        const availableWidth = viewBoxWidth - 2 * padding; // 800 - 100 = 700px
        const availableHeight = viewBoxHeight - 2 * padding; // 800 - 100 = 700px
        
        // Calculate cell size based on available space
        const cellWidth = availableWidth / gridCols; // 700 / 5 = 140px
        const cellHeight = availableHeight / gridRows; // 700 / 5 = 140px
        
        // Ensure pieces fit within cells with some spacing
        const maxPieceSize = Math.min(cellWidth, cellHeight) * 0.8; // 80% of smaller cell dimension
        const minSpacing = 10; // Reduced minimum spacing
        
        // Create a piece with organic, slightly irregular shape
        const minSize = Math.max(40, maxPieceSize * 0.4); // At least 40px, but 40% of max size
        const maxSize = maxPieceSize; // Use the calculated max size
        const baseSize = minSize + Math.random() * (maxSize - minSize);
        
        // Determine if square or rectangle (70% square, 30% rectangle)
        const isSquare = Math.random() < 0.7;
        let width, height;
        
        if (isSquare) {
          width = baseSize;
          height = baseSize;
        } else {
          // Rectangle with aspect ratio between 1:1.5 and 1.5:1
          const aspectRatio = 1 + (Math.random() - 0.5) * 0.5; // 0.75 to 1.25
          width = baseSize;
          height = baseSize * aspectRatio;
        }
        
        // Add organic edge variations
        const edgeVariation = 0.1; // 10% variation
        width += (Math.random() - 0.5) * width * edgeVariation;
        height += (Math.random() - 0.5) * height * edgeVariation;
        
        // Calculate safe jitter (ensure pieces don't overlap)
        const maxJitterForCell = Math.min(gridJitter, (Math.min(cellWidth, cellHeight) - maxPieceSize) / 2);
        const actualJitter = Math.max(0, maxJitterForCell);
        
        // Use passed pieceIndex for sequential placement
        const gridX = pieceIndex % gridCols;
        const gridY = Math.floor(pieceIndex / gridCols); // Fixed: was gridRows, should be gridCols
        
        // Calculate base position in grid cell with better spacing
        // Center the grid in the viewBox (accounting for viewBox starting at -100)
        const totalGridWidth = gridCols * cellWidth;
        const totalGridHeight = gridRows * cellHeight;
        const gridStartX = -100 + (viewBoxWidth - totalGridWidth) / 2;
        const gridStartY = -100 + (viewBoxHeight - totalGridHeight) / 2;
        
        const baseX = gridStartX + gridX * cellWidth + cellWidth / 2;
        const baseY = gridStartY + gridY * cellHeight + cellHeight / 2;
        
        console.log(`Piece ${pieceIndex}: Grid position (${gridX}, ${gridY}), Cell size: ${cellWidth.toFixed(1)}x${cellHeight.toFixed(1)}, Max piece size: ${maxPieceSize.toFixed(1)}px, Jitter: ${actualJitter.toFixed(1)}px`);
        
        // Add jitter for organic feel (reduced to prevent touching)
        const jitterX = (Math.random() - 0.5) * Math.min(actualJitter, 8); // Reduced max jitter
        const jitterY = (Math.random() - 0.5) * Math.min(actualJitter, 8); // Reduced max jitter
        
        let x = baseX + jitterX;
        let y = baseY + jitterY;
        
        // Ensure piece stays within bounds and doesn't touch adjacent cells
        const minSpacingFromEdge = 5; // Minimum distance from cell edge
        const cellLeft = gridStartX + gridX * cellWidth;
        const cellRight = gridStartX + (gridX + 1) * cellWidth;
        const cellTop = gridStartY + gridY * cellHeight;
        const cellBottom = gridStartY + (gridY + 1) * cellHeight;
        
        // Constrain piece to cell bounds with spacing
        x = Math.max(cellLeft + minSpacingFromEdge, Math.min(x, cellRight - width - minSpacingFromEdge));
        y = Math.max(cellTop + minSpacingFromEdge, Math.min(y, cellBottom - height - minSpacingFromEdge));
        
        // Fallback bounds check (accounting for viewBox starting at -100)
        x = Math.max(-100, Math.min(x, 700 - width));
        y = Math.max(-100, Math.min(y, 700 - height));
        
        const piece = {
          id: `piece_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          userId: this.currentUserId,
          submissionId: this.submissionCount,
          pieceIndex: pieceIndex,
          timestamp: Date.now(),
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          type: 'piece',
          edges: this.calculateEdges(width, height) // Store edge lengths for matching
        };
        
        console.log(`Created piece for user: ${this.currentUserId} (submission ${this.submissionCount}, piece ${pieceIndex})`);
        return piece;
      }



      calculateEdges(width, height) {
        // Calculate the four edge lengths for matching
        return {
          top: width,
          right: height,
          bottom: width,
          left: height
        };
      }

      createPatch(pieces) {
        // Combine pieces into a patch
        if (pieces.length < 2) return null;
        
        // Calculate patch bounds
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        pieces.forEach(piece => {
          minX = Math.min(minX, piece.x);
          minY = Math.min(minY, piece.y);
          maxX = Math.max(maxX, piece.x + piece.width);
          maxY = Math.max(maxY, piece.y + piece.height);
        });
        
        return {
          id: `patch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
          color: pieces[0].color, // Use first piece's color
          type: 'patch',
          pieces: pieces,
          edges: this.calculateEdges(maxX - minX, maxY - minY)
        };
      }

      createBlock(patches) {
        // Combine patches into a block
        if (patches.length < 2) return null;
        
        // Calculate block bounds
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        patches.forEach(patch => {
          minX = Math.min(minX, patch.x);
          minY = Math.min(minY, patch.y);
          maxX = Math.max(maxX, patch.x + patch.width);
          maxY = Math.max(maxY, patch.y + patch.height);
        });
        
        return {
          id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
          color: patches[0].color, // Use first patch's color
          type: 'block',
          patches: patches,
          edges: this.calculateEdges(maxX - minX, maxY - minY)
        };
      }

      findBestMatch(items, targetItem) {
        // Find the best match for combining items based on edge lengths
        let bestMatch = null;
        let bestScore = Infinity;
        const tolerance = 0.2; // 20% tolerance for "similar" lengths
        
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item === targetItem) continue;
          
          // Check all edge combinations
          const targetEdges = targetItem.edges;
          const itemEdges = item.edges;
          
          // Check horizontal joining (target right edge to item left edge)
          const horizontalScore = this.calculateEdgeScore(targetEdges.right, itemEdges.left);
          
          // Check vertical joining (target bottom edge to item top edge)
          const verticalScore = this.calculateEdgeScore(targetEdges.bottom, itemEdges.top);
          
          // Take the better score
          const score = Math.min(horizontalScore, verticalScore);
          
          if (score < bestScore) {
            bestScore = score;
            bestMatch = {
              item: item,
              score: score,
              joinType: score === horizontalScore ? 'horizontal' : 'vertical'
            };
          }
        }
        
        return bestMatch;
      }

      calculateEdgeScore(length1, length2) {
        // Calculate how well two edge lengths match
        const difference = Math.abs(length1 - length2);
        const averageLength = (length1 + length2) / 2;
        return difference / averageLength; // Lower is better
      }

      combineItems(item1, item2, joinType) {
        // Combine two items based on join type
        let combinedWidth, combinedHeight, combinedX, combinedY;
        
        if (joinType === 'horizontal') {
          // Adjust lengths to match
          const targetLength = (item1.edges.right + item2.edges.left) / 2;
          const adjustedWidth1 = item1.width;
          const adjustedWidth2 = item2.width;
          
          combinedWidth = item1.width + adjustedWidth2;
          combinedHeight = Math.max(item1.height, item2.height);
          combinedX = item1.x;
          combinedY = Math.min(item1.y, item2.y);
        } else {
          // Vertical join
          const targetLength = (item1.edges.bottom + item2.edges.top) / 2;
          const adjustedHeight1 = item1.height;
          const adjustedHeight2 = item2.height;
          
          combinedWidth = Math.max(item1.width, item2.width);
          combinedHeight = item1.height + adjustedHeight2;
          combinedX = Math.min(item1.x, item2.x);
          combinedY = item1.y;
        }
        
        return {
          width: combinedWidth,
          height: combinedHeight,
          x: combinedX,
          y: combinedY
        };
      }

      formPatchesFromPieces() {
        // Combine pieces into patches using edge matching
        const pieces = [...this.pieces];
        const patches = [];
        
        while (pieces.length >= 2) {
          const piece1 = pieces.shift();
          const bestMatch = this.findBestMatch(pieces, piece1);
          
          if (bestMatch && bestMatch.score < 0.3) { // Good enough match
            const piece2 = bestMatch.item;
            pieces.splice(pieces.indexOf(piece2), 1);
            
            const combined = this.combineItems(piece1, piece2, bestMatch.joinType);
            const patch = this.createPatch([piece1, piece2]);
            if (patch) {
              patch.x = combined.x;
              patch.y = combined.y;
              patch.width = combined.width;
              patch.height = combined.height;
              patches.push(patch);
            }
          } else {
            // No good match found, keep as individual piece
            patches.push(this.createPatch([piece1]));
          }
        }
        
        // Handle remaining single piece
        if (pieces.length === 1) {
          patches.push(this.createPatch([pieces[0]]));
        }
        
        return patches;
      }

      formBlocksFromPatches() {
        // Combine patches into blocks using edge matching
        const patches = [...this.patches];
        const blocks = [];
        
        while (patches.length >= 2) {
          const patch1 = patches.shift();
          const bestMatch = this.findBestMatch(patches, patch1);
          
          if (bestMatch && bestMatch.score < 0.3) { // Good enough match
            const patch2 = bestMatch.item;
            patches.splice(patches.indexOf(patch2), 1);
            
            const combined = this.combineItems(patch1, patch2, bestMatch.joinType);
            const block = this.createBlock([patch1, patch2]);
            if (block) {
              block.x = combined.x;
              block.y = combined.y;
              block.width = combined.width;
              block.height = combined.height;
              blocks.push(block);
            }
          } else {
            // No good match found, keep as individual patch
            blocks.push(this.createBlock([patch1]));
          }
        }
        
        // Handle remaining single patch
        if (patches.length === 1) {
          blocks.push(this.createBlock([patches[0]]));
        }
        
        return blocks;
      }

      isOverlapping(x, y, width, height) {
        // Check if the new piece overlaps with any existing pieces
        const newPiece = { x, y, width, height };
        
        console.log(`Checking overlap for new piece: x=${x.toFixed(1)}, y=${y.toFixed(1)}, w=${width.toFixed(1)}, h=${height.toFixed(1)}`);
        console.log(`Existing pieces: ${this.pieces.length}`);
        
        // Check against existing pieces
        for (let i = 0; i < this.pieces.length; i++) {
          const piece = this.pieces[i];
          const overlaps = this.rectanglesOverlap(newPiece, piece);
          const tooClose = this.isTooClose(newPiece, piece);
          console.log(`Piece ${i}: x=${piece.x.toFixed(1)}, y=${piece.y.toFixed(1)}, w=${piece.width.toFixed(1)}, h=${piece.height.toFixed(1)}, overlaps=${overlaps}, tooClose=${tooClose}`);
          
          if (overlaps || tooClose) {
            return true;
          }
        }
        
        return false;
      }

      isTooClose(rect1, rect2) {
        // Check if pieces are too close to each other (minimum distance requirement)
        const minDistance = 40; // Increased minimum distance for better spacing
        
        const center1 = {
          x: rect1.x + rect1.width / 2,
          y: rect1.y + rect1.height / 2
        };
        
        const center2 = {
          x: rect2.x + rect2.width / 2,
          y: rect2.y + rect2.height / 2
        };
        
        const distance = Math.sqrt(
          Math.pow(center1.x - center2.x, 2) + 
          Math.pow(center1.y - center2.y, 2)
        );
        
        return distance < minDistance;
      }

      rectanglesOverlap(rect1, rect2) {
        // Check if two rectangles overlap
        const tolerance = 5; // Even stricter tolerance for more spacing
        
        const overlapX = Math.max(0, 
          Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - 
          Math.max(rect1.x, rect2.x)
        );
        
        const overlapY = Math.max(0,
          Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - 
          Math.max(rect1.y, rect2.y)
        );
        
        const overlaps = overlapX > tolerance || overlapY > tolerance;
        console.log(`  Overlap check: X=${overlapX.toFixed(1)}, Y=${overlapY.toFixed(1)}, tolerance=${tolerance}, overlaps=${overlaps}`);
        
        // If there's significant overlap (more than tolerance), consider it overlapping
        return overlaps;
      }

      hasDirectOverlap(x, y, width, height) {
        // Check only for direct overlaps, not minimum distance
        const newPiece = { x, y, width, height };
        
        for (const piece of this.pieces) {
          if (this.rectanglesOverlap(newPiece, piece)) {
            return true;
          }
        }
        
        return false;
      }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM loaded, initializing app...');
      const app = new OurDailyApp();
      await app.initialize();
    });
  </script>
</body>
</html> 