<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Quilt</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* ===== SCREENS ===== */
    .screen {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 3rem 0 10px 0;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      opacity: 1;
      pointer-events: auto;
      position: relative;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 900;
      font-size: clamp(2rem, 5vw, 3rem);
      margin-bottom: 0.1rem;
      letter-spacing: -0.02em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.2rem, 3vw, 1.6rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.5rem;
      margin: 3rem auto 2rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 150px;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(1rem, 2.5vw, 1.2rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem 0;
    }
    
    #colorWheelCanvas {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      /* Fallback for browsers that don't support conic-gradient */
      background: hsl(0, 95%, 55%);
      /* Modern browsers with conic-gradient support */
      background: conic-gradient(
        hsl(0, 100%, 55%),
        hsl(30, 100%, 55%),
        hsl(60, 100%, 55%),
        hsl(90, 100%, 55%),
        hsl(120, 100%, 55%),
        hsl(150, 100%, 55%),
        hsl(180, 100%, 55%),
        hsl(210, 100%, 55%),
        hsl(240, 100%, 55%),
        hsl(270, 100%, 55%),
        hsl(300, 100%, 55%),
        hsl(330, 100%, 55%),
        hsl(360, 100%, 55%)
      );
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      /* Add a subtle overlay to tone down the visual intensity */
      position: relative;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
  

    
    #colorWheelCanvas:hover {
      transform: scale(1.02);
    }
    
    #colorWheelCanvas:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; align-items: center;
      margin-top: 2rem;
      width: 100%;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    

    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
      }
      
      .css-color-wheel {
        width: 280px;
        height: 280px;
        /* Ensure conic-gradient works on mobile */
        background: hsl(0, 100%, 55%);
        background: -webkit-conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
        background: conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }
    
    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: center;
    }
    
    .archive-placeholder {
      font-size: 1.5rem;
      color: #999;
      margin: 2rem 0;
      font-style: italic;
    }
    
    .archive-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
    }
    
    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */

    
    #quilt {
      width: 90vw; height: 90vw;
      max-width: 600px; max-height: 600px;
      margin: 2rem auto;
      background: transparent;
      position: relative;
      display: block;
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Fabric texture using CSS */
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .screen { 
        padding: 2rem 1rem 10px 1rem; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      #quilt { 
        width: 100vw; 
        height: 100vw; 
        margin: 0;
        display: block;
        position: relative;
        max-width: none;
        max-height: none;
      }
      
      #screen-quilt {
        padding: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }
  </style>
</head>
<body>
  <main id="app">
    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
      <button class="btn" data-next="screen-welcome" aria-label="Start the daily experience">LET'S BEGIN</button>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">↓</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="35" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
                <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">

        <svg id="quilt" viewBox="-100 -50 800 700" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
              <p class="thank-you-message" aria-live="polite">Thank you for adding your block! Look what we're making together <3</p>
        <button id="testAddBlock" class="btn" style="background: #ff6b6b; color: white; margin: 0.5rem;">TEST: Add Random Block</button>
        <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button>
        <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
        <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <div class="archive-content">
        <p class="archive-placeholder">Archive coming soon...</p>
        <p class="archive-description">Browse through past community quilts and see how our collective creativity has grown over time.</p>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

  <!-- Toast notifications -->
  <div id="toast" class="toast" role="alert" aria-live="polite"></div>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    // Configuration
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '2.0.0',
        defaultColor: '#f7b733',
        quiltSize: 600,
        minBlockSize: 40,
        animationDuration: 2000,
        toastDuration: 3000
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      }
    };

    // Utility functions
    function debounce(func, delay) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(null, args), delay);
      };
    }

    function hslToHex(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      
      let r, g, b;
      
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      const toHex = (c) => {
        const hex = Math.round(c * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function validateHexColor(color) {
      const hexRegex = /^#[0-9A-F]{6}$/i;
      return hexRegex.test(color);
    }

    function getTodayKey() {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function formatDate(date = new Date()) {
      return date.toLocaleDateString(undefined, {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    }

    function showToast(message, duration = CONFIG.APP.toastDuration) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), duration);
    }

    function showLoading(show = true) {
      const loading = document.getElementById('loading');
      if (!loading) return;
      if (show) {
        loading.classList.add('show');
      } else {
        loading.classList.remove('show');
      }
    }

    function handleError(error, context = 'Unknown') {
      console.error(`Error in ${context}:`, error);
      const errorMessages = {
        'loadQuilt': 'Failed to load quilt data. Starting fresh.',
        'saveQuilt': 'Failed to save your color. Please try again.',
        'shareFlow': 'Failed to create share image. Saving instead.',
        'colorPicker': 'Color picker error. Please try again.'
      };
      const message = errorMessages[context] || 'Something went wrong. Please try again.';
      showToast(message);
    }

    // Main application class
    class OurDailyApp {
      constructor() {
        this.blocks = []; // Start with empty quilt - first user submission creates the first piece
        this.lastAddedIndex = null;
        this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
        this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
        this.colorHasBeenSelected = false;
        this.db = null;
        this.quiltDoc = null;
        this.currentScreen = 'screen-portal';
        
        this.quotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "— Pablo Picasso" },
          { text: "Creativity takes courage.", author: "— Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "— Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "— Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "— Vincent Van Gogh" },
          { text: "You can't use up creativity. The more you use, the more you have.", author: "— Maya Angelou" }
        ];
        this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
      }

      async initialize() {
        try {
          showLoading(true);
          await this.initializeFirebase();
          this.setupEventListeners();
          this.initializeUI();
          await this.loadQuilt();
          showLoading(false);
        } catch (error) {
          handleError(error, 'App initialization');
          showLoading(false);
        }
      }

      async initializeFirebase() {
        try {
          const app = initializeApp(CONFIG.FIREBASE);
          this.db = getFirestore(app);
          this.quiltDoc = doc(this.db, "quilts", "main");
        } catch (error) {
          handleError(error, 'Firebase initialization');
          throw error;
        }
      }

      setupEventListeners() {
        // Navigation
        document.querySelectorAll(".btn[data-next]").forEach(btn => {
          btn.addEventListener("click", e => {
            e.preventDefault();
            const targetId = btn.getAttribute("data-next");
            if (targetId) this.showScreen(targetId);
          });
        });

        // Add color button
        const addColorBtn = document.getElementById('addColorBtn');
        if (addColorBtn) {
          addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
        }

        // Share button
        const shareBtnCompleted = document.getElementById('shareBtnCompleted');
        if (shareBtnCompleted) {
          shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
        }

        // Test button
        const testAddBlock = document.getElementById('testAddBlock');
        if (testAddBlock) {
          testAddBlock.addEventListener('click', this.handleTestAddBlock.bind(this));
        }

        // Color picker
        this.setupColorPicker();
        
        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
      }

      setupColorPicker() {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const valueSlider = document.getElementById('valueSlider');

        if (!colorWheel || !indicator || !valueSlider) return;
        
        // Remove any existing preview elements
        const previewElement = document.getElementById('selectedColorPreview');
        if (previewElement) {
          previewElement.remove();
        }

        // Draw color wheel
        this.drawColorWheel();
        this.updatePreview();
        
        // Set slider to default value
        valueSlider.value = this.selectedLightness;
        
        // Force slider value after a small delay to ensure DOM is ready
        setTimeout(() => {
          valueSlider.value = this.selectedLightness;
        }, 100);
        
        // Set initial indicator position
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const radius = rect.width / 2;
        // Convert hue to radians and adjust for coordinate system
        // CSS conic-gradient starts at top (12 o'clock), so subtract 90 degrees
        const angleRad = (this.selectedHue - 90) * Math.PI / 180;
        const x = centerX + radius * Math.cos(angleRad);
        const y = centerY + radius * Math.sin(angleRad);
        
        if (indicator) {
          // Position relative to the color wheel container
          const container = colorWheel.parentElement;
          const containerRect = container.getBoundingClientRect();
          const relativeX = x + rect.left - containerRect.left;
          const relativeY = y + rect.top - containerRect.top;
          indicator.style.left = `${relativeX}px`;
          indicator.style.top = `${relativeY}px`;
        }

        // Event listeners
        const debouncedSetHue = debounce(this.setHueFromCoords.bind(this), 16);
        
        colorWheel.addEventListener('click', e => {
          const rect = colorWheel.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          // Only update if click is within the wheel bounds
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
          const radius = rect.width / 2;
          
          if (distance <= radius) {
            this.setHueFromCoords(x, y);
          }
        });

        colorWheel.addEventListener('mousedown', e => {
          const rect = colorWheel.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          // Only update if click is within the wheel bounds
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
          const radius = rect.width / 2;
          
          if (distance <= radius) {
            this.setHueFromCoords(x, y);
          }
        });

        document.addEventListener('mousemove', e => {
          if (e.buttons === 1) {
            const rect = colorWheel.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Only update if mouse is within the wheel bounds
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            const radius = rect.width / 2;
            
            if (distance <= radius) {
              debouncedSetHue(x, y);
            }
          }
        });

        valueSlider.addEventListener('input', () => {
          this.selectedLightness = Number(valueSlider.value);
          this.updatePreview();
        });


      }

      drawColorWheel() {
        // CSS-based color wheel doesn't need drawing
        // The conic-gradient CSS handles the rendering
      }



      updatePreview() {
        const valueSlider = document.getElementById('valueSlider');
        

        
        const hslColor = `hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, ${this.selectedLightness}%)`;
        const hexColor = hslToHex(this.selectedHue, CONFIG.COLOR_PICKER.saturation, this.selectedLightness);
        
        // Update color screen background only after a color has been selected
        const colorScreen = document.getElementById('screen-color');
        if (colorScreen && this.colorHasBeenSelected) {
          colorScreen.style.backgroundColor = hexColor;
        }
        

        
        if (valueSlider) {
          valueSlider.style.background = `linear-gradient(to right,
            hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 20%), 
            hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 90%))`;
        }
      }

      setHueFromCoords(x, y) {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = rect.width / 2;

        if (distance > radius) {
          // Clamp to the edge of the wheel
          const clampedDistance = radius;
          const clampedX = centerX + (dx / distance) * clampedDistance;
          const clampedY = centerY + (dy / distance) * clampedDistance;
          
          let angle = Math.atan2(dy, dx) * 180 / Math.PI;
          if (angle < 0) angle += 360;
          // Adjust for CSS conic-gradient coordinate system (starts at top, not right)
          this.selectedHue = Math.round((angle + 90) % 360);
          

          
          if (indicator) {
            // Position relative to the color wheel container
            const container = colorWheel.parentElement;
            const containerRect = container.getBoundingClientRect();
            const relativeX = clampedX + rect.left - containerRect.left;
            const relativeY = clampedY + rect.top - containerRect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        } else {
          let angle = Math.atan2(dy, dx) * 180 / Math.PI;
          if (angle < 0) angle += 360;
          
          // Adjust for CSS conic-gradient coordinate system (starts at top, not right)
          this.selectedHue = Math.round((angle + 90) % 360);
          

          
          if (indicator) {
            // Position relative to the color wheel container
            const container = colorWheel.parentElement;
            const containerRect = container.getBoundingClientRect();
            const relativeX = x + rect.left - containerRect.left;
            const relativeY = y + rect.top - containerRect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        }
        
        // Mark that a color has been selected
        this.colorHasBeenSelected = true;
        this.updatePreview();
      }

      initializeUI() {
        const dateText = document.getElementById("date-text");
        if (dateText) {
          dateText.textContent = formatDate();
        }
        this.displayQuote();
        this.showScreen('screen-portal');
      }

      showScreen(screenId) {
        document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
        const target = document.getElementById(screenId);
        if (target) {
          target.classList.add("active");
          this.currentScreen = screenId;
          
          // Reset color selection when entering color screen
          if (screenId === 'screen-color') {
            this.colorHasBeenSelected = false;
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen) {
              colorScreen.style.backgroundColor = '#f6f4f1'; // Reset to default background
            }
          }
          
          // Scroll to top of the screen with multiple methods for better compatibility
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          
          // Also scroll the main container if it exists
          const app = document.getElementById('app');
          if (app) {
            app.scrollTop = 0;
          }
        }
      }

      async loadQuilt() {
        try {
          showLoading(true);
          const todayKey = getTodayKey();
          const quiltDocSnap = await getDoc(this.quiltDoc);
          
          if (!quiltDocSnap.exists() || quiltDocSnap.data().date !== todayKey) {
            this.blocks = []; // Start with empty quilt - first user submission creates the first piece
            await this.saveQuilt();
          } else {
            const data = quiltDocSnap.data();
            if (data.blocks) {
              this.blocks = data.blocks;
            }
          }
          
          this.renderBlocks();
          showLoading(false);
        } catch (error) {
          handleError(error, 'loadQuilt');
          showLoading(false);
          this.blocks = []; // Start with empty quilt - first user submission creates the first piece
          this.renderBlocks();
        }
      }

      async saveQuilt() {
        try {
          await setDoc(this.quiltDoc, { blocks: this.blocks, date: getTodayKey() });
        } catch (error) {
          handleError(error, 'saveQuilt');
          throw error;
        }
      }

      renderBlocks() {
        const quiltSVG = document.getElementById('quilt');
        if (!quiltSVG) return;

        quiltSVG.innerHTML = '';
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
          <filter id="wavyEdges" x="0" y="0" width="200%" height="200%">
            <feTurbulence baseFrequency="0.012" numOctaves="3" result="turb"/>
            <feDisplacementMap in="SourceGraphic" in2="turb" scale="3"/>
          </filter>

          <filter id="dropShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="rgba(0,0,0,0.15)"/>
          </filter>
          
          <!-- Paper texture filter -->
          <filter id="paperTexture" x="0" y="0" width="100%" height="100%">
            <feTurbulence baseFrequency="0.6" numOctaves="3" result="noise" type="fractalNoise"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.15 0" in="noise" result="texture"/>
            <feBlend mode="multiply" in="SourceGraphic" in2="texture"/>
          </filter>
          

          
          <!-- Luminescent glow effect -->
          <filter id="luminescentGlow" x="-100%" y="-100%" width="300%" height="300%">
            <feGaussianBlur stdDeviation="8" result="glow"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0" in="glow" result="coloredGlow"/>
            <feBlend mode="screen" in="SourceGraphic" in2="coloredGlow"/>
          </filter>
          
          <!-- Inner glow effect -->
          <filter id="innerGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="innerBlur"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.2 0" in="innerBlur" result="innerColored"/>
            <feBlend mode="screen" in="SourceGraphic" in2="innerColored"/>
          </filter>
          
          <!-- Overlap transparency effect -->
          <filter id="overlapTransparency" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="1" result="blur"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0" in="blur" result="transparent"/>
            <feBlend mode="multiply" in="SourceGraphic" in2="transparent"/>
          </filter>
          
          <!-- Organic edge distortion -->
          <filter id="organicEdges" x="-20%" y="-20%" width="140%" height="140%">
            <feTurbulence baseFrequency="0.15" numOctaves="2" result="turbulence" type="fractalNoise"/>
            <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="2" xChannelSelector="R" yChannelSelector="G"/>
          </filter>
          
          <filter id="watercolorTexture" x="0" y="0" width="100%" height="100%">
            <feTurbulence baseFrequency="0.3" numOctaves="2" result="noise" type="fractalNoise"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.1 0" in="noise" result="texture"/>
            <feBlend mode="multiply" in="SourceGraphic" in2="texture"/>
          </filter>
          
          <!-- Plastic highlight gradient -->
          <linearGradient id="plasticHighlight" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="white" stop-opacity="0"/>
            <stop offset="10%" stop-color="white" stop-opacity="0.6"/>
            <stop offset="20%" stop-color="white" stop-opacity="0"/>
            <stop offset="40%" stop-color="white" stop-opacity="0.5"/>
            <stop offset="50%" stop-color="white" stop-opacity="0"/>
            <stop offset="70%" stop-color="white" stop-opacity="0.7"/>
            <stop offset="80%" stop-color="white" stop-opacity="0"/>
            <stop offset="100%" stop-color="white" stop-opacity="0.3"/>
          </linearGradient>

`;
        quiltSVG.appendChild(defs);
        
        // Create organic outer boundary for the entire quilt
        const quiltBounds = this.getQuiltBounds();
        const organicBoundary = this.createOrganicQuiltBoundary(quiltBounds);
        
        // Add the organic boundary as a background shape - clear plastic dropcloth effect
        const boundaryPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        boundaryPath.setAttribute('d', organicBoundary);
        boundaryPath.setAttribute('fill', '#e8e4df'); // Slightly darker, more visible
        boundaryPath.setAttribute('opacity', '0.95');
        
        // Add subtle plastic highlights
        const highlightPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        highlightPath.setAttribute('d', organicBoundary);
        highlightPath.setAttribute('fill', 'url(#plasticHighlight)');
        highlightPath.setAttribute('opacity', '0.8');

        quiltSVG.appendChild(boundaryPath);
        quiltSVG.appendChild(highlightPath);
        
        this.blocks.forEach((block, i) => {
          // Add jiggered positioning - more freedom to break square
          const jiggerX = 0; // Disabled for testing clean joins
          const jiggerY = 0; // Disabled for testing clean joins
          const jiggerRotation = 0; // Disabled for testing clean joins
          
          // Apply jiggered positioning to block coordinates
          const jiggeredBlock = {
            x: block.x + jiggerX,
            y: block.y + jiggerY,
            width: block.width,
            height: block.height,
            color: block.color,
            rotation: jiggerRotation
          };
          
          // Randomly decide if this block should have bleed effect
          const shouldBleed = Math.random() < 0.4; // 40% chance of bleed
          const bleedIntensity = shouldBleed ? Math.random() * 0.3 + 0.1 : 0;
          
          // Dynamic edge variation based on number of blocks - reduces gaps as quilt fills up
          const baseEdgeVariation = shouldBleed ? 1 : 0.5; // Reduced for cleaner joins
          const blockCount = this.blocks.length;
          const dynamicReduction = Math.min(0.95, blockCount * 0.08); // Reduce by up to 95% as blocks increase
          const edgeVariation = baseEdgeVariation * (1 - dynamicReduction);
          
          // Create watercolor edges with organic curves
          const createWatercolorEdge = (startX, startY, endX, endY, isVertical = false, edgePosition = '') => {
            const numPoints = 5; // More points for smoother curves
            const points = [];
            
            // Check if this edge is likely to overlap with other blocks
            const hasAdjacentBlock = this.checkEdgeAdjacency(block, edgePosition);
            const isOuter = this.isOuterEdge(block, edgePosition);
            
            // Watercolor variation - organic curves
            let variationMultiplier = 0.8;
            const edgeStyle = Math.random();
            
            if (isOuter) {
              // Outer edges get more organic curves to break square
              variationMultiplier = 0.7;
            } else if (edgeStyle < 0.2) {
              // Straight edge (20% chance) - some edges are straight
              variationMultiplier = 0;
            } else {
              // Organic curve (80% chance) - like watercolor pooling
              variationMultiplier = 0.8;
            }
            
            for (let i = 0; i <= numPoints; i++) {
              const t = i / numPoints;
              const x = startX + (endX - startX) * t;
              const y = startY + (endY - startY) * t;
              
              // Create watercolor curves
              let variation = 0;
              if (variationMultiplier !== 0) {
                // Use smooth curves for watercolor look
                const smoothCurve = Math.sin(t * Math.PI) * Math.sin(t * Math.PI); // Double sine for smoother curve
                const curveIntensity = smoothCurve * edgeVariation * variationMultiplier * 0.7;
                variation = curveIntensity + (Math.random() - 0.5) * edgeVariation * 0.2; // More randomness for organic feel
              }
              
              // Add very subtle diagonal variation for more organic feel
              const diagonalVariation = (Math.random() - 0.5) * edgeVariation * 0.1;
              
              const organicX = x + (isVertical ? variation : diagonalVariation);
              const organicY = y + (isVertical ? diagonalVariation : variation);
              
              points.push({ x: organicX, y: organicY });
            }
            
            return points;
          };
          
          // Generate watercolor edges for each side with jiggered positioning
          const topEdge = createWatercolorEdge(jiggeredBlock.x, jiggeredBlock.y, jiggeredBlock.x + jiggeredBlock.width, jiggeredBlock.y, false, 'top');
          const rightEdge = createWatercolorEdge(jiggeredBlock.x + jiggeredBlock.width, jiggeredBlock.y, jiggeredBlock.x + jiggeredBlock.width, jiggeredBlock.y + jiggeredBlock.height, true, 'right');
          const bottomEdge = createWatercolorEdge(jiggeredBlock.x + jiggeredBlock.width, jiggeredBlock.y + jiggeredBlock.height, jiggeredBlock.x, jiggeredBlock.y + jiggeredBlock.height, false, 'bottom');
          const leftEdge = createWatercolorEdge(jiggeredBlock.x, jiggeredBlock.y + jiggeredBlock.height, jiggeredBlock.x, jiggeredBlock.y, true, 'left');
          
          // Ensure connectivity by adjusting corner points
          const ensureConnectivity = (edge1, edge2, isCorner = false) => {
            if (isCorner) {
              // For corners, use the exact corner point to maintain connectivity
              return edge1[edge1.length - 1];
            }
            return edge1[edge1.length - 1];
          };
          
          // Check for overlaps with previous blocks to determine transparency
          const hasOverlap = this.checkForOverlaps(jiggeredBlock, i);
          const overlapTransparency = 1.0; // Fully opaque
          
          // Create path with organic edges, ensuring connectivity
          const pathData = `M ${topEdge[0].x},${topEdge[0].y}
                            ${topEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${topEdge[topEdge.length - 1].x},${topEdge[topEdge.length - 1].y}
                            ${rightEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${rightEdge[rightEdge.length - 1].x},${rightEdge[rightEdge.length - 1].y}
                            ${bottomEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${bottomEdge[bottomEdge.length - 1].x},${bottomEdge[bottomEdge.length - 1].y}
                            ${leftEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${leftEdge[leftEdge.length - 1].x},${leftEdge[leftEdge.length - 1].y} Z`;
          
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', pathData);
          // Create natural watercolor effect with transparency and bleeding edges
          const centerColor = block.color; // Original color
          const edgeColor = block.color; // Same color for bleeding effect
          
          // Create a radial gradient for natural watercolor effect
          const gradientId = `watercolor-${i}`;
          const defs = quiltSVG.querySelector('defs');
          const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
          gradient.setAttribute('id', gradientId);
          gradient.setAttribute('cx', '50%');
          gradient.setAttribute('cy', '50%');
          gradient.setAttribute('r', '70%');
          
          const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop1.setAttribute('offset', '0%');
          stop1.setAttribute('stop-color', centerColor);
          stop1.setAttribute('stop-opacity', '1.0'); // Fully opaque
          
          const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop2.setAttribute('offset', '100%');
          stop2.setAttribute('stop-color', edgeColor);
          stop2.setAttribute('stop-opacity', '1.0'); // Fully opaque
          
          gradient.appendChild(stop1);
          gradient.appendChild(stop2);
          defs.appendChild(gradient);
          
          path.setAttribute('fill', jiggeredBlock.color);
          
          // Apply rotation transform for jiggered effect
          const centerX = jiggeredBlock.x + jiggeredBlock.width / 2;
          const centerY = jiggeredBlock.y + jiggeredBlock.height / 2;
          path.setAttribute('transform', `rotate(${jiggeredBlock.rotation} ${centerX} ${centerY})`);
          
          // No filters applied for clean look
          
          // Add natural watercolor effect to blocks
          path.setAttribute('opacity', '1.0'); // Fully opaque
          


          

          

          
          if (i === this.lastAddedIndex) {
            // Start the new block completely transparent
            path.setAttribute('opacity', '0');
            path.classList.add('new-block');
            path.addEventListener('animationend', () => {
              path.classList.remove('new-block');
              path.removeAttribute('opacity');
            }, { once: true });
          }

          
          quiltSVG.appendChild(path);
          

        });

        this.lastAddedIndex = null;
      }

      addPieceToQuilt(newColor) {
        try {
          if (!validateHexColor(newColor)) {
            throw new Error(`Invalid color format: ${newColor}`);
          }

          // Track submission count for tiered approach
          const submissionCount = this.blocks.length + 1;
          
          if (submissionCount <= 20) {
            // Phase 1: Create pieces and form patches
            return this.handlePiecePhase(newColor, submissionCount);
          } else if (submissionCount === 21) {
            // Phase 2: Assess patterns and create blocks
            return this.handleBlockPhase();
          } else {
            // Phase 3: Continue adding to existing blocks
            return this.handleContinuedPhase(newColor);
          }
          
        } catch (error) {
          handleError(error, 'addPieceToQuilt');
          return false;
        }
      }

      handlePiecePhase(newColor, submissionCount) {
        if (submissionCount % 2 === 0) {
          // Even submissions: create piece and join with previous piece
          const recentPieces = this.blocks.filter(block => block.type === 'piece');
          if (recentPieces.length > 0) {
            const previousPiece = recentPieces[recentPieces.length - 1];
            
            // Create a new piece that will be sized to match
            const newPiece = {
              color: newColor,
              type: 'piece',
              submissionCount: submissionCount,
              width: 40 + Math.random() * 80, // Random initial size
              height: 40 + Math.random() * 80
            };
            
            // Size and position the new piece to join with previous piece
            const sizedPiece = this.sizePieceToMatch(newPiece, previousPiece);
            
            // Add the new piece that joins with the previous piece
            this.blocks.push(sizedPiece);
            this.lastAddedIndex = this.blocks.length - 1;
          } else {
            // Fallback: just add a piece
            const piece = this.createPiece(newColor, submissionCount);
            this.blocks.push(piece);
            this.lastAddedIndex = this.blocks.length - 1;

          }
        } else {
          // Odd submissions: just add the piece
          const piece = this.createPiece(newColor, submissionCount);
          this.blocks.push(piece);
          this.lastAddedIndex = this.blocks.length - 1;
          

        }
        
        return true;
      }

      handleBlockPhase() {
        // Analyze patches for value, color, and size patterns
        const patternAnalysis = this.analyzePatchesForPatterns();
        
        // Create blocks based on pattern analysis
        const blocks = this.createBlocksFromPatches(patternAnalysis);
        
        // Add blocks while keeping existing pieces and patches visible
        this.blocks.push(...blocks);
        this.lastAddedIndex = this.blocks.length - 1;
        return true;
      }

      handleContinuedPhase(newColor) {
        // Continue adding pieces that can join with existing blocks
        const piece = this.createPiece(newColor, this.blocks.length + 1);
        
        // Try to join with existing blocks
        const joinedBlock = this.tryToJoinWithExistingBlocks(piece);
        
        if (joinedBlock) {
          // Replace the existing block with the joined version
          const blockIndex = this.findBlockToReplace(joinedBlock);
          if (blockIndex !== -1) {
            this.blocks[blockIndex] = joinedBlock;
            this.lastAddedIndex = blockIndex;
          }
        } else {
          // Add as new piece if no good join found
          this.blocks.push(piece);
          this.lastAddedIndex = this.blocks.length - 1;
        }
        
        return true;
      }

      createPiece(color, submissionCount) {
        const minSize = 40;
        const maxSize = 120;
        
        let width, height;
        
        if (submissionCount % 2 === 0) {
          // Even submissions: size will be determined by sizePieceToMatch
          width = minSize + Math.random() * (maxSize - minSize);
          height = minSize + Math.random() * (maxSize - minSize);
        } else {
          // Odd submissions: random size
          width = minSize + Math.random() * (maxSize - minSize);
          height = minSize + Math.random() * (maxSize - minSize);
        }
        
        const position = this.findGoodPosition(width, height);
        
        return {
          x: position.x,
          y: position.y,
          width: width,
          height: height,
          color: color,
          type: 'piece',
          submissionCount: submissionCount
        };
      }

      sizePieceToMatch(newPiece, previousPiece) {
        // Size the new piece to have at least one matching edge with previous piece
        const edgeChoices = ['width', 'height'];
        const matchingEdge = edgeChoices[Math.floor(Math.random() * edgeChoices.length)];
        
        const sizedPiece = { ...newPiece };
        
        // Set default dimensions if not already set
        if (!sizedPiece.width) {
          sizedPiece.width = 40 + Math.random() * 80; // 40-120 range
        }
        if (!sizedPiece.height) {
          sizedPiece.height = 40 + Math.random() * 80; // 40-120 range
        }
        
        if (matchingEdge === 'width') {
          sizedPiece.width = previousPiece.width;
          // Join horizontally - position exactly touching (no overlap)
          sizedPiece.x = previousPiece.x + previousPiece.width;
          sizedPiece.y = previousPiece.y;
        } else {
          sizedPiece.height = previousPiece.height;
          // Join vertically - position exactly touching (no overlap)
          sizedPiece.x = previousPiece.x;
          sizedPiece.y = previousPiece.y + previousPiece.height;
        }
        
        return sizedPiece;
      }

      createPatchFromPieces(piece1, piece2) {
        // Determine if joining horizontally or vertically based on positioning
        const isHorizontalJoin = Math.abs((piece1.x + piece1.width) - piece2.x) < 1; // Exact touching
        const isVerticalJoin = Math.abs((piece1.y + piece1.height) - piece2.y) < 1; // Exact touching
        
        if (isHorizontalJoin) {
          // Join horizontally - pieces are exactly touching
          return {
            x: piece1.x,
            y: piece1.y,
            width: piece1.width + piece2.width,
            height: Math.max(piece1.height, piece2.height),
            color: piece2.color, // Use the new piece's color (user's selection)
            type: 'patch',
            pieces: [piece1, piece2]
          };
        } else if (isVerticalJoin) {
          // Join vertically - pieces are exactly touching
          return {
            x: piece1.x,
            y: piece1.y,
            width: Math.max(piece1.width, piece2.width),
            height: piece1.height + piece2.height,
            color: piece2.color, // Use the new piece's color (user's selection)
            type: 'patch',
            pieces: [piece1, piece2]
          };
        } else {
          // Fallback: just return the second piece as a patch
          return {
            x: piece2.x,
            y: piece2.y,
            width: piece2.width,
            height: piece2.height,
            color: piece2.color,
            type: 'patch',
            pieces: [piece2]
          };
        }
      }

      analyzePatchesForPatterns() {
        const patches = this.blocks.filter(block => block.type === 'patch');
        
        // Analyze by value (lightness)
        const valueGroups = this.groupByValue(patches);
        
        // Analyze by color (hue)
        const colorGroups = this.groupByColor(patches);
        
        // Analyze by size
        const sizeGroups = this.groupBySize(patches);
        
        return {
          valueGroups,
          colorGroups,
          sizeGroups,
          patches
        };
      }

      groupByValue(patches) {
        const groups = { light: [], medium: [], dark: [] };
        
        patches.forEach(patch => {
          const lightness = this.getColorLightness(patch.color);
          if (lightness < 0.4) groups.dark.push(patch);
          else if (lightness < 0.7) groups.medium.push(patch);
          else groups.light.push(patch);
        });
        
        return groups;
      }

      groupByColor(patches) {
        const groups = {};
        
        patches.forEach(patch => {
          const hue = this.getColorHue(patch.color);
          const hueGroup = Math.floor(hue / 60) * 60; // Group by 60° hue ranges
          
          if (!groups[hueGroup]) groups[hueGroup] = [];
          groups[hueGroup].push(patch);
        });
        
        return groups;
      }

      groupBySize(patches) {
        const groups = { small: [], medium: [], large: [] };
        
        patches.forEach(patch => {
          const area = patch.width * patch.height;
          if (area < 4000) groups.small.push(patch);
          else if (area < 8000) groups.medium.push(patch);
          else groups.large.push(patch);
        });
        
        return groups;
      }

      getColorLightness(color) {
        // Convert hex to HSL and return lightness
        const hex = color.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        return (max + min) / 2;
      }

      getColorHue(color) {
        // Convert hex to HSL and return hue
        const hex = color.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;
        
        if (delta === 0) return 0;
        
        let hue = 0;
        if (max === r) hue = ((g - b) / delta) % 6;
        else if (max === g) hue = (b - r) / delta + 2;
        else hue = (r - g) / delta + 4;
        
        return hue * 60;
      }

      createBlocksFromPatches(analysis) {
        const blocks = [];
        const patches = analysis.patches;
        
        // Prioritize value patterns, then color, then size
        const valuePairs = this.findBestPairs(analysis.valueGroups);
        const colorPairs = this.findBestPairs(analysis.colorGroups);
        const sizePairs = this.findBestPairs(analysis.sizeGroups);
        
        // Combine pairs to create 5 blocks
        let usedPatches = new Set();
        
        // First try value pairs
        for (const pair of valuePairs) {
          if (blocks.length >= 5) break;
          if (!usedPatches.has(pair[0]) && !usedPatches.has(pair[1])) {
            const block = this.createBlockFromPatches(pair[0], pair[1]);
            blocks.push(block);
            usedPatches.add(pair[0]);
            usedPatches.add(pair[1]);
          }
        }
        
        // Then try color pairs
        for (const pair of colorPairs) {
          if (blocks.length >= 5) break;
          if (!usedPatches.has(pair[0]) && !usedPatches.has(pair[1])) {
            const block = this.createBlockFromPatches(pair[0], pair[1]);
            blocks.push(block);
            usedPatches.add(pair[0]);
            usedPatches.add(pair[1]);
          }
        }
        
        // Finally try size pairs
        for (const pair of sizePairs) {
          if (blocks.length >= 5) break;
          if (!usedPatches.has(pair[0]) && !usedPatches.has(pair[1])) {
            const block = this.createBlockFromPatches(pair[0], pair[1]);
            blocks.push(block);
            usedPatches.add(pair[0]);
            usedPatches.add(pair[1]);
          }
        }
        
        // Add remaining patches as individual blocks if needed
        for (const patch of patches) {
          if (blocks.length >= 5) break;
          if (!usedPatches.has(patch)) {
            blocks.push(patch); // Keep as patch if no good pairing found
            usedPatches.add(patch);
          }
        }
        
        return blocks;
      }

      findBestPairs(groups) {
        const pairs = [];
        
        // Find pairs within each group
        Object.values(groups).forEach(group => {
          for (let i = 0; i < group.length - 1; i += 2) {
            pairs.push([group[i], group[i + 1]]);
          }
        });
        
        return pairs;
      }

      createBlockFromPatches(patch1, patch2) {
        // Try to join patches with matching edges
        const block = this.tryToJoinPatches(patch1, patch2);
        
        if (block) {
          return block;
        } else {
          // If no good join, resize one patch to match
          const resizedPatch = this.resizePatchToMatch(patch2, patch1);
          return this.tryToJoinPatches(patch1, resizedPatch);
        }
      }

      resizePatchToMatch(patchToResize, targetPatch) {
        // Resize patch to have at least one matching edge
        const resized = { ...patchToResize };
        
        // Choose which edge to match
        const edgeChoices = ['width', 'height'];
        const matchingEdge = edgeChoices[Math.floor(Math.random() * edgeChoices.length)];
        
        if (matchingEdge === 'width') {
          resized.width = targetPatch.width;
        } else {
          resized.height = targetPatch.height;
        }
        
        return resized;
      }

      tryToJoinWithExistingBlocks(piece) {
        // Try to join piece with existing blocks
        for (let i = 0; i < this.blocks.length; i++) {
          const block = this.blocks[i];
          const joinedBlock = this.tryToJoinPatches(piece, block);
          if (joinedBlock) {
            return joinedBlock;
          }
        }
        return null;
      }

      findBlockToReplace(joinedBlock) {
        // Find which existing block should be replaced
        // This is a simplified version - you might want more sophisticated logic
        return this.blocks.length - 1; // Replace the last block for now
      }

      findGoodPosition(width, height) {
        // Find a good position for a new piece
        if (this.blocks.length === 0) {
          // First piece: place in center of quilt area
          const centerX = 300 - width / 2; // Center of 600px quilt
          const centerY = 300 - height / 2;
          return { 
            x: centerX + (Math.random() - 0.5) * 50, // Small random offset
            y: centerY + (Math.random() - 0.5) * 50
          };
        } else {
          // For odd submissions (3, 5, 7, etc.): place away from existing pieces/patches
          const submissionCount = this.blocks.length + 1;
          
          if (submissionCount % 2 === 1) {
            // Find a position that doesn't overlap with existing pieces
            const attempts = 20; // Try multiple positions
            
            for (let attempt = 0; attempt < attempts; attempt++) {
              // Try different positions around the dropcloth
              let x, y;
              
              if (attempt < 5) {
                // Try positions to the right of existing pieces
                x = 500 + Math.random() * 300;
                y = 100 + Math.random() * 400;
              } else if (attempt < 10) {
                // Try positions below existing pieces
                x = 100 + Math.random() * 400;
                y = 500 + Math.random() * 300;
              } else if (attempt < 15) {
                // Try positions to the left of existing pieces
                x = -100 + Math.random() * 200;
                y = 100 + Math.random() * 400;
              } else {
                // Try positions above existing pieces
                x = 100 + Math.random() * 400;
                y = -100 + Math.random() * 200;
              }
              
              // Check if this position overlaps with any existing pieces
              const newPiece = { x, y, width, height };
              let hasOverlap = false;
              
              for (const existingBlock of this.blocks) {
                if (this.checkForOverlaps(newPiece, this.blocks.indexOf(existingBlock))) {
                  hasOverlap = true;
                  break;
                }
              }
              
              if (!hasOverlap) {
                return { x, y };
              }
            }
            
            // If all attempts failed, place in a corner
            return {
              x: -50 + Math.random() * 200,
              y: -50 + Math.random() * 200
            };
          }
          
          // Fallback: place near existing blocks
          const quiltBounds = this.getQuiltBounds();
          let x = quiltBounds.left + (quiltBounds.right - quiltBounds.left) / 2 - width / 2;
          let y = quiltBounds.top + (quiltBounds.bottom - quiltBounds.top) / 2 - height / 2;
          x += (Math.random() - 0.5) * 100;
          y += (Math.random() - 0.5) * 100;
          
          return { x, y };
        }
      }

      async handleAddColor() {
        try {
          const saturationSlider = document.getElementById('saturationSlider');
          const selectedSaturation = saturationSlider ? parseInt(saturationSlider.value) : CONFIG.COLOR_PICKER.saturation;
          
          // Apply warm cast to user-selected colors
          const warmHue = (this.selectedHue + 25) % 360; // Shift towards warmer hues
          const warmSaturation = Math.min(selectedSaturation + 5, 100); // Slightly increase saturation for warmth
          const selectedColor = hslToHex(warmHue, warmSaturation, this.selectedLightness);
          

          
          if (!selectedColor) {
            showToast('Please select a color first');
            return;
          }

          const success = this.addPieceToQuilt(selectedColor);
          
          if (success) {
            // Store the last added index for sharing before renderBlocks resets it
            this.lastAddedForShare = this.lastAddedIndex;
            

            
            await this.saveQuilt();
            this.renderBlocks();
            this.showScreen('screen-quilt');
          }
        } catch (error) {
          handleError(error, 'handleAddColor');
          showToast('Failed to add color. Please try again.');
        }
      }

      async handleTestAddBlock() {
        try {
          // Generate random color with warm cast within user picker limitations
          const randomHue = Math.floor(Math.random() * 360); // Full hue range
          const randomSaturation = CONFIG.COLOR_PICKER.saturation; // Fixed at 65% to match user picker
          const randomLightness = 35 + Math.floor(Math.random() * 56); // Between 35-90 lightness (same as user slider)
          
          // Apply warm cast by shifting hue towards warm colors and adjusting saturation
          const warmHue = (randomHue + 25) % 360; // Shift towards warmer hues
          const warmSaturation = Math.min(randomSaturation + 5, 100); // Slightly increase saturation for warmth
          const randomColor = hslToHex(warmHue, warmSaturation, randomLightness);
          

          
          const success = this.addPieceToQuilt(randomColor);
          
          if (success) {
            this.lastAddedForShare = this.lastAddedIndex;
            await this.saveQuilt();
            this.renderBlocks();
            showToast(`Added block ${this.blocks.length}!`);
          }
        } catch (error) {
          handleError(error, 'handleTestAddBlock');
          showToast('Test add failed.');
        }
      }

      async handleShare() {
        try {
          const shareBtn = document.getElementById('shareBtnCompleted');
          if (shareBtn) shareBtn.disabled = true;
          
          showToast("Preparing flyer...");
          await this.shareFlow();
          
          if (shareBtn) shareBtn.disabled = false;
        } catch (error) {
          handleError(error, 'handleShare');
          showToast('Share failed. Saving instead.');
          
          const shareBtn = document.getElementById('shareBtnCompleted');
          if (shareBtn) shareBtn.disabled = false;
        }
      }

      async shareFlow() {
        try {
                      // Use the stored last added index for sharing
            const lastAddedIndex = this.lastAddedForShare;
            

          const quiltElement = document.getElementById('quilt');
          const clonedSVG = quiltElement.cloneNode(true);
          clonedSVG.removeAttribute('id');
          clonedSVG.setAttribute('width', '800');
          clonedSVG.setAttribute('height', '800');
          clonedSVG.style.transform = "rotate(-5deg)";
          
          // Expand viewBox by small fixed amount for all instances
          const originalViewBox = clonedSVG.getAttribute('viewBox');
          if (originalViewBox) {
            const [x, y, width, height] = originalViewBox.split(' ').map(Number);
            const fixedPadding = 20; // Small, consistent padding for all instances
            

            
            const newViewBox = `${x - fixedPadding} ${y - fixedPadding} ${width + fixedPadding * 2} ${height + fixedPadding * 2}`;
            clonedSVG.setAttribute('viewBox', newViewBox);
            
            // Add background rect FIRST (before any quilt blocks) to ensure it's behind everything
            const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bgRect.setAttribute('x', x - fixedPadding);
            bgRect.setAttribute('y', y - fixedPadding);
            bgRect.setAttribute('width', width + fixedPadding * 2);
            bgRect.setAttribute('height', height + fixedPadding * 2);
            bgRect.setAttribute('fill', '#f6f4f1');
            bgRect.setAttribute('stroke', 'none');
            bgRect.setAttribute('opacity', '1'); // Ensure fully opaque
            bgRect.setAttribute('filter', 'none'); // Explicitly disable any filters
            bgRect.setAttribute('style', 'filter: none !important;'); // Force no filters
            clonedSVG.insertBefore(bgRect, clonedSVG.firstChild);
            
            // Also set the SVG background color to match
            clonedSVG.style.backgroundColor = '#f6f4f1';
            

          }

          const wrapper = document.createElement('div');
          wrapper.style.width = '1080px';
          wrapper.style.height = '1920px';
          wrapper.style.background = '#f6f4f1';
          wrapper.style.display = 'flex';
          wrapper.style.flexDirection = 'column';
          wrapper.style.alignItems = 'center';
          wrapper.style.padding = '100px 60px 80px 60px';
          wrapper.style.fontFamily = "system-ui, sans-serif";

          const title = document.createElement('h1');
          title.textContent = "OUR DAILY";
          title.style.fontSize = '96px';
          title.style.fontWeight = '900';
          title.style.margin = '0';

          const date = document.createElement('p');
          date.textContent = formatDate();
          date.style.fontSize = '48px';
          date.style.margin = '0 0 40px 0';

          const quoteCard = document.createElement('div');
          quoteCard.style.border = '4px solid #000';
          quoteCard.style.borderRadius = '16px';
          quoteCard.style.padding = '20px 30px';
          quoteCard.style.marginBottom = '60px';
          quoteCard.style.maxWidth = '800px';
          quoteCard.style.textAlign = 'left';

          const quoteLine = document.createElement('p');
          quoteLine.textContent = `"${this.getTodayQuote().text}"`;
          quoteLine.style.fontSize = '60px';
          quoteLine.style.fontStyle = 'italic';
          quoteLine.style.fontWeight = '600';
          quoteLine.style.margin = '0 0 10px 0';
          quoteLine.style.lineHeight = '1.1';

          const quoteAuthor = document.createElement('p');
          quoteAuthor.textContent = this.getTodayQuote().author;
          quoteAuthor.style.fontSize = '60px';
          quoteAuthor.style.fontWeight = '500';
          quoteAuthor.style.margin = '0';
          quoteAuthor.style.lineHeight = '1.1';

          quoteCard.appendChild(quoteLine);
          quoteCard.appendChild(quoteAuthor);

          const quiltContainer = document.createElement('div');
          quiltContainer.style.width = '800px';
          quiltContainer.style.height = '800px';
          quiltContainer.style.transform = "rotate(-5deg)";
          quiltContainer.style.position = "relative";
          quiltContainer.appendChild(clonedSVG);
          
                      // Identify the last added block by local user
            if (lastAddedIndex !== null && lastAddedIndex < this.blocks.length) {
            
            // ADD VISUAL INDICATOR: Simple dot on the last added block
            const blockCenterX = lastAddedBlock.x + lastAddedBlock.width / 2;
            const blockCenterY = lastAddedBlock.y + lastAddedBlock.height / 2;
            
            // Create SVG circle element that encircles the block
            const blockWidth = lastAddedBlock.width;
            const blockHeight = lastAddedBlock.height;
            
            // Calculate circle radius to fit around the block with padding
            const padding = 8; // Padding around the block
            const radius = Math.max(blockWidth, blockHeight) / 2 + padding;
            
            const circleSVG = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleSVG.setAttribute('cx', blockCenterX);
            circleSVG.setAttribute('cy', blockCenterY);
            circleSVG.setAttribute('r', radius);
            circleSVG.setAttribute('fill', 'none'); // Transparent fill
            circleSVG.setAttribute('stroke', '#000000');
            circleSVG.setAttribute('stroke-width', '3');
            circleSVG.setAttribute('opacity', '0.6'); // Semi-transparent
            
            // Add the circle to the SVG
            clonedSVG.appendChild(circleSVG);
            
          }  

          const footer = document.createElement('div');
          footer.style.width = '100%';
          footer.style.display = 'flex';
          footer.style.flexDirection = 'column';
          footer.style.alignItems = 'flex-end';
          footer.style.marginTop = '60px';
          footer.style.paddingRight = '40px';

          const bigLine = document.createElement('span');
          bigLine.textContent = 'ADD YOUR COLOR';
          bigLine.style.fontSize = '55px';
          bigLine.style.fontWeight = '900';

          const smallLine = document.createElement('span');
          smallLine.innerHTML = 'Visit <strong>@zakfoster.quilts</strong> — link in bio';
          smallLine.style.fontSize = '44px';
          smallLine.style.fontWeight = '400';

          footer.appendChild(bigLine);
          footer.appendChild(smallLine);

          const headerGroup = document.createElement('div');
          headerGroup.style.alignSelf = 'flex-start';
          headerGroup.style.textAlign = 'left';
          headerGroup.style.marginLeft = '60px';

          headerGroup.appendChild(title);
          headerGroup.appendChild(date);
          headerGroup.appendChild(quoteCard);

          wrapper.appendChild(headerGroup);
          wrapper.appendChild(quiltContainer);
          wrapper.appendChild(footer);

          document.body.appendChild(wrapper);

          try {
            const canvas = await html2canvas(wrapper, {
              scale: 1, // Reduced scale for better performance
              backgroundColor: '#f6f4f1',
              useCORS: true,
              allowTaint: true,
              logging: false, // Disable logging to reduce noise
              width: 1080,
              height: 1920
            });

            document.body.removeChild(wrapper);

            // Use toDataURL instead of toBlob for better compatibility
            const dataURL = canvas.toDataURL('image/png', 0.9);

            // Try native sharing first
            if (navigator.canShare) {
              try {
                // Convert data URL to blob
                const response = await fetch(dataURL);
                const blob = await response.blob();
    
                
                const filesArray = [new File([blob], 'community-quilt.png', { type: 'image/png' })];
                const shareData = {
                  files: filesArray,
                  title: "Today's Community Quilt",
                  text: "Tag me on Instagram if you're sharing! @zakfoster.quilts 🌈✨"
                };

                await navigator.share(shareData);
                showToast("Thanks for sharing! Tag me @zakfoster.quilts 🌈✨");
                return;
              } catch (shareError) {
                // Native sharing failed, fall back to download
              }
            }

            // Fallback to download
            const link = document.createElement('a');
            link.download = 'community-quilt.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast("Image saved! Tag me @zakfoster.quilts 🌈✨");
            
          } catch (canvasError) {
            console.error('Error in html2canvas:', canvasError);
            if (document.body.contains(wrapper)) {
              document.body.removeChild(wrapper);
            }
            handleError(canvasError, 'shareFlow');
          }

        } catch (error) {
          handleError(error, 'shareFlow');
          throw error;
        }
      }

      getTodayQuote() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayString = `${year}-${month}-${day}`;
        const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        return this.quotes[quoteIndex];
      }

      displayQuote() {
        try {
          const { text, author } = this.getTodayQuote();
          const quoteLine = document.querySelector('.quote-line');
          const quoteAuthor = document.querySelector('.quote-author');
          
          if (quoteLine) quoteLine.textContent = text;
          if (quoteAuthor) quoteAuthor.textContent = author;
        } catch (error) {
          handleError(error, 'displayQuote');
        }
      }

      checkForOverlaps(currentBlock, currentIndex) {
        // Check if current block overlaps with any previous blocks
        for (let i = 0; i < currentIndex; i++) {
          const previousBlock = this.blocks[i];
          
          // Simple rectangle overlap detection
          const overlapX = Math.max(0, 
            Math.min(currentBlock.x + currentBlock.width, previousBlock.x + previousBlock.width) - 
            Math.max(currentBlock.x, previousBlock.x)
          );
          
          const overlapY = Math.max(0,
            Math.min(currentBlock.y + currentBlock.height, previousBlock.y + previousBlock.height) - 
            Math.max(currentBlock.y, previousBlock.y)
          );
          
          // If there's significant overlap (more than 20% of either block's area)
          const overlapArea = overlapX * overlapY;
          const currentArea = currentBlock.width * currentBlock.height;
          const previousArea = previousBlock.width * previousBlock.height;
          
          if (overlapArea > 0 && (overlapArea > currentArea * 0.2 || overlapArea > previousArea * 0.2)) {
            return true;
          }
        }
        return false;
      }

      checkEdgeAdjacency(currentBlock, edgePosition) {
        // Check if a specific edge of the current block is adjacent to other blocks
        const tolerance = 10; // Distance tolerance for adjacency
        
        for (let i = 0; i < this.blocks.length; i++) {
          const otherBlock = this.blocks[i];
          if (otherBlock === currentBlock) continue;
          
          let isAdjacent = false;
          
          switch (edgePosition) {
            case 'top':
              // Check if this block's top edge is near another block's bottom edge
              isAdjacent = Math.abs(currentBlock.y - (otherBlock.y + otherBlock.height)) < tolerance;
              break;
            case 'right':
              // Check if this block's right edge is near another block's left edge
              isAdjacent = Math.abs((currentBlock.x + currentBlock.width) - otherBlock.x) < tolerance;
              break;
            case 'bottom':
              // Check if this block's bottom edge is near another block's top edge
              isAdjacent = Math.abs((currentBlock.y + currentBlock.height) - otherBlock.y) < tolerance;
              break;
            case 'left':
              // Check if this block's left edge is near another block's right edge
              isAdjacent = Math.abs(currentBlock.x - (otherBlock.x + otherBlock.width)) < tolerance;
              break;
          }
          
          if (isAdjacent) return true;
        }
        
        return false;
      }

      isOuterEdge(currentBlock, edgePosition) {
        // Check if this edge is on the outer boundary of the quilt
        const quiltBounds = this.getQuiltBounds();
        const tolerance = 15; // Larger tolerance to allow more freedom
        
        switch (edgePosition) {
          case 'top':
            return Math.abs(currentBlock.y - quiltBounds.top) < tolerance;
          case 'right':
            return Math.abs((currentBlock.x + currentBlock.width) - quiltBounds.right) < tolerance;
          case 'bottom':
            return Math.abs((currentBlock.y + currentBlock.height) - quiltBounds.bottom) < tolerance;
          case 'left':
            return Math.abs(currentBlock.x - quiltBounds.left) < tolerance;
          default:
            return false;
        }
      }

      getQuiltBounds() {
        // Calculate the bounding box of all blocks
        if (this.blocks.length === 0) {
          // Return default bounds for empty quilt
          return { top: 0, right: 600, bottom: 600, left: 0 };
        }
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        this.blocks.forEach(block => {
          minX = Math.min(minX, block.x);
          minY = Math.min(minY, block.y);
          maxX = Math.max(maxX, block.x + block.width);
          maxY = Math.max(maxY, block.y + block.height);
        });
        
        return { top: minY, right: maxX, bottom: maxY, left: minX };
      }

      createOrganicQuiltBoundary(bounds) {
        // Create a fixed, large plastic dropcloth that doesn't change size
        const dropclothSize = 800; // Large fixed size
        const centerX = 300; // Center of 600px quilt area
        const centerY = 300;
        
        // Create fixed bounds for the dropcloth
        const expandedBounds = {
          top: centerY - dropclothSize / 2,
          right: centerX + dropclothSize / 2,
          bottom: centerY + dropclothSize / 2,
          left: centerX - dropclothSize / 2
        };
        
        // Organic edge variation for the dropcloth
        const variation = 25; // More organic edge variation
        
        // Create organic edge points for each side
        const createOrganicSide = (startX, startY, endX, endY, isVertical = false) => {
          const numPoints = 8; // More points for smoother curves
          const points = [];
          
          for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            const x = startX + (endX - startX) * t;
            const y = startY + (endY - startY) * t;
            
            // Add organic variation
            const variationAmount = (Math.random() - 0.5) * variation;
            const organicX = x + (isVertical ? variationAmount : 0);
            const organicY = y + (isVertical ? 0 : variationAmount);
            
            points.push({ x: organicX, y: organicY });
          }
          
          return points;
        };
        
        // Generate organic sides
        const topSide = createOrganicSide(expandedBounds.left, expandedBounds.top, expandedBounds.right, expandedBounds.top, false);
        const rightSide = createOrganicSide(expandedBounds.right, expandedBounds.top, expandedBounds.right, expandedBounds.bottom, true);
        const bottomSide = createOrganicSide(expandedBounds.right, expandedBounds.bottom, expandedBounds.left, expandedBounds.bottom, false);
        const leftSide = createOrganicSide(expandedBounds.left, expandedBounds.bottom, expandedBounds.left, expandedBounds.top, true);
        
        // Create path with organic boundary
        const pathData = `M ${topSide[0].x},${topSide[0].y}
                          ${topSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${topSide[topSide.length - 1].x},${topSide[topSide.length - 1].y}
                          ${rightSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${rightSide[rightSide.length - 1].x},${rightSide[rightSide.length - 1].y}
                          ${bottomSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${bottomSide[bottomSide.length - 1].x},${bottomSide[bottomSide.length - 1].y}
                          ${leftSide.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                          L ${leftSide[leftSide.length - 1].x},${leftSide[leftSide.length - 1].y} Z`;
        
        return pathData;
      }

      handleKeyDown(event) {
        if (event.key === 'Escape') {
          if (this.currentScreen === 'screen-quote') {
            this.showScreen('screen-portal');
          } else if (this.currentScreen === 'screen-color') {
            this.showScreen('screen-quote');
          } else if (this.currentScreen === 'screen-quilt') {
            this.showScreen('screen-color');
          }
        }
      }

      tryToJoinPatches(patch1, patch2) {
        // Check if patches can be joined along edges of similar length
        const tolerance = 0.2; // 20% tolerance for "similar" lengths
        
        // Check horizontal joining (patch1 right edge to patch2 left edge)
        if (Math.abs(patch1.height - patch2.height) / Math.max(patch1.height, patch2.height) < tolerance) {
          if (this.canJoinHorizontally(patch1, patch2)) {
            return this.joinPatchesHorizontally(patch1, patch2);
          }
        }
        
        // Check vertical joining (patch1 bottom edge to patch2 top edge)
        if (Math.abs(patch1.width - patch2.width) / Math.max(patch1.width, patch2.width) < tolerance) {
          if (this.canJoinVertically(patch1, patch2)) {
            return this.joinPatchesVertically(patch1, patch2);
          }
        }
        
        return null; // Cannot join
      }

      canJoinHorizontally(item1, item2) {
        // Check if items can be joined horizontally (right edge of item1 to left edge of item2)
        const gap = Math.abs((item1.x + item1.width) - item2.x);
        return gap < 20; // Allow small gap for organic feel
      }

      canJoinVertically(item1, item2) {
        // Check if items can be joined vertically (bottom edge of item1 to top edge of item2)
        const gap = Math.abs((item1.y + item1.height) - item2.y);
        return gap < 20; // Allow small gap for organic feel
      }

      joinPatchesHorizontally(patch1, patch2) {
        return {
          x: Math.min(patch1.x, patch2.x),
          y: Math.min(patch1.y, patch2.y),
          width: patch1.width + patch2.width,
          height: Math.max(patch1.height, patch2.height),
          color: patch2.color, // Use the newer patch's color
          type: 'block',
          patches: [patch1, patch2]
        };
      }

      joinPatchesVertically(patch1, patch2) {
        return {
          x: Math.min(patch1.x, patch2.x),
          y: Math.min(patch1.y, patch2.y),
          width: Math.max(patch1.width, patch2.width),
          height: patch1.height + patch2.height,
          color: patch2.color, // Use the newer patch's color
          type: 'block',
          patches: [patch1, patch2]
        };
      }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', async () => {
      const app = new OurDailyApp();
      await app.initialize();
    });
  </script>
</body>
</html> 