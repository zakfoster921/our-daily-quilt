<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Quilt - Simplified</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow: hidden;
      border: 3px solid purple !important;
    }

    /* ===== SCREENS ===== */
    .screen {
      display: none; /* Hide by default */
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out;
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 0.5rem 0 0 0;
      align-items: center;
      justify-content: flex-start;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      display: flex !important; /* Force display when active */
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 500;
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      margin-bottom: 0.0em;
      letter-spacing:.02em;
    }
    
    .portal-header .quilt-text {
      font-weight: 900;
      font-size: clamp(2.5rem, 6vw, 6rem);
      margin-top: -.5rem;
      margin-bottom: 0.5rem;
      letter-spacing: 0.05em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1rem, 2.5vw, 1.4rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.5rem, 3.5vw, 2.2rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.2rem;
      margin: 1.5rem auto 1.5rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 120px;
      max-height: 40vh;
    }
    
    .quote-line { 
      font-size: clamp(1rem, 2.8vw, 1.4rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(0.9rem, 2.2vw, 1.1rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: fit-content;
      gap: 1.5rem;
    }
    
    #colorWheelCanvas {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      position: relative;
      background: conic-gradient(
        hsl(25, 100%, 50%),
        hsl(40, 100%, 50%),
        hsl(55, 100%, 50%),
        hsl(70, 100%, 50%),
        hsl(85, 100%, 50%),
        hsl(100, 100%, 50%),
        hsl(115, 100%, 50%),
        hsl(130, 100%, 50%),
        hsl(145, 100%, 50%),
        hsl(160, 100%, 50%),
        hsl(175, 100%, 50%),
        hsl(190, 100%, 50%),
        hsl(205, 100%, 50%),
        hsl(220, 100%, 50%),
        hsl(235, 100%, 50%),
        hsl(250, 100%, 50%),
        hsl(265, 100%, 50%),
        hsl(280, 100%, 50%),
        hsl(295, 100%, 50%),
        hsl(310, 100%, 50%),
        hsl(325, 100%, 50%),
        hsl(340, 100%, 50%),
        hsl(355, 100%, 50%),
        hsl(10, 100%, 50%),
        hsl(25, 100%, 50%)
      );
    }
    
    .css-color-wheel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, white 0%, transparent 70%);
      pointer-events: none;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
    
    #colorWheelCanvas:hover {
      transform: scale(1.02);
    }
    
    #colorWheelCanvas:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; 
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 300px;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
      justify-content: center;
    }
    
    #screen-quote {
      justify-content: center;
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
        justify-content: center;
      }
      
      .css-color-wheel {
        width: 224px !important;
        height: 224px !important;
        background: -webkit-conic-gradient(
          hsl(25, 100%, 50%),
          hsl(40, 100%, 50%),
          hsl(55, 100%, 50%),
          hsl(70, 100%, 50%),
          hsl(85, 100%, 50%),
          hsl(100, 100%, 50%),
          hsl(115, 100%, 50%),
          hsl(130, 100%, 50%),
          hsl(145, 100%, 50%),
          hsl(160, 100%, 50%),
          hsl(175, 100%, 50%),
          hsl(190, 100%, 50%),
          hsl(205, 100%, 50%),
          hsl(220, 100%, 50%),
          hsl(235, 100%, 50%),
          hsl(250, 100%, 50%),
          hsl(265, 100%, 50%),
          hsl(280, 100%, 50%),
          hsl(295, 100%, 50%),
          hsl(310, 100%, 50%),
          hsl(325, 100%, 50%),
          hsl(340, 100%, 50%),
          hsl(355, 100%, 50%),
          hsl(10, 100%, 50%),
          hsl(25, 100%, 50%)
        );
        background: conic-gradient(
          hsl(25, 100%, 50%),
          hsl(40, 100%, 50%),
          hsl(55, 100%, 50%),
          hsl(70, 100%, 50%),
          hsl(85, 100%, 50%),
          hsl(100, 100%, 50%),
          hsl(115, 100%, 50%),
          hsl(130, 100%, 50%),
          hsl(145, 100%, 50%),
          hsl(160, 100%, 50%),
          hsl(175, 100%, 50%),
          hsl(190, 100%, 50%),
          hsl(205, 100%, 50%),
          hsl(220, 100%, 50%),
          hsl(235, 100%, 50%),
          hsl(250, 100%, 50%),
          hsl(265, 100%, 50%),
          hsl(280, 100%, 50%),
          hsl(295, 100%, 50%),
          hsl(310, 100%, 50%),
          hsl(325, 100%, 50%),
          hsl(340, 100%, 50%),
          hsl(355, 100%, 50%),
          hsl(10, 100%, 50%),
          hsl(25, 100%, 50%)
        );
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */
    #quilt {
      width: 100vw !important;
      height: 100%;
      max-width: 100vw !important;
      max-height: 100%;
      background: transparent;
      position: relative;
      display: block;
      margin: 0;
      padding: 0;
      border: 3px solid blue !important;
    }
    
    .quilt-container {
      width: 100%;
      height: 100vh;
      position: relative;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      background: transparent;
      overflow: hidden;
      border: 3px solid red !important;
    }

    /* ===== SQUARE COUNTER ===== */
    .square-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #000;
      border-radius: 8px;
      font-family: inherit;
    }
    
    .counter-number {
      font-size: 1.5rem;
      font-weight: 700;
      color: #000;
    }
    
    .counter-label {
      font-size: 1rem;
      font-weight: 400;
      color: #333;
      text-transform: lowercase;
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000 !important;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #000 !important; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      html, body {
        overflow: hidden !important;
        position: fixed !important;
        width: 100% !important;
        height: 100% !important;
        -webkit-overflow-scrolling: touch;
      }
      
      #app {
        overflow: hidden !important;
        height: 100% !important;
        width: 100% !important;
      }
      
      .screen { 
        padding: 2rem 1rem 0 1rem; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      .quilt-container {
        width: 100% !important;
        max-width: 100vw !important;
        height: 100vh !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        z-index: 1;
        display: flex !important;
        align-items: stretch !important;
        justify-content: stretch !important;
        overflow: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
        border: 3px solid red !important;
        background-color: rgba(255, 0, 0, 0.1) !important;
      }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      

      
      /* Square counter styling for quilt screen */
      #screen-quilt .square-counter {
        background: #fff !important;
        border: 2px solid #000 !important;
        margin: 1rem 0.5rem 0.5rem 0.5rem !important;
        padding: 0.5rem !important;
        border-radius: 6px !important;
      }
      
      #screen-quilt .counter-number {
        font-size: 1.3rem !important;
        font-weight: 700 !important;
      }
      
      #screen-quilt .counter-label {
        font-size: 0.9rem !important;
      }
      
      /* Quilt screen button styling - QUILT SCREEN ONLY */
      #screen-quilt .btn {
        background: #fff !important;
        border: 2px solid #000 !important;
        color: #000 !important;
        font-size: 0.9rem !important;
        padding: 8px 16px !important;
        margin: 0.5rem !important;
        display: block !important;
        width: 100% !important;
        max-width: none !important;
      }
      
      /* Reset button styling for other screens */
      #screen-portal .btn,
      #screen-welcome .btn,
      #screen-quote .btn,
      #screen-color .btn,
      #screen-archive .btn,
      #screen-about .btn {
        background: transparent !important;
        border: 1px solid #000 !important;
        font-size: 1rem !important;
        padding: 12px 30px !important;
        margin: 0.5rem !important;
        display: inline-block !important;
        width: auto !important;
        max-width: none !important;
      }
      
      #screen-quilt {
        padding: 0 !important;
        margin: 0 !important;
        justify-content: flex-start !important;
        align-items: stretch !important;
        min-height: 100vh !important;
        height: 100vh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        max-width: 100vw !important;
        border: 3px solid green !important;
        background-color: rgba(0, 255, 0, 0.1) !important;
        box-sizing: border-box !important;
      }
      
      /* Fixed height screens - NO SCROLLING */
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 1rem !important;
        justify-content: center !important;
        align-items: center !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
      
      /* Quilt screen - CAN SCROLL */
      #screen-quilt {
        padding: 0 !important;
        justify-content: flex-start !important;
        align-items: stretch !important;
        min-height: 100vh !important;
        height: auto !important;
        max-height: none !important;
        overflow-y: auto !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
      }
      
      /* Archive screen - CAN SCROLL */
      #screen-archive {
        padding: 3rem 0 10px 0 !important;
        justify-content: flex-start !important;
        align-items: center !important;
        min-height: 100vh !important;
        height: auto !important;
        max-height: none !important;
        overflow-y: auto !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
      }
      
      /* About screen - FIXED HEIGHT */
      #screen-about {
        padding: 3rem 0 10px 0 !important;
        justify-content: center !important;
        align-items: center !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        overflow: hidden !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
      }
      
      /* Button container that sits below the full-screen quilt - QUILT SCREEN ONLY */
      #screen-quilt .button-container {
        position: relative !important;
        background: #f6f4f1 !important;
        padding: 1rem !important;
        border-top: 2px solid #000 !important;
        margin-top: 100vh !important;
        border: 3px solid orange !important;
      }
      
      /* Ensure other screens don't have button container styling */
      #screen-portal .button-container,
      #screen-welcome .button-container,
      #screen-quote .button-container,
      #screen-color .button-container,
      #screen-archive .button-container,
      #screen-about .button-container {
        position: static !important;
        background: transparent !important;
        padding: 0 !important;
        border-top: none !important;
        margin-top: 0 !important;
      }
      

      

      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      html, body {
        overflow: hidden !important;
        position: fixed !important;
        width: 100vw !important;
        height: 100vh !important;
        -webkit-overflow-scrolling: touch;
      }
      
      #app {
        overflow: hidden !important;
        height: 100vh !important;
        width: 100vw !important;
      }
      
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
      
      .quilt-container {
        width: 100% !important;
        max-width: 100vw !important;
        height: 100vh !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        z-index: 1;
        display: flex !important;
        align-items: stretch !important;
        justify-content: stretch !important;
        overflow: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
        border: 3px solid red !important;
        background-color: rgba(255, 0, 0, 0.1) !important;
      }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      
      #screen-quilt .thank-you-message {
        font-size: 1rem;
        margin-bottom: 0.3rem;
      }
      
      /* Fixed height screens for smaller mobile - NO SCROLLING */
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 0.5rem !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
    }

    /* ===== FLOATING ADMIN BUTTON ===== */
    .floating-admin-btn {
      position: fixed !important;
      bottom: 20px !important;
      right: 20px !important;
      width: 50px !important;
      height: 50px !important;
      border-radius: 50% !important;
      background: #f6f4f1 !important;
      color: #000 !important;
      border: none !important;
      font-size: 20px !important;
      cursor: pointer !important;
      z-index: 1000 !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2) !important;
      transition: all 0.3s ease !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }

    .floating-admin-btn:hover {
      transform: scale(1.1) !important;
      box-shadow: 0 6px 12px rgba(0,0,0,0.4) !important;
    }

    .floating-admin-btn:active {
      transform: scale(0.95) !important;
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    /* ===== MOBILE SCROLL PREVENTION ===== */
    @media (max-width: 768px) {
      * {
        -webkit-overflow-scrolling: touch;
      }
      
      .screen {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
      }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }

    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-feed {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .archive-load-more {
      margin: 2rem auto;
      display: block;
      background: #666;
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 24px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .archive-load-more:hover {
      background: #333;
    }
    
    .archive-load-more:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .archive-loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }

    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <main id="app">
    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <h1 class="quilt-text">QUILT</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">↓</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="25" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">
      <!-- Quilt container -->
      <div class="quilt-container">
        <svg id="quilt" viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      </div>
      
      <!-- Button container -->
      <div class="button-container">
        <!-- Square counter -->
        <div class="square-counter">
          <span class="counter-number" id="squareCounter">1</span>
          <span class="counter-label">squares</span>
        </div>
        
        <div class="button-group">
          <button id="testAddBlock" class="btn" style="background: #ff6b6b; color: white;">TEST: ADD RANDOM BLOCK</button>
          <button id="rumiTestBtn" class="btn" style="background: #FF9800; color: white;">🧪 TEST RUMI SEQUENCE</button>
          <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white;">SHOW ME MY PIECE</button>
          <button id="testDifferentUserBtn" class="btn" style="background: #9C27B0; color: white;">TEST: Simulate Different User</button>
        </div>
        
        <div class="button-group">
          <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button>
          <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
          <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
        </div>
      </div>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <!-- Archive Feed -->
      <div class="archive-feed" id="archiveFeed">
        <!-- Archive posts will be dynamically inserted here -->
      </div>
      
      <!-- Load More Button -->
      <button class="btn archive-load-more" id="archiveLoadMore" style="display: none;">Load More</button>
      
      <!-- Loading Indicator -->
      <div class="archive-loading" id="archiveLoading" style="display: none;">
        <p>Loading quilts...</p>
      </div>
      
      <!-- Back Button -->
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

  <!-- Toast notifications -->
  <div id="toast" class="toast" role="alert" aria-live="polite"></div>

  <!-- Floating Admin Button -->
  <button id="floatingAdminBtn" class="floating-admin-btn" aria-label="Admin controls" style="display: none;">
    ⚙️
  </button>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script type="module">
    // ===== CONFIGURATION =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '2.0.0-simplified',
        defaultColor: '#f7b733',
        quiltSize: 1000, // Base size for calculations
        minBlockSize: 40,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        gridCols: 8,
        gridRows: 8,
        blockSpacing: 4,
        blockPadding: 2
      }
    };

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static hexToLightness(hexColor) {
        // Convert hex to RGB
        const r = parseInt(hexColor.slice(1, 3), 16) / 255;
        const g = parseInt(hexColor.slice(3, 5), 16) / 255;
        const b = parseInt(hexColor.slice(5, 7), 16) / 255;
        
        // Calculate relative luminance (lightness)
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        return luminance;
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static getQuiltDimensions() {
        // Comprehensive viewport detection for mobile devices
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        const hasDynamicViewport = CSS.supports('height', '1dvh');
        
        let screenWidth, screenHeight;
        let detectionMethod = 'unknown';
        
        if (hasVisualViewport) {
          // Method 1: Visual Viewport API (most accurate)
          screenWidth = window.visualViewport.width;
          screenHeight = window.visualViewport.height;
          
          // Apply small safety margin for visual viewport (5% or 40px max)
          const safetyMargin = Math.min(screenHeight * 0.05, 40);
          screenHeight = screenHeight - safetyMargin;
          
          detectionMethod = 'visualViewport';
        } else {
          // Method 2: Try to measure actual visible area
          const body = document.body;
          const html = document.documentElement;
          
          // Get the actual rendered dimensions
          const bodyRect = body.getBoundingClientRect();
          const htmlRect = html.getBoundingClientRect();
          
          // Use the smaller of the two (more likely to be accurate)
          const measuredWidth = Math.min(bodyRect.width, htmlRect.width);
          const measuredHeight = Math.min(bodyRect.height, htmlRect.height);
          
          if (measuredWidth > 0 && measuredHeight > 0) {
            screenWidth = measuredWidth;
            screenHeight = measuredHeight;
            detectionMethod = 'getBoundingClientRect';
          } else {
            // Method 3: Fallback to inner dimensions with safety margin
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            
            // Apply safety margin for browser UI
            const browserUIMargin = Math.min(screenHeight * 0.15, 120); // 15% or 120px max
            screenHeight = screenHeight - browserUIMargin;
            detectionMethod = 'innerDimensionsWithMargin';
          }
        }
        
        const isMobile = screenWidth <= 768;
        
        console.log('🔍 DEBUG: Screen dimensions:', { 
          screenWidth, 
          screenHeight, 
          isMobile,
          detectionMethod,
          hasVisualViewport,
          hasDynamicViewport,
          visualViewport: window.visualViewport ? {
            width: window.visualViewport.width,
            height: window.visualViewport.height,
            scale: window.visualViewport.scale,
            offsetTop: window.visualViewport.offsetTop,
            offsetLeft: window.visualViewport.offsetLeft
          } : 'not available',
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight,
          bodyRect: document.body ? document.body.getBoundingClientRect() : 'not available',
          htmlRect: document.documentElement ? document.documentElement.getBoundingClientRect() : 'not available'
        });
        
        if (isMobile) {
          // On mobile, use the most accurate viewport available
          const dimensions = {
            width: screenWidth,
            height: screenHeight,
            viewBoxWidth: screenWidth,
            viewBoxHeight: screenHeight
          };
          console.log(`📱 Mobile dimensions (${detectionMethod}):`, dimensions);
          return dimensions;
        } else {
          // On desktop, use a square that fits the screen
          const maxSize = Math.min(screenWidth * 0.8, screenHeight * 0.8);
          const dimensions = {
            width: maxSize,
            height: maxSize,
            viewBoxWidth: maxSize,
            viewBoxHeight: maxSize
          };
          console.log('🖥️ Desktop dimensions:', dimensions);
          return dimensions;
        }
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }

      static getColorFamily(color) {
        const hsl = Utils.hexToHsl(color);
        const hue = hsl.h;
        
        // Define color families based on hue ranges
        if (hue >= 0 && hue < 30) return 'red';
        if (hue >= 30 && hue < 60) return 'orange';
        if (hue >= 60 && hue < 90) return 'yellow';
        if (hue >= 90 && hue < 150) return 'green';
        if (hue >= 150 && hue < 210) return 'cyan';
        if (hue >= 210 && hue < 270) return 'blue';
        if (hue >= 270 && hue < 300) return 'magenta';
        if (hue >= 300 && hue < 330) return 'pink';
        if (hue >= 330 && hue < 360) return 'red';
        
        return 'neutral';
      }

      static hexToHsl(hexColor) {
        const r = parseInt(hexColor.slice(1, 3), 16) / 255;
        const g = parseInt(hexColor.slice(3, 5), 16) / 255;
        const b = parseInt(hexColor.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;
        
        let h = 0;
        let s = 0;
        const l = (max + min) / 2;
        
        if (delta !== 0) {
          s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
          
          switch (max) {
            case r: h = ((g - b) / delta) % 6; break;
            case g: h = (b - r) / delta + 2; break;
            case b: h = (r - g) / delta + 4; break;
          }
          
          h = h * 60;
          if (h < 0) h += 360;
        }
        
        return { h, s: s * 100, l: l * 100 };
      }
    }

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = '🧵';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} ⚠️ ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} ❌ ${message}`, error || '');
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        try {
          this.logger.log(`🔄 Switching to screen: ${screenId}`);
          
          // Remove active class from all screens
          document.querySelectorAll(".screen").forEach(s => {
            s.classList.remove("active");
            s.style.display = 'none'; // Ensure screens are hidden
          });
          
          const target = document.getElementById(screenId);
          if (target) {
            // Show the target screen
            target.style.display = 'flex';
            target.classList.add("active");
            
            // Force a reflow to ensure the screen is visible
            target.offsetHeight;
            
            this.logger.log(`✅ Successfully switched to ${screenId}`);
            
            if (screenId === 'screen-color') {
              const colorScreen = document.getElementById('screen-color');
              if (colorScreen) {
                colorScreen.style.backgroundColor = '#f6f4f1';
              }
            }
            
            // Reset scroll positions
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            const app = document.getElementById('app');
            if (app) {
              app.scrollTop = 0;
            }
          } else {
            this.logger.error(`❌ Screen not found: ${screenId}`);
            // Fallback to portal screen
            this.showScreen('screen-portal');
          }
        } catch (error) {
          this.logger.error(`❌ Error switching to screen ${screenId}:`, error);
          // Emergency fallback
          const portalScreen = document.getElementById('screen-portal');
          if (portalScreen) {
            document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
            portalScreen.classList.add("active");
            portalScreen.style.display = 'flex';
          }
        }
      }
    }

    // ===== ERROR HANDLING SERVICE =====
    class ErrorHandler {
      constructor(uiService, logger) {
        this.uiService = uiService;
        this.logger = logger;
      }

      handleError(error, context = 'Unknown') {
        this.logger.error(`Error in ${context}:`, error);
        
        const errorMessages = {
          'loadQuilt': 'Failed to load quilt data. Starting fresh.',
          'saveQuilt': 'Failed to save your color. Please try again.',
          'shareFlow': 'Failed to create share image. Saving instead.',
          'colorPicker': 'Color picker error. Please try again.',
          'App initialization': 'Failed to initialize app. Please refresh.',
          'renderQuilt': 'Failed to render quilt. Please try again.',
          'addColorToQuilt': 'Failed to add color. Please try again.'
        };
        
        const message = errorMessages[context] || 'Something went wrong. Please try again.';
        this.uiService.showToast(message);
      }

      validateColor(color) {
        if (!Utils.validateHexColor(color)) {
          throw new Error(`Invalid color format: ${color}`);
        }
        return true;
      }
    }

    // ===== DATA LAYER =====
    class QuiltDataService {
      constructor(logger, errorHandler) {
        this.logger = logger;
        this.errorHandler = errorHandler;
        this.db = null;
        this.quiltDoc = null;
      }

      async initialize() {
        try {
          this.logger.log('🔄 Starting Firebase initialization...');
          
          const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js');
          const { getFirestore, doc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
          
          const app = initializeApp(CONFIG.FIREBASE);
          this.db = getFirestore(app);
          this.quiltDoc = doc(this.db, 'quilts', 'daily');
          
          this.logger.log('✅ Firebase initialization complete');
        } catch (error) {
          this.logger.error('❌ Firebase initialization failed:', error);
          this.errorHandler.handleError(error, 'Firebase initialization');
          this.db = null;
          this.quiltDoc = null;
        }
      }

      async loadQuilt() {
        try {
          this.logger.log('🔄 Loading quilt data from Firebase...');
          
          if (!this.db || !this.quiltDoc) {
            this.logger.log('❌ Firebase not initialized');
            const dimensions = Utils.getQuiltDimensions();
        return [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }];
          }
          
          const { getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
          const docSnap = await getDoc(this.quiltDoc);
          
          if (docSnap.exists()) {
            const data = docSnap.data();
            const blocks = data.blocks || [];
            const contributorCount = data.contributorCount || 1;
            this.logger.log(`✅ Successfully loaded ${blocks.length} blocks from Firebase`);
            return { blocks, contributorCount };
          } else {
            this.logger.log('📝 No existing quilt document found, starting fresh');
            const dimensions = Utils.getQuiltDimensions();
            return { 
              blocks: [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }], 
              contributorCount: 1 
            };
          }
        } catch (error) {
          this.logger.error('❌ Firebase load error:', error);
          this.errorHandler.handleError(error, 'loadQuilt');
          const dimensions = Utils.getQuiltDimensions();
          return { 
            blocks: [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }], 
            contributorCount: 1 
          };
        }
      }

      async saveQuilt(blocks, contributorCount) {
        try {
          this.logger.log('Saving quilt data');
          
          if (!this.db || !this.quiltDoc) {
            this.logger.log('Firebase not available, skipping save');
            return true;
          }
          
          const { setDoc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
          await setDoc(this.quiltDoc, {
            blocks: blocks,
            contributorCount: contributorCount,
            lastUpdated: new Date().toISOString(),
            date: new Date().toISOString().split('T')[0]
          });
          
          this.logger.log(`🔥 Saved ${blocks?.length || 0} blocks to Firebase`);
          return true;
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          this.logger.log('⚠️ Firebase save failed');
          return false;
        }
      }
    }

    // ===== QUOTE SERVICE =====
    class QuoteService {
      constructor() {
        this.quotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "— Pablo Picasso" },
          { text: "Creativity takes courage.", author: "— Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "— Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "— Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "— Vincent Van Gogh" },
          { text: "You can't use up creativity. The more you use, the more you have.", author: "— Maya Angelou" }
        ];
        this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
      }

      getTodayQuote() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayString = `${year}-${month}-${day}`;
        const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        return this.quotes[quoteIndex];
      }

      displayQuote() {
        try {
          const { text, author } = this.getTodayQuote();
          const quoteLine = document.querySelector('.quote-line');
          const quoteAuthor = document.querySelector('.quote-author');
          
          if (quoteLine) quoteLine.textContent = text;
          if (quoteAuthor) quoteAuthor.textContent = author;
        } catch (error) {
          console.error('Error displaying quote:', error);
        }
      }
    }

    // ===== BLOCK-BASED QUILT RENDERER =====
    class BlockQuiltRenderer {
      constructor(logger) {
        this.logger = logger;
        this.quiltSVG = null;
        this.lastAddedIndex = null;
      }

      initialize() {
        this.quiltSVG = document.getElementById('quilt');
        if (!this.quiltSVG) {
          throw new Error('Quilt SVG element not found');
        }
        this.logger.log('Block quilt renderer initialized');
      }

      renderBlocks(blocks) {
        if (!this.quiltSVG) {
          this.logger.warn('Quilt SVG not found');
          return;
        }

        this.logger.log(`🎨 Rendering ${blocks.length} blocks`);

        // Clear existing content
        this.quiltSVG.innerHTML = '';

        if (blocks.length === 0) {
          this.logger.log('No blocks to render');
          return;
        }

        // Set viewBox and dimensions to match the quilt dimensions
        const dimensions = Utils.getQuiltDimensions();
        console.log('🎨 RENDERER: Applying dimensions:', dimensions);
        
        // Use full available width and calculated height
        const fullWidth = window.innerWidth;
        const calculatedHeight = dimensions.height;
        
        this.quiltSVG.setAttribute('viewBox', `0 0 ${fullWidth} ${calculatedHeight}`);
        this.quiltSVG.setAttribute('width', fullWidth);
        this.quiltSVG.setAttribute('height', calculatedHeight);
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMidYMid slice');
        
        // Force CSS width to full viewport width
        this.quiltSVG.style.width = `${fullWidth}px`;
        this.quiltSVG.style.maxWidth = `${fullWidth}px`;
        this.quiltSVG.style.minWidth = `${fullWidth}px`;
        
        console.log('🎨 RENDERER: SVG attributes set:', {
          viewBox: this.quiltSVG.getAttribute('viewBox'),
          width: this.quiltSVG.getAttribute('width'),
          height: this.quiltSVG.getAttribute('height'),
          preserveAspectRatio: this.quiltSVG.getAttribute('preserveAspectRatio')
        });
        
        this.logger.log(`ViewBox set to: ${fullWidth} x ${calculatedHeight}, size: ${fullWidth} x ${calculatedHeight}`);

        // Add SVG definitions for effects
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
          <filter id="dropShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="rgba(0,0,0,0.15)"/>
          </filter>
          <filter id="watercolorTexture" x="0" y="0" width="100%" height="100%">
            <feTurbulence baseFrequency="0.3" numOctaves="2" result="noise" type="fractalNoise"/>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.1 0" in="noise" result="texture"/>
            <feBlend mode="multiply" in="SourceGraphic" in2="texture"/>
          </filter>
        `;
        this.quiltSVG.appendChild(defs);



        // Render each block
        blocks.forEach((block, i) => {
          // Add jittered positioning for organic feel - scaled by block size
          const blockArea = block.width * block.height;
          const maxArea = 10000; // Reference area for scaling
          const jitterScale = Math.min(1, Math.max(0.3, blockArea / maxArea)); // Scale between 0.3 and 1
          
          const jitterX = (Math.random() - 0.5) * 6 * jitterScale;
          const jitterY = (Math.random() - 0.5) * 6 * jitterScale;
          const jitterRotation = (Math.random() - 0.5) * 3 * jitterScale;
          
          const jitteredBlock = {
            x: block.x + jitterX,
            y: block.y + jitterY,
            width: block.width,
            height: block.height,
            color: block.color,
            rotation: jitterRotation
          };
          
          // Create organic edges
          const edgeVariation = 2;
          const topEdge = this.createWatercolorEdge(jitteredBlock.x, jitteredBlock.y, jitteredBlock.x + jitteredBlock.width, jitteredBlock.y, false, edgeVariation);
          const rightEdge = this.createWatercolorEdge(jitteredBlock.x + jitteredBlock.width, jitteredBlock.y, jitteredBlock.x + jitteredBlock.width, jitteredBlock.y + jitteredBlock.height, true, edgeVariation);
          const bottomEdge = this.createWatercolorEdge(jitteredBlock.x + jitteredBlock.width, jitteredBlock.y + jitteredBlock.height, jitteredBlock.x, jitteredBlock.y + jitteredBlock.height, false, edgeVariation);
          const leftEdge = this.createWatercolorEdge(jitteredBlock.x, jitteredBlock.y + jitteredBlock.height, jitteredBlock.x, jitteredBlock.y, true, edgeVariation);
          
          // Create path with organic edges
          const pathData = `M ${topEdge[0].x},${topEdge[0].y}
                            ${topEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${topEdge[topEdge.length - 1].x},${topEdge[topEdge.length - 1].y}
                            ${rightEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${rightEdge[rightEdge.length - 1].x},${rightEdge[rightEdge.length - 1].y}
                            ${bottomEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${bottomEdge[bottomEdge.length - 1].x},${bottomEdge[bottomEdge.length - 1].y}
                            ${leftEdge.slice(1, -1).map(p => `L ${p.x},${p.y}`).join(' ')}
                            L ${leftEdge[leftEdge.length - 1].x},${leftEdge[leftEdge.length - 1].y} Z`;
          
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', pathData);
          path.setAttribute('fill', jitteredBlock.color);
          
          // Apply rotation transform
          const centerX = jitteredBlock.x + jitteredBlock.width / 2;
          const centerY = jitteredBlock.y + jitteredBlock.height / 2;
          path.setAttribute('transform', `rotate(${jitteredBlock.rotation} ${centerX} ${centerY})`);
          
          // Add animation for new blocks
          if (i === this.lastAddedIndex) {
            path.setAttribute('opacity', '0');
            path.classList.add('new-block');
            path.addEventListener('animationend', () => {
              path.classList.remove('new-block');
              path.removeAttribute('opacity');
            }, { once: true });
          }
          
          this.quiltSVG.appendChild(path);
        });

        this.lastAddedIndex = null;
        this.logger.log(`✅ Rendered ${blocks.length} organic blocks`);
      }

      createWatercolorEdge(startX, startY, endX, endY, isVertical = false, edgeVariation = 2) {
        const numPoints = 5;
        const points = [];
        
        for (let i = 0; i <= numPoints; i++) {
          const t = i / numPoints;
          const x = startX + (endX - startX) * t;
          const y = startY + (endY - startY) * t;
          
          // Create organic curves
          const smoothCurve = Math.sin(t * Math.PI) * Math.sin(t * Math.PI);
          const curveIntensity = smoothCurve * edgeVariation * 0.7;
          const variation = curveIntensity + (Math.random() - 0.5) * edgeVariation * 0.2;
          
          const diagonalVariation = (Math.random() - 0.5) * edgeVariation * 0.1;
          
          const organicX = x + (isVertical ? variation : diagonalVariation);
          const organicY = y + (isVertical ? diagonalVariation : variation);
          
          points.push({ x: organicX, y: organicY });
        }
        
        return points;
      }



      setLastAddedIndex(index) {
        this.lastAddedIndex = index;
      }
    }

    // ===== MAIN APPLICATION =====
    class SimplifiedQuiltApp {
      constructor() {
        // Initialize services
        this.logger = new Logger(CONFIG.APP.debugMode);
        this.uiService = new UIService(this.logger);
        this.errorHandler = new ErrorHandler(this.uiService, this.logger);
        this.dataService = new QuiltDataService(this.logger, this.errorHandler);
        this.quoteService = new QuoteService();
        this.renderer = new BlockQuiltRenderer(this.logger);
        
        // App state - now using blocks instead of colors
        const dimensions = Utils.getQuiltDimensions();
        this.blocks = [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }];
        this.contributorCount = 1;
        this.currentUserId = Utils.getOrCreateUserId();
        
        // Color picker state
        this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
        this.selectedSaturation = CONFIG.COLOR_PICKER.saturation;
        this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
        this.colorHasBeenSelected = false;
        
        this.logger.log('SimplifiedQuiltApp initialized with block-based system');
      }

      async initialize() {
        try {
          this.logger.log('🚀 Starting app initialization...');
          this.logger.log(`Initial blocks state:`, this.blocks);
          
          // Ensure portal screen is visible during initialization
          this.uiService.showScreen('screen-portal');
          
          await this.dataService.initialize();
          this.setupEventListeners();
          this.initializeUI();
          await this.loadQuilt();
          
          this.logger.log(`After loadQuilt, blocks:`, this.blocks);
          
          this.renderer.initialize();
          this.renderQuilt();
          this.updateSquareCounter();
          
          this.logger.log('App initialization complete');
          this.logger.log(`Final blocks state:`, this.blocks);
          
          // Auto-transition from portal screen after delay
          this.setupAutoTransition();
          
        } catch (error) {
          this.errorHandler.handleError(error, 'App initialization');
          // Ensure portal screen is still visible even if initialization fails
          this.uiService.showScreen('screen-portal');
        }
      }

      setupEventListeners() {
        // Navigation
        document.querySelectorAll(".btn[data-next]").forEach(btn => {
          btn.addEventListener("click", e => {
            e.preventDefault();
            const targetId = btn.getAttribute("data-next");
            if (targetId) this.uiService.showScreen(targetId);
          });
        });

        // Add color button
        const addColorBtn = document.getElementById('addColorBtn');
        if (addColorBtn) {
          addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
        }

        // Share button
        const shareBtnCompleted = document.getElementById('shareBtnCompleted');
        if (shareBtnCompleted) {
          shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
        }

        // Test buttons
        const testAddBlock = document.getElementById('testAddBlock');
        if (testAddBlock) {
          testAddBlock.addEventListener('click', this.handleTestAddBlock.bind(this));
        }

        const rumiTestBtn = document.getElementById('rumiTestBtn');
        if (rumiTestBtn) {
          rumiTestBtn.addEventListener('click', this.testRumiColorSequence.bind(this));
        }

        const showMyPieceBtn = document.getElementById('showMyPieceBtn');
        if (showMyPieceBtn) {
          showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
        }

        const testDifferentUserBtn = document.getElementById('testDifferentUserBtn');
        if (testDifferentUserBtn) {
          testDifferentUserBtn.addEventListener('click', this.handleTestDifferentUser.bind(this));
        }

        // Color picker
        this.setupColorPicker();

        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        
        // Window resize handler
        window.addEventListener('resize', this.handleWindowResize.bind(this));
        
        // Visual viewport resize handler (for mobile browser UI changes)
        if (window.visualViewport) {
          window.visualViewport.addEventListener('resize', this.handleWindowResize.bind(this));
        }
        
        // Floating admin button
        this.setupFloatingAdminButton();
      }

      setupColorPicker() {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const valueSlider = document.getElementById('valueSlider');

        if (colorWheel) {
          // Mouse events for CSS color wheel
          colorWheel.addEventListener('mousedown', this.handleColorWheelMouseDown.bind(this));
          colorWheel.addEventListener('mousemove', this.handleColorWheelMouseMove.bind(this));
          colorWheel.addEventListener('mouseup', this.handleColorWheelMouseUp.bind(this));
          
          // Touch events for CSS color wheel
          colorWheel.addEventListener('touchstart', this.handleColorWheelTouchStart.bind(this));
          colorWheel.addEventListener('touchmove', this.handleColorWheelTouchMove.bind(this));
          colorWheel.addEventListener('touchend', this.handleColorWheelTouchEnd.bind(this));
          
          // Keyboard events for CSS color wheel
          colorWheel.addEventListener('keydown', this.handleColorWheelKeyDown.bind(this));
          
          // Click event for CSS color wheel
          colorWheel.addEventListener('click', this.handleColorWheelClick.bind(this));
        }

        if (valueSlider) {
          valueSlider.addEventListener('input', this.handleValueSliderChange.bind(this));
        }

        // Initialize color wheel
        this.updateColorWheel();
      }

      handleColorWheelMouseDown(e) {
        e.preventDefault();
        this.isDragging = true;
        this.setHueFromCoords(e.clientX, e.clientY);
      }

      handleColorWheelMouseMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          this.setHueFromCoords(e.clientX, e.clientY);
        }
      }

      handleColorWheelMouseUp(e) {
        this.isDragging = false;
      }

      handleColorWheelClick(e) {
        e.preventDefault();
        this.setHueFromCoords(e.clientX, e.clientY);
        this.updateColorWheel();
      }

      handleColorWheelTouchStart(e) {
        e.preventDefault();
        this.isDragging = true;
        const touch = e.touches[0];
        this.setHueFromCoords(touch.clientX, touch.clientY);
      }

      handleColorWheelTouchMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          const touch = e.touches[0];
          this.setHueFromCoords(touch.clientX, touch.clientY);
        }
      }

      handleColorWheelTouchEnd(e) {
        this.isDragging = false;
      }

      handleColorWheelKeyDown(e) {
        const step = 15;
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            this.selectedHue = (this.selectedHue - step + 360) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.selectedHue = (this.selectedHue + step) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.selectedLightness = Math.min(90, this.selectedLightness + 5);
            this.updateColorWheel();
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.selectedLightness = Math.max(25, this.selectedLightness - 5);
            this.updateColorWheel();
            break;
        }
      }

      handleValueSliderChange(e) {
        this.selectedLightness = parseInt(e.target.value);
        this.updateColorWheel();
      }

      updateColorWheel() {
        const valueSlider = document.getElementById('valueSlider');
        
        const hslColor = `hsl(${this.selectedHue}, ${this.selectedSaturation}%, ${this.selectedLightness}%)`;
        const hexColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
        
        const colorScreen = document.getElementById('screen-color');
        if (colorScreen && this.colorHasBeenSelected) {
          colorScreen.style.backgroundColor = hexColor;
        }
        
        if (valueSlider) {
          valueSlider.style.background = `linear-gradient(to right,
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 20%), 
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 90%))`;
        }
      }

      setHueFromCoords(x, y) {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = rect.width / 2;

        // Calculate angle for hue
        let angle = Math.atan2(dy, dx) * 180 / Math.PI;
        if (angle < 0) angle += 360;
        
        const rawHue = Math.round((angle + 90) % 360);
        this.selectedHue = (rawHue + 25) % 360;
        
        // Calculate saturation based on distance from center
        const baseSaturation = Math.min(100, (distance / radius) * 100);
        this.selectedSaturation = Math.min(Math.round(baseSaturation + 5), 100);

        if (distance > radius) {
          const clampedDistance = radius;
          const clampedX = centerX + (dx / distance) * clampedDistance;
          const clampedY = centerY + (dy / distance) * clampedDistance;
          this.selectedSaturation = 100;
          
          if (indicator) {
            const container = colorWheel.parentElement;
            const containerRect = container.getBoundingClientRect();
            const relativeX = clampedX + rect.left - containerRect.left;
            const relativeY = clampedY + rect.top - containerRect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        } else {
          if (indicator) {
            const container = colorWheel.parentElement;
            const containerRect = container.getBoundingClientRect();
            const relativeX = x + rect.left - containerRect.left;
            const relativeY = y + rect.top - containerRect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        }
        
        this.colorHasBeenSelected = true;
        this.updateColorWheel();
      }

      handleKeyDown(event) {
        if (event.key === 'Escape') {
          const currentScreen = document.querySelector('.screen.active');
          if (currentScreen) {
            const currentId = currentScreen.id;
            if (currentId === 'screen-quote') {
              this.uiService.showScreen('screen-portal');
            } else if (currentId === 'screen-color') {
              this.uiService.showScreen('screen-quote');
            } else if (currentId === 'screen-quilt') {
              this.uiService.showScreen('screen-color');
            }
          }
        }
      }

      handleWindowResize() {
        this.logger.log('🔄 Window resized, updating quilt dimensions...');
        
        // Update quilt dimensions when window is resized
        if (this.blocks && this.blocks.length > 0) {
          const dimensions = Utils.getQuiltDimensions();
          this.logger.log(`New dimensions: ${dimensions.width} x ${dimensions.height}`);
          
          // Re-render the quilt with new dimensions
          
          // Re-render the quilt with new dimensions
          this.renderQuilt();
        }
      }

      setupFloatingAdminButton() {
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          // Check if current user is admin (only show for you)
          const isAdmin = this.isCurrentUserAdmin();
          
          if (isAdmin) {
            adminBtn.style.display = 'flex';
            // Only add event listener if not already added
            if (!adminBtn.hasAttribute('data-admin-initialized')) {
              adminBtn.addEventListener('click', () => {
                this.showAdminMenu();
              });
              adminBtn.setAttribute('data-admin-initialized', 'true');
            }
          } else {
            adminBtn.style.display = 'none';
          }
        }
      }

      isCurrentUserAdmin() {
        // Add your specific user ID or admin check here
        const currentUserId = this.currentUserId;
        
        // Option 1: Check for specific user ID (replace with your actual user ID)
        const adminUserIds = [
          // Add your user ID here - you can find it in localStorage or console
          'your_user_id_here'
        ];
        
        // Option 2: Check for admin flag in localStorage
        const isAdminFlag = localStorage.getItem('ourDailyIsAdmin') === 'true';
        
        // Option 3: Check for specific admin email/identifier
        const adminEmails = [
          // Add your email or identifier here
          'your_email@example.com'
        ];
        
        // For now, let's use a simple check - you can modify this
        return isAdminFlag || adminUserIds.includes(currentUserId);
      }

      // Admin helper methods
      enableAdminMode() {
        localStorage.setItem('ourDailyIsAdmin', 'true');
        this.logger.log('🔓 Admin mode enabled');
        this.uiService.showToast('Admin mode enabled');
        // Refresh the admin button
        this.setupFloatingAdminButton();
      }

      disableAdminMode() {
        // Add confirmation to prevent accidental disabling
        if (!confirm('Are you sure you want to disable admin mode? You can re-enable it with enableAdmin().')) {
          return;
        }
        
        localStorage.removeItem('ourDailyIsAdmin');
        this.logger.log('🔒 Admin mode disabled');
        this.uiService.showToast('Admin mode disabled');
        // Hide the admin button
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          adminBtn.style.display = 'none';
        }
      }

      showAdminMenu() {
        // Create admin menu with quick actions
        const menu = document.createElement('div');
        menu.className = 'admin-menu';
        menu.innerHTML = `
          <div class="admin-menu-content">
            <h3>Admin Controls</h3>
            <button onclick="app.handleTestAddBlock()">Add Random Block</button>
            <button onclick="app.testRumiColorSequence()">🧪 Test Rumi Sequence (982 colors)</button>
            <button onclick="app.handleShowMyPiece()">Show My Piece</button>
            <button onclick="app.handleTestDifferentUser()">Simulate Different User</button>
            <button onclick="app.resetQuiltForNewDay()">Reset Quilt</button>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        // Style the menu
        menu.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          z-index: 1001;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          min-width: 250px;
        `;
        
        // Style the content
        const content = menu.querySelector('.admin-menu-content');
        content.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 10px;
        `;
        
        // Style the buttons
        const buttons = menu.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
          `;
        });
        
        // Add close on background click
        menu.addEventListener('click', (e) => {
          if (e.target === menu) {
            menu.remove();
          }
        });
        
        document.body.appendChild(menu);
      }

      initializeUI() {
        const dateText = document.getElementById("date-text");
        if (dateText) {
          dateText.textContent = Utils.formatDate();
        }
        this.quoteService.displayQuote();
        this.uiService.showScreen('screen-portal');
      }

      setupAutoTransition() {
        const currentScreen = document.querySelector('.screen.active');
        if (currentScreen && currentScreen.id === 'screen-portal') {
          // Increase delay for mobile devices and add better error handling
          const delay = window.innerWidth <= 768 ? 3000 : 2000;
          this.logger.log(`⏰ Setting up auto transition in ${delay}ms`);
          
          setTimeout(() => {
            // Check if we're still on the portal screen before transitioning
            const currentScreen = document.querySelector('.screen.active');
            if (currentScreen && currentScreen.id === 'screen-portal') {
              this.autoTransitionFromPortal();
            } else {
              this.logger.log('⏰ Auto transition cancelled - user has navigated away');
            }
          }, delay);
        }
      }

      async autoTransitionFromPortal() {
        try {
          this.logger.log('🔄 Starting auto transition from portal...');
          
          const hasVisitedBefore = localStorage.getItem('ourDailyHasVisited');
          const lastVisitDate = localStorage.getItem('ourDailyLastVisitDate');
          
          const now = new Date();
          const currentDate = now.toDateString();
          const isNewDay = lastVisitDate !== currentDate;
          
          this.logger.log(`Visit status: hasVisitedBefore=${hasVisitedBefore}, isNewDay=${isNewDay}`);
          
          if (!hasVisitedBefore || isNewDay) {
            localStorage.setItem('ourDailyHasVisited', 'true');
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            
            if (isNewDay) {
              this.logger.log(`🔄 New day detected: ${currentDate}`);
              await this.resetQuiltForNewDay();
            }
            
            this.logger.log('📱 Showing welcome screen...');
            this.uiService.showScreen('screen-welcome');
            
            // Longer delay for mobile before showing quote
            const quoteDelay = window.innerWidth <= 768 ? 2500 : 1500;
            setTimeout(() => {
              this.logger.log('📝 Showing quote screen...');
              this.uiService.showScreen('screen-quote');
            }, quoteDelay);
          } else {
            this.logger.log('📝 Showing quote screen directly...');
            this.uiService.showScreen('screen-quote');
          }
        } catch (error) {
          this.logger.error('❌ Auto transition failed:', error);
          // Fallback: show quote screen
          this.uiService.showScreen('screen-quote');
        }
      }
      
      async resetQuiltForNewDay() {
        this.logger.log('🔄 Resetting quilt for new day...');
        
        const dimensions = Utils.getQuiltDimensions();
        this.blocks = [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }];
        this.contributorCount = 1;
        
        try {
          await this.dataService.saveQuilt(this.blocks, this.contributorCount);
          this.logger.log('🗑️ Firebase data cleared for new day');
        } catch (error) {
          this.logger.warn('⚠️ Failed to clear Firebase data for new day:', error);
        }
        
        this.renderQuilt();
        this.updateSquareCounter();
        
        this.logger.log('✅ Quilt reset complete for new day');
      }

      async loadQuilt() {
        try {
          this.logger.log('🔄 Loading quilt data...');
          const data = await this.dataService.loadQuilt();
          this.blocks = data.blocks;
          this.contributorCount = data.contributorCount;
          this.logger.log(`📦 Loaded ${this.blocks.length} blocks:`, this.blocks);
          
          // Ensure we always have at least one block
          if (!this.blocks || this.blocks.length === 0) {
            this.logger.log('No blocks found, initializing default block');
            const dimensions = Utils.getQuiltDimensions();
            this.blocks = [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }];
            this.contributorCount = 1;
          }
        } catch (error) {
          this.logger.error('❌ Failed to load quilt:', error);
          this.errorHandler.handleError(error, 'loadQuilt');
          const dimensions = Utils.getQuiltDimensions();
          this.blocks = [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }];
          this.contributorCount = 1;
        }
      }



      async saveQuilt() {
        try {
          await this.dataService.saveQuilt(this.blocks, this.contributorCount);
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          throw error;
        }
      }

      renderQuilt() {
        this.logger.log('🔄 Rendering quilt...');
        this.logger.log(`Screen dimensions: ${window.innerWidth} x ${window.innerHeight}`);
        this.logger.log(`Quilt blocks: ${this.blocks.length}`);
        
        // Ensure quilt fits within available space
        this.ensureQuiltFits();
        
        this.renderer.renderBlocks(this.blocks);
        this.updateSquareCounter();
        
        this.logger.log('✅ Quilt rendering complete');
      }

      ensureQuiltFits() {
        if (!this.blocks || this.blocks.length === 0) return;
        
        // Get the actual available space using visual viewport
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        const availableWidth = hasVisualViewport ? window.visualViewport.width : window.innerWidth;
        const availableHeight = hasVisualViewport ? window.visualViewport.height : window.innerHeight;
        
        // Find the current bounds of all blocks
        const minX = Math.min(...this.blocks.map(b => b.x));
        const minY = Math.min(...this.blocks.map(b => b.y));
        const maxX = Math.max(...this.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.blocks.map(b => b.y + b.height));
        
        const currentWidth = maxX - minX;
        const currentHeight = maxY - minY;
        
        console.log('🔍 Quilt bounds:', { minX, minY, maxX, maxY, currentWidth, currentHeight });
        console.log('🔍 Available space:', { availableWidth, availableHeight });
        
        // Calculate optimal scale to fit both width and height
        const scaleX = availableWidth / currentWidth;
        const scaleY = availableHeight / currentHeight;
        const optimalScale = Math.min(scaleX, scaleY); // Scale to fit both dimensions
        
        console.log('🔄 Optimal scaling factor:', optimalScale, 'to fit both width and height');
        
        // Scale all blocks proportionally
        this.blocks = this.blocks.map(block => ({
          ...block,
          x: block.x * optimalScale,
          y: block.y * optimalScale,
          width: block.width * optimalScale,
          height: block.height * optimalScale
        }));
        
        // Ensure the quilt spans the full width
        const newMaxX = Math.max(...this.blocks.map(b => b.x + b.width));
        if (newMaxX < availableWidth) {
          console.log('🔧 Extending blocks to fill full width');
          // Find the rightmost block and extend it
          const rightmostBlock = this.blocks.reduce((rightmost, current) => 
            (current.x + current.width) > (rightmost.x + rightmost.width) ? current : rightmost
          );
          rightmostBlock.width = availableWidth - rightmostBlock.x;
        }
        
        // Final check: ensure quilt fits within available height
        const finalMaxY = Math.max(...this.blocks.map(b => b.y + b.height));
        if (finalMaxY > availableHeight) {
          console.log('🔧 Final height adjustment to fit available space');
          const finalHeightScale = availableHeight / finalMaxY;
          this.blocks = this.blocks.map(block => ({
            ...block,
            y: block.y * finalHeightScale,
            height: block.height * finalHeightScale
          }));
        }
        
        // Log final dimensions and fit analysis
        const finalMaxX = Math.max(...this.blocks.map(b => b.x + b.width));
        const finalMaxYFinal = Math.max(...this.blocks.map(b => b.y + b.height));
        const widthFit = finalMaxX <= availableWidth;
        const heightFit = finalMaxYFinal <= availableHeight;
        
        console.log('✅ Final quilt dimensions:', { 
          width: finalMaxX, 
          height: finalMaxYFinal,
          availableWidth,
          availableHeight,
          widthFit,
          heightFit,
          widthGap: availableWidth - finalMaxX,
          heightGap: availableHeight - finalMaxYFinal
        });
        
        if (widthFit && heightFit) {
          console.log('✅ Quilt perfectly fits available space');
        } else {
          console.log('⚠️ Quilt does not fit perfectly - may need scrolling');
        }
      }

      updateSquareCounter() {
        const counterElement = document.getElementById('squareCounter');
        if (counterElement) {
          counterElement.textContent = this.blocks.length;
        }
      }



      splitBlock(blockIndex, newColor) {
        try {
          this.logger.log(`Splitting block at index ${blockIndex} with color ${newColor}`);
          this.logger.log(`Current blocks array:`, this.blocks);
          this.logger.log(`Blocks array length: ${this.blocks.length}`);
          
          if (!Utils.validateHexColor(newColor)) {
            throw new Error(`Invalid color format: ${newColor}`);
          }

          if (blockIndex < 0 || blockIndex >= this.blocks.length) {
            throw new Error(`Block index ${blockIndex} is out of bounds (array length: ${this.blocks.length})`);
          }

          const block = this.blocks[blockIndex];
          if (!block) {
            throw new Error(`Block at index ${blockIndex} not found`);
          }

          this.logger.log(`Found block to split:`, block);

          const splitVertically = block.width >= block.height;
          
          // Composition-aware splitting ratios (REVERSE LOGIC)
          let splitRatio;
          const aspectRatio = Math.max(block.width / block.height, block.height / block.width);
          const blockArea = block.width * block.height;
          
          // Calculate composition density around this block
          const densityScore = this.calculateCompositionDensity(block);
          const densityMultiplier = this.getDensityMultiplier(densityScore);
          
          if (this.blocks.length >= 50) {
            // ULTRA-STRICT mode: COMPOSITION-AWARE splitting
            let baseRatio;
            if (aspectRatio > 3.0) {
              baseRatio = 0.25 + Math.random() * 0.15; // 25-40% for very long rectangles
            } else if (aspectRatio > 2.0) {
              baseRatio = 0.3 + Math.random() * 0.2; // 30-50% for long rectangles
            } else if (blockArea > 15000) {
              baseRatio = 0.3 + Math.random() * 0.2; // 30-50% of very large blocks
            } else if (blockArea > 8000) {
              baseRatio = 0.35 + Math.random() * 0.25; // 35-60% of large blocks
            } else if (blockArea > 3000) {
              baseRatio = 0.4 + Math.random() * 0.3; // 40-70% of medium blocks
            } else {
              baseRatio = 0.45 + Math.random() * 0.35; // 45-80% of small blocks
            }
            
            // Apply composition density multiplier
            splitRatio = baseRatio * densityMultiplier;
            
            // Ensure ratio stays within reasonable bounds (15% - 85%)
            splitRatio = Math.max(0.15, Math.min(0.85, splitRatio));
            
          } else {
            // Normal protection levels with composition awareness
            const baseRatio = 0.3 + Math.random() * 0.4;
            splitRatio = baseRatio * densityMultiplier;
            splitRatio = Math.max(0.2, Math.min(0.8, splitRatio));
          }
          
          let block1, block2;
          if (splitVertically) {
            const splitX = block.width * splitRatio;
            block1 = { ...block, width: splitX };
            block2 = { ...block, x: block.x + splitX, width: block.width - splitX, color: newColor };
          } else {
            const splitY = block.height * splitRatio;
            block1 = { ...block, height: splitY };
            block2 = { ...block, y: block.y + splitY, height: block.height - splitY, color: newColor };
          }
          
          this.blocks.splice(blockIndex, 1, block1, block2);
          const newBlockIndex = blockIndex + 1; // Point to the second piece (block2)
          
          // Set the last added index in the renderer for animation
          this.renderer.setLastAddedIndex(newBlockIndex);
          
          this.logger.log('Split block successfully:', {
            originalIndex: blockIndex,
            newIndex: newBlockIndex,
            splitDirection: splitVertically ? 'vertical' : 'horizontal',
            splitRatio: splitRatio,
            newBlocksCount: this.blocks.length
          });
          
          return true;
        } catch (error) {
          this.logger.error('Split block failed:', error);
          return false;
        }
      }

      async handleAddColor() {
        try {
          this.logger.log('🎨 Starting color addition process');
          
          const selectedColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
          
          this.logger.log(`Converted color: ${selectedColor}`);
          
          if (!selectedColor) {
            this.logger.warn('No color selected');
            return;
          }

          if (!Utils.validateHexColor(selectedColor)) {
            this.logger.error(`Invalid color generated: ${selectedColor}`);
            return;
          }

          // Ensure blocks are initialized
          if (!this.blocks || this.blocks.length === 0) {
            this.logger.log('Initializing blocks array');
            const dimensions = Utils.getQuiltDimensions();
            this.blocks = [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }];
            this.contributorCount = 1;
          }

          this.logger.log(`Current blocks: ${this.blocks.length}`, this.blocks);

          // Strategic block selection based on quilt density
          const eligibleBlocks = this.blocks.filter(b => b.width > CONFIG.APP.minBlockSize && b.height > CONFIG.APP.minBlockSize);
          let indexToSplit;
          
          if (this.blocks.length >= 50) {
            // ULTRA-STRICT MODE: Minimizing visual disruption
            const familyBlocks = this.findColorFamilyBlocks(selectedColor);
            
            if (familyBlocks.length > 0) {
              const bestFamilyBlock = familyBlocks[0];
              const colorDistance = bestFamilyBlock.distance;
              const isLongRectangle = bestFamilyBlock.rectangularityScore > 50;
              
              // ULTRA-STRICT thresholds with enhanced long rectangle protection
              const maxDistanceForLongRectangles = 15;
              const maxDistanceForRegularBlocks = 25;
              
              // Additional protection: avoid splitting very long rectangles unless perfect color match
              const aspectRatio = Math.max(bestFamilyBlock.block.width / bestFamilyBlock.block.height, 
                                         bestFamilyBlock.block.height / bestFamilyBlock.block.width);
              const isVeryLongRectangle = aspectRatio > 4.0;
              const isPerfectColorMatch = colorDistance < 5; // Very close color match
              
              if (eligibleBlocks.includes(bestFamilyBlock.block) && 
                  (colorDistance < (isLongRectangle ? maxDistanceForLongRectangles : maxDistanceForRegularBlocks)) &&
                  (!isVeryLongRectangle || isPerfectColorMatch)) {
                indexToSplit = bestFamilyBlock.index;
              } else {
                // Fallback to smallest block for minimal disruption
                if (eligibleBlocks.length > 0) {
                  const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                    const smallestArea = smallest.width * smallest.height;
                    const currentArea = current.width * current.height;
                    return currentArea < smallestArea ? current : smallest;
                  });
                  indexToSplit = this.blocks.indexOf(smallestEligible);
                } else {
                  // No eligible blocks - use smallest of all blocks
                  const smallestBlock = this.blocks.reduce((smallest, current) => {
                    const smallestArea = smallest.width * smallest.height;
                    const currentArea = current.width * current.height;
                    return currentArea < smallestArea ? current : smallest;
                  });
                  indexToSplit = this.blocks.indexOf(smallestBlock);
                }
              }
            } else {
              // No family blocks - use smallest block
              if (eligibleBlocks.length > 0) {
                const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                  const smallestArea = smallest.width * smallest.height;
                  const currentArea = current.width * current.height;
                  return currentArea < smallestArea ? current : smallest;
                });
                indexToSplit = this.blocks.indexOf(smallestEligible);
              } else {
                // No eligible blocks - use smallest of all blocks
                const smallestBlock = this.blocks.reduce((smallest, current) => {
                  const smallestArea = smallest.width * smallest.height;
                  const currentArea = current.width * current.height;
                  return currentArea < smallestArea ? current : smallest;
                });
                indexToSplit = this.blocks.indexOf(smallestBlock);
              }
            }
          } else {
            // Before 50 blocks: use SMALLEST block for controlled growth
            if (eligibleBlocks.length > 0) {
              const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                const smallestArea = smallest.width * smallest.height;
                const currentArea = current.width * current.height;
                return currentArea < smallestArea ? current : smallest;
              });
              indexToSplit = this.blocks.indexOf(smallestEligible);
            } else {
              // No eligible blocks - use smallest of all blocks
              const smallestBlock = this.blocks.reduce((smallest, current) => {
                const smallestArea = smallest.width * smallest.height;
                const currentArea = current.width * current.height;
                return currentArea < smallestArea ? current : smallest;
              });
              indexToSplit = this.blocks.indexOf(smallestBlock);
            }
          }

          this.logger.log(`Splitting block at index: ${indexToSplit}`, this.blocks[indexToSplit]);

          const success = this.splitBlock(indexToSplit, selectedColor);
          
          if (success) {
            this.contributorCount++;
            
            this.logger.log('Block split successfully');
            
            // Save to Firebase
            await this.saveQuilt();
            
            // Render updated quilt
            this.renderQuilt();
            
            this.uiService.showToast('Color added to the quilt!');
            this.uiService.showScreen('screen-quilt');
          }
          
        } catch (error) {
          this.errorHandler.handleError(error, 'handleAddColor');
        }
      }

      async handleShare() {
        try {
          this.logger.log('📤 Starting share process...');
          
          const quiltSVG = document.getElementById('quilt');
          if (!quiltSVG) {
            throw new Error('Quilt SVG not found');
          }

          // Generate image from SVG
          const canvas = await html2canvas(quiltSVG, {
            backgroundColor: '#f6f4f1',
            scale: 2,
            useCORS: true,
            allowTaint: true
          });

          // Convert to blob
          canvas.toBlob(async (blob) => {
            try {
              // Create share data
              const shareData = {
                title: 'Our Daily Quilt',
                text: `Check out today's community quilt with ${this.contributorCount} contributors!`,
                files: [new File([blob], 'quilt.png', { type: 'image/png' })]
              };

              // Try native sharing
              if (navigator.share && navigator.canShare(shareData)) {
                await navigator.share(shareData);
                this.uiService.showToast('Shared successfully!');
              } else {
                // Fallback: download image
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quilt-${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.uiService.showToast('Quilt downloaded!');
              }
            } catch (error) {
              this.logger.error('Share failed:', error);
              this.uiService.showToast('Share failed. Please try again.');
            }
          }, 'image/png', 0.9);

        } catch (error) {
          this.errorHandler.handleError(error, 'shareFlow');
        }
      }

      async handleTestAddBlock() {
        const testColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
        const randomColor = testColors[Math.floor(Math.random() * testColors.length)];
        
        // Strategic block selection based on quilt density (same logic as handleAddColor)
        const eligibleBlocks = this.blocks.filter(b => b.width > CONFIG.APP.minBlockSize && b.height > CONFIG.APP.minBlockSize);
        let indexToSplit;
        
        if (this.blocks.length >= 50) {
          // ULTRA-STRICT MODE: Minimizing visual disruption
          const familyBlocks = this.findColorFamilyBlocks(randomColor);
          
          if (familyBlocks.length > 0) {
            const bestFamilyBlock = familyBlocks[0];
            const colorDistance = bestFamilyBlock.distance;
            const isLongRectangle = bestFamilyBlock.rectangularityScore > 50;
            
            // ULTRA-STRICT thresholds with enhanced long rectangle protection
            const maxDistanceForLongRectangles = 15;
            const maxDistanceForRegularBlocks = 25;
            
            // Additional protection: avoid splitting very long rectangles unless perfect color match
            const aspectRatio = Math.max(bestFamilyBlock.block.width / bestFamilyBlock.block.height, 
                                       bestFamilyBlock.block.height / bestFamilyBlock.block.width);
            const isVeryLongRectangle = aspectRatio > 4.0;
            const isPerfectColorMatch = colorDistance < 5; // Very close color match
            
            if (eligibleBlocks.includes(bestFamilyBlock.block) && 
                (colorDistance < (isLongRectangle ? maxDistanceForLongRectangles : maxDistanceForRegularBlocks)) &&
                (!isVeryLongRectangle || isPerfectColorMatch)) {
              indexToSplit = bestFamilyBlock.index;
            } else {
              // Fallback to smallest block for minimal disruption
              if (eligibleBlocks.length > 0) {
                const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                  const smallestArea = smallest.width * smallest.height;
                  const currentArea = current.width * current.height;
                  return currentArea < smallestArea ? current : smallest;
                });
                indexToSplit = this.blocks.indexOf(smallestEligible);
              } else {
                // No eligible blocks - use smallest of all blocks
                const smallestBlock = this.blocks.reduce((smallest, current) => {
                  const smallestArea = smallest.width * smallest.height;
                  const currentArea = current.width * current.height;
                  return currentArea < smallestArea ? current : smallest;
                });
                indexToSplit = this.blocks.indexOf(smallestBlock);
              }
            }
          } else {
            // No family blocks - use smallest block
            if (eligibleBlocks.length > 0) {
              const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                const smallestArea = smallest.width * smallest.height;
                const currentArea = current.width * current.height;
                return currentArea < smallestArea ? current : smallest;
              });
              indexToSplit = this.blocks.indexOf(smallestEligible);
            } else {
              // No eligible blocks - use smallest of all blocks
              const smallestBlock = this.blocks.reduce((smallest, current) => {
                const smallestArea = smallest.width * smallest.height;
                const currentArea = current.width * current.height;
                return currentArea < smallestArea ? current : smallest;
              });
              indexToSplit = this.blocks.indexOf(smallestBlock);
            }
          }
        } else {
          // Before 50 blocks: use largest block (original logic)
          if (eligibleBlocks.length > 0) {
            const largestEligible = eligibleBlocks.reduce((largest, current) => {
              const largestArea = largest.width * largest.height;
              const currentArea = current.width * current.height;
              return currentArea > largestArea ? current : largest;
            });
            indexToSplit = this.blocks.indexOf(largestEligible);
          } else {
            let maxArea = 0;
            indexToSplit = 0;
            this.blocks.forEach((b, i) => {
              const area = b.width * b.height;
              if (area > maxArea) {
                maxArea = area;
                indexToSplit = i;
              }
            });
          }
        }

        const success = this.splitBlock(indexToSplit, randomColor);
        
        if (success) {
          this.contributorCount++;
          this.renderQuilt();
          await this.saveQuilt();
          
          this.uiService.showToast(`Added test block: ${randomColor}`);
        }
      }

      async testRumiColorSequence() {
        const rumiColors = [
          "#931f25",  "#61dede",  "#ce822c",  "#61cfde",  "#6189de",  "#9dde61",  "#4024a8",  "#d8a746",  "#ea9b9a",  "#8061de",
          "#618bde",  "#ad92e8",  "#1f2193",  "#61c9de",  "#70cae1",  "#dcc95b",  "#1f931f",  "#1f5393",  "#d84654",  "#e37d89",
          "#eac49a",  "#7e7de3",  "#61acde",  "#dab852",  "#dab74e",  "#de61c3",  "#37a022",  "#b261de",  "#abe3ed",  "#d5f6f3",
          "#61de76",  "#1f4293",  "#deba61",  "#61b8de",  "#1f4293",  "#6167de",  "#209750",  "#deae61",  "#afeec2",  "#eba2ce",
          "#ded561",  "#df9368",  "#61b4de",  "#de6c61",  "#1f938a",  "#5f23a4",  "#f6eed5",  "#e78dd8",  "#e2a074",  "#61c1de",
          "#61d5de",  "#de6176",  "#ded961",  "#de61aa",  "#3985d5",  "#61cdde",  "#7061de",  "#252cb1",  "#ded561",  "#cd61de",
          "#24a89d",  "#de61c7",  "#1f933a",  "#d5eef6",  "#de6170",  "#ae61de",  "#617cde",  "#de6174",  "#de618f",  "#d54939",
          "#f6eed5",  "#8b61de",  "#7d93e3",  "#d7de61",  "#f0b7cc",  "#de619b",  "#de619d",  "#d9b54a",  "#2bcaca",  "#d5ae39",
          "#61c7de",  "#b3efed",  "#7c61de",  "#61dedb",  "#ccb7f0",  "#d67a3d",  "#2dd2b4",  "#6197de",  "#6182de",  "#61b2de",
          "#61bade",  "#61c5de",  "#251f93",  "#9761de",  "#bd283c",  "#61de82",  "#de7a61",  "#61c9de",  "#de61c1",  "#1f2593",
          "#dec761",  "#4aa9d9",  "#6187de",  "#91de61",  "#b061de",  "#de61a8",  "#61d9de",  "#9eeae4",  "#d94aab",  "#6163de",
          "#de6165",  "#c961de",  "#de6174",  "#61d9de",  "#1f9331",  "#6c61de",  "#d33131",  "#5fc4dd",  "#b061de",  "#61de61",
          "#afd8ee",  "#f6dcd5",  "#de8061",  "#931f2b",  "#67de61",  "#619fde",  "#63de61",  "#63decc",  "#c58de7",  "#aade61",
          "#db61de",  "#a861de",  "#61c3de",  "#6170de",  "#ce2cb0",  "#3dc7d6",  "#de61ba",  "#616cde",  "#b1afee",  "#1f3593",
          "#e5b085",  "#52da57",  "#de6167",  "#9361de",  "#61dea8",  "#b061de",  "#8f61de",  "#d5f3c8",  "#de6193",  "#dbcc57",
          "#de9561",  "#afeed2",  "#de61ba",  "#61de67",  "#e2c874",  "#9561de",  "#931f42",  "#6ade61",  "#d45235",  "#dc665b",
          "#f6d5eb",  "#61cbde",  "#de616c",  "#edabbd",  "#f6e8d5",  "#236aa4",  "#f1bce3",  "#de61ba",  "#70bbe1",  "#2564b1",
          "#2996c2",  "#a02241",  "#2bcac7",  "#9ab125",  "#6197de",  "#8461de",  "#e5e78d",  "#d57d39",  "#6761de",  "#93e278",
          "#61dec1",  "#61b2de",  "#4a7ad9",  "#2e26b5",  "#decd61",  "#61acde",  "#caa22b",  "#61dec5",  "#9bdb57",  "#3177d3",
          "#f6eed5",  "#de8761",  "#dec961",  "#cb61de",  "#618fde",  "#b661de",  "#61b4de",  "#6189de",  "#ededab",  "#ddafee",
          "#a8de61",  "#61deb8",  "#61c5de",  "#61decf",  "#931f82",  "#dcbc5b",  "#9bbd28",  "#de61c5",  "#2359a4",  "#61ded5",
          "#617cde",  "#617cde",  "#61bade",  "#1f7a93",  "#61d1de",  "#92cae8",  "#8dd6e7",  "#61ded5",  "#de61cd",  "#6e61de",
          "#61c9de",  "#de6161",  "#ba61de",  "#61ded3",  "#a461de",  "#259eb1",  "#de7661",  "#61b8de",  "#61b8de",  "#de61d1",
          "#61decf",  "#24a4a8",  "#dec161",  "#61de7a",  "#de61a6",  "#33b927",  "#6172de",  "#5fb7dd",  "#ded561",  "#daa252",
          "#f0e2b7",  "#abedea",  "#abedea",  "#61d5de",  "#de617c",  "#ca8a2b",  "#61a1de",  "#a2ebe2",  "#72de61",  "#caa72b",
          "#bede61",  "#ae8de7",  "#de617e",  "#931f42",  "#beeeaf",  "#de8d61",  "#6161de",  "#da4ed3",  "#dc5b5b",  "#e7938d",
          "#c25729",  "#619dde",  "#61de97",  "#61dbde",  "#de7063",  "#61bade",  "#29931f",  "#61c9de",  "#dec361",  "#e5e285",
          "#d5de61",  "#28bdb8",  "#4a9bd9",  "#de61cb",  "#1f3c93",  "#de6165",  "#61deba",  "#61de95",  "#e8d292",  "#ac61de",
          "#61d7de",  "#6e61de",  "#61bede",  "#61aade",  "#61de6c",  "#21739c",  "#61de61",  "#de616c",  "#de61a8",  "#61d5de",
          "#6dad25",  "#c62a44",  "#a861de",  "#e17077",  "#d4358d",  "#25b166",  "#dec4f3",  "#cdde61",  "#dedb61",  "#8961de",
          "#61cdde",  "#618bde",  "#de9761",  "#de9d61",  "#61dec7",  "#6883df",  "#61de9b",  "#debe61",  "#e38a7d",  "#61deb2",
          "#616ede",  "#b261de",  "#b261de",  "#6195de",  "#4a29c2",  "#61c3de",  "#5b61dc",  "#c0ebf2",  "#61de9b",  "#1f9321",
          "#de6163",  "#61bade",  "#6191de",  "#de6187",  "#2969c2",  "#61bcde",  "#63a7de",  "#de6178",  "#ad7825",  "#6170de",
          "#de61bc",  "#46d8cc",  "#6172de",  "#4e99da",  "#d7a2eb",  "#6191de",  "#de6e61",  "#61c1de",  "#edbeab",  "#61bede",
          "#6174de",  "#259cb1",  "#6187de",  "#c23329",  "#9b61de",  "#57d0db",  "#db5771",  "#92bee8",  "#61c3de",  "#de8261",
          "#6170de",  "#d7b742",  "#61d7de",  "#61dbde",  "#1f2193",  "#ba61de",  "#7061de",  "#ba2dd2",  "#9161de",  "#61c1de",
          "#21259c",  "#788ce2",  "#a861de",  "#daad4e",  "#845bdc",  "#93741f",  "#93741f",  "#b92753",  "#2a85c6",  "#e996a2",
          "#898fe6",  "#73b927",  "#68df6f",  "#5fd0dd",  "#63dece",  "#b0de61",  "#dade63",  "#de6187",  "#31add3",  "#6ce0d4",
          "#f6d5ee",  "#61deba",  "#316ad3",  "#ba61de",  "#b14d25",  "#b55826",  "#a2da4e",  "#de63b1",  "#8461de",  "#de6e61",
          "#9561de",  "#6165de",  "#b1252c",  "#61dbde",  "#6187de",  "#42c229",  "#61b4de",  "#1f9382",  "#e9e996",  "#231f93",
          "#f6d5e6",  "#d1de61",  "#b49eea",  "#be61de",  "#de61cf",  "#57d5db",  "#61b2de",  "#782ac6",  "#b661de",  "#61deac",
          "#92c1e8",  "#de618d",  "#94b526",  "#61dbde",  "#78b8e2",  "#4c931f",  "#85bbe5",  "#61bede",  "#dc5b7d",  "#eedeaf",
          "#6199de",  "#e2e274",  "#de61c5",  "#61dbde",  "#c4eef3",  "#de61b8",  "#de616e",  "#afe6ee",  "#de61c7",  "#84de61",
          "#b1e06c",  "#61de6c",  "#ebd7a2",  "#8bde61",  "#25ad49",  "#618dde",  "#61d9de",  "#a531d3",  "#dd815f",  "#a824a6",
          "#61ded1",  "#2e29c2",  "#2747b9",  "#6174de",  "#de6c61",  "#8fde61",  "#61de63",  "#6161de",  "#61b0de",  "#d43542",
          "#f2ddc0",  "#9c4021",  "#b54126",  "#df7768",  "#7ede61",  "#3cd539",  "#61de74",  "#29c299",  "#6199de",  "#617cde",
          "#61aade",  "#61cfde",  "#de61ae",  "#deb061",  "#de619d",  "#e37db2",  "#dec361",  "#78de61",  "#96b8e9",  "#6ade61",
          "#5223a4",  "#24a824",  "#61a4de",  "#8f4ad9",  "#8d98e7",  "#ad2527",  "#d35fdd",  "#cf78e2",  "#61ded3",  "#61a4de",
          "#61dec9",  "#debe61",  "#61d3de",  "#de7c61",  "#31c8d3",  "#6178de",  "#61a1de",  "#9761de",  "#eba2dc",  "#63de72",
          "#de6172",  "#618fde",  "#e06ca0",  "#61deaa",  "#4e53da",  "#de61b0",  "#85d5e5",  "#61aade",  "#619fde",  "#acde61",
          "#78e2d6",  "#61b8de",  "#72de61",  "#61deae",  "#426cd7",  "#6187de",  "#61cfde",  "#61dec5",  "#251f93",  "#61d3de",
          "#61decf",  "#f0b7db",  "#ded161",  "#61dea8",  "#61b2de",  "#4a88d9",  "#d94ab0",  "#5ba0dc",  "#6ce0aa",  "#de6167",
          "#6172de",  "#b99527",  "#6c6ce0",  "#97e892",  "#1f5393",  "#b061de",  "#f2c4f3",  "#29a3c2",  "#61b4de",  "#61d3de",
          "#9ecbea",  "#9c2721",  "#a661de",  "#745fdd",  "#6165de",  "#f4f3cd",  "#e1d770",  "#f6d5da",  "#de7861",  "#9f61de",
          "#93311f",  "#33931f",  "#d9de61",  "#42d7c3",  "#dcc45b",  "#428fd7",  "#3223a4",  "#b59126",  "#e892c4",  "#61a1de",
          "#25b128",  "#619fde",  "#61de76",  "#61de89",  "#1f5293",  "#617cde",  "#d7de61",  "#61deba",  "#de8d61",  "#617cde",
          "#687ddf",  "#d45835",  "#de7661",  "#de6e61",  "#1f4093",  "#6182de",  "#d561de",  "#ded961",  "#8761de",  "#6167de",
          "#61dea4",  "#6195de",  "#61c5de",  "#de7c61",  "#de617e",  "#de9f61",  "#6187de",  "#de617c",  "#271f93",  "#5023a4",
          "#61ded1",  "#61dec5",  "#a04122",  "#de9161",  "#617cde",  "#6184de",  "#6170de",  "#61c9de",  "#d5e1f6",  "#2731b9",
          "#d0abed",  "#a861de",  "#b6e689",  "#61de6a",  "#61dea6",  "#931f33",  "#a8e170",  "#da964e",  "#3025ad",  "#3025ad",
          "#3025ad",  "#e2de74",  "#d6d33d",  "#8061de",  "#efb3b5",  "#caa22b",  "#e27495",  "#a461de",  "#931f57",  "#931f57",
          "#d3de61",  "#61dea4",  "#f0ebb7",  "#de8061",  "#6193de",  "#2a85c6",  "#e6aa89",  "#61c7de",  "#e7e28d",  "#ded361",
          "#db61de",  "#debb63",  "#de61b2",  "#256dad",  "#de7c61",  "#de6761",  "#1f9344",  "#de6195",  "#61c7de",  "#617cde",
          "#de61d3",  "#dbde61",  "#de6199",  "#a1de61",  "#25a423",  "#61bede",  "#5f70dd",  "#dea161",  "#d561de",  "#3956d5",
          "#618dde",  "#93761f",  "#cca2eb",  "#d7de61",  "#8461de",  "#9abbea",  "#94d63d",  "#f0bbb7",  "#2c47ce",  "#d5f6f2",
          "#619fde",  "#dcc05b",  "#7661de",  "#6e61de",  "#1f934e",  "#de61b4",  "#35d485",  "#a4e06c",  "#2d6fd2",  "#59b125",
          "#de61b0",  "#e58597",  "#26b591",  "#d9de61",  "#6172de",  "#57d7db",  "#b3efcd",  "#61dec5",  "#9161de",  "#de61b8",
          "#1f4093",  "#de617c",  "#35d43a",  "#6184de",  "#de61a6",  "#deaa61",  "#6a61de",  "#f1e4bc",  "#342ac6",  "#d4b235",
          "#2544b1",  "#2544b1",  "#de9761",  "#d539b6",  "#618dde",  "#61de78",  "#6170de",  "#61cfde",  "#d2cd2d",  "#61dedb",
          "#78e2bd",  "#f0b7e5",  "#ca2b3d",  "#de61c9",  "#1f9346",  "#5f87dd",  "#dd5fdb",  "#f6d5ec",  "#61c9de",  "#7db3e3",
          "#96d4e9",  "#cbabed",  "#61cdde",  "#e481ac",  "#61b0de",  "#6187de",  "#bd3028",  "#7731d3",  "#616ade",  "#61d9de",
          "#e9f6d5",  "#e9f6d5",  "#616ade",  "#de61cd",  "#271f93",  "#2c4fce",  "#b7dbf0",  "#b59126",  "#de61bc",  "#618fde",
          "#251f93",  "#e4c0f2",  "#6361de",  "#afd1ee",  "#617ede",  "#de7061",  "#5ba2dc",  "#c66b2a",  "#61deb2",  "#61debc",
          "#dda95f",  "#9b61de",  "#92bee8",  "#9d61de",  "#e996ac",  "#deb061",  "#6761de",  "#a4de61",  "#2d1f93",  "#649720",
          "#6172de",  "#b7afee",  "#618fde",  "#9492e8",  "#de7a61",  "#de6a61",  "#931f40",  "#de61c7",  "#61de61",  "#616ede",
          "#c0f2f2",  "#dc5bb1",  "#8261de",  "#e06ca4",  "#de6c61",  "#f5d1db",  "#deb661",  "#de7863",  "#1f1f93",  "#61cfde",
          "#429720",  "#231f93",  "#9f61de",  "#93761f",  "#61dedb",  "#35d4ca",  "#61de61",  "#61cdde",  "#b061de",  "#c62a6d",
          "#61dbde",  "#61bcde",  "#a4a423",  "#7a61de",  "#6172de",  "#ad2529",  "#61bede",  "#617ede",  "#61deb4",  "#d22d51",
          "#db57a8",  "#a47de3",  "#8b61de",  "#61de7a",  "#61ded7",  "#61b6de",  "#d1f5dd",  "#9aeaea",  "#9aeaea",  "#9aeaea",
          "#9aeaea",  "#d24e2d",  "#61a4de",  "#1f6193",  "#ac61de",  "#de61ae",  "#6174de",  "#7861de",  "#b861de",  "#222097",
          "#6182de",  "#7d25ad",  "#1f9336",  "#8a85e5",  "#db7657",  "#61debc",  "#61aede",  "#debe61",  "#61bede",  "#619bde",
          "#529bda",  "#2bcaaa",  "#5bbedc",  "#61a6de",  "#d9de61",  "#d361de",  "#709fe1",  "#bc61de",  "#c0f2ef",  "#61dede",
          "#89dbe6",  "#61cfde",  "#2dd232",  "#5f1f93",  "#6361de",  "#85e5b7",  "#7e61de",  "#1f7893",  "#de61c1",  "#de6193",
          "#969ae9",  "#de7061",  "#9b57db",  "#2595b1",  "#5b97dc",  "#de7a61",  "#c5de61",  "#8761de",  "#211f93",  "#debc61",
          "#de6167",  "#4249d7",  "#d761de",  "#d63d57",  "#6167de",  "#de8461",  "#9aeae2",  "#52da8b",  "#d74253",  "#d74253",
          "#d74253",  "#d74253",  "#d74253",  "#de61cb",  "#95de61",  "#61aede",  "#deb861",  "#e585b7",  "#de9f61",  "#6189de",
          "#618bde",  "#de61b2",  "#61d9de",  "#ba92e8",  "#6cbfe0",  "#8461de",  "#61debe",  "#6176de",  "#deb261",  "#de616c",
          "#de6178",  "#74de61",  "#89cae6",  "#de7e61",  "#6b931f",  "#de61aa",  "#de61aa",  "#de61aa",  "#b3d8ef",  "#618fde",
          "#6cb3e0",  "#de61de",  "#de6172",  "#de617e",  "#61d3de",  "#61dec7",  "#61de91",  "#eba2ad",  "#ea9ed7",  "#de6761",
          "#2566b1",  "#5bdcd8",  "#61acde",  "#6561de",  "#70de61",  "#f1e3bc",  "#ddc45f",  "#deb061",  "#61cfde",  "#d43575",
          "#f6d5e1",  "#61a4de",  "#cf61de",  "#8d61de",  "#e06ca6",  "#c761de",  "#617cde",  "#decd61",  "#6ade61",  "#de61c9",
          "#295cc2",  "#de61aa",  "#61b2de",  "#7a61de",  "#61cfde",  "#f0edb7",  "#6195de",  "#93361f",  "#61dec9",  "#de6172",
          "#e8c4f3",  "#61a1de",  "#6163de",  "#616ede",  "#74a9e2",  "#6193de",  "#57a4db",  "#de61b4",  "#c23d29",  "#6184de",
          "#de9f61",  "#de61a1",  "#61dea8",  "#1f2b93",  "#de6761",  "#61debc",  "#61ded7",  "#77d331",  "#bede61",  "#61decd",
          "#6187de",  "#65931f",  "#65931f",  "#6a61de",  "#89abe6",  "#615fdd",  "#617cde",  "#de7e61",  "#a1df68",  "#1f3393"
        ];
        
        for (let i = 0; i < rumiColors.length; i++) {
          const color = rumiColors[i];
          
          // Use the SAME logic as handleAddColor() but with the specific color
          const eligibleBlocks = this.blocks.filter(b => b.width > CONFIG.APP.minBlockSize && b.height > CONFIG.APP.minBlockSize);
          let indexToSplit;
          
          if (this.blocks.length >= 50) {
            // ULTRA-STRICT MODE: Minimizing visual disruption
            const familyBlocks = this.findColorFamilyBlocks(color);
            
            if (familyBlocks.length > 0) {
              const bestFamilyBlock = familyBlocks[0];
              const colorDistance = bestFamilyBlock.distance;
              const isLongRectangle = bestFamilyBlock.rectangularityScore > 50;
              
              // ULTRA-STRICT thresholds with enhanced long rectangle protection
              const maxDistanceForLongRectangles = 15;
              const maxDistanceForRegularBlocks = 25;
              
              // Additional protection: avoid splitting very long rectangles unless perfect color match
              const aspectRatio = Math.max(bestFamilyBlock.block.width / bestFamilyBlock.block.height, 
                                         bestFamilyBlock.block.height / bestFamilyBlock.block.width);
              const isVeryLongRectangle = aspectRatio > 4.0;
              const isPerfectColorMatch = colorDistance < 5; // Very close color match
              
              if (eligibleBlocks.includes(bestFamilyBlock.block) && 
                  (colorDistance < (isLongRectangle ? maxDistanceForLongRectangles : maxDistanceForRegularBlocks)) &&
                  (!isVeryLongRectangle || isPerfectColorMatch)) {
                indexToSplit = bestFamilyBlock.index;
              } else {
                // Fallback to smallest block for minimal disruption
                if (eligibleBlocks.length > 0) {
                  const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                    const smallestArea = smallest.width * smallest.height;
                    const currentArea = current.width * current.height;
                    return currentArea < smallestArea ? current : smallest;
                  });
                  indexToSplit = this.blocks.indexOf(smallestEligible);
                } else {
                  // No eligible blocks - use smallest of all blocks
                  const smallestBlock = this.blocks.reduce((smallest, current) => {
                    const smallestArea = smallest.width * smallest.height;
                    const currentArea = current.width * current.height;
                    return currentArea < smallestArea ? current : smallest;
                  });
                  indexToSplit = this.blocks.indexOf(smallestBlock);
                }
              }
            } else {
              // No family blocks - use smallest block
              if (eligibleBlocks.length > 0) {
                const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                  const smallestArea = smallest.width * smallest.height;
                  const currentArea = current.width * current.height;
                  return currentArea < smallestArea ? current : smallest;
                });
                indexToSplit = this.blocks.indexOf(smallestEligible);
              } else {
                // No eligible blocks - use smallest of all blocks
                const smallestBlock = this.blocks.reduce((smallest, current) => {
                  const smallestArea = smallest.width * smallest.height;
                  const currentArea = current.width * current.height;
                  return currentArea < smallestArea ? current : smallest;
                });
                indexToSplit = this.blocks.indexOf(smallestBlock);
              }
            }
          } else {
            // Before 50 blocks: use SMALLEST block for controlled growth
            if (eligibleBlocks.length > 0) {
              const smallestEligible = eligibleBlocks.reduce((smallest, current) => {
                const smallestArea = smallest.width * smallest.height;
                const currentArea = current.width * current.height;
                return currentArea < smallestArea ? current : smallest;
              });
              indexToSplit = this.blocks.indexOf(smallestEligible);
            } else {
              // No eligible blocks - use smallest of all blocks
              const smallestBlock = this.blocks.reduce((smallest, current) => {
                const smallestArea = smallest.width * smallest.height;
                const currentArea = current.width * current.height;
                return currentArea < smallestArea ? current : smallest;
              });
              indexToSplit = this.blocks.indexOf(smallestBlock);
            }
          }
          
          const success = this.splitBlock(indexToSplit, color);
          
          if (success) {
            this.contributorCount++;
            this.renderQuilt();
            await this.saveQuilt();
            await new Promise(resolve => setTimeout(resolve, 20)); // 20ms delay
          }
        }
        
        this.uiService.showToast('Rumi color sequence test complete! (982 colors added)');
      }

      handleShowMyPiece() {
        // In block-based system, we can highlight the last added block
        if (this.blocks.length > 1) {
          this.uiService.showToast('Your piece is highlighted!');
          // The renderer already handles highlighting the last added block
        } else {
          this.uiService.showToast('No pieces found for current user');
        }
      }

      // ===== ULTRA-STRICT MODE HELPER FUNCTIONS =====
      
      findColorFamilyBlocks(newColor) {
        const newColorFamily = Utils.getColorFamily(newColor);
        const familyBlocks = [];
        
        for (let i = 0; i < this.blocks.length; i++) {
          const block = this.blocks[i];
          if (Utils.getColorFamily(block.color) === newColorFamily) {
            const distance = this.calculateColorDistance(newColor, block.color);
            const area = block.width * block.height;
            const rectangularityScore = this.calculateRectangularityScore(block);
            const densityScore = this.calculateSpatialDensity(i, newColorFamily);
            
            familyBlocks.push({
              index: i,
              block: block,
              distance: distance,
              area: area,
              rectangularityScore: rectangularityScore,
              densityScore: densityScore
            });
          }
        }
        
        // Sort by rectangularity score first, then density, then area, then distance
        familyBlocks.sort((a, b) => {
          if (b.rectangularityScore !== a.rectangularityScore) {
            return b.rectangularityScore - a.rectangularityScore;
          }
          if (b.densityScore !== a.densityScore) {
            return b.densityScore - a.densityScore;
          }
          if (b.area !== a.area) {
            return b.area - a.area;
          }
          return a.distance - b.distance;
        });
        
        return familyBlocks;
      }

      calculateColorDistance(color1, color2) {
        const hsl1 = Utils.hexToHsl(color1);
        const hsl2 = Utils.hexToHsl(color2);
        
        const hueDiff = Math.min(
          Math.abs(hsl1.h - hsl2.h),
          Math.abs(hsl1.h - hsl2.h + 360),
          Math.abs(hsl1.h - hsl2.h - 360)
        );
        
        const saturationDiff = Math.abs(hsl1.s - hsl2.s);
        const lightnessDiff = Math.abs(hsl1.l - hsl2.l);
        
        return (hueDiff * 0.6) + (saturationDiff * 0.25) + (lightnessDiff * 0.15);
      }

      calculateRectangularityScore(block) {
        const aspectRatio = Math.max(block.width / block.height, block.height / block.width);
        const area = block.width * block.height;
        
        // Enhanced long rectangle protection
        let rectangularityBonus = 0;
        if (aspectRatio > 6.0) rectangularityBonus = 500; // Very long rectangles - maximum protection
        else if (aspectRatio > 4.0) rectangularityBonus = 300; // Long rectangles - high protection
        else if (aspectRatio > 3.0) rectangularityBonus = 200; // Medium-long rectangles - medium protection
        else if (aspectRatio > 2.0) rectangularityBonus = 100; // Short-long rectangles - some protection
        
        const areaBonus = Math.log(area) * 10;
        
        return rectangularityBonus + areaBonus;
      }

            calculateSpatialDensity(blockIndex, targetFamily) {
        const searchRadius = 200;
        let densityScore = 0;
        
        for (let i = 0; i < this.blocks.length; i++) {
          if (i === blockIndex) continue;
          
          const otherBlock = this.blocks[i];
          if (Utils.getColorFamily(otherBlock.color) === targetFamily) {
            const distance = Math.sqrt(
              Math.pow(this.blocks[blockIndex].x - otherBlock.x, 2) + 
              Math.pow(this.blocks[blockIndex].y - otherBlock.y, 2)
            );
            
            if (distance < searchRadius) {
              const proximityScore = (searchRadius - distance) / searchRadius;
              densityScore += proximityScore * 100;
            }
          }
        }
        
        return densityScore;
      }

      calculateCompositionDensity(block) {
        // Calculate how dense the composition is around this block
        const searchRadius = 150; // Smaller radius for composition density
        let nearbyBlocks = 0;
        let totalArea = 0;
        
        for (let i = 0; i < this.blocks.length; i++) {
          const otherBlock = this.blocks[i];
          if (otherBlock === block) continue;
          
          // Calculate distance between block centers
          const blockCenterX = block.x + block.width / 2;
          const blockCenterY = block.y + block.height / 2;
          const otherCenterX = otherBlock.x + otherBlock.width / 2;
          const otherCenterY = otherBlock.y + otherBlock.height / 2;
          
          const distance = Math.sqrt(
            Math.pow(blockCenterX - otherCenterX, 2) + 
            Math.pow(blockCenterY - otherCenterY, 2)
          );
          
          if (distance < searchRadius) {
            nearbyBlocks++;
            totalArea += otherBlock.width * otherBlock.height;
          }
        }
        
        // Calculate density score (0 = sparse, 1 = dense)
        const areaDensity = totalArea / (Math.PI * searchRadius * searchRadius);
        const blockDensity = nearbyBlocks / 10; // Normalize to 0-1 range
        
        return Math.min(1, (areaDensity + blockDensity) / 2);
      }

      getDensityMultiplier(densityScore) {
        // REVERSE LOGIC: Sparse areas get smaller splits, dense areas get larger splits
        // Sparse areas need careful, gradual filling
        // Dense areas can handle larger, more dramatic splits
        
        if (densityScore < 0.2) {
          // Very sparse area - very small splits for careful filling
          return 0.5 + Math.random() * 0.2; // 0.5-0.7x multiplier
        } else if (densityScore < 0.4) {
          // Sparse area - small splits for gradual filling
          return 0.7 + Math.random() * 0.2; // 0.7-0.9x multiplier
        } else if (densityScore < 0.6) {
          // Medium density - neutral splits
          return 1.0 + Math.random() * 0.2; // 1.0-1.2x multiplier
        } else if (densityScore < 0.8) {
          // Dense area - larger splits for dramatic effect
          return 1.3 + Math.random() * 0.2; // 1.3-1.5x multiplier
        } else {
          // Very dense area - very large splits for maximum drama
          return 1.5 + Math.random() * 0.3; // 1.5-1.8x multiplier
        }
      }

      handleTestDifferentUser() {
        // Generate a new user ID
        this.currentUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('ourDailyUserId', this.currentUserId);
        
        this.uiService.showToast('Switched to different user');
        this.logger.log(`New user ID: ${this.currentUserId}`);
      }
    }

    // Global function to update contributor counter
    window.updateContributorCounter = function(contributorCount) {
      const thankYouElement = document.querySelector('.thank-you-message');
      if (thankYouElement) {
        if (contributorCount === 1) {
          thankYouElement.textContent = "Thank you for adding your block! Look what we're making together <3";
        } else {
          thankYouElement.textContent = `Thank you for adding your block! Look what ${contributorCount} people are making together <3`;
        }
      }
    };

    // Initialize the application
    document.addEventListener('DOMContentLoaded', async () => {
      const app = new SimplifiedQuiltApp();
      await app.initialize();
      
      // Expose app globally for testing
      window.app = app;
      
      // Global test functions
      window.addTestBlock = () => app.handleTestAddBlock();
      window.showMyPiece = () => app.handleShowMyPiece();
      window.switchUser = () => app.handleTestDifferentUser();
      window.shareQuilt = () => app.handleShare();
      window.testRumiSequence = () => app.testRumiColorSequence();
      
      // Admin console commands
      window.enableAdmin = () => app.enableAdminMode();
      window.disableAdmin = () => app.disableAdminMode();
      
      console.log('✅ Simplified Quilt App initialized');
      console.log('🔧 Admin commands available:');
      console.log('  enableAdmin()  - Enable admin mode');
      console.log('  disableAdmin() - Disable admin mode');
      console.log('🧪 Test commands available:');
      console.log('  testRumiSequence() - Test ultra-strict mode with 982 Rumi colors');
    });
  </script>
</body>
</html> 