<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Quilt</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* ===== SCREENS ===== */
    .screen {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 3rem 0 10px 0;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 900;
      font-size: clamp(2rem, 5vw, 3rem);
      margin-bottom: 0.1rem;
      letter-spacing: -0.02em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.2rem, 3vw, 1.6rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.5rem;
      margin: 3rem auto 2rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 150px;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(1rem, 2.5vw, 1.2rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem 0;
    }
    
    #colorWheelCanvas {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      /* Fallback for browsers that don't support conic-gradient */
      background: hsl(0, 95%, 55%);
      /* Modern browsers with conic-gradient support */
      background: conic-gradient(
        hsl(0, 100%, 55%),
        hsl(30, 100%, 55%),
        hsl(60, 100%, 55%),
        hsl(90, 100%, 55%),
        hsl(120, 100%, 55%),
        hsl(150, 100%, 55%),
        hsl(180, 100%, 55%),
        hsl(210, 100%, 55%),
        hsl(240, 100%, 55%),
        hsl(270, 100%, 55%),
        hsl(300, 100%, 55%),
        hsl(330, 100%, 55%),
        hsl(360, 100%, 55%)
      );
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      /* Add a subtle overlay to tone down the visual intensity */
      position: relative;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
  

    
    #colorWheelCanvas:hover {
      transform: scale(1.02);
    }
    
    #colorWheelCanvas:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; align-items: center;
      margin-top: 2rem;
      width: 100%;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    

    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
      }
      
      .css-color-wheel {
        width: 280px;
        height: 280px;
        /* Ensure conic-gradient works on mobile */
        background: hsl(0, 100%, 55%);
        background: -webkit-conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
        background: conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    /* Debug: Ensure proper vertical centering */
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }
    
    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: center;
    }
    
    .archive-placeholder {
      font-size: 1.5rem;
      color: #999;
      margin: 2rem 0;
      font-style: italic;
    }
    
    .archive-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
    }
    
    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */

    
    #quilt {
      width: 90vw; height: 90vw;
      max-width: 600px; max-height: 600px;
      margin: 2rem auto;
      background: transparent;
      position: relative;
      display: block;
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Fabric texture using CSS */
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .screen { 
        padding: 2rem 1rem 10px 1rem; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      #quilt { 
        width: 100vw; 
        height: 100vw; 
        margin: 0;
        display: block;
        position: relative;
        max-width: none;
        max-height: none;
      }
      
      #screen-quilt {
        padding: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }
  </style>
</head>
<body>
  <main id="app">
    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
      <button class="btn" data-next="screen-welcome" aria-label="Start the daily experience">LET'S BEGIN</button>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">â†“</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="35" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">
      <div id="phase-indicator" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; color: #666;">Collection Phase (0/5)</div>
      <div id="user-counter" style="font-size: 1rem; font-weight: 500; margin-bottom: 0.5rem; color: #888; background: #f0f0f0; padding: 0.5rem; border-radius: 4px;">Submission #0</div>
      <svg id="quilt" viewBox="-100 -100 800 800" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      <p class="thank-you-message" aria-live="polite">Thank you for adding your block! Look what we're making together <3</p>
      <button id="testAddBlock" class="btn" style="background: #ff6b6b; color: white; margin: 0.5rem;">TEST: Add Random Block</button>
      <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white; margin: 0.5rem;">SHOW ME MY PIECE</button>
      <button id="testDifferentUserBtn" class="btn" style="background: #9C27B0; color: white; margin: 0.5rem;">TEST: Simulate Different User</button>
      <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button>
      <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
      <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <div class="archive-content">
        <p class="archive-placeholder">Archive coming soon...</p>
        <p class="archive-description">Browse through past community quilts and see how our collective creativity has grown over time.</p>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

  <!-- Toast notifications -->
  <div id="toast" class="toast" role="alert" aria-live="polite"></div>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script type="module">
    // ===== CONFIGURATION OBJECT =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '2.0.0',
        defaultColor: '#f7b733',
        quiltSize: 600,
        minBlockSize: 40,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        viewBoxStartX: -100,
        viewBoxStartY: -100,
        edgePadding: 20,
        gridCols: 5,
        gridRows: 5,
        gridJitter: 15,
        minSpacing: 10,
        maxPieceSizeRatio: 0.8,
        minPieceSizeRatio: 0.4,
        edgeVariation: 0.1,
        organicVariation: 3
      },
      PHASES: {
        collection: {
          maxSubmissions: 5,
          piecesPerSubmission: [4, 4, 4, 4, 4, 4, 1, 1, 1] // pieces for submissions 1-9
        },
        patchFormation: {
          triggerSubmission: 6, // User 6 triggers block formation
          targetPatches: 2,
          edgeTolerance: 0.2,
          valueContrastWeight: 0.8
        },
        blockFormation: {
          triggerSubmission: 6, // User 6 sees blocks, not patches
          edgeTolerance: 1.5, // Increased tolerance to ensure all patches get matched
          valueContrastWeight: 0.8
        },
        quiltFormation: {
          triggerSubmission: 9
        }
      },
      RENDERING: {
        organicEdgesFilter: 'organicEdges',
        userHighlightFilter: 'userHighlight',
        animationClass: 'new-block',
        borderColor: {
          pieces: '#ffa726',
          patches: '#ff6b6b',
          blocks: '#4ecdc4'
        }
      },
      POSITIONING: {
        spacing: {
          pieces: 120,
          patches: 120,
          blocks: 250  // Increased spacing for blocks to prevent overlapping
        },
        jitter: {
          pieces: 8,
          patches: 8,
          blocks: 5  // Reduced jitter for blocks to prevent overlap
        }
      }
    };

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = 'ðŸ§µ';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} âš ï¸ ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} âŒ ${message}`, error || '');
      }

      phase(phase, data = null) {
        this.log(`ðŸ”„ Phase: ${phase}`, data);
      }

      render(element, count) {
        this.log(`ðŸŽ¨ Rendering ${count} ${element}`);
      }

      position(element, index, x, y) {
        this.log(`ðŸ“ ${element} ${index} positioned at (${x.toFixed(1)}, ${y.toFixed(1)})`);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(null, args), delay);
        };
      }

      static hslToHex(h, s, l) {
        // Debug logging
        console.log(`hslToHex input: h=${h}, s=${s}, l=${l}`);
        
        h /= 360;
        s /= 100;
        l /= 100;
        
        console.log(`hslToHex normalized: h=${h}, s=${s}, l=${l}`);
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        console.log(`hslToHex RGB: r=${r}, g=${g}, b=${b}`);
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        const result = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        console.log(`hslToHex result: ${result}`);
        return result;
      }

      static hexToHsl(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return {
          h: Math.round(h * 360),
          s: Math.round(s * 100),
          l: Math.round(l * 100)
        };
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
        const target = document.getElementById(screenId);
        if (target) {
          target.classList.add("active");
          
          // Reset color selection when entering color screen
          if (screenId === 'screen-color') {
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen) {
              colorScreen.style.backgroundColor = '#f6f4f1';
            }
          }
          
          // Scroll to top
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          
          const app = document.getElementById('app');
          if (app) {
            app.scrollTop = 0;
          }
        }
      }

      updatePhaseIndicator(phase, submissionCount) {
        const phaseIndicator = document.getElementById('phase-indicator');
        if (phaseIndicator) {
          const phaseText = {
            'collection': `Collection Phase (${submissionCount}/5)`,
            'patch-formation': 'Patch Formation Phase',
            'block-formation': 'Block Formation Phase',
            'quilt-formation': 'Quilt Formation Phase'
          };
          phaseIndicator.textContent = phaseText[phase] || 'Unknown Phase';
        }
      }

      updateUserCounter(submissionCount, phase, elementCounts) {
        const userCounterElement = document.getElementById('user-counter');
        if (userCounterElement) {
          let phaseInfo = '';
          if (phase === 'collection') {
            phaseInfo = `Collection Phase (${submissionCount}/5)`;
          } else if (phase === 'patch-formation') {
            phaseInfo = `Patch Formation Phase (${elementCounts.patches || 0} patches)`;
          } else if (phase === 'block-formation') {
            phaseInfo = `Block Formation Phase (${elementCounts.blocks || 0} blocks)`;
          } else if (phase === 'quilt-formation') {
            phaseInfo = `Quilt Formation Phase`;
          }
          
          userCounterElement.textContent = `Submission #${submissionCount} - ${phaseInfo}`;
        }
      }
    }

         // ===== ERROR HANDLING SERVICE =====
     class ErrorHandler {
       constructor(uiService, logger) {
         this.uiService = uiService;
         this.logger = logger;
       }

       handleError(error, context = 'Unknown') {
         this.logger.error(`Error in ${context}:`, error);
         
         const errorMessages = {
           'loadQuilt': 'Failed to load quilt data. Starting fresh.',
           'saveQuilt': 'Failed to save your color. Please try again.',
           'shareFlow': 'Failed to create share image. Saving instead.',
           'colorPicker': 'Color picker error. Please try again.',
           'App initialization': 'Failed to initialize app. Please refresh.',
           'renderBlocks': 'Failed to render quilt. Please try again.',
           'addPieceToQuilt': 'Failed to add piece. Please try again.'
         };
         
         const message = errorMessages[context] || 'Something went wrong. Please try again.';
         this.uiService.showToast(message);
       }

       validatePiece(piece) {
         if (!piece || typeof piece.x === 'undefined' || typeof piece.y === 'undefined' || 
             typeof piece.width === 'undefined' || typeof piece.height === 'undefined') {
           throw new Error(`Invalid piece data: ${JSON.stringify(piece)}`);
         }
         return true;
       }

       validateColor(color) {
         if (!Utils.validateHexColor(color)) {
           throw new Error(`Invalid color format: ${color}`);
         }
         return true;
       }
     }

     // ===== STATE MANAGEMENT =====
     class QuiltState {
       constructor(logger) {
         this.logger = logger;
         this.reset();
       }

       reset() {
         this.blocks = [];
         this.pieces = [];
         this.allPieces = [];
         this.patches = [];
         this.originalPatches = [];
         this.quilt = null;
         this.submissionCount = 0;
         this.currentPhase = 'collection';
         this.lastAddedIndex = null;
         this.unmatchedPieces = [];
         this.unmatchedPatches = [];
         this.userPiecesHighlighted = false;
         this.currentUserId = Utils.getOrCreateUserId();
         this.logger.log('State reset');
       }

       getElementCounts() {
         return {
           pieces: this.pieces.length,
           patches: this.patches.length,
           blocks: this.blocks.length,
           unmatchedPieces: this.unmatchedPieces.length,
           unmatchedPatches: this.unmatchedPatches.length
         };
       }

       addPiece(piece) {
         this.pieces.push(piece);
         this.allPieces.push(piece);
         this.logger.log(`Added piece ${piece.id}`);
       }

       addPatch(patch) {
         this.patches.push(patch);
         this.logger.log(`Added patch ${patch.id}`);
       }

       addBlock(block) {
         this.blocks.push(block);
         this.logger.log(`Added block ${block.id}`);
       }

       setPhase(phase) {
         this.currentPhase = phase;
         this.logger.phase(phase);
       }

       incrementSubmission() {
         this.submissionCount++;
         this.logger.log(`Submission count: ${this.submissionCount}`);
       }
     }

     // ===== DATA LAYER =====
     class QuiltDataService {
       constructor(logger, errorHandler) {
         this.logger = logger;
         this.errorHandler = errorHandler;
         this.db = null;
         this.quiltDoc = null;
       }

       async initialize() {
         try {
           // Disable Firebase for easier testing
           this.db = null;
           this.quiltDoc = null;
           this.logger.log('Data service initialized (Firebase disabled)');
         } catch (error) {
           this.errorHandler.handleError(error, 'Data service initialization');
           throw error;
         }
       }

       async loadQuilt() {
         try {
           this.logger.log('Loading quilt data');
           // Disable Firestore for easier testing
           return []; // Start with empty quilt
         } catch (error) {
           this.errorHandler.handleError(error, 'loadQuilt');
           return [];
         }
       }

       async saveQuilt() {
         try {
           this.logger.log('Saving quilt data');
           // Disable Firestore for easier testing
         } catch (error) {
           this.errorHandler.handleError(error, 'saveQuilt');
           throw error;
         }
       }
     }

     // ===== QUOTE SERVICE =====
     class QuoteService {
       constructor() {
         this.quotes = [
           { text: "Art washes away from the soul the dust of everyday life.", author: "â€” Pablo Picasso" },
           { text: "Creativity takes courage.", author: "â€” Henri Matisse" },
           { text: "Every artist was first an amateur.", author: "â€” Ralph Waldo Emerson" },
           { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "â€” Wassily Kandinsky" },
           { text: "Great things are done by a series of small things brought together.", author: "â€” Vincent Van Gogh" },
           { text: "You can't use up creativity. The more you use, the more you have.", author: "â€” Maya Angelou" }
         ];
         this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
       }

       getTodayQuote() {
         const today = new Date();
         const year = today.getFullYear();
         const month = String(today.getMonth() + 1).padStart(2, '0');
         const day = String(today.getDate()).padStart(2, '0');
         const todayString = `${year}-${month}-${day}`;
         const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
         const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
         return this.quotes[quoteIndex];
       }

       displayQuote() {
         try {
           const { text, author } = this.getTodayQuote();
           const quoteLine = document.querySelector('.quote-line');
           const quoteAuthor = document.querySelector('.quote-author');
           
           if (quoteLine) quoteLine.textContent = text;
           if (quoteAuthor) quoteAuthor.textContent = author;
         } catch (error) {
           console.error('Error displaying quote:', error);
         }
       }
     }

     // ===== POSITIONING SERVICE =====
     class PositioningService {
       constructor(logger) {
         this.logger = logger;
       }

       createPiece(color, pieceIndex, userId, submissionId) {
         const config = CONFIG.QUILT;
         
         // Calculate grid cell size
         const availableWidth = config.viewBoxWidth - 2 * config.edgePadding;
         const availableHeight = config.viewBoxHeight - 2 * config.edgePadding;
         const cellWidth = availableWidth / config.gridCols;
         const cellHeight = availableHeight / config.gridRows;
         
         // Calculate piece size
         const maxPieceSize = Math.min(cellWidth, cellHeight) * config.maxPieceSizeRatio;
         const minSize = Math.max(CONFIG.APP.minBlockSize, maxPieceSize * config.minPieceSizeRatio);
         const maxSize = maxPieceSize;
         const baseSize = minSize + Math.random() * (maxSize - minSize);
         
         // Determine shape
         const isSquare = Math.random() < 0.7;
         let width, height;
         
         if (isSquare) {
           width = baseSize;
           height = baseSize;
         } else {
           const aspectRatio = 1 + (Math.random() - 0.5) * 0.5;
           width = baseSize;
           height = baseSize * aspectRatio;
         }
         
         // Add organic edge variations
         width += (Math.random() - 0.5) * width * config.edgeVariation;
         height += (Math.random() - 0.5) * height * config.edgeVariation;
         
         // Calculate position
         const gridX = pieceIndex % config.gridCols;
         const gridY = Math.floor(pieceIndex / config.gridCols);
         
         const totalGridWidth = config.gridCols * cellWidth;
         const totalGridHeight = config.gridRows * cellHeight;
         const gridStartX = config.viewBoxStartX + (config.viewBoxWidth - totalGridWidth) / 2;
         const gridStartY = config.viewBoxStartY + (config.viewBoxHeight - totalGridHeight) / 2;
         
         const baseX = gridStartX + gridX * cellWidth + cellWidth / 2;
         const baseY = gridStartY + gridY * cellHeight + cellHeight / 2;
         
         // Add jitter
         const maxJitter = Math.min(config.gridJitter, (Math.min(cellWidth, cellHeight) - maxPieceSize) / 2);
         const jitterX = (Math.random() - 0.5) * Math.min(maxJitter, 8);
         const jitterY = (Math.random() - 0.5) * Math.min(maxJitter, 8);
         
         let x = baseX + jitterX;
         let y = baseY + jitterY;
         
         // Constrain to cell bounds
         const minSpacingFromEdge = 5;
         const cellLeft = gridStartX + gridX * cellWidth;
         const cellRight = gridStartX + (gridX + 1) * cellWidth;
         const cellTop = gridStartY + gridY * cellHeight;
         const cellBottom = gridStartY + (gridY + 1) * cellHeight;
         
         x = Math.max(cellLeft + minSpacingFromEdge, Math.min(x, cellRight - width - minSpacingFromEdge));
         y = Math.max(cellTop + minSpacingFromEdge, Math.min(y, cellBottom - height - minSpacingFromEdge));
         
         // Final bounds check
         x = Math.max(config.viewBoxStartX, Math.min(x, config.viewBoxStartX + config.viewBoxWidth - width));
         y = Math.max(config.viewBoxStartY, Math.min(y, config.viewBoxStartY + config.viewBoxHeight - height));
         
         const piece = {
           id: `piece_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
           userId: userId,
           submissionId: submissionId,
           pieceIndex: pieceIndex,
           timestamp: Date.now(),
           x: x,
           y: y,
           width: width,
           height: height,
           color: color,
           type: 'piece',
           edges: this.calculateEdges(width, height)
         };
         
         this.logger.position('piece', pieceIndex, x, y);
         return piece;
       }

       calculateEdges(width, height) {
         return {
           top: width,
           right: height,
           bottom: width,
           left: height
         };
       }

                positionElementsInGrid(elements, startIndex = 0, type = 'pieces') {
           if (elements.length === 0) return;
           
           const config = CONFIG.QUILT;
           const spacing = CONFIG.POSITIONING.spacing[type] || 120;
           const jitter = CONFIG.POSITIONING.jitter[type] || 8;
           
           // For blocks, use touching layout instead of grid
           if (type === 'blocks') {
             this.positionBlocksInTouchingLayout(elements);
             return;
           }
           
           // Calculate optimal grid dimensions for pieces/patches
           const elementCount = elements.length;
           const aspectRatio = config.viewBoxWidth / config.viewBoxHeight;
           const cols = Math.ceil(Math.sqrt(elementCount * aspectRatio));
           const rows = Math.ceil(elementCount / cols);
           
           const availableWidth = config.viewBoxWidth - (2 * config.edgePadding);
           const availableHeight = config.viewBoxHeight - (2 * config.edgePadding);
           const cellWidth = availableWidth / cols;
           const cellHeight = availableHeight / rows;
           
           this.logger.log(`Positioning ${elements.length} ${type} in ${rows}x${cols} grid`);
           
           elements.forEach((element, index) => {
             const gridIndex = startIndex + index;
             const row = Math.floor(gridIndex / cols);
             const col = gridIndex % cols;
             
             const x = config.viewBoxStartX + config.edgePadding + (col * cellWidth);
             const y = config.viewBoxStartY + config.edgePadding + (row * cellHeight);
             
             // Center element in cell
             const centerX = x + (cellWidth - element.width) / 2;
             const centerY = y + (cellHeight - element.height) / 2;
             
             // Add jitter
             const jitterX = (Math.random() - 0.5) * jitter;
             const jitterY = (Math.random() - 0.5) * jitter;
             
             // Ensure element stays within bounds
             const maxX = config.viewBoxStartX + config.viewBoxWidth - config.edgePadding - element.width;
             const maxY = config.viewBoxStartY + config.viewBoxHeight - config.edgePadding - element.height;
             
             element.x = Math.max(config.viewBoxStartX + config.edgePadding, Math.min(maxX, centerX + jitterX));
             element.y = Math.max(config.viewBoxStartY + config.edgePadding, Math.min(maxY, centerY + jitterY));
             
             this.logger.position(type, index, element.x, element.y);
           });
         }
         
         positionBlocksInTouchingLayout(blocks) {
           if (blocks.length === 0) return;
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning ${blocks.length} blocks using pairing logic`);
           
           // For 6 blocks, use the new pairing approach
           if (blocks.length === 6) {
             this.positionBlocksWithPairing(blocks);
             return;
           }
           
           // Fallback to original logic for other block counts
           this.positionBlocksIteratively(blocks);
         }
         
         positionBlocksWithPairing(blocks) {
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log('Using pairing approach for 6 blocks');
           
           // Phase 1: Create 3 paired blocks
           const pairedBlocks = this.createPairedBlocks(blocks);
           
           // Phase 2: Combine 2 paired blocks into a 4-block section
           const fourBlockSection = this.combinePairedBlocks(pairedBlocks);
           
           // Phase 3: Add the remaining paired block
           this.addFinalPairedBlock(fourBlockSection, pairedBlocks[2]);
           
           // Position the final quilt at the center
           this.centerQuilt(blocks);
         }
         
         createPairedBlocks(blocks) {
           this.logger.log('Phase 1: Creating paired blocks');
           this.logger.log(`Initial blocks:`, blocks.map(b => ({ id: b.id, width: b.width, height: b.height, color: b.color })));
           
           // Generate all possible pairs
           const allPairs = [];
           for (let i = 0; i < blocks.length; i++) {
             for (let j = i + 1; j < blocks.length; j++) {
               const pair = this.evaluateBlockPair(blocks[i], blocks[j]);
               allPairs.push(pair);
               this.logger.log(`Pair ${i}-${j}: score=${pair.score.toFixed(2)}, joinType=${pair.joinType}, edgeDiff=${Math.abs(pair.edgeMatch?.edge1.length - pair.edgeMatch?.edge2.length) || 'N/A'}`);
             }
           }
           
           // Sort by score (lower is better)
           allPairs.sort((a, b) => a.score - b.score);
           
           // Select the 3 best pairs, ensuring no block is used twice
           const selectedPairs = [];
           const usedBlocks = new Set();
           
           for (const pair of allPairs) {
             if (!usedBlocks.has(pair.block1) && !usedBlocks.has(pair.block2)) {
               selectedPairs.push(pair);
               usedBlocks.add(pair.block1);
               usedBlocks.add(pair.block2);
               
               if (selectedPairs.length === 3) break;
             }
           }
           
           // Create paired blocks
           const pairedBlocks = selectedPairs.map(pair => this.createPairedBlock(pair));
           
           this.logger.log(`Created ${pairedBlocks.length} paired blocks`);
           this.logger.log('Paired blocks details:', pairedBlocks.map(pb => ({
             width: pb.width,
             height: pb.height,
             joinType: pb.joinType,
             score: pb.score,
             blockIds: pb.blocks.map(b => b.id)
           })));
           return pairedBlocks;
         }
         
         evaluateBlockPair(block1, block2) {
           let bestScore = Infinity;
           let bestJoinType = null;
           let bestEdgeMatch = null;
           
           // Check all possible edge combinations
           const edges1 = [
             { type: 'horizontal', length: block1.width, side: 'right' },
             { type: 'horizontal', length: block1.width, side: 'left' },
             { type: 'vertical', length: block1.height, side: 'bottom' },
             { type: 'vertical', length: block1.height, side: 'top' }
           ];
           
           const edges2 = [
             { type: 'horizontal', length: block2.width, side: 'right' },
             { type: 'horizontal', length: block2.width, side: 'left' },
             { type: 'vertical', length: block2.height, side: 'bottom' },
             { type: 'vertical', length: block2.height, side: 'top' }
           ];
           
           for (const edge1 of edges1) {
             for (const edge2 of edges2) {
               if (edge1.type === edge2.type) {
                 const lengthDiff = Math.abs(edge1.length - edge2.length);
                 const valueContrast = this.calculateValueContrastScore(block1.color, block2.color);
                 
                 // Combined score: edge compatibility + value contrast
                 const score = lengthDiff + (1 - valueContrast) * 50;
                 
                 if (score < bestScore) {
                   bestScore = score;
                   bestJoinType = edge1.type;
                   bestEdgeMatch = { edge1, edge2 };
                 }
               }
             }
           }
           
           return {
             block1,
             block2,
             score: bestScore,
             joinType: bestJoinType,
             edgeMatch: bestEdgeMatch
           };
         }
         
         createPairedBlock(pair) {
           const { block1, block2, joinType, edgeMatch } = pair;
           
           this.logger.log(`Creating paired block: ${block1.id} + ${block2.id}, joinType=${joinType}`);
           this.logger.log(`Before resize: block1=${block1.width}x${block1.height}, block2=${block2.width}x${block2.height}`);
           
           // Resize blocks slightly if needed for better edge alignment
           if (joinType === 'horizontal') {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               block1.width = targetLength;
               this.logger.log(`Resized block1 width to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               block2.width = targetLength;
               this.logger.log(`Resized block2 width to ${targetLength}`);
             }
           } else {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               block1.height = targetLength;
               this.logger.log(`Resized block1 height to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               block2.height = targetLength;
               this.logger.log(`Resized block2 height to ${targetLength}`);
             }
           }
           
           this.logger.log(`After resize: block1=${block1.width}x${block1.height}, block2=${block2.width}x${block2.height}`);
           
           // Calculate combined dimensions
           let combinedWidth, combinedHeight;
           if (joinType === 'horizontal') {
             combinedWidth = block1.width + block2.width;
             combinedHeight = Math.max(block1.height, block2.height);
           } else {
             combinedWidth = Math.max(block1.width, block2.width);
             combinedHeight = block1.height + block2.height;
           }
           
           // Position the two blocks within the paired block
           block1.x = 0;
           block1.y = 0;
           
           if (joinType === 'horizontal') {
             // For horizontal join, place block2 to the right of block1
             block2.x = block1.width;
             block2.y = 0;
           } else {
             // For vertical join, place block2 below block1
             block2.x = 0;
             block2.y = block1.height;
           }
           
           this.logger.log(`Positioned blocks in pair: ${block1.id} at (${block1.x}, ${block1.y}), ${block2.id} at (${block2.x}, ${block2.y})`);
           this.logger.log(`Paired block dimensions: ${combinedWidth}x${combinedHeight}, joinType=${joinType}`);
           
           return {
             blocks: [block1, block2],
             width: combinedWidth,
             height: combinedHeight,
             joinType,
             score: pair.score
           };
         }
         
         combinePairedBlocks(pairedBlocks) {
           this.logger.log('Phase 2: Combining paired blocks');
           
           // Evaluate all possible combinations of 2 paired blocks
           const combinations = [];
           for (let i = 0; i < pairedBlocks.length; i++) {
             for (let j = i + 1; j < pairedBlocks.length; j++) {
               const combination = this.evaluatePairedBlockCombination(pairedBlocks[i], pairedBlocks[j]);
               combinations.push(combination);
               this.logger.log(`Combination ${i}-${j}: score=${combination.score.toFixed(2)}, joinType=${combination.joinType}`);
             }
           }
           
           // Select the best combination
           combinations.sort((a, b) => a.score - b.score);
           const bestCombination = combinations[0];
           
           // Create the 4-block section
           const fourBlockSection = this.createFourBlockSection(bestCombination);
           
           this.logger.log('Created 4-block section');
           return fourBlockSection;
         }
         
         evaluatePairedBlockCombination(pair1, pair2) {
           let bestScore = Infinity;
           let bestJoinType = null;
           let bestEdgeMatch = null;
           
           // Check all possible edge combinations between the paired blocks
           const edges1 = [
             { type: 'horizontal', length: pair1.width, side: 'right' },
             { type: 'horizontal', length: pair1.width, side: 'left' },
             { type: 'vertical', length: pair1.height, side: 'bottom' },
             { type: 'vertical', length: pair1.height, side: 'top' }
           ];
           
           const edges2 = [
             { type: 'horizontal', length: pair2.width, side: 'right' },
             { type: 'horizontal', length: pair2.width, side: 'left' },
             { type: 'vertical', length: pair2.height, side: 'bottom' },
             { type: 'vertical', length: pair2.height, side: 'top' }
           ];
           
           for (const edge1 of edges1) {
             for (const edge2 of edges2) {
               if (edge1.type === edge2.type) {
                 const lengthDiff = Math.abs(edge1.length - edge2.length);
                 const score = lengthDiff;
                 
                 if (score < bestScore) {
                   bestScore = score;
                   bestJoinType = edge1.type;
                   bestEdgeMatch = { edge1, edge2 };
                 }
               }
             }
           }
           
           return {
             pair1,
             pair2,
             score: bestScore,
             joinType: bestJoinType,
             edgeMatch: bestEdgeMatch
           };
         }
         
         createFourBlockSection(combination) {
           const { pair1, pair2, joinType, edgeMatch } = combination;
           
           this.logger.log(`Creating four-block section: pair1=${pair1.width}x${pair1.height}, pair2=${pair2.width}x${pair2.height}, joinType=${joinType}`);
           
           // Resize paired blocks slightly if needed
           if (joinType === 'horizontal') {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               pair1.width = targetLength;
               this.logger.log(`Resized pair1 width to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               pair2.width = targetLength;
               this.logger.log(`Resized pair2 width to ${targetLength}`);
             }
           } else {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               pair1.height = targetLength;
               this.logger.log(`Resized pair1 height to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               pair2.height = targetLength;
               this.logger.log(`Resized pair2 height to ${targetLength}`);
             }
           }
           
           // Calculate combined dimensions
           let combinedWidth, combinedHeight;
           if (joinType === 'horizontal') {
             combinedWidth = pair1.width + pair2.width;
             combinedHeight = Math.max(pair1.height, pair2.height);
           } else {
             combinedWidth = Math.max(pair1.width, pair2.width);
             combinedHeight = pair1.height + pair2.height;
           }
           
           this.logger.log(`Four-block section dimensions: ${combinedWidth}x${combinedHeight}`);
           
                       // Position the blocks within the four-block section
            let currentX = 0;
            let currentY = 0;
            
            // Position blocks from pair1 first
            for (const block of pair1.blocks) {
              // Add the pair1 offset to the block's existing relative position
              block.x = currentX + block.x;
              block.y = currentY + block.y;
              
              if (pair1.joinType === 'horizontal') {
                currentX += block.width;
              } else {
                currentY += block.height;
              }
              
              this.logger.log(`Positioned pair1 block ${block.id} at (${block.x}, ${block.y})`);
            }
            
            // Reset position for pair2
            if (joinType === 'horizontal') {
              // Attach pair2 to the right of pair1 - ensure they touch
              currentX = pair1.width;
              currentY = 0;
            } else {
              // Attach pair2 below pair1 - ensure they touch
              currentX = 0;
              currentY = pair1.height;
            }
            
            // Position blocks from pair2
            for (const block of pair2.blocks) {
              // Add the pair2 offset to the block's existing relative position
              block.x = currentX + block.x;
              block.y = currentY + block.y;
              
              // Update current position based on the four-block section's join type, not the pair's join type
              if (joinType === 'horizontal') {
                currentX += block.width;
              } else {
                currentY += block.height;
              }
              
              this.logger.log(`Positioned pair2 block ${block.id} at (${block.x}, ${block.y})`);
            }
           
           this.logger.log('Final four-block section positions:', [...pair1.blocks, ...pair2.blocks].map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Check for overlaps in the four-block section
           this.logger.log('Checking for overlaps in four-block section...');
           const allBlocks = [...pair1.blocks, ...pair2.blocks];
           for (let i = 0; i < allBlocks.length; i++) {
             for (let j = i + 1; j < allBlocks.length; j++) {
               const block1 = allBlocks[i];
               const block2 = allBlocks[j];
               
               // Check for horizontal overlap
               const horizontalOverlap = Math.min(block1.x + block1.width, block2.x + block2.width) - Math.max(block1.x, block2.x);
               if (horizontalOverlap > 0) {
                 const verticalOverlap = Math.min(block1.y + block1.height, block2.y + block2.height) - Math.max(block1.y, block2.y);
                 if (verticalOverlap > 0) {
                   this.logger.log(`FOUR-BLOCK OVERLAP detected between ${block1.id} and ${block2.id}: ${horizontalOverlap}x${verticalOverlap}px`);
                 }
               }
             }
           }
           
           return {
             blocks: [...pair1.blocks, ...pair2.blocks],
             width: combinedWidth,
             height: combinedHeight,
             joinType,
             score: combination.score
           };
         }
         
         addFinalPairedBlock(fourBlockSection, remainingPairedBlock) {
           this.logger.log('Phase 3: Adding final paired block');
           
           // Find the best way to add the remaining paired block
           const bestAttachment = this.findBestAttachment(fourBlockSection, remainingPairedBlock);
           
           // Apply the attachment
           this.applyAttachment(fourBlockSection, remainingPairedBlock, bestAttachment);
           
           this.logger.log('Final quilt layout complete');
         }
         
         findBestAttachment(fourBlockSection, pairedBlock) {
           let bestScore = Infinity;
           let bestPosition = null;
           let bestJoinType = null;
           
           // Try different attachment positions
           const attachmentPositions = [
             { side: 'right', x: fourBlockSection.width, y: 0 },
             { side: 'left', x: -pairedBlock.width, y: 0 },
             { side: 'bottom', x: 0, y: fourBlockSection.height },
             { side: 'top', x: 0, y: -pairedBlock.height }
           ];
           
           for (const position of attachmentPositions) {
             const score = this.evaluateAttachmentPosition(fourBlockSection, pairedBlock, position);
             if (score < bestScore) {
               bestScore = score;
               bestPosition = position;
               bestJoinType = position.side === 'right' || position.side === 'left' ? 'horizontal' : 'vertical';
             }
           }
           
           return {
             position: bestPosition,
             joinType: bestJoinType,
             score: bestScore
           };
         }
         
         evaluateAttachmentPosition(fourBlockSection, pairedBlock, position) {
           // Simple scoring based on edge alignment and shape balance
           let score = 0;
           
           // Edge alignment score
           if (position.side === 'right' || position.side === 'left') {
             const lengthDiff = Math.abs(fourBlockSection.height - pairedBlock.height);
             score += lengthDiff;
           } else {
             const lengthDiff = Math.abs(fourBlockSection.width - pairedBlock.width);
             score += lengthDiff;
           }
           
           // Shape balance score (prefer more square shapes)
           const combinedWidth = position.side === 'right' || position.side === 'left' 
             ? fourBlockSection.width + pairedBlock.width 
             : Math.max(fourBlockSection.width, pairedBlock.width);
           const combinedHeight = position.side === 'top' || position.side === 'bottom'
             ? fourBlockSection.height + pairedBlock.height
             : Math.max(fourBlockSection.height, pairedBlock.height);
           
           const aspectRatio = Math.max(combinedWidth, combinedHeight) / Math.min(combinedWidth, combinedHeight);
           score += (aspectRatio - 1) * 10; // Penalize very long/thin shapes
           
           return score;
         }
         
         applyAttachment(fourBlockSection, pairedBlock, attachment) {
           const { position, joinType } = attachment;
           
           this.logger.log(`Applying attachment: joinType=${joinType}, position=${JSON.stringify(position)}`);
           this.logger.log(`Before attachment: fourBlockSection=${fourBlockSection.width}x${fourBlockSection.height}, pairedBlock=${pairedBlock.width}x${pairedBlock.height}`);
           
           // Resize if needed for better alignment
           if (joinType === 'horizontal') {
             const targetHeight = Math.max(fourBlockSection.height, pairedBlock.height);
             if (fourBlockSection.height < targetHeight) {
               fourBlockSection.height = targetHeight;
               this.logger.log(`Resized fourBlockSection height to ${targetHeight}`);
             }
             if (pairedBlock.height < targetHeight) {
               pairedBlock.height = targetHeight;
               this.logger.log(`Resized pairedBlock height to ${targetHeight}`);
             }
           } else {
             const targetWidth = Math.max(fourBlockSection.width, pairedBlock.width);
             if (fourBlockSection.width < targetWidth) {
               fourBlockSection.width = targetWidth;
               this.logger.log(`Resized fourBlockSection width to ${targetWidth}`);
             }
             if (pairedBlock.width < targetWidth) {
               pairedBlock.width = targetWidth;
               this.logger.log(`Resized pairedBlock width to ${targetWidth}`);
             }
           }
           
           // Position blocks based on the attachment position
           const allBlocks = [...fourBlockSection.blocks, ...pairedBlock.blocks];
           
           this.logger.log(`Positioning ${allBlocks.length} blocks based on attachment position`);
           
           // Calculate the offset for the paired block based on attachment position
           let pairedBlockOffsetX = 0;
           let pairedBlockOffsetY = 0;
           
           if (position.side === 'right') {
             // Attach to the right - paired block starts where four-block section ends
             pairedBlockOffsetX = fourBlockSection.width;
             pairedBlockOffsetY = 0;
           } else if (position.side === 'left') {
             // Attach to the left - paired block ends where four-block section starts
             pairedBlockOffsetX = -pairedBlock.width;
             pairedBlockOffsetY = 0;
           } else if (position.side === 'bottom') {
             // Attach below - paired block starts where four-block section ends
             pairedBlockOffsetX = 0;
             pairedBlockOffsetY = fourBlockSection.height;
           } else if (position.side === 'top') {
             // Attach above - paired block ends where four-block section starts
             pairedBlockOffsetX = 0;
             pairedBlockOffsetY = -pairedBlock.height;
           }
           
           this.logger.log(`Paired block offset: (${pairedBlockOffsetX}, ${pairedBlockOffsetY})`);
           
           // Position blocks from the four-block section (they stay at their current positions)
           for (const block of fourBlockSection.blocks) {
             this.logger.log(`Four-block section block ${block.id} stays at (${block.x}, ${block.y})`);
           }
           
           // Position blocks from the paired block with the calculated offset
           for (const block of pairedBlock.blocks) {
             // Add the paired block offset to the block's existing relative position
             block.x = pairedBlockOffsetX + block.x;
             block.y = pairedBlockOffsetY + block.y;
             
             this.logger.log(`Positioned paired block ${block.id} at (${block.x}, ${block.y})`);
           }
           
           this.logger.log('Final block positions:', allBlocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Check for overlaps and gaps by analyzing all block pairs
           this.logger.log('Checking for overlaps and gaps between blocks...');
           for (let i = 0; i < allBlocks.length; i++) {
             for (let j = i + 1; j < allBlocks.length; j++) {
               const block1 = allBlocks[i];
               const block2 = allBlocks[j];
               
               // Check for horizontal overlap
               const horizontalOverlap = Math.min(block1.x + block1.width, block2.x + block2.width) - Math.max(block1.x, block2.x);
               if (horizontalOverlap > 0) {
                 const verticalOverlap = Math.min(block1.y + block1.height, block2.y + block2.height) - Math.max(block1.y, block2.y);
                 if (verticalOverlap > 0) {
                   this.logger.log(`OVERLAP detected between ${block1.id} and ${block2.id}: ${horizontalOverlap}x${verticalOverlap}px`);
                 }
               }
               
               // Check if blocks are adjacent horizontally
               if (Math.abs(block1.y - block2.y) < 1) {
                 const gap = Math.abs(block1.x + block1.width - block2.x);
                 if (gap > 1) {
                   this.logger.log(`Gap detected between ${block1.id} and ${block2.id}: ${gap}px`);
                 }
               }
               
               // Check if blocks are adjacent vertically
               if (Math.abs(block1.x - block2.x) < 1) {
                 const gap = Math.abs(block1.y + block1.height - block2.y);
                 if (gap > 1) {
                   this.logger.log(`Gap detected between ${block1.id} and ${block2.id}: ${gap}px`);
                 }
               }
             }
           }
         }
         
         centerQuilt(blocks) {
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log('Centering quilt...');
           this.logger.log('Before centering:', blocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Calculate quilt bounds
           const bounds = this.getQuiltBounds(blocks);
           this.logger.log('Quilt bounds:', bounds);
           
           // Calculate center position
           const centerX = config.viewBoxStartX + (config.viewBoxWidth / 2) - (bounds.width / 2);
           const centerY = config.viewBoxStartY + (config.viewBoxHeight / 2) - (bounds.height / 2);
           
           this.logger.log(`Target center: (${centerX}, ${centerY})`);
           
           // Adjust all block positions
           const offsetX = centerX - bounds.x;
           const offsetY = centerY - bounds.y;
           
           this.logger.log(`Applying offset: (${offsetX}, ${offsetY})`);
           
           for (const block of blocks) {
             const oldX = block.x;
             const oldY = block.y;
             
             block.x += offsetX;
             block.y += offsetY;
             
             // Ensure blocks stay within bounds
             const newX = Math.max(config.viewBoxStartX + padding, 
                              Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - block.width, block.x));
             const newY = Math.max(config.viewBoxStartY + padding, 
                              Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - block.height, block.y));
             
             if (newX !== block.x || newY !== block.y) {
               this.logger.log(`Bounds adjustment for block ${block.id}: (${block.x}, ${block.y}) -> (${newX}, ${newY})`);
             }
             
             block.x = newX;
             block.y = newY;
           }
           
           this.logger.log('After centering:', blocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
         }
         
         positionBlocksIteratively(blocks) {
           if (blocks.length === 0) return;
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning ${blocks.length} blocks using iterative edge-matching logic`);
           
           // Start with the first block at the center
           blocks[0].x = config.viewBoxStartX + (config.viewBoxWidth / 2) - (blocks[0].width / 2);
           blocks[0].y = config.viewBoxStartY + (config.viewBoxHeight / 2) - (blocks[0].height / 2);
           
           // Create a list of available blocks to join
           const availableBlocks = blocks.slice(1);
           const joinedBlocks = [blocks[0]];
           
           // Iteratively join blocks using edge matching
           while (availableBlocks.length > 0) {
             let bestMatch = null;
             let bestScore = Infinity;
             let bestJoinType = null;
             let bestBlockIndex = -1;
             let bestJoinedIndex = -1;
             
             // Find the best edge match between available blocks and joined blocks
             for (let i = 0; i < availableBlocks.length; i++) {
               const availableBlock = availableBlocks[i];
               
               for (let j = 0; j < joinedBlocks.length; j++) {
                 const joinedBlock = joinedBlocks[j];
                 
                 // Check all four edges of each block
                 const edges = [
                   { type: 'horizontal', length: availableBlock.width, block: availableBlock, side: 'right' },
                   { type: 'horizontal', length: availableBlock.width, block: availableBlock, side: 'left' },
                   { type: 'vertical', length: availableBlock.height, block: availableBlock, side: 'bottom' },
                   { type: 'vertical', length: availableBlock.height, block: availableBlock, side: 'top' }
                 ];
                 
                 const joinedEdges = [
                   { type: 'horizontal', length: joinedBlock.width, block: joinedBlock, side: 'right' },
                   { type: 'horizontal', length: joinedBlock.width, block: joinedBlock, side: 'left' },
                   { type: 'vertical', length: joinedBlock.height, block: joinedBlock, side: 'bottom' },
                   { type: 'vertical', length: joinedBlock.height, block: joinedBlock, side: 'top' }
                 ];
                 
                 // Find best matching edges
                 for (const edge of edges) {
                   for (const joinedEdge of joinedEdges) {
                     if (edge.type === joinedEdge.type) {
                       const lengthDiff = Math.abs(edge.length - joinedEdge.length);
                       const score = lengthDiff;
                       
                       if (score < bestScore) {
                         bestScore = score;
                         bestMatch = { available: edge, joined: joinedEdge };
                         bestJoinType = edge.type;
                         bestBlockIndex = i;
                         bestJoinedIndex = j;
                       }
                     }
                   }
                 }
               }
             }
             
             if (bestMatch) {
               // Join the blocks
               const availableBlock = availableBlocks[bestBlockIndex];
               const joinedBlock = joinedBlocks[bestJoinedIndex];
               
               // Calculate position based on join type
               let newX, newY;
               
               if (bestJoinType === 'horizontal') {
                 // Join horizontally
                 if (bestMatch.available.side === 'right' && bestMatch.joined.side === 'left') {
                   newX = joinedBlock.x + joinedBlock.width;
                   newY = joinedBlock.y;
                 } else if (bestMatch.available.side === 'left' && bestMatch.joined.side === 'right') {
                   newX = joinedBlock.x - availableBlock.width;
                   newY = joinedBlock.y;
                 } else {
                   // Resize to match
                   const targetLength = Math.max(bestMatch.available.length, bestMatch.joined.length);
                   if (bestMatch.available.length < targetLength) {
                     availableBlock.width = targetLength;
                   }
                   if (bestMatch.joined.length < targetLength) {
                     joinedBlock.width = targetLength;
                   }
                   newX = joinedBlock.x + joinedBlock.width;
                   newY = joinedBlock.y;
                 }
               } else {
                 // Join vertically
                 if (bestMatch.available.side === 'bottom' && bestMatch.joined.side === 'top') {
                   newX = joinedBlock.x;
                   newY = joinedBlock.y + joinedBlock.height;
                 } else if (bestMatch.available.side === 'top' && bestMatch.joined.side === 'bottom') {
                   newX = joinedBlock.x;
                   newY = joinedBlock.y - availableBlock.height;
                 } else {
                   // Resize to match
                   const targetLength = Math.max(bestMatch.available.length, bestMatch.joined.length);
                   if (bestMatch.available.length < targetLength) {
                     availableBlock.height = targetLength;
                   }
                   if (bestMatch.joined.length < targetLength) {
                     joinedBlock.height = targetLength;
                   }
                   newX = joinedBlock.x;
                   newY = joinedBlock.y + joinedBlock.height;
                 }
               }
               
               // Ensure the block stays within bounds
               newX = Math.max(config.viewBoxStartX + padding, 
                              Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - availableBlock.width, newX));
               newY = Math.max(config.viewBoxStartY + padding, 
                              Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - availableBlock.height, newY));
               
               availableBlock.x = newX;
               availableBlock.y = newY;
               
               // Move block from available to joined
               joinedBlocks.push(availableBlock);
               availableBlocks.splice(bestBlockIndex, 1);
               
               this.logger.log(`Joined block ${bestBlockIndex} to block ${bestJoinedIndex} with score ${bestScore}`);
             } else {
               // Fallback: position remaining blocks around the quilt
               const remainingBlock = availableBlocks[0];
               const quiltBounds = this.getQuiltBounds(joinedBlocks);
               
               remainingBlock.x = quiltBounds.x + quiltBounds.width;
               remainingBlock.y = quiltBounds.y;
               
               joinedBlocks.push(remainingBlock);
               availableBlocks.splice(0, 1);
               
               this.logger.log(`Fallback positioning for remaining block`);
             }
           }
         }
         
         positionPieceWithQuilt(piece, existingBlocks) {
           if (existingBlocks.length === 0) {
             // If no existing blocks, position piece normally
             piece.x = CONFIG.QUILT.viewBoxStartX + CONFIG.QUILT.edgePadding;
             piece.y = CONFIG.QUILT.viewBoxStartY + CONFIG.QUILT.edgePadding;
             return;
           }
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning piece with ${existingBlocks.length} existing blocks`);
           
           // Find the best position to attach the piece to the quilt
           let bestX = config.viewBoxStartX + padding;
           let bestY = config.viewBoxStartY + padding;
           let bestScore = Infinity;
           
           // Try different attachment points around the existing quilt
           for (let attempt = 0; attempt < 20; attempt++) {
             let testX, testY;
             
             if (attempt < 5) {
               // Try attaching to the right edge of the quilt
               const rightmostBlock = existingBlocks.reduce((rightmost, block) => 
                 block.x + block.width > rightmost.x + rightmost.width ? block : rightmost
               );
               testX = rightmostBlock.x + rightmostBlock.width;
               testY = rightmostBlock.y + (Math.random() - 0.5) * rightmostBlock.height;
             } else if (attempt < 10) {
               // Try attaching to the bottom edge of the quilt
               const bottommostBlock = existingBlocks.reduce((bottommost, block) => 
                 block.y + block.height > bottommost.y + bottommost.height ? block : bottommost
               );
               testX = bottommostBlock.x + (Math.random() - 0.5) * bottommostBlock.width;
               testY = bottommostBlock.y + bottommostBlock.height;
             } else {
               // Try random positions near the quilt
               const quiltBounds = this.getQuiltBounds(existingBlocks);
               testX = quiltBounds.x + (Math.random() - 0.5) * quiltBounds.width;
               testY = quiltBounds.y + (Math.random() - 0.5) * quiltBounds.height;
             }
             
             // Ensure piece stays within bounds
             testX = Math.max(config.viewBoxStartX + padding, 
                            Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - piece.width, testX));
             testY = Math.max(config.viewBoxStartY + padding, 
                            Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - piece.height, testY));
             
             // Check if this position touches at least one existing block
             let touchesExisting = false;
             let minDistance = Infinity;
             
             for (const block of existingBlocks) {
               const horizontalTouch = (testX + piece.width === block.x) || 
                                    (block.x + block.width === testX);
               const verticalTouch = (testY + piece.height === block.y) || 
                                  (block.y + block.height === testY);
               
               if (horizontalTouch || verticalTouch) {
                 touchesExisting = true;
                 break;
               }
               
               // Calculate distance to block
               const distance = Math.sqrt(
                 Math.pow(testX - block.x, 2) + Math.pow(testY - block.y, 2)
               );
               minDistance = Math.min(minDistance, distance);
             }
             
             // Prefer positions that touch existing blocks
             const score = touchesExisting ? minDistance : minDistance + 1000;
             
             if (score < bestScore) {
               bestScore = score;
               bestX = testX;
               bestY = testY;
             }
           }
           
           piece.x = bestX;
           piece.y = bestY;
           
           this.logger.log(`Piece positioned at (${piece.x}, ${piece.y}) with score ${bestScore}`);
         }
         
         getQuiltBounds(blocks) {
           if (blocks.length === 0) {
             return { x: 0, y: 0, width: 0, height: 0 };
           }
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           
           blocks.forEach(block => {
             minX = Math.min(minX, block.x);
             minY = Math.min(minY, block.y);
             maxX = Math.max(maxX, block.x + block.width);
             maxY = Math.max(maxY, block.y + block.height);
           });
           
           return {
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY
           };
         }
         
         calculateValueContrastScore(color1, color2) {
           const hsl1 = Utils.hexToHsl(color1);
           const hsl2 = Utils.hexToHsl(color2);
           const valueDifference = Math.abs(hsl1.l - hsl2.l);
           const normalizedContrast = valueDifference / 100;
           const contrastScore = Math.pow(normalizedContrast, 0.7);
           return contrastScore;
         }
     }

     // ===== RENDERING SERVICE =====
     class RenderingService {
       constructor(logger, errorHandler) {
         this.logger = logger;
         this.errorHandler = errorHandler;
         this.quiltSVG = null;
         this.isInitialized = false;
       }

       initialize() {
         this.quiltSVG = document.getElementById('quilt');
         if (!this.quiltSVG) {
           throw new Error('Quilt SVG element not found');
         }
         this.isInitialized = true;
         this.logger.log('Rendering service initialized');
       }

       renderBlocks(state) {
         if (!this.isInitialized) {
           this.logger.warn('Rendering service not initialized');
           return;
         }
         
         if (!this.quiltSVG) {
           this.logger.warn('Quilt SVG not found');
           return;
         }

         try {
           // Clear existing content
           this.quiltSVG.innerHTML = '';
           
           // Create SVG definitions
           this.createSVGDefinitions();
           
           // Add viewBox border for debugging
           this.addViewBoxBorder();
           
           // Render based on current phase
           this.renderByPhase(state);
           
           // Update UI
           this.updateUI(state);
           
           this.logger.render('elements', this.getTotalElements(state));
         } catch (error) {
           this.errorHandler.handleError(error, 'renderBlocks');
         }
       }

       createSVGDefinitions() {
         const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
         defs.innerHTML = `
           <filter id="organicEdges" x="0" y="0" width="200%" height="200%">
             <feTurbulence baseFrequency="0.015" numOctaves="2" result="turb"/>
             <feDisplacementMap in="SourceGraphic" in2="turb" scale="2"/>
           </filter>
           <filter id="userHighlight" x="0" y="0" width="200%" height="200%">
             <feGaussianBlur stdDeviation="3" result="blur"/>
             <feFlood flood-color="#FFD700" flood-opacity="0.6" result="glow"/>
             <feComposite in="glow" in2="blur" operator="in" result="glowBlur"/>
             <feMerge>
               <feMergeNode in="glowBlur"/>
               <feMergeNode in="SourceGraphic"/>
             </feMerge>
           </filter>`;
         this.quiltSVG.appendChild(defs);
       }

       addViewBoxBorder() {
         const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         border.setAttribute('x', '-100');
         border.setAttribute('y', '-100');
         border.setAttribute('width', '800');
         border.setAttribute('height', '800');
         border.setAttribute('fill', 'none');
         border.setAttribute('stroke', '#ff0000');
         border.setAttribute('stroke-width', '2');
         border.setAttribute('stroke-dasharray', '5,5');
         this.quiltSVG.appendChild(border);
       }

       renderByPhase(state) {
         this.logger.log(`ðŸŽ¨ renderByPhase called for phase: ${state.currentPhase}`);
         
         switch (state.currentPhase) {
           case 'collection':
             this.logger.log(`ðŸŽ¨ Rendering pieces in collection phase`);
             this.renderPieces(state.pieces);
             break;
           case 'patch-formation':
             this.logger.log(`ðŸŽ¨ Rendering patches in patch-formation phase`);
             this.renderPatches(state.patches);
             this.renderUnmatchedPieces(state.unmatchedPieces);
             break;
           case 'block-formation':
             this.logger.log(`ðŸŽ¨ Rendering blocks in block-formation phase`);
             this.renderBlockList(state.blocks);
             this.renderUnmatchedPieces(state.unmatchedPieces);
             this.renderUnmatchedPatches(state.unmatchedPatches);
             break;
           case 'quilt-formation':
             this.logger.log(`ðŸŽ¨ Rendering quilt in quilt-formation phase`);
             this.renderQuilt(state.quilt);
             break;
           default:
             this.logger.log(`ðŸŽ¨ Default case: rendering blocks`);
             this.renderBlockList(state.blocks);
         }
         
         this.logger.log(`ðŸŽ¨ renderByPhase completed for phase: ${state.currentPhase}`);
       }

       renderPieces(pieces) {
         pieces.forEach((piece, i) => {
           this.renderPiece(piece, i);
         });
       }

       renderPatches(patches) {
         patches.forEach((patch, i) => {
           this.renderPatch(patch, i);
         });
       }

       renderBlockList(blocks) {
         if (!blocks || !Array.isArray(blocks)) {
           this.logger.warn('No blocks to render');
           return;
         }
         blocks.forEach((block, i) => {
           this.renderBlock(block, i);
         });
       }

       renderBlocks(state) {
         if (!state || !state.currentPhase) {
           this.logger.warn('âŒ State or currentPhase is undefined, using default phase');
           state = { currentPhase: 'collection' };
         }
         
         this.logger.log(`ðŸŽ¨ Starting renderBlocks for phase: ${state.currentPhase}`);
         
         if (!this.quiltSVG) {
           this.logger.error('âŒ quiltSVG element not found!');
           return;
         }
         
         this.logger.log(`ðŸŽ¨ Found quiltSVG element, clearing content`);
         this.quiltSVG.innerHTML = '';
         
         // Create SVG definitions
         this.createSVGDefinitions();
         
         // Add viewBox border for debugging
         this.addViewBoxBorder();
         
         // Render based on current phase
         this.renderByPhase(state);
         
         this.logger.log('âœ… renderBlocks completed');
       }

       renderUnmatchedPieces(pieces) {
         if (pieces && pieces.length > 0) {
           pieces.forEach((piece, i) => {
             this.renderPiece(piece, i);
           });
         }
       }

       renderUnmatchedPatches(patches) {
         if (patches && patches.length > 0) {
           patches.forEach((patch, i) => {
             this.renderPatch(patch, i);
           });
         }
       }

       renderQuilt(state) {
         this.logger.log('ðŸŽ¨ renderQuilt called, delegating to renderBlocks');
         this.renderBlocks(state);
       }



       renderQuiltBlocks(quilt) {
         if (quilt && quilt.blocks) {
           quilt.blocks.forEach((quiltBlock, index) => {
             if (quiltBlock && quiltBlock.blocks) {
               quiltBlock.blocks.forEach((block, blockIndex) => {
                 this.renderBlock(block, blockIndex);
               });
             }
           });
         }
       }

       renderPiece(piece, index) {
         this.logger.log(`ðŸŽ¨ Rendering piece ${index}:`, piece);
         
         const pathData = this.createOrganicPath(piece);
         this.logger.log(`ðŸŽ¨ Created path data for piece ${index}`);
         
         const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
         path.setAttribute('d', pathData);
         path.setAttribute('fill', piece.color);
         
         // Apply filters
         if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
           this.logger.log(`ðŸŽ¨ Applying user highlight filter to piece ${index}`);
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.userHighlightFilter})`);
         } else {
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.organicEdgesFilter})`);
         }
         
         // Animate new pieces
         const isCurrentUserPiece = piece.userId === this.currentUserId;
         const isLatestSubmission = piece.submissionId === this.submissionCount;
         if (isCurrentUserPiece && isLatestSubmission) {
           this.logger.log(`ðŸŽ¨ Adding animation class to piece ${index}`);
           path.classList.add(CONFIG.RENDERING.animationClass);
         }
         
         this.quiltSVG.appendChild(path);
         this.logger.log(`âœ… Piece ${index} rendered successfully`);
       }

       renderPatch(patch, index) {
         if (!patch || !patch.pieces || patch.pieces.length === 0) return;
         
         const piece1 = patch.pieces[0];
         const piece2 = patch.pieces[1];
         
         // Add organic jitter
         const jitterX = (Math.random() - 0.5) * 8;
         const jitterY = (Math.random() - 0.5) * 8;
         const jitteredPatchX = patch.x + jitterX;
         const jitteredPatchY = patch.y + jitterY;
         
         const isRotated = patch.rotation === 90;
         const effectiveWidth = isRotated ? patch.height : patch.width;
         const effectiveHeight = isRotated ? patch.width : patch.height;
         
         let positionedPiece1, positionedPiece2;
         
         if (effectiveWidth > effectiveHeight) {
           // Horizontal join
           const piece1Ratio = piece1.width / (piece1.width + piece2.width);
           const piece2Ratio = piece2.width / (piece1.width + piece2.width);
           const joinJitter = (Math.random() - 0.5) * 6;
           
           positionedPiece1 = {
             ...piece1,
             x: jitteredPatchX,
             y: jitteredPatchY,
             width: (effectiveWidth * piece1Ratio) + joinJitter,
             height: effectiveHeight + (Math.random() - 0.5) * 4
           };
           positionedPiece2 = {
             ...piece2,
             x: jitteredPatchX + (effectiveWidth * piece1Ratio) + joinJitter,
             y: jitteredPatchY,
             width: (effectiveWidth * piece2Ratio) - joinJitter,
             height: effectiveHeight + (Math.random() - 0.5) * 4
           };
         } else {
           // Vertical join
           const piece1Ratio = piece1.height / (piece1.height + piece2.height);
           const piece2Ratio = piece2.height / (piece1.height + piece2.height);
           const joinJitter = (Math.random() - 0.5) * 6;
           
           positionedPiece1 = {
             ...piece1,
             x: jitteredPatchX,
             y: jitteredPatchY,
             width: effectiveWidth + (Math.random() - 0.5) * 4,
             height: (effectiveHeight * piece1Ratio) + joinJitter
           };
           positionedPiece2 = {
             ...piece2,
             x: jitteredPatchX,
             y: jitteredPatchY + (effectiveHeight * piece1Ratio) + joinJitter,
             width: effectiveWidth + (Math.random() - 0.5) * 4,
             height: (effectiveHeight * piece2Ratio) - joinJitter
           };
         }
         
         [positionedPiece1, positionedPiece2].forEach((piece, pieceIndex) => {
           const pathData = this.createOrganicPath(piece);
           if (!pathData) return;
           
           const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
           path.setAttribute('d', pathData);
           path.setAttribute('fill', piece.color);
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.organicEdgesFilter})`);
           
           if (patch.rotation === 90) {
             const centerX = piece.x + piece.width / 2;
             const centerY = piece.y + piece.height / 2;
             path.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`);
           }
           
           if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
             path.setAttribute('filter', `url(#${CONFIG.RENDERING.userHighlightFilter})`);
           }
           
           const isCurrentUserPiece = piece.userId === this.currentUserId;
           const isLatestSubmission = piece.submissionId === this.submissionCount;
           if (isCurrentUserPiece && isLatestSubmission) {
             path.classList.add(CONFIG.RENDERING.animationClass);
           }
           
           this.quiltSVG.appendChild(path);
         });
       }

       renderBlock(block, index) {
         if (!block || !block.patches || block.patches.length === 0) return;
         
         const blockJitterX = (Math.random() - 0.5) * 8;
         const blockJitterY = (Math.random() - 0.5) * 8;
         const jitteredBlockX = block.x + blockJitterX;
         const jitteredBlockY = block.y + blockJitterY;
         
         if (block.patches.length >= 2) {
           const patch1 = block.patches[0];
           const patch2 = block.patches[1];
           
           let positionedPatch1, positionedPatch2;
           
           if (block.width > block.height) {
             // Horizontal join
             const patch1Ratio = patch1.width / (patch1.width + patch2.width);
             const patch2Ratio = patch2.width / (patch1.width + patch2.width);
             const joinJitter = (Math.random() - 0.5) * 6;
             
             positionedPatch1 = {
               ...patch1,
               x: jitteredBlockX,
               y: jitteredBlockY,
               width: (block.width * patch1Ratio) + joinJitter,
               height: block.height + (Math.random() - 0.5) * 4
             };
             positionedPatch2 = {
               ...patch2,
               x: jitteredBlockX + (block.width * patch1Ratio) + joinJitter,
               y: jitteredBlockY,
               width: (block.width * patch2Ratio) - joinJitter,
               height: block.height + (Math.random() - 0.5) * 4
             };
           } else {
             // Vertical join
             const patch1Ratio = patch1.height / (patch1.height + patch2.height);
             const patch2Ratio = patch2.height / (patch1.height + patch2.height);
             const joinJitter = (Math.random() - 0.5) * 6;
             
             positionedPatch1 = {
               ...patch1,
               x: jitteredBlockX,
               y: jitteredBlockY,
               width: block.width + (Math.random() - 0.5) * 4,
               height: (block.height * patch1Ratio) + joinJitter
             };
             positionedPatch2 = {
               ...patch2,
               x: jitteredBlockX,
               y: jitteredBlockY + (block.height * patch1Ratio) + joinJitter,
               width: block.width + (Math.random() - 0.5) * 4,
               height: (block.height * patch2Ratio) - joinJitter
             };
           }
           
           [positionedPatch1, positionedPatch2].forEach((patch, patchIndex) => {
             this.renderPatch(patch);
           });
         }
       }

       createOrganicPath(item) {
         if (!item || typeof item.x === 'undefined' || typeof item.y === 'undefined' || 
             typeof item.width === 'undefined' || typeof item.height === 'undefined') {
           this.logger.error('Invalid item for createOrganicPath:', item);
           return '';
         }
         
         const variation = CONFIG.QUILT.organicVariation;
         const x1 = item.x + (Math.random() - 0.5) * variation;
         const y1 = item.y + (Math.random() - 0.5) * variation;
         const x2 = item.x + item.width + (Math.random() - 0.5) * variation;
         const y2 = item.y + (Math.random() - 0.5) * variation;
         const x3 = item.x + item.width + (Math.random() - 0.5) * variation;
         const y3 = item.y + item.height + (Math.random() - 0.5) * variation;
         const x4 = item.x + (Math.random() - 0.5) * variation;
         const y4 = item.y + item.height + (Math.random() - 0.5) * variation;
         
         return `M ${x1},${y1} L ${x2},${y2} L ${x3},${y3} L ${x4},${y4} Z`;
       }

       updateUI(state) {
         // Update phase indicator and user counter
         // This will be handled by the main app
       }

                getTotalElements(state) {
           return (state.pieces ? state.pieces.length : 0) + 
                  (state.patches ? state.patches.length : 0) + 
                  (state.blocks ? state.blocks.length : 0) + 
                  (state.unmatchedPieces ? state.unmatchedPieces.length : 0) + 
                  (state.unmatchedPatches ? state.unmatchedPatches.length : 0);
         }
       }

       // ===== MAIN APPLICATION =====
       class OurDailyApp {
         constructor() {
           // Initialize services
           this.logger = new Logger(CONFIG.APP.debugMode);
           this.uiService = new UIService(this.logger);
           this.errorHandler = new ErrorHandler(this.uiService, this.logger);
           this.state = new QuiltState(this.logger);
           this.dataService = new QuiltDataService(this.logger, this.errorHandler);
           this.quoteService = new QuoteService();
           this.positioningService = new PositioningService(this.logger);
           this.renderingService = new RenderingService(this.logger, this.errorHandler);
           
           // Color picker state
           this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
           this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
           this.colorHasBeenSelected = false;
           
           // Share state
           this.lastAddedForShare = null;
           
           this.logger.log('OurDailyApp initialized');
         }

         async initialize() {
           try {
             this.uiService.showLoading(true);
             
             await this.dataService.initialize();
             this.setupEventListeners();
             this.initializeUI();
             await this.loadQuilt();
             
             this.renderingService.initialize();
             
             // Force initial render
             setTimeout(() => {
               this.renderingService.renderQuilt(this.state);
               this.updateUI();
             }, 100);
             
             this.uiService.showLoading(false);
             this.logger.log('App initialization complete');
           } catch (error) {
             this.errorHandler.handleError(error, 'App initialization');
             this.uiService.showLoading(false);
           }
         }

         setupEventListeners() {
           // Navigation
           document.querySelectorAll(".btn[data-next]").forEach(btn => {
             btn.addEventListener("click", e => {
               e.preventDefault();
               const targetId = btn.getAttribute("data-next");
               if (targetId) this.uiService.showScreen(targetId);
             });
           });

           // Add color button
           const addColorBtn = document.getElementById('addColorBtn');
           if (addColorBtn) {
             addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
           }

           // Share button
           const shareBtnCompleted = document.getElementById('shareBtnCompleted');
           if (shareBtnCompleted) {
             shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
           }

           // Test buttons
           const testAddBlock = document.getElementById('testAddBlock');
           if (testAddBlock) {
             testAddBlock.addEventListener('click', this.handleTestAddBlock.bind(this));
           }

           const showMyPieceBtn = document.getElementById('showMyPieceBtn');
           if (showMyPieceBtn) {
             showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
           }

           const testDifferentUserBtn = document.getElementById('testDifferentUserBtn');
           if (testDifferentUserBtn) {
             testDifferentUserBtn.addEventListener('click', this.handleTestDifferentUser.bind(this));
           }

           // Color picker
           this.setupColorPicker();
           
           // Keyboard navigation
           document.addEventListener('keydown', this.handleKeyDown.bind(this));
         }

         initializeUI() {
           const dateText = document.getElementById("date-text");
           if (dateText) {
             dateText.textContent = Utils.formatDate();
           }
           this.quoteService.displayQuote();
           this.uiService.showScreen('screen-portal');
         }

         async loadQuilt() {
           try {
             this.uiService.showLoading(true);
             const blocks = await this.dataService.loadQuilt();
             this.state.blocks = blocks;
             
             if (this.renderingService.isInitialized) {
               this.renderingService.renderQuilt(this.state);
             }
             this.uiService.showLoading(false);
           } catch (error) {
             this.errorHandler.handleError(error, 'loadQuilt');
             this.uiService.showLoading(false);
             this.state.blocks = [];
             if (this.renderingService.isInitialized) {
               this.renderingService.renderQuilt(this.state);
             }
           }
         }

         async saveQuilt() {
           try {
             await this.dataService.saveQuilt();
           } catch (error) {
             this.errorHandler.handleError(error, 'saveQuilt');
             throw error;
           }
         }

         addPieceToQuilt(newColor) {
           try {
             this.logger.log(`ðŸ”„ Starting addPieceToQuilt with color: ${newColor}`);
             
             this.errorHandler.validateColor(newColor);
             this.logger.log('âœ… Color validation passed');
             
             this.state.incrementSubmission();
             this.logger.log(`ðŸ“Š Submission count incremented to: ${this.state.submissionCount}`);
             
             // Determine pieces to create based on submission count
             const piecesToCreate = CONFIG.PHASES.collection.piecesPerSubmission[this.state.submissionCount - 1] || 1;
             this.logger.log(`ðŸŽ¯ Creating ${piecesToCreate} pieces for submission ${this.state.submissionCount}`);
             
             // Create pieces for this submission
             const startIndex = this.state.pieces.length;
             this.logger.log(`ðŸ“ Starting piece creation at index: ${startIndex}`);
             
             for (let i = 0; i < piecesToCreate; i++) {
               const currentIndex = startIndex + i;
               this.logger.log(`ðŸ”§ Creating piece ${i + 1}/${piecesToCreate} at index ${currentIndex}`);
               
               const piece = this.positioningService.createPiece(
                 newColor, 
                 currentIndex, 
                 this.state.currentUserId, 
                 this.state.submissionCount
               );
               
               this.logger.log(`âœ… Piece created:`, piece);
               this.state.addPiece(piece);
             }
             
             this.logger.log(`ðŸ“ˆ Total pieces after addition: ${this.state.pieces.length}`);
             
             // Handle phase transitions
             this.logger.log('ðŸ”„ Checking for phase transitions');
             this.handlePhaseTransitions();
             
             this.state.lastAddedIndex = this.state.blocks.length - 1;
             this.logger.log(`ðŸŽ¯ Last added index set to: ${this.state.lastAddedIndex}`);
             
             this.logger.log('âœ… addPieceToQuilt completed successfully');
             return true;
             
           } catch (error) {
             this.logger.error(`âŒ Error in addPieceToQuilt: ${error.message}`);
             this.errorHandler.handleError(error, 'addPieceToQuilt');
             return false;
           }
         }

         handlePhaseTransitions() {
           const submissionCount = this.state.submissionCount;
           this.logger.log(`ðŸ”„ Checking phase transitions at submission ${submissionCount}`);
           
           if (submissionCount === CONFIG.PHASES.patchFormation.triggerSubmission) {
             this.logger.log('ðŸ”„ Transitioning to patch-formation phase');
             this.state.setPhase('block-formation');
             
             // Form patches from all pieces (24 pieces â†’ 12 patches)
             const allPatches = this.formPatchesFromPieces(this.state.allPieces);
             this.logger.log(`ðŸ“Š Formed ${allPatches.length} patches from all pieces`);
             
             // Form blocks from patches (12 patches â†’ 6 blocks)
             const blockFormationResult = this.formBlocksFromPatches(allPatches);
             this.state.blocks = blockFormationResult.blocks;
             this.state.unmatchedPatches = blockFormationResult.unmatchedPatches;
             this.state.originalPatches = [...allPatches];
             
             // Clear pieces and patches, show blocks
             this.state.pieces = [];
             this.state.patches = [];
             this.state.allPieces = [];
             
             this.logger.log(`ðŸ“Š User 6 sees ${this.state.blocks.length} blocks`);
             this.uiService.showToast('Block formation phase activated!');
                       } else if (submissionCount === CONFIG.PHASES.blockFormation.triggerSubmission && submissionCount > 6) {
              this.logger.log('ðŸ”„ User 7+ adding piece to existing blocks');
              
              // Create the new piece
              const newPiece = this.createPiece();
              this.state.pieces = [newPiece];
              
              // Position the piece to attach to the existing quilt
              this.positioningService.positionPieceWithQuilt(newPiece, this.state.blocks);
              
              this.logger.log(`ðŸ“Š User ${submissionCount} adds piece to existing ${this.state.blocks.length} blocks`);
              this.uiService.showToast(`Your piece added to the quilt!`);
           } else if (submissionCount === CONFIG.PHASES.quiltFormation.triggerSubmission) {
             this.logger.log('ðŸ”„ Transitioning to quilt-formation phase');
             this.state.setPhase('quilt-formation');
             const allPatches = this.formPatchesFromPieces(this.state.allPieces);
             this.logger.log(`ðŸ“Š Processing ${allPatches.length} patches for quilt formation`);
             const allBlocks = this.formBlocksFromPatches(allPatches);
             this.logger.log(`ðŸ“Š Processing ${allBlocks.blocks.length} blocks for quilt formation`);
             this.state.quilt = this.formQuiltFromBlocks(allBlocks);
             this.state.blocks = [];
             this.state.patches = [];
             this.state.pieces = [];
             this.state.unmatchedPieces = [];
             this.state.allPieces = [];
             this.logger.log('ðŸ“Š Quilt formation completed');
             this.uiService.showToast('Quilt formation phase activated! All pieces included!');
           } else {
             this.logger.log(`ðŸ“Š No phase transition needed at submission ${submissionCount}`);
           }
         }

         formPatchesFromPieces(specificPieces = null) {
           const pieces = specificPieces ? [...specificPieces] : [...this.state.pieces];
           const patches = [];
           const unmatchedPieces = [];
           
           this.logger.log(`formPatchesFromPieces: Starting with ${pieces.length} pieces`);
           
           const totalPieces = pieces.length;
           const targetPatches = Math.floor(totalPieces / 2); // Use all pieces to create patches
           const maxMatches = targetPatches;
           
           this.logger.log(`Target: ${targetPatches} patches, using all ${totalPieces} pieces`);
           
           let matchesMade = 0;
           
           while (pieces.length >= 2 && matchesMade < maxMatches) {
             const piece1 = pieces.shift();
             const bestMatch = this.findBestMatch(pieces, piece1);
             
             if (matchesMade < maxMatches) {
               const piece2 = bestMatch ? bestMatch.item : pieces[0];
               if (!bestMatch) {
                 pieces.splice(0, 1);
               } else {
                 pieces.splice(pieces.indexOf(piece2), 1);
               }
               
               const combined = this.combineItems(piece1, piece2, bestMatch ? bestMatch.joinType : 'horizontal');
               const patch = this.createPatch([piece1, piece2]);
               if (patch) {
                 patch.x = combined.x;
                 patch.y = combined.y;
                 patch.width = combined.width;
                 patch.height = combined.height;
                 patches.push(patch);
               }
               matchesMade++;
             } else {
               unmatchedPieces.push(piece1);
             }
           }
           
           while (pieces.length > 0) {
             unmatchedPieces.push(pieces.shift());
           }
           
           this.state.unmatchedPieces = unmatchedPieces;
           this.logger.log(`formPatchesFromPieces: Created ${patches.length} patches and ${unmatchedPieces.length} unmatched pieces`);
           
           this.positioningService.positionElementsInGrid(patches, 0, 'patches');
           
           return patches;
         }

         formBlocksFromPatches(specificPatches = null) {
           const patches = specificPatches ? [...specificPatches] : [...this.state.patches];
           const blocks = [];
           const unmatchedPatches = [];
           
           this.logger.log(`Starting block formation with ${patches.length} patches`);
           
           while (patches.length >= 2) {
             const patch1 = patches.shift();
             
             if (!patch1) {
               this.logger.warn('Skipping null patch1');
               continue;
             }
             
             const bestMatch = this.findBestMatch(patches, patch1);
             
             if (bestMatch && bestMatch.score < CONFIG.PHASES.blockFormation.edgeTolerance) {
               const patch2 = bestMatch.item;
               patches.splice(patches.indexOf(patch2), 1);
               
               this.logger.log(`Found match: patch ${patch1.id || 'unknown'} + patch ${patch2.id || 'unknown'} (score: ${bestMatch.score.toFixed(3)})`);
               
               let resizedPatch1 = { ...patch1 };
               let resizedPatch2 = { ...patch2 };
               
               if (bestMatch.joinType === 'horizontal') {
                 const targetHeight = Math.max(patch1.height, patch2.height);
                 if (patch1.height !== targetHeight) resizedPatch1.height = targetHeight;
                 if (patch2.height !== targetHeight) resizedPatch2.height = targetHeight;
               } else {
                 const targetWidth = Math.max(patch1.width, patch2.width);
                 if (patch1.width !== targetWidth) resizedPatch1.width = targetWidth;
                 if (patch2.width !== targetWidth) resizedPatch2.width = targetWidth;
               }
               
               const combined = this.combineItems(resizedPatch1, resizedPatch2, bestMatch.joinType);
               const block = this.createBlock([resizedPatch1, resizedPatch2]);
               if (block) {
                 block.x = combined.x;
                 block.y = combined.y;
                 block.width = combined.width;
                 block.height = combined.height;
                 blocks.push(block);
                 this.logger.log(`Created block ${blocks.length} from 2 patches`);
               }
             } else {
               this.logger.log(`No good match found for patch ${patch1.id || 'unknown'} (best score: ${bestMatch ? bestMatch.score.toFixed(3) : 'none'})`);
               unmatchedPatches.push(patch1);
             }
           }
           
           if (patches.length === 1) {
             this.logger.log(`Adding remaining single patch to unmatched`);
             unmatchedPatches.push(patches[0]);
           }
           
           this.logger.log(`Block formation summary: ${blocks.length} blocks created, ${unmatchedPatches.length} unmatched patches`);
           
           this.positioningService.positionElementsInGrid(blocks, 0, 'blocks');
           
           return {
             blocks: blocks,
             unmatchedPatches: unmatchedPatches
           };
         }



         formQuiltFromBlocks(blocks) {
           const allBlocks = [...blocks];
           const quiltBlocks = [];
           const unmatchedBlocks = [];
           
           while (allBlocks.length >= 2) {
             const block1 = allBlocks.shift();
             
             if (!block1) {
               this.logger.warn('Skipping null block1');
               continue;
             }
             
             const bestMatch = this.findBestMatch(allBlocks, block1);
             
             if (bestMatch && bestMatch.score < CONFIG.PHASES.blockFormation.edgeTolerance) {
               const block2 = bestMatch.item;
               allBlocks.splice(allBlocks.indexOf(block2), 1);
               
               let resizedBlock1 = { ...block1 };
               let resizedBlock2 = { ...block2 };
               
               if (bestMatch.joinType === 'horizontal') {
                 const targetHeight = Math.max(block1.height, block2.height);
                 if (block1.height !== targetHeight) resizedBlock1.height = targetHeight;
                 if (block2.height !== targetHeight) resizedBlock2.height = targetHeight;
               } else {
                 const targetWidth = Math.max(block1.width, block2.width);
                 if (block1.width !== targetWidth) resizedBlock1.width = targetWidth;
                 if (block2.width !== targetWidth) resizedBlock2.width = targetWidth;
               }
               
               const combined = this.combineItems(resizedBlock1, resizedBlock2, bestMatch.joinType);
               const quiltBlock = this.createQuiltBlock([resizedBlock1, resizedBlock2]);
               if (quiltBlock) {
                 quiltBlock.x = combined.x;
                 quiltBlock.y = combined.y;
                 quiltBlock.width = combined.width;
                 quiltBlock.height = combined.height;
                 quiltBlocks.push(quiltBlock);
               }
             } else {
               unmatchedBlocks.push(block1);
             }
           }
           
           if (allBlocks.length === 1) {
             unmatchedBlocks.push(allBlocks[0]);
           }
           
           unmatchedBlocks.forEach(block => {
             if (block) {
               const singleQuiltBlock = this.createQuiltBlock([block]);
               if (singleQuiltBlock) {
                 quiltBlocks.push(singleQuiltBlock);
               }
             }
           });
           
           this.positionQuiltBlocks(quiltBlocks);
           
           return {
             id: `quilt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             type: 'quilt',
             blocks: quiltBlocks,
             width: 600,
             height: 600
           };
         }

         findBestMatch(items, targetItem) {
           let bestMatch = null;
           let bestScore = Infinity;
           const tolerance = CONFIG.PHASES.patchFormation.edgeTolerance;
           
           this.logger.log(`Finding best match for item ${targetItem.id || 'unknown'} among ${items.length} candidates`);
           
           for (let i = 0; i < items.length; i++) {
             const item = items[i];
             if (item === targetItem) continue;
             
             const targetEdges = targetItem.edges;
             const itemEdges = item.edges;
             
             const horizontalEdgeScore = this.calculateEdgeScore(targetEdges.right, itemEdges.left);
             const verticalEdgeScore = this.calculateEdgeScore(targetEdges.bottom, itemEdges.top);
             const valueContrastScore = this.calculateValueContrastScore(targetItem.color, item.color);
             const sameColorPenalty = targetItem.color === item.color ? 1.0 : 0;
             
             const horizontalScore = horizontalEdgeScore - valueContrastScore * CONFIG.PHASES.patchFormation.valueContrastWeight + sameColorPenalty;
             const verticalScore = verticalEdgeScore - valueContrastScore * CONFIG.PHASES.patchFormation.valueContrastWeight + sameColorPenalty;
             
             const score = Math.min(horizontalScore, verticalScore);
             const sameColor = targetItem.color === item.color;
             
             this.logger.log(`  Candidate ${i}: edge scores (H:${horizontalEdgeScore.toFixed(3)}, V:${verticalEdgeScore.toFixed(3)}), contrast:${valueContrastScore.toFixed(3)}, sameColor:${sameColor}, final score:${score.toFixed(3)}`);
             
             if (score < bestScore) {
               bestScore = score;
               bestMatch = {
                 item: item,
                 score: score,
                 joinType: score === horizontalScore ? 'horizontal' : 'vertical',
                 edgeScore: Math.min(horizontalEdgeScore, verticalEdgeScore),
                 valueContrastScore: valueContrastScore
               };
               this.logger.log(`  New best match found with score ${score.toFixed(3)}`);
             }
           }
           
           this.logger.log(`Best match score: ${bestMatch ? bestMatch.score.toFixed(3) : 'none'}`);
           return bestMatch;
         }

         calculateEdgeScore(length1, length2) {
           const difference = Math.abs(length1 - length2);
           const averageLength = (length1 + length2) / 2;
           return difference / averageLength;
         }

         calculateValueContrastScore(color1, color2) {
           const hsl1 = Utils.hexToHsl(color1);
           const hsl2 = Utils.hexToHsl(color2);
           const valueDifference = Math.abs(hsl1.l - hsl2.l);
           const normalizedContrast = valueDifference / 100;
           const contrastScore = Math.pow(normalizedContrast, 0.7);
           return contrastScore;
         }

         combineItems(item1, item2, joinType) {
           let combinedWidth, combinedHeight, combinedX, combinedY;
           
           if (joinType === 'horizontal') {
             const targetLength = (item1.edges.right + item2.edges.left) / 2;
             const adjustedWidth1 = item1.width;
             const adjustedWidth2 = item2.width;
             
             combinedWidth = item1.width + adjustedWidth2;
             combinedHeight = Math.max(item1.height, item2.height);
             combinedX = item1.x;
             combinedY = Math.min(item1.y, item2.y);
           } else {
             const targetLength = (item1.edges.bottom + item2.edges.top) / 2;
             const adjustedHeight1 = item1.height;
             const adjustedHeight2 = item2.height;
             
             combinedWidth = Math.max(item1.width, item2.width);
             combinedHeight = item1.height + adjustedHeight2;
             combinedX = Math.min(item1.x, item2.x);
             combinedY = item1.y;
           }
           
           return {
             width: combinedWidth,
             height: combinedHeight,
             x: combinedX,
             y: combinedY
           };
         }

         createPatch(pieces) {
           if (pieces.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           pieces.forEach(piece => {
             minX = Math.min(minX, piece.x);
             minY = Math.min(minY, piece.y);
             maxX = Math.max(maxX, piece.x + piece.width);
             maxY = Math.max(maxY, piece.y + piece.height);
           });
           
           return {
             id: `patch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             color: pieces[0].color,
             type: 'patch',
             pieces: pieces,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         createBlock(patches) {
           if (patches.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           patches.forEach(patch => {
             minX = Math.min(minX, patch.x);
             minY = Math.min(minY, patch.y);
             maxX = Math.max(maxX, patch.x + patch.width);
             maxY = Math.max(maxY, patch.y + patch.height);
           });
           
           return {
             id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             color: patches[0].color,
             type: 'block',
             patches: patches,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         createQuiltBlock(blocks) {
           if (blocks.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           blocks.forEach(block => {
             minX = Math.min(minX, block.x);
             minY = Math.min(minY, block.y);
             maxX = Math.max(maxX, block.x + block.width);
             maxY = Math.max(maxY, block.y + block.height);
           });
           
           return {
             id: `quilt_block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             type: 'quilt_block',
             blocks: blocks,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         positionQuiltBlocks(quiltBlocks) {
           const quiltSize = 600;
           const padding = 20;
           const availableSize = quiltSize - 2 * padding;
           
           this.logger.log(`Positioning ${quiltBlocks.length} quilt blocks in touching layout`);
           
           if (quiltBlocks.length === 0) return;
           
           quiltBlocks[0].x = padding;
           quiltBlocks[0].y = padding;
           this.logger.log(`Quilt block 0 positioned at (${quiltBlocks[0].x}, ${quiltBlocks[0].y})`);
           
           for (let i = 1; i < quiltBlocks.length; i++) {
             const block = quiltBlocks[i];
             
             if (!block || typeof block.width === 'undefined' || typeof block.height === 'undefined') {
               this.logger.warn(`Skipping invalid quilt block at index ${i}:`, block);
               continue;
             }
             
             let bestX = padding;
             let bestY = padding;
             let bestScore = Infinity;
             
             for (let attempt = 0; attempt < 100; attempt++) {
               const testX = padding + Math.random() * (availableSize - block.width);
               const testY = padding + Math.random() * (availableSize - block.height);
               
               let touchesExisting = false;
               let minDistance = Infinity;
               
               for (let j = 0; j < i; j++) {
                 const existingBlock = quiltBlocks[j];
                 if (!existingBlock) continue;
                 
                 const horizontalOverlap = !(testX + block.width <= existingBlock.x || 
                                          testX >= existingBlock.x + existingBlock.width);
                 const verticalOverlap = !(testY + block.height <= existingBlock.y || 
                                         testY >= existingBlock.y + existingBlock.height);
                 
                 if (horizontalOverlap && verticalOverlap) {
                   touchesExisting = false;
                   break;
                 }
                 
                 const horizontalTouch = (testX + block.width === existingBlock.x) || 
                                      (existingBlock.x + existingBlock.width === testX);
                 const verticalTouch = (testY + block.height === existingBlock.y) || 
                                    (existingBlock.y + existingBlock.height === testY);
                 
                 if (horizontalTouch && verticalTouch) {
                   touchesExisting = true;
                 }
                 
                 const distance = Math.sqrt(
                   Math.pow(testX - existingBlock.x, 2) + 
                   Math.pow(testY - existingBlock.y, 2)
                 );
                 if (distance < minDistance) {
                   minDistance = distance;
                 }
               }
               
               const score = touchesExisting ? -minDistance : minDistance + 1000;
               
               if (score < bestScore) {
                 bestScore = score;
                 bestX = testX;
                 bestY = testY;
               }
             }
             
             block.x = bestX;
             block.y = bestY;
             this.logger.log(`Quilt block ${i} positioned at (${block.x}, ${block.y})`);
           }
         }

         updateUI() {
           this.uiService.updatePhaseIndicator(this.state.currentPhase, this.state.submissionCount);
           this.uiService.updateUserCounter(this.state.submissionCount, this.state.currentPhase, this.state.getElementCounts());
         }

         async handleAddColor() {
           try {
             this.logger.log('ðŸŽ¨ Starting color addition process');
             this.logger.log(`Selected hue: ${this.selectedHue}`);
             this.logger.log(`Selected lightness: ${this.selectedLightness}`);
             this.logger.log(`Config saturation: ${CONFIG.COLOR_PICKER.saturation}`);
             
             const selectedColor = Utils.hslToHex(this.selectedHue, CONFIG.COLOR_PICKER.saturation, this.selectedLightness);
             
             this.logger.log(`Converted color: ${selectedColor}`);
             
             if (!selectedColor) {
               this.logger.warn('No color selected');
               this.uiService.showToast('Please select a color first');
               return;
             }

             // Validate the color
             if (!Utils.validateHexColor(selectedColor)) {
               this.logger.error(`Invalid color generated: ${selectedColor}`);
               this.uiService.showToast('Invalid color generated. Please try again.');
               return;
             }

             this.logger.log(`Adding piece with color: ${selectedColor}`);
             const success = this.addPieceToQuilt(selectedColor);
             
             if (success) {
               this.logger.log('Piece added successfully');
               this.lastAddedForShare = this.state.lastAddedIndex;
               
               this.logger.log('Saving quilt data');
               await this.saveQuilt();
               
               this.logger.log('Rendering updated quilt');
               this.logger.log('About to call renderingService.renderQuilt');
               this.renderingService.renderQuilt(this.state);
               this.logger.log('renderQuilt call completed');
               this.updateUI();
               this.uiService.showScreen('screen-quilt');
             } else {
               this.logger.warn('Failed to add piece to quilt');
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'handleAddColor');
             this.uiService.showToast('Failed to add color. Please try again.');
           }
         }

         async handleTestAddBlock() {
           try {
             const randomHue = Math.floor(Math.random() * 360);
             const randomSaturation = CONFIG.COLOR_PICKER.saturation;
             const randomLightness = 35 + Math.floor(Math.random() * 56);
             
             const warmHue = (randomHue + 25) % 360;
             const warmSaturation = Math.min(randomSaturation + 5, 100);
             const randomColor = Utils.hslToHex(warmHue, warmSaturation, randomLightness);
             
             const success = this.addPieceToQuilt(randomColor);
             
             this.updateUI();
             
             if (success) {
               this.lastAddedForShare = this.state.lastAddedIndex;
               await this.saveQuilt();
               this.logger.log(`About to call renderingService.renderQuilt with state:`, this.state);
               this.renderingService.renderQuilt(this.state);
               
               let message;
               if (this.state.currentPhase === 'collection') {
                 message = `Added ${CONFIG.PHASES.collection.piecesPerSubmission[this.state.submissionCount - 1] || 1} pieces! (${this.state.pieces.length} total pieces)`;
               } else if (this.state.currentPhase === 'patch-formation') {
                 message = `Added pieces! (${this.state.patches.length} patches formed)`;
               } else if (this.state.currentPhase === 'block-formation') {
                 message = `Added pieces! (${this.state.blocks.length} blocks formed)`;
               } else if (this.state.currentPhase === 'quilt-formation') {
                 message = `Added pieces! Final quilt formed!`;
               } else {
                 message = `Added pieces!`;
               }
               this.uiService.showToast(message);
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'handleTestAddBlock');
             this.uiService.showToast('Test add failed.');
           }
         }

         handleShowMyPiece() {
           try {
             this.state.userPiecesHighlighted = !this.state.userPiecesHighlighted;
             
             const userPieces = this.state.pieces.filter(piece => piece.userId === this.state.currentUserId);
             const userPatches = this.state.patches.filter(patch => 
               patch.pieces && patch.pieces.some(piece => piece.userId === this.state.currentUserId)
             );
             const userBlocks = this.state.blocks.filter(block => 
               block.patches && block.patches.some(patch => 
                 patch.pieces && patch.pieces.some(piece => piece.userId === this.state.currentUserId)
               )
             );
             
             const totalUserPieces = userPieces.length + userPatches.length + userBlocks.length;
             
             if (this.state.userPiecesHighlighted) {
               if (totalUserPieces > 0) {
                 this.uiService.showToast(`Found ${totalUserPieces} of your pieces! âœ¨`);
               } else {
                 this.uiService.showToast("You haven't added any pieces yet. Try adding your first color!");
               }
             } else {
               this.uiService.showToast('Highlighting turned off');
             }
             
             this.renderingService.renderQuilt(this.state);
             
           } catch (error) {
             this.errorHandler.handleError(error, 'handleShowMyPiece');
             this.uiService.showToast('Failed to highlight your pieces. Please try again.');
           }
         }

         handleTestDifferentUser() {
           try {
             const originalUserId = this.state.currentUserId;
             this.state.currentUserId = `test_user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
             
             this.uiService.showToast(`Now simulating user: ${this.state.currentUserId.substring(0, 20)}...`);
             
             const randomColor = Utils.hslToHex(Math.floor(Math.random() * 360), 65, 50);
             const success = this.addPieceToQuilt(randomColor);
             
             this.updateUI();
             
             if (success) {
               this.lastAddedForShare = this.state.lastAddedIndex;
               this.renderingService.renderQuilt(this.state);
               this.uiService.showToast(`Added piece for different user! Now try "SHOW ME MY PIECE"`);
             }
             
             setTimeout(() => {
               this.state.currentUserId = originalUserId;
               this.uiService.showToast('Switched back to original user');
             }, 5000);
             
           } catch (error) {
             this.errorHandler.handleError(error, 'handleTestDifferentUser');
             this.uiService.showToast('Failed to simulate different user.');
           }
         }

         async handleShare() {
           try {
             const shareBtn = document.getElementById('shareBtnCompleted');
             if (shareBtn) shareBtn.disabled = true;
             
             this.uiService.showToast("Preparing flyer...");
             await this.shareFlow();
             
             if (shareBtn) shareBtn.disabled = false;
           } catch (error) {
             this.errorHandler.handleError(error, 'handleShare');
             this.uiService.showToast('Share failed. Saving instead.');
             
             const shareBtn = document.getElementById('shareBtnCompleted');
             if (shareBtn) shareBtn.disabled = false;
           }
         }

         async shareFlow() {
           // Share flow implementation would go here
           // This is a simplified version - the full implementation would be quite long
           this.uiService.showToast("Share functionality would be implemented here");
         }

         setupColorPicker() {
           const colorWheel = document.getElementById('colorWheelCanvas');
           const indicator = document.getElementById('colorIndicator');
           const valueSlider = document.getElementById('valueSlider');

           if (!colorWheel || !indicator || !valueSlider) return;
           
           const previewElement = document.getElementById('selectedColorPreview');
           if (previewElement) {
             previewElement.remove();
           }

           this.drawColorWheel();
           this.updatePreview();
           
           valueSlider.value = this.selectedLightness;
           
           setTimeout(() => {
             valueSlider.value = this.selectedLightness;
           }, 100);
           
           const rect = colorWheel.getBoundingClientRect();
           const centerX = rect.width / 2;
           const centerY = rect.height / 2;
           const radius = rect.width / 2;
           const angleRad = (this.selectedHue - 90) * Math.PI / 180;
           const x = centerX + radius * Math.cos(angleRad);
           const y = centerY + radius * Math.sin(angleRad);
           
           if (indicator) {
             const container = colorWheel.parentElement;
             const containerRect = container.getBoundingClientRect();
             const relativeX = x + rect.left - containerRect.left;
             const relativeY = y + rect.top - containerRect.top;
             indicator.style.left = `${relativeX}px`;
             indicator.style.top = `${relativeY}px`;
           }

           const debouncedSetHue = Utils.debounce(this.setHueFromCoords.bind(this), 16);
           
           colorWheel.addEventListener('click', e => {
             const rect = colorWheel.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
             const radius = rect.width / 2;
             
             if (distance <= radius) {
               this.setHueFromCoords(x, y);
             }
           });

           colorWheel.addEventListener('mousedown', e => {
             const rect = colorWheel.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
             const radius = rect.width / 2;
             
             if (distance <= radius) {
               this.setHueFromCoords(x, y);
             }
           });

           document.addEventListener('mousemove', e => {
             if (e.buttons === 1) {
               const rect = colorWheel.getBoundingClientRect();
               const x = e.clientX - rect.left;
               const y = e.clientY - rect.top;
               
               const centerX = rect.width / 2;
               const centerY = rect.height / 2;
               const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
               const radius = rect.width / 2;
               
               if (distance <= radius) {
                 debouncedSetHue(x, y);
               }
             }
           });

           valueSlider.addEventListener('input', () => {
             this.selectedLightness = Number(valueSlider.value);
             this.updatePreview();
           });
         }

         drawColorWheel() {
           // CSS-based color wheel doesn't need drawing
         }

         updatePreview() {
           const valueSlider = document.getElementById('valueSlider');
           
           const hslColor = `hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, ${this.selectedLightness}%)`;
           const hexColor = Utils.hslToHex(this.selectedHue, CONFIG.COLOR_PICKER.saturation, this.selectedLightness);
           
           const colorScreen = document.getElementById('screen-color');
           if (colorScreen && this.colorHasBeenSelected) {
             colorScreen.style.backgroundColor = hexColor;
           }
           
           if (valueSlider) {
             valueSlider.style.background = `linear-gradient(to right,
               hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 20%), 
               hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 90%))`;
           }
         }

         setHueFromCoords(x, y) {
           const colorWheel = document.getElementById('colorWheelCanvas');
           const indicator = document.getElementById('colorIndicator');
           const rect = colorWheel.getBoundingClientRect();
           const centerX = rect.width / 2;
           const centerY = rect.height / 2;
           
           const dx = x - centerX;
           const dy = y - centerY;
           const distance = Math.sqrt(dx * dx + dy * dy);
           const radius = rect.width / 2;

           if (distance > radius) {
             const clampedDistance = radius;
             const clampedX = centerX + (dx / distance) * clampedDistance;
             const clampedY = centerY + (dy / distance) * clampedDistance;
             
             let angle = Math.atan2(dy, dx) * 180 / Math.PI;
             if (angle < 0) angle += 360;
             this.selectedHue = Math.round((angle + 90) % 360);
             
             if (indicator) {
               const container = colorWheel.parentElement;
               const containerRect = container.getBoundingClientRect();
               const relativeX = clampedX + rect.left - containerRect.left;
               const relativeY = clampedY + rect.top - containerRect.top;
               indicator.style.left = `${relativeX}px`;
               indicator.style.top = `${relativeY}px`;
             }
           } else {
             let angle = Math.atan2(dy, dx) * 180 / Math.PI;
             if (angle < 0) angle += 360;
             
             this.selectedHue = Math.round((angle + 90) % 360);
             
             if (indicator) {
               const container = colorWheel.parentElement;
               const containerRect = container.getBoundingClientRect();
               const relativeX = x + rect.left - containerRect.left;
               const relativeY = y + rect.top - containerRect.top;
               indicator.style.left = `${relativeX}px`;
               indicator.style.top = `${relativeY}px`;
             }
           }
           
           this.colorHasBeenSelected = true;
           this.updatePreview();
         }

         handleKeyDown(event) {
           if (event.key === 'Escape') {
             const currentScreen = document.querySelector('.screen.active');
             if (currentScreen) {
               const currentId = currentScreen.id;
               if (currentId === 'screen-quote') {
                 this.uiService.showScreen('screen-portal');
               } else if (currentId === 'screen-color') {
                 this.uiService.showScreen('screen-quote');
               } else if (currentId === 'screen-quilt') {
                 this.uiService.showScreen('screen-color');
               }
             }
           }
         }
       }

       // Initialize the application
       document.addEventListener('DOMContentLoaded', async () => {
         const app = new OurDailyApp();
         await app.initialize();
       });
     </script>
   </body>
   </html> 