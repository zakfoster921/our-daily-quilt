<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Quilt</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* ===== SCREENS ===== */
    .screen {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 3rem 0 10px 0;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 900;
      font-size: clamp(2rem, 5vw, 3rem);
      margin-bottom: 0.1rem;
      letter-spacing: -0.02em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.2rem, 3vw, 1.6rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.5rem;
      margin: 3rem auto 2rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 150px;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(1rem, 2.5vw, 1.2rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem 0;
    }
    
    #colorWheelCanvas {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      /* Fallback for browsers that don't support conic-gradient */
      background: hsl(0, 95%, 55%);
      /* Modern browsers with conic-gradient support */
      background: conic-gradient(
        hsl(0, 100%, 55%),
        hsl(30, 100%, 55%),
        hsl(60, 100%, 55%),
        hsl(90, 100%, 55%),
        hsl(120, 100%, 55%),
        hsl(150, 100%, 55%),
        hsl(180, 100%, 55%),
        hsl(210, 100%, 55%),
        hsl(240, 100%, 55%),
        hsl(270, 100%, 55%),
        hsl(300, 100%, 55%),
        hsl(330, 100%, 55%),
        hsl(360, 100%, 55%)
      );
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      /* Add a subtle overlay to tone down the visual intensity */
      position: relative;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
  

    
    #colorWheelCanvas:hover {
      transform: scale(1.02);
    }
    
    #colorWheelCanvas:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; align-items: center;
      margin-top: 2rem;
      width: 100%;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    

    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
      }
      
      .css-color-wheel {
        width: 280px;
        height: 280px;
        /* Ensure conic-gradient works on mobile */
        background: hsl(0, 100%, 55%);
        background: -webkit-conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
        background: conic-gradient(
          hsl(0, 100%, 55%),
          hsl(30, 100%, 55%),
          hsl(60, 100%, 55%),
          hsl(90, 100%, 55%),
          hsl(120, 100%, 55%),
          hsl(150, 100%, 55%),
          hsl(180, 100%, 55%),
          hsl(210, 100%, 55%),
          hsl(240, 100%, 55%),
          hsl(270, 100%, 55%),
          hsl(300, 100%, 55%),
          hsl(330, 100%, 55%),
          hsl(360, 100%, 55%)
        );
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    /* Debug: Ensure proper vertical centering */
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }
    
    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: center;
    }
    
    .archive-placeholder {
      font-size: 1.5rem;
      color: #999;
      margin: 2rem 0;
      font-style: italic;
    }
    
    .archive-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
    }
    
    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */

    
    #quilt {
      width: 90vw; height: 90vw;
      max-width: 600px; max-height: 600px;
      margin: 2rem auto;
      background: transparent;
      position: relative;
      display: block;
    }
    
    /* MOBILE-FIRST: Override constraints when time-based engine is active */
    #quilt[data-time-based-active="true"] {
      width: 100vw !important;
      height: auto !important;
      max-width: none !important;
      max-height: none !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Fabric texture using CSS */
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== ADMIN PANEL ===== */
    #adminPanel {
      display: none;
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.95);
      color: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      max-width: 350px;
      border: 2px solid #333;
    }

    #adminPanel.visible {
      display: block;
    }

    .admin-header {
      font-weight: 600;
      margin-bottom: 15px;
      color: #ff6b6b;
      border-bottom: 1px solid #333;
      padding-bottom: 8px;
    }

    .admin-section {
      margin-bottom: 20px;
    }

    .admin-section h4 {
      margin: 0 0 10px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #ccc;
    }

    .admin-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .admin-input {
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      width: 80px;
      font-size: 14px;
    }

    .admin-btn {
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .admin-btn:hover {
      background: #444;
      border-color: #666;
    }

    .admin-btn.primary {
      background: #ff6b6b;
      border-color: #ff6b6b;
    }

    .admin-btn.primary:hover {
      background: #ff5252;
    }

    .admin-btn.danger {
      background: #f44336;
      border-color: #f44336;
    }

    .admin-btn.danger:hover {
      background: #d32f2f;
    }

    .admin-info {
      font-size: 11px;
      color: #888;
      margin-top: 5px;
    }

    #adminToggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 12px;
      z-index: 999;
      opacity: 0.3;
      transition: opacity 0.2s ease;
    }

    #adminToggle:hover {
      opacity: 0.8;
    }

    /* ===== QUILT ===== */
    #quilt {
      width: 90vw !important; 
      height: 90vw !important;
      min-width: 600px !important;
      min-height: 600px !important;
      max-width: 1200px !important;
      max-height: 1200px !important;
      margin: 10rem auto 1rem auto !important;
      background: transparent;
      position: relative;
      display: block !important;
      box-sizing: border-box !important;
    }
    
    /* MOBILE-FIRST: Override the !important constraints when time-based engine is active */
    #quilt[data-time-based-active="true"] {
      width: 100vw !important;
      height: auto !important;
      min-width: unset !important;
      min-height: unset !important;
      max-width: unset !important;
      max-height: unset !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* Fix screen centering for quilt */
    #screen-quilt {
      justify-content: center !important;
      align-items: center !important;
      padding: 1rem 0 !important;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .screen { 
        padding: 2rem 1rem 10px 1rem; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      #quilt { 
        width: 90vw !important; 
        height: 90vw !important; 
        min-width: 300px !important;
        min-height: 300px !important;
        max-width: 100vw !important;
        max-height: 100vw !important;
        margin: 1rem auto !important;
        display: block !important;
        position: relative;
      }
      
      /* MOBILE-FIRST: Override responsive constraints for time-based engine */
      #quilt[data-time-based-active="true"] { 
        width: 100vw !important; 
        height: auto !important; 
        min-width: unset !important;
        min-height: unset !important;
        max-width: unset !important;
        max-height: unset !important;
        margin: 0 !important;
        box-sizing: border-box !important;
      }
      
      #screen-quilt {
        padding: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
      
      /* Extra small mobile devices */
      #quilt { 
        width: 95vw !important; 
        height: 95vw !important; 
        min-width: 280px !important;
        min-height: 280px !important;
        margin: 0.5rem auto !important;
      }
      
      /* MOBILE-FIRST: Override extra small device constraints for time-based engine */
      #quilt[data-time-based-active="true"] { 
        width: 100vw !important; 
        height: auto !important; 
        min-width: unset !important;
        min-height: unset !important;
        max-width: unset !important;
        max-height: unset !important;
        margin: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        font-size: 1rem;
        margin-bottom: 0.3rem;
      }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }
  </style>
</head>
<body>
  <main id="app">
    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
      <button class="btn" data-next="screen-welcome" aria-label="Start the daily experience">LET'S BEGIN</button>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">↓</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="35" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">
      <div id="phase-indicator" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; color: #666;">Collection Phase (0/5)</div>
      <div id="user-counter" style="font-size: 1rem; font-weight: 500; margin-bottom: 0.5rem; color: #888; background: #f0f0f0; padding: 0.5rem; border-radius: 4px;">Submission #0</div>
      <svg id="quilt" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      <p class="thank-you-message" aria-live="polite" id="community-message">Thank you for adding your block! <span id="user-count">1 quilter</span> contributing together <3</p>
      <button id="testAddBlock" class="btn" style="background: #ff6b6b; color: white; margin: 0.5rem;">TEST: Add Random Block</button>
      <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white; margin: 0.5rem;">SHOW ME MY PIECE</button>
      <button id="testDifferentUserBtn" class="btn" style="background: #9C27B0; color: white; margin: 0.5rem;">TEST: Simulate Different User</button>
      <button id="testUniversalMatchingBtn" class="btn" style="background: #FF9800; color: white; margin: 0.5rem;">TEST: Universal Matching</button>
      <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button>
      <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
      <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <div class="archive-content">
        <p class="archive-placeholder">Archive coming soon...</p>
        <p class="archive-description">Browse through past community quilts and see how our collective creativity has grown over time.</p>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

  <!-- Toast notifications -->
      <div id="toast" class="toast" role="alert" aria-live="polite"></div>

    <!-- Admin Panel -->
    <button id="adminToggle">ADMIN</button>
    
    <div id="adminPanel">
      <div class="admin-header">🛠️ ADMIN CONTROLS</div>
      
      <div class="admin-section">
        <h4>Add Sample Blocks</h4>
        <div class="admin-controls">
          <input type="number" id="blockCount" class="admin-input" value="10" min="1" max="100" placeholder="Count">
          <button id="addSampleBlocks" class="admin-btn primary">Add Blocks</button>
        </div>
        <div class="admin-info">Adds blocks using colors already submitted by users</div>
      </div>

      <div class="admin-section">
        <h4>Pattern Control</h4>
        <div class="admin-controls">
          <select id="forcePattern" class="admin-input" style="width: 120px;">
            <option value="">Auto-Select</option>
            <option value="spiral">Spiral</option>
            <option value="gradient_flow">Gradient Flow</option>
            <option value="radial">Radial</option>
            <option value="warm_cool_split">Warm/Cool Split</option>
            <option value="checkerboard">Checkerboard</option>
          </select>
          <button id="applyPattern" class="admin-btn">Apply</button>
        </div>
        <div class="admin-info">Force a specific pattern for testing</div>
      </div>

      <div class="admin-section">
        <h4>System Control</h4>
        <div class="admin-controls">
          <button id="forceReorganize" class="admin-btn">Reorganize Now</button>
          <button id="resetQuiltAdmin" class="admin-btn danger">Reset Quilt</button>
        </div>
        <div class="admin-controls" style="margin-top: 8px;">
          <span style="font-size: 12px; color: #ccc;">Threshold:</span>
          <input type="number" id="reorganizeThreshold" class="admin-input" value="5" min="1" max="50" style="width: 60px;">
          <button id="updateThreshold" class="admin-btn">Update</button>
        </div>
        <div class="admin-info">Control reorganization behavior</div>
      </div>

      <div class="admin-section">
        <h4>Emergency</h4>
        <div class="admin-controls">
          <button id="emergencyResetBtn" class="admin-btn danger">Emergency Reset</button>
        </div>
        <div class="admin-info">⚠️ Clears ALL data and resets system state</div>
      </div>

      <div class="admin-section">
        <h4>Diagnostics</h4>
        <div class="admin-controls">
          <button id="showDiagnostics" class="admin-btn">Show Stats</button>
          <button id="exportQuilt" class="admin-btn">Export Data</button>
        </div>
        <div class="admin-info">View system information and export quilt state</div>
      </div>
    </div>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script type="module">
    // ===== CONFIGURATION OBJECT =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '2.0.0',
        defaultColor: '#f7b733',
        quiltSize: 600,
        minBlockSize: 40,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        viewBoxStartX: 0,
        viewBoxStartY: 0,
        edgePadding: 20,
        gridCols: 5,
        gridRows: 5,
        gridJitter: 15,
        minSpacing: 10,
        maxPieceSizeRatio: 0.8,
        minPieceSizeRatio: 0.4,
        edgeVariation: 0.1,
        organicVariation: 3
      },
      PHASES: {
        collection: {
          maxSubmissions: 5,
          piecesPerSubmission: [4, 4, 4, 4, 4, 4, 1, 1, 1] // pieces for submissions 1-9
        },
        patchFormation: {
          triggerSubmission: 6, // User 6 triggers block formation
          targetPatches: 2,
          edgeTolerance: 0.2,
          valueContrastWeight: 0.8
        },
        blockFormation: {
          triggerSubmission: 6, // User 6 sees blocks, not patches
          edgeTolerance: 1.5, // Increased tolerance to ensure all patches get matched
          valueContrastWeight: 0.8
        },
        quiltFormation: {
          triggerSubmission: 9
        }
      },
      RENDERING: {
        organicEdgesFilter: 'organicEdges',
        userHighlightFilter: 'userHighlight',
        animationClass: 'new-block',
        borderColor: {
          pieces: '#ffa726',
          patches: '#ff6b6b',
          blocks: '#4ecdc4'
        }
      },
      POSITIONING: {
        spacing: {
          pieces: 120,
          patches: 120,
          blocks: 250  // Increased spacing for blocks to prevent overlapping
        },
        jitter: {
          pieces: 8,
          patches: 8,
          blocks: 5  // Reduced jitter for blocks to prevent overlap
        }
      }
    };

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = '🧵';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} ⚠️ ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} ❌ ${message}`, error || '');
      }

      phase(phase, data = null) {
        this.log(`🔄 Phase: ${phase}`, data);
      }

      render(element, count) {
        this.log(`🎨 Rendering ${count} ${element}`);
      }

      position(element, index, x, y) {
        this.log(`📍 ${element} ${index} positioned at (${x.toFixed(1)}, ${y.toFixed(1)})`);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(null, args), delay);
        };
      }

      static hslToHex(h, s, l) {
        // Debug logging
        console.log(`hslToHex input: h=${h}, s=${s}, l=${l}`);
        
        h /= 360;
        s /= 100;
        l /= 100;
        
        console.log(`hslToHex normalized: h=${h}, s=${s}, l=${l}`);
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        console.log(`hslToHex RGB: r=${r}, g=${g}, b=${b}`);
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        const result = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        console.log(`hslToHex result: ${result}`);
        return result;
      }

      static hexToHsl(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return {
          h: Math.round(h * 360),
          s: Math.round(s * 100),
          l: Math.round(l * 100)
        };
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
        const target = document.getElementById(screenId);
        if (target) {
          target.classList.add("active");
          
          // Reset color selection when entering color screen
          if (screenId === 'screen-color') {
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen) {
              colorScreen.style.backgroundColor = '#f6f4f1';
            }
          }
          
          // Scroll to top
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          
          const app = document.getElementById('app');
          if (app) {
            app.scrollTop = 0;
          }
        }
      }

      updatePhaseIndicator(phase, submissionCount) {
        const phaseIndicator = document.getElementById('phase-indicator');
        if (phaseIndicator) {
          const phaseText = {
            'collection': `Collection Phase (${submissionCount}/5)`,
            'patch-formation': 'Patch Formation Phase',
            'block-formation': 'Block Formation Phase',
            'quilt-formation': 'Quilt Formation Phase'
          };
          phaseIndicator.textContent = phaseText[phase] || 'Unknown Phase';
        }
      }

      updateUserCounter(submissionCount, phase, elementCounts) {
        const userCounterElement = document.getElementById('user-counter');
        if (userCounterElement) {
          let phaseInfo = '';
          if (phase === 'collection') {
            phaseInfo = `Collection Phase (${submissionCount}/5)`;
          } else if (phase === 'patch-formation') {
            phaseInfo = `Patch Formation Phase (${elementCounts.patches || 0} patches)`;
          } else if (phase === 'block-formation') {
            phaseInfo = `Block Formation Phase (${elementCounts.blocks || 0} blocks)`;
          } else if (phase === 'quilt-formation') {
            phaseInfo = `Quilt Formation Phase`;
          }
          
          userCounterElement.textContent = `Submission #${submissionCount} - ${phaseInfo}`;
        }
      }
    }

         // ===== ERROR HANDLING SERVICE =====
     class ErrorHandler {
       constructor(uiService, logger) {
         this.uiService = uiService;
         this.logger = logger;
       }

       handleError(error, context = 'Unknown') {
         this.logger.error(`Error in ${context}:`, error);
         
         const errorMessages = {
           'loadQuilt': 'Failed to load quilt data. Starting fresh.',
           'saveQuilt': 'Failed to save your color. Please try again.',
           'shareFlow': 'Failed to create share image. Saving instead.',
           'colorPicker': 'Color picker error. Please try again.',
           'App initialization': 'Failed to initialize app. Please refresh.',
           'renderBlocks': 'Failed to render quilt. Please try again.',
           'addPieceToQuilt': 'Failed to add piece. Please try again.'
         };
         
         const message = errorMessages[context] || 'Something went wrong. Please try again.';
         this.uiService.showToast(message);
       }

       validatePiece(piece) {
         if (!piece || typeof piece.x === 'undefined' || typeof piece.y === 'undefined' || 
             typeof piece.width === 'undefined' || typeof piece.height === 'undefined') {
           throw new Error(`Invalid piece data: ${JSON.stringify(piece)}`);
         }
         return true;
       }

       validateColor(color) {
         if (!Utils.validateHexColor(color)) {
           throw new Error(`Invalid color format: ${color}`);
         }
         return true;
       }
     }

     // ===== STATE MANAGEMENT =====
     class QuiltState {
       constructor(logger) {
         this.logger = logger;
         this.reset();
       }

       reset() {
         this.blocks = [];
         this.pieces = [];
         this.allPieces = [];
         this.patches = [];
         this.originalPatches = [];
         this.quilt = null;
         this.submissionCount = 0;
         this.currentPhase = 'collection';
         this.lastAddedIndex = null;
         this.unmatchedPieces = [];
         this.unmatchedPatches = [];
         this.userPiecesHighlighted = false;
         this.currentUserId = Utils.getOrCreateUserId();
         this.logger.log('State reset');
       }

       getElementCounts() {
         return {
           pieces: this.pieces.length,
           patches: this.patches.length,
           blocks: this.blocks.length,
           unmatchedPieces: this.unmatchedPieces.length,
           unmatchedPatches: this.unmatchedPatches.length
         };
       }

       addPiece(piece) {
         this.pieces.push(piece);
         this.allPieces.push(piece);
         this.logger.log(`Added piece ${piece.id}`);
       }

       addPatch(patch) {
         this.patches.push(patch);
         this.logger.log(`Added patch ${patch.id}`);
       }

       addBlock(block) {
         this.blocks.push(block);
         this.logger.log(`Added block ${block.id}`);
       }

       setPhase(phase) {
         this.currentPhase = phase;
         this.logger.phase(phase);
       }

       incrementSubmission() {
         this.submissionCount++;
         this.logger.log(`Submission count: ${this.submissionCount}`);
       }
     }

     // ===== DATA LAYER =====
     class QuiltDataService {
       constructor(logger, errorHandler) {
         this.logger = logger;
         this.errorHandler = errorHandler;
         this.db = null;
         this.quiltDoc = null;
       }

       async initialize() {
         try {
           // Disable Firebase for easier testing
           this.db = null;
           this.quiltDoc = null;
           this.logger.log('Data service initialized (Firebase disabled)');
         } catch (error) {
           this.errorHandler.handleError(error, 'Data service initialization');
           throw error;
         }
       }

       async loadQuilt() {
         try {
           this.logger.log('Loading quilt data');
           // Disable Firestore for easier testing
           return []; // Start with empty quilt
         } catch (error) {
           this.errorHandler.handleError(error, 'loadQuilt');
           return [];
         }
       }

       async saveQuilt() {
         try {
           this.logger.log('Saving quilt data');
           // Disable Firestore for easier testing
         } catch (error) {
           this.errorHandler.handleError(error, 'saveQuilt');
           throw error;
         }
       }
     }

     // ===== QUOTE SERVICE =====
     class QuoteService {
       constructor() {
         this.quotes = [
           { text: "Art washes away from the soul the dust of everyday life.", author: "— Pablo Picasso" },
           { text: "Creativity takes courage.", author: "— Henri Matisse" },
           { text: "Every artist was first an amateur.", author: "— Ralph Waldo Emerson" },
           { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "— Wassily Kandinsky" },
           { text: "Great things are done by a series of small things brought together.", author: "— Vincent Van Gogh" },
           { text: "You can't use up creativity. The more you use, the more you have.", author: "— Maya Angelou" }
         ];
         this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
       }

       getTodayQuote() {
         const today = new Date();
         const year = today.getFullYear();
         const month = String(today.getMonth() + 1).padStart(2, '0');
         const day = String(today.getDate()).padStart(2, '0');
         const todayString = `${year}-${month}-${day}`;
         const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
         const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
         return this.quotes[quoteIndex];
       }

       displayQuote() {
         try {
           const { text, author } = this.getTodayQuote();
           const quoteLine = document.querySelector('.quote-line');
           const quoteAuthor = document.querySelector('.quote-author');
           
           if (quoteLine) quoteLine.textContent = text;
           if (quoteAuthor) quoteAuthor.textContent = author;
         } catch (error) {
           console.error('Error displaying quote:', error);
         }
       }
     }

     // ===== POSITIONING SERVICE =====
     class PositioningService {
       constructor(logger) {
         this.logger = logger;
       }

       createPiece(color, pieceIndex, userId, submissionId) {
         const config = CONFIG.QUILT;
         
         // Calculate grid cell size
         const availableWidth = config.viewBoxWidth - 2 * config.edgePadding;
         const availableHeight = config.viewBoxHeight - 2 * config.edgePadding;
         const cellWidth = availableWidth / config.gridCols;
         const cellHeight = availableHeight / config.gridRows;
         
         // Calculate piece size
         const maxPieceSize = Math.min(cellWidth, cellHeight) * config.maxPieceSizeRatio;
         const minSize = Math.max(CONFIG.APP.minBlockSize, maxPieceSize * config.minPieceSizeRatio);
         const maxSize = maxPieceSize;
         const baseSize = minSize + Math.random() * (maxSize - minSize);
         
         // Determine shape
         const isSquare = Math.random() < 0.7;
         let width, height;
         
         if (isSquare) {
           width = baseSize;
           height = baseSize;
         } else {
           const aspectRatio = 1 + (Math.random() - 0.5) * 0.5;
           width = baseSize;
           height = baseSize * aspectRatio;
         }
         
         // Add organic edge variations
         width += (Math.random() - 0.5) * width * config.edgeVariation;
         height += (Math.random() - 0.5) * height * config.edgeVariation;
         
         // Calculate position
         const gridX = pieceIndex % config.gridCols;
         const gridY = Math.floor(pieceIndex / config.gridCols);
         
         const totalGridWidth = config.gridCols * cellWidth;
         const totalGridHeight = config.gridRows * cellHeight;
         const gridStartX = config.viewBoxStartX + (config.viewBoxWidth - totalGridWidth) / 2;
         const gridStartY = config.viewBoxStartY + (config.viewBoxHeight - totalGridHeight) / 2;
         
         const baseX = gridStartX + gridX * cellWidth + cellWidth / 2;
         const baseY = gridStartY + gridY * cellHeight + cellHeight / 2;
         
         // Add jitter
         const maxJitter = Math.min(config.gridJitter, (Math.min(cellWidth, cellHeight) - maxPieceSize) / 2);
         const jitterX = (Math.random() - 0.5) * Math.min(maxJitter, 8);
         const jitterY = (Math.random() - 0.5) * Math.min(maxJitter, 8);
         
         let x = baseX + jitterX;
         let y = baseY + jitterY;
         
         // Constrain to cell bounds
         const minSpacingFromEdge = 5;
         const cellLeft = gridStartX + gridX * cellWidth;
         const cellRight = gridStartX + (gridX + 1) * cellWidth;
         const cellTop = gridStartY + gridY * cellHeight;
         const cellBottom = gridStartY + (gridY + 1) * cellHeight;
         
         x = Math.max(cellLeft + minSpacingFromEdge, Math.min(x, cellRight - width - minSpacingFromEdge));
         y = Math.max(cellTop + minSpacingFromEdge, Math.min(y, cellBottom - height - minSpacingFromEdge));
         
         // Final bounds check
         x = Math.max(config.viewBoxStartX, Math.min(x, config.viewBoxStartX + config.viewBoxWidth - width));
         y = Math.max(config.viewBoxStartY, Math.min(y, config.viewBoxStartY + config.viewBoxHeight - height));
         
         const piece = {
           id: `piece_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
           userId: userId,
           submissionId: submissionId,
           pieceIndex: pieceIndex,
           timestamp: Date.now(),
           x: x,
           y: y,
           width: width,
           height: height,
           color: color,
           type: 'piece',
           edges: this.calculateEdges(width, height)
         };
         
         this.logger.position('piece', pieceIndex, x, y);
         return piece;
       }

       calculateEdges(width, height) {
         return {
           top: width,
           right: height,
           bottom: width,
           left: height
         };
       }

                positionElementsInGrid(elements, startIndex = 0, type = 'pieces') {
           if (elements.length === 0) return;
           
           const config = CONFIG.QUILT;
           const spacing = CONFIG.POSITIONING.spacing[type] || 120;
           const jitter = CONFIG.POSITIONING.jitter[type] || 8;
           
           // For blocks, use touching layout instead of grid
           if (type === 'blocks') {
             this.positionBlocksInTouchingLayout(elements);
             return;
           }
           
           // Calculate optimal grid dimensions for pieces/patches
           const elementCount = elements.length;
           const aspectRatio = config.viewBoxWidth / config.viewBoxHeight;
           const cols = Math.ceil(Math.sqrt(elementCount * aspectRatio));
           const rows = Math.ceil(elementCount / cols);
           
           const availableWidth = config.viewBoxWidth - (2 * config.edgePadding);
           const availableHeight = config.viewBoxHeight - (2 * config.edgePadding);
           const cellWidth = availableWidth / cols;
           const cellHeight = availableHeight / rows;
           
           this.logger.log(`Positioning ${elements.length} ${type} in ${rows}x${cols} grid`);
           
           elements.forEach((element, index) => {
             const gridIndex = startIndex + index;
             const row = Math.floor(gridIndex / cols);
             const col = gridIndex % cols;
             
             const x = config.viewBoxStartX + config.edgePadding + (col * cellWidth);
             const y = config.viewBoxStartY + config.edgePadding + (row * cellHeight);
             
             // Center element in cell
             const centerX = x + (cellWidth - element.width) / 2;
             const centerY = y + (cellHeight - element.height) / 2;
             
             // Add jitter
             const jitterX = (Math.random() - 0.5) * jitter;
             const jitterY = (Math.random() - 0.5) * jitter;
             
             // Ensure element stays within bounds
             const maxX = config.viewBoxStartX + config.viewBoxWidth - config.edgePadding - element.width;
             const maxY = config.viewBoxStartY + config.viewBoxHeight - config.edgePadding - element.height;
             
             element.x = Math.max(config.viewBoxStartX + config.edgePadding, Math.min(maxX, centerX + jitterX));
             element.y = Math.max(config.viewBoxStartY + config.edgePadding, Math.min(maxY, centerY + jitterY));
             
             this.logger.position(type, index, element.x, element.y);
           });
         }
         
         positionBlocksInTouchingLayout(blocks) {
           if (blocks.length === 0) return;
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning ${blocks.length} blocks using pairing logic`);
           
           // For 6 blocks, use the new pairing approach
           if (blocks.length === 6) {
             this.positionBlocksWithPairing(blocks);
             return;
           }
           
           // Fallback to original logic for other block counts
           this.positionBlocksIteratively(blocks);
         }
         
         positionBlocksWithPairing(blocks) {
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log('Using pairing approach for 6 blocks');
           
           // Phase 1: Create 3 paired blocks
           const pairedBlocks = this.createPairedBlocks(blocks);
           
           // Phase 2: Combine 2 paired blocks into a 4-block section
           const fourBlockSection = this.combinePairedBlocks(pairedBlocks);
           
           // Phase 3: Add the remaining paired block
           this.addFinalPairedBlock(fourBlockSection, pairedBlocks[2]);
           
           // Position the final quilt at the center
           this.centerQuilt(blocks);
         }
         
         createPairedBlocks(blocks) {
           this.logger.log('Phase 1: Creating paired blocks');
           this.logger.log(`Initial blocks:`, blocks.map(b => ({ id: b.id, width: b.width, height: b.height, color: b.color })));
           
           // Generate all possible pairs
           const allPairs = [];
           for (let i = 0; i < blocks.length; i++) {
             for (let j = i + 1; j < blocks.length; j++) {
               const pair = this.evaluateBlockPair(blocks[i], blocks[j]);
               allPairs.push(pair);
               this.logger.log(`Pair ${i}-${j}: score=${pair.score.toFixed(2)}, joinType=${pair.joinType}, edgeDiff=${Math.abs(pair.edgeMatch?.edge1.length - pair.edgeMatch?.edge2.length) || 'N/A'}`);
             }
           }
           
           // Sort by score (lower is better)
           allPairs.sort((a, b) => a.score - b.score);
           
           // Select the 3 best pairs, ensuring no block is used twice
           const selectedPairs = [];
           const usedBlocks = new Set();
           
           for (const pair of allPairs) {
             if (!usedBlocks.has(pair.block1) && !usedBlocks.has(pair.block2)) {
               selectedPairs.push(pair);
               usedBlocks.add(pair.block1);
               usedBlocks.add(pair.block2);
               
               if (selectedPairs.length === 3) break;
             }
           }
           
           // Create paired blocks
           const pairedBlocks = selectedPairs.map(pair => this.createPairedBlock(pair));
           
           this.logger.log(`Created ${pairedBlocks.length} paired blocks`);
           this.logger.log('Paired blocks details:', pairedBlocks.map(pb => ({
             width: pb.width,
             height: pb.height,
             joinType: pb.joinType,
             score: pb.score,
             blockIds: pb.blocks.map(b => b.id)
           })));
           return pairedBlocks;
         }
         
         evaluateBlockPair(block1, block2) {
           let bestScore = Infinity;
           let bestJoinType = null;
           let bestEdgeMatch = null;
           
           // Check all possible edge combinations
           const edges1 = [
             { type: 'horizontal', length: block1.width, side: 'right' },
             { type: 'horizontal', length: block1.width, side: 'left' },
             { type: 'vertical', length: block1.height, side: 'bottom' },
             { type: 'vertical', length: block1.height, side: 'top' }
           ];
           
           const edges2 = [
             { type: 'horizontal', length: block2.width, side: 'right' },
             { type: 'horizontal', length: block2.width, side: 'left' },
             { type: 'vertical', length: block2.height, side: 'bottom' },
             { type: 'vertical', length: block2.height, side: 'top' }
           ];
           
           for (const edge1 of edges1) {
             for (const edge2 of edges2) {
               if (edge1.type === edge2.type) {
                 const lengthDiff = Math.abs(edge1.length - edge2.length);
                 const valueContrast = this.calculateValueContrastScore(block1.color, block2.color);
                 
                 // Combined score: edge compatibility + value contrast
                 const score = lengthDiff + (1 - valueContrast) * 50;
                 
                 if (score < bestScore) {
                   bestScore = score;
                   bestJoinType = edge1.type;
                   bestEdgeMatch = { edge1, edge2 };
                 }
               }
             }
           }
           
           return {
             block1,
             block2,
             score: bestScore,
             joinType: bestJoinType,
             edgeMatch: bestEdgeMatch
           };
         }
         
         createPairedBlock(pair) {
           const { block1, block2, joinType, edgeMatch } = pair;
           
           this.logger.log(`Creating paired block: ${block1.id} + ${block2.id}, joinType=${joinType}`);
           this.logger.log(`Before resize: block1=${block1.width}x${block1.height}, block2=${block2.width}x${block2.height}`);
           
           // Resize blocks slightly if needed for better edge alignment
           if (joinType === 'horizontal') {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               block1.width = targetLength;
               this.logger.log(`Resized block1 width to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               block2.width = targetLength;
               this.logger.log(`Resized block2 width to ${targetLength}`);
             }
           } else {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               block1.height = targetLength;
               this.logger.log(`Resized block1 height to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               block2.height = targetLength;
               this.logger.log(`Resized block2 height to ${targetLength}`);
             }
           }
           
           this.logger.log(`After resize: block1=${block1.width}x${block1.height}, block2=${block2.width}x${block2.height}`);
           
           // Calculate combined dimensions
           let combinedWidth, combinedHeight;
           if (joinType === 'horizontal') {
             combinedWidth = block1.width + block2.width;
             combinedHeight = Math.max(block1.height, block2.height);
           } else {
             combinedWidth = Math.max(block1.width, block2.width);
             combinedHeight = block1.height + block2.height;
           }
           
           // Position the two blocks within the paired block
           block1.x = 0;
           block1.y = 0;
           
           if (joinType === 'horizontal') {
             // For horizontal join, place block2 to the right of block1
             block2.x = block1.width;
             block2.y = 0;
           } else {
             // For vertical join, place block2 below block1
             block2.x = 0;
             block2.y = block1.height;
           }
           
           this.logger.log(`Positioned blocks in pair: ${block1.id} at (${block1.x}, ${block1.y}), ${block2.id} at (${block2.x}, ${block2.y})`);
           this.logger.log(`Paired block dimensions: ${combinedWidth}x${combinedHeight}, joinType=${joinType}`);
           
           return {
             blocks: [block1, block2],
             width: combinedWidth,
             height: combinedHeight,
             joinType,
             score: pair.score
           };
         }
         
         combinePairedBlocks(pairedBlocks) {
           this.logger.log('Phase 2: Combining paired blocks');
           
           // Evaluate all possible combinations of 2 paired blocks
           const combinations = [];
           for (let i = 0; i < pairedBlocks.length; i++) {
             for (let j = i + 1; j < pairedBlocks.length; j++) {
               const combination = this.evaluatePairedBlockCombination(pairedBlocks[i], pairedBlocks[j]);
               combinations.push(combination);
               this.logger.log(`Combination ${i}-${j}: score=${combination.score.toFixed(2)}, joinType=${combination.joinType}`);
             }
           }
           
           // Select the best combination
           combinations.sort((a, b) => a.score - b.score);
           const bestCombination = combinations[0];
           
           // Create the 4-block section
           const fourBlockSection = this.createFourBlockSection(bestCombination);
           
           this.logger.log('Created 4-block section');
           return fourBlockSection;
         }
         
         evaluatePairedBlockCombination(pair1, pair2) {
           let bestScore = Infinity;
           let bestJoinType = null;
           let bestEdgeMatch = null;
           
           // Check all possible edge combinations between the paired blocks
           const edges1 = [
             { type: 'horizontal', length: pair1.width, side: 'right' },
             { type: 'horizontal', length: pair1.width, side: 'left' },
             { type: 'vertical', length: pair1.height, side: 'bottom' },
             { type: 'vertical', length: pair1.height, side: 'top' }
           ];
           
           const edges2 = [
             { type: 'horizontal', length: pair2.width, side: 'right' },
             { type: 'horizontal', length: pair2.width, side: 'left' },
             { type: 'vertical', length: pair2.height, side: 'bottom' },
             { type: 'vertical', length: pair2.height, side: 'top' }
           ];
           
           for (const edge1 of edges1) {
             for (const edge2 of edges2) {
               if (edge1.type === edge2.type) {
                 const lengthDiff = Math.abs(edge1.length - edge2.length);
                 const score = lengthDiff;
                 
                 if (score < bestScore) {
                   bestScore = score;
                   bestJoinType = edge1.type;
                   bestEdgeMatch = { edge1, edge2 };
                 }
               }
             }
           }
           
           return {
             pair1,
             pair2,
             score: bestScore,
             joinType: bestJoinType,
             edgeMatch: bestEdgeMatch
           };
         }
         
         createFourBlockSection(combination) {
           const { pair1, pair2, joinType, edgeMatch } = combination;
           
           this.logger.log(`Creating four-block section: pair1=${pair1.width}x${pair1.height}, pair2=${pair2.width}x${pair2.height}, joinType=${joinType}`);
           
           // Resize paired blocks slightly if needed
           if (joinType === 'horizontal') {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               pair1.width = targetLength;
               this.logger.log(`Resized pair1 width to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               pair2.width = targetLength;
               this.logger.log(`Resized pair2 width to ${targetLength}`);
             }
           } else {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               pair1.height = targetLength;
               this.logger.log(`Resized pair1 height to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               pair2.height = targetLength;
               this.logger.log(`Resized pair2 height to ${targetLength}`);
             }
           }
           
           // Calculate combined dimensions
           let combinedWidth, combinedHeight;
           if (joinType === 'horizontal') {
             combinedWidth = pair1.width + pair2.width;
             combinedHeight = Math.max(pair1.height, pair2.height);
           } else {
             combinedWidth = Math.max(pair1.width, pair2.width);
             combinedHeight = pair1.height + pair2.height;
           }
           
           this.logger.log(`Four-block section dimensions: ${combinedWidth}x${combinedHeight}`);
           
                       // Position the blocks within the four-block section
            let currentX = 0;
            let currentY = 0;
            
            // Position blocks from pair1 first
            for (const block of pair1.blocks) {
              // Add the pair1 offset to the block's existing relative position
              block.x = currentX + block.x;
              block.y = currentY + block.y;
              
              if (pair1.joinType === 'horizontal') {
                currentX += block.width;
              } else {
                currentY += block.height;
              }
              
              this.logger.log(`Positioned pair1 block ${block.id} at (${block.x}, ${block.y})`);
            }
            
            // Reset position for pair2
            if (joinType === 'horizontal') {
              // Attach pair2 to the right of pair1 - ensure they touch
              currentX = pair1.width;
              currentY = 0;
            } else {
              // Attach pair2 below pair1 - ensure they touch
              currentX = 0;
              currentY = pair1.height;
            }
            
            // Position blocks from pair2
            for (const block of pair2.blocks) {
              // Add the pair2 offset to the block's existing relative position
              block.x = currentX + block.x;
              block.y = currentY + block.y;
              
              // Update current position based on the four-block section's join type, not the pair's join type
              if (joinType === 'horizontal') {
                currentX += block.width;
              } else {
                currentY += block.height;
              }
              
              this.logger.log(`Positioned pair2 block ${block.id} at (${block.x}, ${block.y})`);
            }
           
           this.logger.log('Final four-block section positions:', [...pair1.blocks, ...pair2.blocks].map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Check for overlaps in the four-block section
           this.logger.log('Checking for overlaps in four-block section...');
           const allBlocks = [...pair1.blocks, ...pair2.blocks];
           for (let i = 0; i < allBlocks.length; i++) {
             for (let j = i + 1; j < allBlocks.length; j++) {
               const block1 = allBlocks[i];
               const block2 = allBlocks[j];
               
               // Check for horizontal overlap
               const horizontalOverlap = Math.min(block1.x + block1.width, block2.x + block2.width) - Math.max(block1.x, block2.x);
               if (horizontalOverlap > 0) {
                 const verticalOverlap = Math.min(block1.y + block1.height, block2.y + block2.height) - Math.max(block1.y, block2.y);
                 if (verticalOverlap > 0) {
                   this.logger.log(`FOUR-BLOCK OVERLAP detected between ${block1.id} and ${block2.id}: ${horizontalOverlap}x${verticalOverlap}px`);
                 }
               }
             }
           }
           
           return {
             blocks: [...pair1.blocks, ...pair2.blocks],
             width: combinedWidth,
             height: combinedHeight,
             joinType,
             score: combination.score
           };
         }
         
         addFinalPairedBlock(fourBlockSection, remainingPairedBlock) {
           this.logger.log('Phase 3: Adding final paired block');
           
           // Find the best way to add the remaining paired block
           const bestAttachment = this.findBestAttachment(fourBlockSection, remainingPairedBlock);
           
           // Apply the attachment
           this.applyAttachment(fourBlockSection, remainingPairedBlock, bestAttachment);
           
           this.logger.log('Final quilt layout complete');
         }
         
         findBestAttachment(fourBlockSection, pairedBlock) {
           let bestScore = Infinity;
           let bestPosition = null;
           let bestJoinType = null;
           
           // Try different attachment positions
           const attachmentPositions = [
             { side: 'right', x: fourBlockSection.width, y: 0 },
             { side: 'left', x: -pairedBlock.width, y: 0 },
             { side: 'bottom', x: 0, y: fourBlockSection.height },
             { side: 'top', x: 0, y: -pairedBlock.height }
           ];
           
           for (const position of attachmentPositions) {
             const score = this.evaluateAttachmentPosition(fourBlockSection, pairedBlock, position);
             if (score < bestScore) {
               bestScore = score;
               bestPosition = position;
               bestJoinType = position.side === 'right' || position.side === 'left' ? 'horizontal' : 'vertical';
             }
           }
           
           return {
             position: bestPosition,
             joinType: bestJoinType,
             score: bestScore
           };
         }
         
         evaluateAttachmentPosition(fourBlockSection, pairedBlock, position) {
           // Simple scoring based on edge alignment and shape balance
           let score = 0;
           
           // Edge alignment score
           if (position.side === 'right' || position.side === 'left') {
             const lengthDiff = Math.abs(fourBlockSection.height - pairedBlock.height);
             score += lengthDiff;
           } else {
             const lengthDiff = Math.abs(fourBlockSection.width - pairedBlock.width);
             score += lengthDiff;
           }
           
           // Shape balance score (prefer more square shapes)
           const combinedWidth = position.side === 'right' || position.side === 'left' 
             ? fourBlockSection.width + pairedBlock.width 
             : Math.max(fourBlockSection.width, pairedBlock.width);
           const combinedHeight = position.side === 'top' || position.side === 'bottom'
             ? fourBlockSection.height + pairedBlock.height
             : Math.max(fourBlockSection.height, pairedBlock.height);
           
           const aspectRatio = Math.max(combinedWidth, combinedHeight) / Math.min(combinedWidth, combinedHeight);
           score += (aspectRatio - 1) * 10; // Penalize very long/thin shapes
           
           return score;
         }
         
         applyAttachment(fourBlockSection, pairedBlock, attachment) {
           const { position, joinType } = attachment;
           
           this.logger.log(`Applying attachment: joinType=${joinType}, position=${JSON.stringify(position)}`);
           this.logger.log(`Before attachment: fourBlockSection=${fourBlockSection.width}x${fourBlockSection.height}, pairedBlock=${pairedBlock.width}x${pairedBlock.height}`);
           
           // Resize if needed for better alignment
           if (joinType === 'horizontal') {
             const targetHeight = Math.max(fourBlockSection.height, pairedBlock.height);
             if (fourBlockSection.height < targetHeight) {
               fourBlockSection.height = targetHeight;
               this.logger.log(`Resized fourBlockSection height to ${targetHeight}`);
             }
             if (pairedBlock.height < targetHeight) {
               pairedBlock.height = targetHeight;
               this.logger.log(`Resized pairedBlock height to ${targetHeight}`);
             }
           } else {
             const targetWidth = Math.max(fourBlockSection.width, pairedBlock.width);
             if (fourBlockSection.width < targetWidth) {
               fourBlockSection.width = targetWidth;
               this.logger.log(`Resized fourBlockSection width to ${targetWidth}`);
             }
             if (pairedBlock.width < targetWidth) {
               pairedBlock.width = targetWidth;
               this.logger.log(`Resized pairedBlock width to ${targetWidth}`);
             }
           }
           
           // Position blocks based on the attachment position
           const allBlocks = [...fourBlockSection.blocks, ...pairedBlock.blocks];
           
           this.logger.log(`Positioning ${allBlocks.length} blocks based on attachment position`);
           
           // Calculate the offset for the paired block based on attachment position
           let pairedBlockOffsetX = 0;
           let pairedBlockOffsetY = 0;
           
           if (position.side === 'right') {
             // Attach to the right - paired block starts where four-block section ends
             pairedBlockOffsetX = fourBlockSection.width;
             pairedBlockOffsetY = 0;
           } else if (position.side === 'left') {
             // Attach to the left - paired block ends where four-block section starts
             pairedBlockOffsetX = -pairedBlock.width;
             pairedBlockOffsetY = 0;
           } else if (position.side === 'bottom') {
             // Attach below - paired block starts where four-block section ends
             pairedBlockOffsetX = 0;
             pairedBlockOffsetY = fourBlockSection.height;
           } else if (position.side === 'top') {
             // Attach above - paired block ends where four-block section starts
             pairedBlockOffsetX = 0;
             pairedBlockOffsetY = -pairedBlock.height;
           }
           
           this.logger.log(`Paired block offset: (${pairedBlockOffsetX}, ${pairedBlockOffsetY})`);
           
           // Position blocks from the four-block section (they stay at their current positions)
           for (const block of fourBlockSection.blocks) {
             this.logger.log(`Four-block section block ${block.id} stays at (${block.x}, ${block.y})`);
           }
           
           // Position blocks from the paired block with the calculated offset
           for (const block of pairedBlock.blocks) {
             // Add the paired block offset to the block's existing relative position
             block.x = pairedBlockOffsetX + block.x;
             block.y = pairedBlockOffsetY + block.y;
             
             this.logger.log(`Positioned paired block ${block.id} at (${block.x}, ${block.y})`);
           }
           
           this.logger.log('Final block positions:', allBlocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Check for overlaps and gaps by analyzing all block pairs
           this.logger.log('Checking for overlaps and gaps between blocks...');
           for (let i = 0; i < allBlocks.length; i++) {
             for (let j = i + 1; j < allBlocks.length; j++) {
               const block1 = allBlocks[i];
               const block2 = allBlocks[j];
               
               // Check for horizontal overlap
               const horizontalOverlap = Math.min(block1.x + block1.width, block2.x + block2.width) - Math.max(block1.x, block2.x);
               if (horizontalOverlap > 0) {
                 const verticalOverlap = Math.min(block1.y + block1.height, block2.y + block2.height) - Math.max(block1.y, block2.y);
                 if (verticalOverlap > 0) {
                   this.logger.log(`OVERLAP detected between ${block1.id} and ${block2.id}: ${horizontalOverlap}x${verticalOverlap}px`);
                 }
               }
               
               // Check if blocks are adjacent horizontally
               if (Math.abs(block1.y - block2.y) < 1) {
                 const gap = Math.abs(block1.x + block1.width - block2.x);
                 if (gap > 1) {
                   this.logger.log(`Gap detected between ${block1.id} and ${block2.id}: ${gap}px`);
                 }
               }
               
               // Check if blocks are adjacent vertically
               if (Math.abs(block1.x - block2.x) < 1) {
                 const gap = Math.abs(block1.y + block1.height - block2.y);
                 if (gap > 1) {
                   this.logger.log(`Gap detected between ${block1.id} and ${block2.id}: ${gap}px`);
                 }
               }
             }
           }
         }
         
         centerQuilt(blocks) {
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log('Centering quilt...');
           this.logger.log('Before centering:', blocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Calculate quilt bounds
           const bounds = this.getQuiltBounds(blocks);
           this.logger.log('Quilt bounds:', bounds);
           
           // Calculate center position
           const centerX = config.viewBoxStartX + (config.viewBoxWidth / 2) - (bounds.width / 2);
           const centerY = config.viewBoxStartY + (config.viewBoxHeight / 2) - (bounds.height / 2);
           
           this.logger.log(`Target center: (${centerX}, ${centerY})`);
           
           // Adjust all block positions
           const offsetX = centerX - bounds.x;
           const offsetY = centerY - bounds.y;
           
           this.logger.log(`Applying offset: (${offsetX}, ${offsetY})`);
           
           for (const block of blocks) {
             const oldX = block.x;
             const oldY = block.y;
             
             block.x += offsetX;
             block.y += offsetY;
             
             // Ensure blocks stay within bounds
             const newX = Math.max(config.viewBoxStartX + padding, 
                              Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - block.width, block.x));
             const newY = Math.max(config.viewBoxStartY + padding, 
                              Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - block.height, block.y));
             
             if (newX !== block.x || newY !== block.y) {
               this.logger.log(`Bounds adjustment for block ${block.id}: (${block.x}, ${block.y}) -> (${newX}, ${newY})`);
             }
             
             block.x = newX;
             block.y = newY;
           }
           
           this.logger.log('After centering:', blocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
         }
         
         positionBlocksIteratively(blocks) {
           if (blocks.length === 0) return;
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning ${blocks.length} blocks using iterative edge-matching logic`);
           
           // Start with the first block at the center
           blocks[0].x = config.viewBoxStartX + (config.viewBoxWidth / 2) - (blocks[0].width / 2);
           blocks[0].y = config.viewBoxStartY + (config.viewBoxHeight / 2) - (blocks[0].height / 2);
           
           // Create a list of available blocks to join
           const availableBlocks = blocks.slice(1);
           const joinedBlocks = [blocks[0]];
           
           // Iteratively join blocks using edge matching
           while (availableBlocks.length > 0) {
             let bestMatch = null;
             let bestScore = Infinity;
             let bestJoinType = null;
             let bestBlockIndex = -1;
             let bestJoinedIndex = -1;
             
             // Find the best edge match between available blocks and joined blocks
             for (let i = 0; i < availableBlocks.length; i++) {
               const availableBlock = availableBlocks[i];
               
               for (let j = 0; j < joinedBlocks.length; j++) {
                 const joinedBlock = joinedBlocks[j];
                 
                 // Check all four edges of each block
                 const edges = [
                   { type: 'horizontal', length: availableBlock.width, block: availableBlock, side: 'right' },
                   { type: 'horizontal', length: availableBlock.width, block: availableBlock, side: 'left' },
                   { type: 'vertical', length: availableBlock.height, block: availableBlock, side: 'bottom' },
                   { type: 'vertical', length: availableBlock.height, block: availableBlock, side: 'top' }
                 ];
                 
                 const joinedEdges = [
                   { type: 'horizontal', length: joinedBlock.width, block: joinedBlock, side: 'right' },
                   { type: 'horizontal', length: joinedBlock.width, block: joinedBlock, side: 'left' },
                   { type: 'vertical', length: joinedBlock.height, block: joinedBlock, side: 'bottom' },
                   { type: 'vertical', length: joinedBlock.height, block: joinedBlock, side: 'top' }
                 ];
                 
                 // Find best matching edges
                 for (const edge of edges) {
                   for (const joinedEdge of joinedEdges) {
                     if (edge.type === joinedEdge.type) {
                       const lengthDiff = Math.abs(edge.length - joinedEdge.length);
                       const score = lengthDiff;
                       
                       if (score < bestScore) {
                         bestScore = score;
                         bestMatch = { available: edge, joined: joinedEdge };
                         bestJoinType = edge.type;
                         bestBlockIndex = i;
                         bestJoinedIndex = j;
                       }
                     }
                   }
                 }
               }
             }
             
             if (bestMatch) {
               // Join the blocks
               const availableBlock = availableBlocks[bestBlockIndex];
               const joinedBlock = joinedBlocks[bestJoinedIndex];
               
               // Calculate position based on join type
               let newX, newY;
               
               if (bestJoinType === 'horizontal') {
                 // Join horizontally
                 if (bestMatch.available.side === 'right' && bestMatch.joined.side === 'left') {
                   newX = joinedBlock.x + joinedBlock.width;
                   newY = joinedBlock.y;
                 } else if (bestMatch.available.side === 'left' && bestMatch.joined.side === 'right') {
                   newX = joinedBlock.x - availableBlock.width;
                   newY = joinedBlock.y;
                 } else {
                   // Resize to match
                   const targetLength = Math.max(bestMatch.available.length, bestMatch.joined.length);
                   if (bestMatch.available.length < targetLength) {
                     availableBlock.width = targetLength;
                   }
                   if (bestMatch.joined.length < targetLength) {
                     joinedBlock.width = targetLength;
                   }
                   newX = joinedBlock.x + joinedBlock.width;
                   newY = joinedBlock.y;
                 }
               } else {
                 // Join vertically
                 if (bestMatch.available.side === 'bottom' && bestMatch.joined.side === 'top') {
                   newX = joinedBlock.x;
                   newY = joinedBlock.y + joinedBlock.height;
                 } else if (bestMatch.available.side === 'top' && bestMatch.joined.side === 'bottom') {
                   newX = joinedBlock.x;
                   newY = joinedBlock.y - availableBlock.height;
                 } else {
                   // Resize to match
                   const targetLength = Math.max(bestMatch.available.length, bestMatch.joined.length);
                   if (bestMatch.available.length < targetLength) {
                     availableBlock.height = targetLength;
                   }
                   if (bestMatch.joined.length < targetLength) {
                     joinedBlock.height = targetLength;
                   }
                   newX = joinedBlock.x;
                   newY = joinedBlock.y + joinedBlock.height;
                 }
               }
               
               // Ensure the block stays within bounds
               newX = Math.max(config.viewBoxStartX + padding, 
                              Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - availableBlock.width, newX));
               newY = Math.max(config.viewBoxStartY + padding, 
                              Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - availableBlock.height, newY));
               
               availableBlock.x = newX;
               availableBlock.y = newY;
               
               // Move block from available to joined
               joinedBlocks.push(availableBlock);
               availableBlocks.splice(bestBlockIndex, 1);
               
               this.logger.log(`Joined block ${bestBlockIndex} to block ${bestJoinedIndex} with score ${bestScore}`);
             } else {
               // Fallback: position remaining blocks around the quilt
               const remainingBlock = availableBlocks[0];
               const quiltBounds = this.getQuiltBounds(joinedBlocks);
               
               remainingBlock.x = quiltBounds.x + quiltBounds.width;
               remainingBlock.y = quiltBounds.y;
               
               joinedBlocks.push(remainingBlock);
               availableBlocks.splice(0, 1);
               
               this.logger.log(`Fallback positioning for remaining block`);
             }
           }
         }
         
         positionPieceWithQuilt(piece, existingBlocks) {
           if (existingBlocks.length === 0) {
             // If no existing blocks, position piece normally
             piece.x = CONFIG.QUILT.viewBoxStartX + CONFIG.QUILT.edgePadding;
             piece.y = CONFIG.QUILT.viewBoxStartY + CONFIG.QUILT.edgePadding;
             return;
           }
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning piece with ${existingBlocks.length} existing blocks`);
           
           // Find the best position to attach the piece to the quilt
           let bestX = config.viewBoxStartX + padding;
           let bestY = config.viewBoxStartY + padding;
           let bestScore = Infinity;
           
           // Try different attachment points around the existing quilt
           for (let attempt = 0; attempt < 20; attempt++) {
             let testX, testY;
             
             if (attempt < 5) {
               // Try attaching to the right edge of the quilt
               const rightmostBlock = existingBlocks.reduce((rightmost, block) => 
                 block.x + block.width > rightmost.x + rightmost.width ? block : rightmost
               );
               testX = rightmostBlock.x + rightmostBlock.width;
               testY = rightmostBlock.y + (Math.random() - 0.5) * rightmostBlock.height;
             } else if (attempt < 10) {
               // Try attaching to the bottom edge of the quilt
               const bottommostBlock = existingBlocks.reduce((bottommost, block) => 
                 block.y + block.height > bottommost.y + bottommost.height ? block : bottommost
               );
               testX = bottommostBlock.x + (Math.random() - 0.5) * bottommostBlock.width;
               testY = bottommostBlock.y + bottommostBlock.height;
             } else {
               // Try random positions near the quilt
               const quiltBounds = this.getQuiltBounds(existingBlocks);
               testX = quiltBounds.x + (Math.random() - 0.5) * quiltBounds.width;
               testY = quiltBounds.y + (Math.random() - 0.5) * quiltBounds.height;
             }
             
             // Ensure piece stays within bounds
             testX = Math.max(config.viewBoxStartX + padding, 
                            Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - piece.width, testX));
             testY = Math.max(config.viewBoxStartY + padding, 
                            Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - piece.height, testY));
             
             // Check if this position touches at least one existing block
             let touchesExisting = false;
             let minDistance = Infinity;
             
             for (const block of existingBlocks) {
               const horizontalTouch = (testX + piece.width === block.x) || 
                                    (block.x + block.width === testX);
               const verticalTouch = (testY + piece.height === block.y) || 
                                  (block.y + block.height === testY);
               
               if (horizontalTouch || verticalTouch) {
                 touchesExisting = true;
                 break;
               }
               
               // Calculate distance to block
               const distance = Math.sqrt(
                 Math.pow(testX - block.x, 2) + Math.pow(testY - block.y, 2)
               );
               minDistance = Math.min(minDistance, distance);
             }
             
             // Prefer positions that touch existing blocks
             const score = touchesExisting ? minDistance : minDistance + 1000;
             
             if (score < bestScore) {
               bestScore = score;
               bestX = testX;
               bestY = testY;
             }
           }
           
           piece.x = bestX;
           piece.y = bestY;
           
           this.logger.log(`Piece positioned at (${piece.x}, ${piece.y}) with score ${bestScore}`);
         }
         
         getQuiltBounds(blocks) {
           if (blocks.length === 0) {
             return { x: 0, y: 0, width: 0, height: 0 };
           }
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           
           blocks.forEach(block => {
             minX = Math.min(minX, block.x);
             minY = Math.min(minY, block.y);
             maxX = Math.max(maxX, block.x + block.width);
             maxY = Math.max(maxY, block.y + block.height);
           });
           
           return {
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY
           };
         }
         
         calculateValueContrastScore(color1, color2) {
           const hsl1 = Utils.hexToHsl(color1);
           const hsl2 = Utils.hexToHsl(color2);
           const valueDifference = Math.abs(hsl1.l - hsl2.l);
           const normalizedContrast = valueDifference / 100;
           const contrastScore = Math.pow(normalizedContrast, 0.7);
           return contrastScore;
         }
     }

     // ===== UNIVERSAL MATCHING SERVICE =====
     class UniversalMatchingService {
       constructor(logger) {
         this.logger = logger;
       }

       /**
        * Universal matching algorithm that works for any element type
        * @param {Array} elements - Array of elements to match against
        * @param {Object} targetElement - The element to find a match for
        * @param {Object} options - Matching options (tolerance, valueContrastWeight, etc.)
        * @returns {Object|null} - Best match or null
        */
       findBestMatch(elements, targetElement, options = {}) {
         const {
           edgeTolerance = CONFIG.PHASES.patchFormation.edgeTolerance,
           valueContrastWeight = CONFIG.PHASES.patchFormation.valueContrastWeight
         } = options;

         let bestMatch = null;
         let bestScore = Infinity;
         
         this.logger.log(`Universal matching: Finding best match for ${targetElement.type || 'element'} ${targetElement.id || 'unknown'} among ${elements.length} candidates`);
         
         for (let i = 0; i < elements.length; i++) {
           const element = elements[i];
           if (element === targetElement) continue;
           
           const targetEdges = targetElement.edges;
           const elementEdges = element.edges;
           
           const horizontalEdgeScore = this.calculateEdgeScore(targetEdges.right, elementEdges.left);
           const verticalEdgeScore = this.calculateEdgeScore(targetEdges.bottom, elementEdges.top);
           const valueContrastScore = this.calculateValueContrastScore(targetElement.color, element.color);
           const sameColorPenalty = targetElement.color === element.color ? 1.0 : 0;
           
           const horizontalScore = horizontalEdgeScore - valueContrastScore * valueContrastWeight + sameColorPenalty;
           const verticalScore = verticalEdgeScore - valueContrastScore * valueContrastWeight + sameColorPenalty;
           
           const score = Math.min(horizontalScore, verticalScore);
           const sameColor = targetElement.color === element.color;
           
           this.logger.log(`  Candidate ${i}: edge scores (H:${horizontalEdgeScore.toFixed(3)}, V:${verticalEdgeScore.toFixed(3)}), contrast:${valueContrastScore.toFixed(3)}, sameColor:${sameColor}, final score:${score.toFixed(3)}`);
           
           if (score < bestScore) {
             bestScore = score;
             bestMatch = {
               item: element,
               score: score,
               joinType: score === horizontalScore ? 'horizontal' : 'vertical',
               edgeScore: Math.min(horizontalEdgeScore, verticalEdgeScore),
               valueContrastScore: valueContrastScore
             };
             this.logger.log(`  New best match found with score ${score.toFixed(3)}`);
           }
         }
         
         this.logger.log(`Best match score: ${bestMatch ? bestMatch.score.toFixed(3) : 'none'}`);
         return bestMatch;
       }

       /**
        * Universal edge scoring algorithm
        */
       calculateEdgeScore(length1, length2) {
         const difference = Math.abs(length1 - length2);
         const averageLength = (length1 + length2) / 2;
         return difference / averageLength;
       }

       /**
        * Universal value contrast scoring
        */
       calculateValueContrastScore(color1, color2) {
         const hsl1 = Utils.hexToHsl(color1);
         const hsl2 = Utils.hexToHsl(color2);
         const valueDifference = Math.abs(hsl1.l - hsl2.l);
         const normalizedContrast = valueDifference / 100;
         const contrastScore = Math.pow(normalizedContrast, 0.7);
         return contrastScore;
       }

       /**
        * Universal element joining logic
        */
       combineElements(element1, element2, joinType) {
         let combinedWidth, combinedHeight, combinedX, combinedY;
         
         if (joinType === 'horizontal') {
           const targetLength = (element1.edges.right + element2.edges.left) / 2;
           const adjustedWidth1 = element1.width;
           const adjustedWidth2 = element2.width;
           
           combinedWidth = element1.width + adjustedWidth2;
           combinedHeight = Math.max(element1.height, element2.height);
           combinedX = element1.x;
           combinedY = Math.min(element1.y, element2.y);
         } else {
           const targetLength = (element1.edges.bottom + element2.edges.top) / 2;
           const adjustedHeight1 = element1.height;
           const adjustedHeight2 = element2.height;
           
           combinedWidth = Math.max(element1.width, element2.width);
           combinedHeight = element1.height + adjustedHeight2;
           combinedX = Math.min(element1.x, element2.x);
           combinedY = element1.y;
         }
         
         return {
           width: combinedWidth,
           height: combinedHeight,
           x: combinedX,
           y: combinedY
         };
       }

       /**
        * Universal element resizing for better edge alignment
        */
       resizeElementsForAlignment(element1, element2, joinType) {
         let resizedElement1 = { ...element1 };
         let resizedElement2 = { ...element2 };
         
         if (joinType === 'horizontal') {
           const targetHeight = Math.max(element1.height, element2.height);
           if (element1.height !== targetHeight) resizedElement1.height = targetHeight;
           if (element2.height !== targetHeight) resizedElement2.height = targetHeight;
         } else {
           const targetWidth = Math.max(element1.width, element2.width);
           if (element1.width !== targetWidth) resizedElement1.width = targetWidth;
           if (element2.width !== targetWidth) resizedElement2.width = targetWidth;
         }
         
         return { resizedElement1, resizedElement2 };
       }

                /**
          * Universal formation algorithm that works for any element type
          */
         formCompositeElements(elements, targetType, options = {}) {
           const {
             edgeTolerance = CONFIG.PHASES.patchFormation.edgeTolerance,
             valueContrastWeight = CONFIG.PHASES.patchFormation.valueContrastWeight,
             createCompositeFunction = null,
             maxMatches = Math.floor(elements.length / 2) // Default to half the elements
           } = options;

           const compositeElements = [];
           const unmatchedElements = [];
           const workingElements = [...elements];
           
           this.logger.log(`Universal formation: Starting with ${workingElements.length} elements to form ${targetType}, max matches: ${maxMatches}`);
           
           let matchesMade = 0;
           
           while (workingElements.length >= 2 && matchesMade < maxMatches) {
             const element1 = workingElements.shift();
             
             if (!element1) {
               this.logger.warn('Skipping null element1');
               continue;
             }
             
             const bestMatch = this.findBestMatch(workingElements, element1, { edgeTolerance, valueContrastWeight });
             
             // Use fallback mechanism like the current system
             if (matchesMade < maxMatches) {
               const element2 = bestMatch ? bestMatch.item : workingElements[0];
               if (!bestMatch) {
                 workingElements.splice(0, 1);
               } else {
                 workingElements.splice(workingElements.indexOf(element2), 1);
               }
               
               this.logger.log(`Creating composite: ${element1.type || 'element'} ${element1.id || 'unknown'} + ${element2.type || 'element'} ${element2.id || 'unknown'} (score: ${bestMatch ? bestMatch.score.toFixed(3) : 'fallback'})`);
               
               // Resize elements for better alignment
               const { resizedElement1, resizedElement2 } = this.resizeElementsForAlignment(element1, element2, bestMatch ? bestMatch.joinType : 'horizontal');
               
               // Combine elements
               const combined = this.combineElements(resizedElement1, resizedElement2, bestMatch ? bestMatch.joinType : 'horizontal');
               
               // Create composite element
               if (createCompositeFunction) {
                 const compositeElement = createCompositeFunction([resizedElement1, resizedElement2]);
                 if (compositeElement) {
                   compositeElement.x = combined.x;
                   compositeElement.y = combined.y;
                   compositeElement.width = combined.width;
                   compositeElement.height = combined.height;
                   compositeElements.push(compositeElement);
                 }
               }
               matchesMade++;
             } else {
               unmatchedElements.push(element1);
             }
           }
           
           // Handle remaining elements
           while (workingElements.length > 0) {
             unmatchedElements.push(workingElements.shift());
           }
           
           this.logger.log(`Universal formation summary: ${compositeElements.length} composite elements created, ${unmatchedElements.length} unmatched elements`);
           
           return {
             compositeElements,
             unmatchedElements
           };
         }
     }

     // ===== RENDERING SERVICE =====
     class RenderingService {
       constructor(logger, errorHandler) {
         this.logger = logger;
         this.errorHandler = errorHandler;
         this.quiltSVG = null;
         this.isInitialized = false;
       }

       initialize() {
         this.quiltSVG = document.getElementById('quilt');
         if (!this.quiltSVG) {
           throw new Error('Quilt SVG element not found');
         }
         this.isInitialized = true;
         this.logger.log('Rendering service initialized');
       }

       renderBlocks(state) {
         if (!this.isInitialized) {
           this.logger.warn('Rendering service not initialized');
           return;
         }
         
         if (!this.quiltSVG) {
           this.logger.warn('Quilt SVG not found');
           return;
         }

         // Check if time-based rendering is active - if so, don't interfere
         if (this.quiltSVG.getAttribute('data-time-based-active') === 'true') {
           this.logger.log('🚫 Skipping legacy renderBlocks - time-based rendering is active');
           return;
         }

         try {
           // Clear existing content
           this.quiltSVG.innerHTML = '';
           
           // Create SVG definitions
           this.createSVGDefinitions();
           
           // Add viewBox border for debugging
           this.addViewBoxBorder();
           
           // Render based on current phase
           this.renderByPhase(state);
           
           // Update UI
           this.updateUI(state);
           
           this.logger.render('elements', this.getTotalElements(state));
         } catch (error) {
           this.errorHandler.handleError(error, 'renderBlocks');
         }
       }

       createSVGDefinitions() {
         const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
         defs.innerHTML = `
           <filter id="organicEdges" x="0" y="0" width="200%" height="200%">
             <feTurbulence baseFrequency="0.015" numOctaves="2" result="turb"/>
             <feDisplacementMap in="SourceGraphic" in2="turb" scale="2"/>
           </filter>
           <filter id="userHighlight" x="0" y="0" width="200%" height="200%">
             <feGaussianBlur stdDeviation="3" result="blur"/>
             <feFlood flood-color="#FFD700" flood-opacity="0.6" result="glow"/>
             <feComposite in="glow" in2="blur" operator="in" result="glowBlur"/>
             <feMerge>
               <feMergeNode in="glowBlur"/>
               <feMergeNode in="SourceGraphic"/>
             </feMerge>
           </filter>`;
         this.quiltSVG.appendChild(defs);
       }

       addViewBoxBorder() {
         const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         border.setAttribute('x', '0');
         border.setAttribute('y', '0');
         border.setAttribute('width', '800');
         border.setAttribute('height', '800');
         border.setAttribute('fill', 'none');
         border.setAttribute('stroke', '#ff0000');
         border.setAttribute('stroke-width', '2');
         border.setAttribute('stroke-dasharray', '5,5');
         this.quiltSVG.appendChild(border);
       }

       renderByPhase(state) {
         this.logger.log(`🎨 renderByPhase called for phase: ${state.currentPhase}`);
         
         switch (state.currentPhase) {
           case 'collection':
             this.logger.log(`🎨 Rendering pieces in collection phase`);
             this.renderPieces(state.pieces);
             break;
           case 'patch-formation':
             this.logger.log(`🎨 Rendering patches in patch-formation phase`);
             this.renderPatches(state.patches);
             this.renderUnmatchedPieces(state.unmatchedPieces);
             break;
           case 'block-formation':
             this.logger.log(`🎨 Rendering blocks in block-formation phase`);
             this.renderBlockList(state.blocks);
             this.renderUnmatchedPieces(state.unmatchedPieces);
             this.renderUnmatchedPatches(state.unmatchedPatches);
             break;
           case 'quilt-formation':
             this.logger.log(`🎨 Rendering quilt in quilt-formation phase`);
             this.renderQuilt(state.quilt);
             break;
           default:
             this.logger.log(`🎨 Default case: rendering blocks`);
             this.renderBlockList(state.blocks);
         }
         
         this.logger.log(`🎨 renderByPhase completed for phase: ${state.currentPhase}`);
       }

       renderPieces(pieces) {
         pieces.forEach((piece, i) => {
           this.renderPiece(piece, i);
         });
       }

       renderPatches(patches) {
         patches.forEach((patch, i) => {
           this.renderPatch(patch, i);
         });
       }

       renderBlockList(blocks) {
         if (!blocks || !Array.isArray(blocks)) {
           this.logger.warn('No blocks to render');
           return;
         }
         blocks.forEach((block, i) => {
           this.renderBlock(block, i);
         });
       }

       renderBlocks(state) {
         if (!state || !state.currentPhase) {
           this.logger.warn('❌ State or currentPhase is undefined, using default phase');
           state = { currentPhase: 'collection' };
         }
         
         this.logger.log(`🎨 Starting renderBlocks for phase: ${state.currentPhase}`);
         
         if (!this.quiltSVG) {
           this.logger.error('❌ quiltSVG element not found!');
           return;
         }
         
         // Check if time-based rendering is active - if so, don't interfere
         if (this.quiltSVG.getAttribute('data-time-based-active') === 'true') {
           this.logger.log('🚫 Skipping legacy renderBlocks - time-based rendering is active');
           return;
         }
         
         this.logger.log(`🎨 Found quiltSVG element, clearing content`);
         this.quiltSVG.innerHTML = '';
         
         // Create SVG definitions
         this.createSVGDefinitions();
         
         // Add viewBox border for debugging
         this.addViewBoxBorder();
         
         // Render based on current phase
         this.renderByPhase(state);
         
         this.logger.log('✅ renderBlocks completed');
       }

       renderUnmatchedPieces(pieces) {
         if (pieces && pieces.length > 0) {
           pieces.forEach((piece, i) => {
             this.renderPiece(piece, i);
           });
         }
       }

       renderUnmatchedPatches(patches) {
         if (patches && patches.length > 0) {
           patches.forEach((patch, i) => {
             this.renderPatch(patch, i);
           });
         }
       }

       renderQuilt(state) {
         this.logger.log('🎨 renderQuilt called, delegating to renderBlocks');
         this.renderBlocks(state);
       }



       renderQuiltBlocks(quilt) {
         if (quilt && quilt.blocks) {
           quilt.blocks.forEach((quiltBlock, index) => {
             if (quiltBlock && quiltBlock.blocks) {
               quiltBlock.blocks.forEach((block, blockIndex) => {
                 this.renderBlock(block, blockIndex);
               });
             }
           });
         }
       }

       renderPiece(piece, index) {
         this.logger.log(`🎨 Rendering piece ${index}:`, piece);
         
         const pathData = this.createOrganicPath(piece);
         this.logger.log(`🎨 Created path data for piece ${index}`);
         
         const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
         path.setAttribute('d', pathData);
         path.setAttribute('fill', piece.color);
         
         // Apply filters
         if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
           this.logger.log(`🎨 Applying user highlight filter to piece ${index}`);
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.userHighlightFilter})`);
         } else {
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.organicEdgesFilter})`);
         }
         
         // Animate new pieces
         const isCurrentUserPiece = piece.userId === this.currentUserId;
         const isLatestSubmission = piece.submissionId === this.submissionCount;
         if (isCurrentUserPiece && isLatestSubmission) {
           this.logger.log(`🎨 Adding animation class to piece ${index}`);
           path.classList.add(CONFIG.RENDERING.animationClass);
         }
         
         this.quiltSVG.appendChild(path);
         this.logger.log(`✅ Piece ${index} rendered successfully`);
       }

       renderPatch(patch, index) {
         if (!patch || !patch.pieces || patch.pieces.length === 0) return;
         
         const piece1 = patch.pieces[0];
         const piece2 = patch.pieces[1];
         
         // Add organic jitter
         const jitterX = (Math.random() - 0.5) * 8;
         const jitterY = (Math.random() - 0.5) * 8;
         const jitteredPatchX = patch.x + jitterX;
         const jitteredPatchY = patch.y + jitterY;
         
         const isRotated = patch.rotation === 90;
         const effectiveWidth = isRotated ? patch.height : patch.width;
         const effectiveHeight = isRotated ? patch.width : patch.height;
         
         let positionedPiece1, positionedPiece2;
         
         if (effectiveWidth > effectiveHeight) {
           // Horizontal join
           const piece1Ratio = piece1.width / (piece1.width + piece2.width);
           const piece2Ratio = piece2.width / (piece1.width + piece2.width);
           const joinJitter = (Math.random() - 0.5) * 6;
           
           positionedPiece1 = {
             ...piece1,
             x: jitteredPatchX,
             y: jitteredPatchY,
             width: (effectiveWidth * piece1Ratio) + joinJitter,
             height: effectiveHeight + (Math.random() - 0.5) * 4
           };
           positionedPiece2 = {
             ...piece2,
             x: jitteredPatchX + (effectiveWidth * piece1Ratio) + joinJitter,
             y: jitteredPatchY,
             width: (effectiveWidth * piece2Ratio) - joinJitter,
             height: effectiveHeight + (Math.random() - 0.5) * 4
           };
         } else {
           // Vertical join
           const piece1Ratio = piece1.height / (piece1.height + piece2.height);
           const piece2Ratio = piece2.height / (piece1.height + piece2.height);
           const joinJitter = (Math.random() - 0.5) * 6;
           
           positionedPiece1 = {
             ...piece1,
             x: jitteredPatchX,
             y: jitteredPatchY,
             width: effectiveWidth + (Math.random() - 0.5) * 4,
             height: (effectiveHeight * piece1Ratio) + joinJitter
           };
           positionedPiece2 = {
             ...piece2,
             x: jitteredPatchX,
             y: jitteredPatchY + (effectiveHeight * piece1Ratio) + joinJitter,
             width: effectiveWidth + (Math.random() - 0.5) * 4,
             height: (effectiveHeight * piece2Ratio) - joinJitter
           };
         }
         
         [positionedPiece1, positionedPiece2].forEach((piece, pieceIndex) => {
           const pathData = this.createOrganicPath(piece);
           if (!pathData) return;
           
           const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
           path.setAttribute('d', pathData);
           path.setAttribute('fill', piece.color);
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.organicEdgesFilter})`);
           
           if (patch.rotation === 90) {
             const centerX = piece.x + piece.width / 2;
             const centerY = piece.y + piece.height / 2;
             path.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`);
           }
           
           if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
             path.setAttribute('filter', `url(#${CONFIG.RENDERING.userHighlightFilter})`);
           }
           
           const isCurrentUserPiece = piece.userId === this.currentUserId;
           const isLatestSubmission = piece.submissionId === this.submissionCount;
           if (isCurrentUserPiece && isLatestSubmission) {
             path.classList.add(CONFIG.RENDERING.animationClass);
           }
           
           this.quiltSVG.appendChild(path);
         });
       }

       renderBlock(block, index) {
         if (!block || !block.patches || block.patches.length === 0) return;
         
         const blockJitterX = (Math.random() - 0.5) * 8;
         const blockJitterY = (Math.random() - 0.5) * 8;
         const jitteredBlockX = block.x + blockJitterX;
         const jitteredBlockY = block.y + blockJitterY;
         
         if (block.patches.length >= 2) {
           const patch1 = block.patches[0];
           const patch2 = block.patches[1];
           
           let positionedPatch1, positionedPatch2;
           
           if (block.width > block.height) {
             // Horizontal join
             const patch1Ratio = patch1.width / (patch1.width + patch2.width);
             const patch2Ratio = patch2.width / (patch1.width + patch2.width);
             const joinJitter = (Math.random() - 0.5) * 6;
             
             positionedPatch1 = {
               ...patch1,
               x: jitteredBlockX,
               y: jitteredBlockY,
               width: (block.width * patch1Ratio) + joinJitter,
               height: block.height + (Math.random() - 0.5) * 4
             };
             positionedPatch2 = {
               ...patch2,
               x: jitteredBlockX + (block.width * patch1Ratio) + joinJitter,
               y: jitteredBlockY,
               width: (block.width * patch2Ratio) - joinJitter,
               height: block.height + (Math.random() - 0.5) * 4
             };
           } else {
             // Vertical join
             const patch1Ratio = patch1.height / (patch1.height + patch2.height);
             const patch2Ratio = patch2.height / (patch1.height + patch2.height);
             const joinJitter = (Math.random() - 0.5) * 6;
             
             positionedPatch1 = {
               ...patch1,
               x: jitteredBlockX,
               y: jitteredBlockY,
               width: block.width + (Math.random() - 0.5) * 4,
               height: (block.height * patch1Ratio) + joinJitter
             };
             positionedPatch2 = {
               ...patch2,
               x: jitteredBlockX,
               y: jitteredBlockY + (block.height * patch1Ratio) + joinJitter,
               width: block.width + (Math.random() - 0.5) * 4,
               height: (block.height * patch2Ratio) - joinJitter
             };
           }
           
           [positionedPatch1, positionedPatch2].forEach((patch, patchIndex) => {
             this.renderPatch(patch);
           });
         }
       }

       createOrganicPath(item) {
         if (!item || typeof item.x === 'undefined' || typeof item.y === 'undefined' || 
             typeof item.width === 'undefined' || typeof item.height === 'undefined') {
           this.logger.error('Invalid item for createOrganicPath:', item);
           return '';
         }
         
         const variation = CONFIG.QUILT.organicVariation;
         const x1 = item.x + (Math.random() - 0.5) * variation;
         const y1 = item.y + (Math.random() - 0.5) * variation;
         const x2 = item.x + item.width + (Math.random() - 0.5) * variation;
         const y2 = item.y + (Math.random() - 0.5) * variation;
         const x3 = item.x + item.width + (Math.random() - 0.5) * variation;
         const y3 = item.y + item.height + (Math.random() - 0.5) * variation;
         const x4 = item.x + (Math.random() - 0.5) * variation;
         const y4 = item.y + item.height + (Math.random() - 0.5) * variation;
         
         return `M ${x1},${y1} L ${x2},${y2} L ${x3},${y3} L ${x4},${y4} Z`;
       }

       updateUI(state) {
         // Update phase indicator and user counter
         // This will be handled by the main app
       }

                getTotalElements(state) {
           return (state.pieces ? state.pieces.length : 0) + 
                  (state.patches ? state.patches.length : 0) + 
                  (state.blocks ? state.blocks.length : 0) + 
                  (state.unmatchedPieces ? state.unmatchedPieces.length : 0) + 
                  (state.unmatchedPatches ? state.unmatchedPatches.length : 0);
         }
      }

      // ===== TIME-BASED QUILT ENGINE =====
      class TimeBasedQuiltEngine {
        constructor(logger, errorHandler) {
          this.logger = logger;
          this.errorHandler = errorHandler;
          this.colorAnalyzer = new ColorAnalyzer(logger);
          this.patternGenerator = new PatternGenerator(logger);
          this.transitionManager = new TransitionManager(logger);
          this.gridState = new GridState(logger);
          
          // Reorganization tracking
          this.colorsSinceReorganization = 0;
          this.reorganizationThreshold = 5;
          this.isReorganizing = false; // Prevent race conditions
          
          this.logger.log('TimeBasedQuiltEngine initialized');
        }

        getCurrentPhase() {
          // 🧪 TESTING MODE: Force specific phase for debugging
          // Comment/uncomment the phase you want to test:
          
          // return 'pattern_selection';  // 🧪 TEST: Pattern selection phase
          return 'collection';         // 🧪 TEST: Collection phase  
          // return 'pattern_filling';    // 🧪 TEST: Pattern filling phase
          // return 'finalization';       // 🧪 TEST: Finalization phase
          
          /* 🕐 TIME-BASED LOGIC (disabled for testing)
          const hour = new Date().getHours();
          
          if (hour >= 6 && hour < 12) return 'collection';
          if (hour >= 12 && hour < 18) return 'pattern_selection';
          if (hour >= 18 && hour < 24) return 'pattern_filling';
          return 'finalization';
          */
        }

        addColor(color) {
          // Reject new colors during reorganization to prevent race conditions
          if (this.isReorganizing) {
            this.logger.log(`🔒 Rejecting color ${color} - reorganization in progress`);
            return { success: false, reason: 'reorganization_in_progress' };
          }
          
          const phase = this.getCurrentPhase();
          this.logger.log(`Adding color ${color} in ${phase} phase`);
          
          let result;
          switch (phase) {
            case 'collection':
              result = this.addColorInCollectionPhase(color);
              break;
            case 'pattern_selection':
              result = this.addColorInPatternPhase(color);
              break;
            case 'pattern_filling':
              result = this.addColorInFillingPhase(color);
              break;
            case 'finalization':
              result = this.addColorInFinalizationPhase(color);
              break;
          }
          
          // Check if reorganization is needed (but NOT during collection phase)
          if (result.success) {
            this.colorsSinceReorganization++;
            const currentPhase = this.getCurrentPhase();
            
            if (currentPhase === 'collection') {
              this.logger.log(`🧵 Collection phase: keeping loose columns (${this.colorsSinceReorganization} colors added)`);
            } else if (this.colorsSinceReorganization >= this.reorganizationThreshold) {
              this.reorganizeQuilt();
              this.colorsSinceReorganization = 0;
            }
          }
          
          return result;
        }

        addColorInCollectionPhase(color) {
          // Place colors in quilter's workspace columns by color family
          const position = this.gridState.getNextScatterPosition(color);
          this.gridState.addColor(color, position);
          this.colorAnalyzer.analyzeColor(color);
          
          // Collection phase: Just collect and analyze - NO pattern selection yet!
          // Pattern selection will happen when phase transitions to 'pattern_selection'
          
          return { success: true, phase: 'collection', position };
        }

        addColorInPatternPhase(color) {
          // If pattern is already selected, process this color immediately (no queuing needed)
          if (this.patternGenerator.getCurrentPattern()) {
            const occupiedPositions = this.gridState.getOccupiedPositions();
            const position = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
            this.gridState.addColor(color, position);
            this.colorAnalyzer.analyzeColor(color); // Still analyze for ongoing insights
            return { success: true, phase: 'pattern_selection', position: position };
          }
          
          // No pattern yet - add to queue and continue analysis
          this.gridState.addColorToQueue(color);
          this.colorAnalyzer.analyzeColor(color);
          
          // Check if we should select pattern now
          if (this.colorAnalyzer.hasEnoughDataForPattern()) {
            this.triggerPatternSelection();
            // triggerPatternSelection() already processed ALL queued colors (including this one)
            // So we're done - don't process this color again
            return { success: true, phase: 'pattern_selection', processed_in_batch: true };
          }
          
          return { success: true, phase: 'pattern_selection', queued: true };
        }

        addColorInFillingPhase(color) {
          // Pattern is chosen, place optimally
          const occupiedPositions = this.gridState.getOccupiedPositions();
          const optimalPosition = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
          this.gridState.addColor(color, optimalPosition);
          return { success: true, phase: 'pattern_filling', position: optimalPosition };
        }

        addColorInFinalizationPhase(color) {
          // Accept colors throughout the night - no limit
          const occupiedPositions = this.gridState.getOccupiedPositions();
          const position = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
          this.gridState.addColor(color, position);
          return { success: true, phase: 'finalization', position };
        }

        triggerPatternSelection() {
          this.logger.log('Triggering pattern selection...');
          const analysis = this.colorAnalyzer.getAnalysis();
          const selectedPattern = this.patternGenerator.selectPattern(analysis);
          
          this.logger.log(`Selected pattern: ${selectedPattern}`);
          
          // Process any queued colors with the new pattern
          const queuedColors = this.gridState.getQueuedColors();
          this.logger.log(`Processing ${queuedColors.length} queued colors into ${selectedPattern} pattern`);
          
          queuedColors.forEach((color, index) => {
            const position = this.patternGenerator.getOptimalPosition(color);
            this.gridState.addColor(color, position);
            this.logger.log(`Placed queued color ${index + 1}/${queuedColors.length}: ${color} at position (${position.x}, ${position.y})`);
          });
          this.gridState.clearQueue();
          
          this.logger.log(`Pattern selection complete: ${this.gridState.getAllColors().length} colors now placed`);
          
          // Reorganize existing colors into pattern
          this.transitionManager.reorganizeToPattern(
            this.gridState.getAllColors(), 
            selectedPattern
          );
        }

        getState() {
          return {
            phase: this.getCurrentPhase(),
            colors: this.gridState.getAllColors(),
            queuedColors: this.gridState.getQueuedColors(),
            pattern: this.patternGenerator.getCurrentPattern(),
            analysis: this.colorAnalyzer.getAnalysis()
          };
        }
        
        reorganizeQuilt() {
          this.logger.log('🔄 Reorganizing quilt for optimal compactness...');
          
          // Set reorganization lock to prevent race conditions
          this.isReorganizing = true;
          this.logger.log('🔒 Reorganization lock ACQUIRED');
          
          // Get all current colors - PRESERVE EVERY SINGLE ONE
          const allColors = this.gridState.getAllColors();
          const queuedColors = this.gridState.getQueuedColors();
          const totalColors = [...allColors.map(c => c.color), ...queuedColors];
          
          // Keep ALL colors including duplicates - admin wants duplicate colors!
          if (totalColors.length === 0) {
            // Release lock even if no colors to reorganize
            this.isReorganizing = false;
            this.logger.log('🔓 Reorganization lock RELEASED (no colors)');
            return;
          }
          
          try {
            const originalCount = totalColors.length;
            this.logger.log(`📊 BEFORE: ${originalCount} total colors to reorganize (including duplicates)`);
            this.logger.log(`📊 Colors: [${totalColors.join(', ')}]`);
            
            // Clear current state
            this.gridState.clearAll();
            
            // Reset pattern and give it the FULL color set (including duplicates)
            this.patternGenerator.resetPatternWithColors(totalColors);
            
            // Re-add ALL colors (including duplicates) with proper position calculation
            this.logger.log(`🔄 Re-adding ${totalColors.length} total colors with atomic reorganization...`);
            totalColors.forEach((color, index) => {
              const occupiedPositions = this.gridState.getOccupiedPositions();
              const position = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
              this.gridState.addColor(color, position);
            });
            
            // SAFETY CHECK: Verify no colors were lost
            const finalColors = this.gridState.getAllColors();
            const finalCount = finalColors.length;
            
            if (finalCount !== originalCount) {
              this.logger.error(`🚨 COLOR LOSS DETECTED! Original: ${originalCount}, Final: ${finalCount}`);
              throw new Error('Color preservation failed during reorganization!');
            }
            
            this.logger.log(`✅ AFTER: ${finalCount} colors preserved - NO LOSSES!`);
            this.logger.log(`✨ Reorganized into compact formation - all contributions safe`);
          } catch (error) {
            this.logger.error('🚨 Reorganization failed:', error);
            throw error;
          } finally {
            // ALWAYS release reorganization lock, even if there's an error
            this.isReorganizing = false;
            this.logger.log('🔓 Reorganization lock RELEASED');
          }
        }
      }

      // ===== COLOR ANALYZER =====
      class ColorAnalyzer {
        constructor(logger) {
          this.logger = logger;
          this.colors = [];
          this.analysis = {
            hueDistribution: new Map(),
            saturationRange: { min: 100, max: 0 },
            lightnessRange: { min: 100, max: 0 },
            dominantTheme: null,
            hasContrasts: false,
            isMonochromatic: false
          };
        }

        analyzeColor(hexColor) {
          this.colors.push(hexColor);
          const hsl = this.hexToHsl(hexColor);
          
          // Update hue distribution
          const hueGroup = Math.floor(hsl.h / 30) * 30; // Group into 30-degree segments
          this.analysis.hueDistribution.set(hueGroup, 
            (this.analysis.hueDistribution.get(hueGroup) || 0) + 1
          );

          // Update ranges
          this.analysis.saturationRange.min = Math.min(this.analysis.saturationRange.min, hsl.s);
          this.analysis.saturationRange.max = Math.max(this.analysis.saturationRange.max, hsl.s);
          this.analysis.lightnessRange.min = Math.min(this.analysis.lightnessRange.min, hsl.l);
          this.analysis.lightnessRange.max = Math.max(this.analysis.lightnessRange.max, hsl.l);

          this.updateThemeAnalysis();
        }

        updateThemeAnalysis() {
          const hueGroups = Array.from(this.analysis.hueDistribution.keys());
          
          // Check if monochromatic (within 60 degrees)
          if (hueGroups.length <= 2) {
            this.analysis.isMonochromatic = true;
            this.analysis.dominantTheme = 'monochromatic';
          }
          
          // Check for warm/cool split
          const warmHues = hueGroups.filter(h => h >= 300 || h <= 60);
          const coolHues = hueGroups.filter(h => h > 60 && h < 300);
          
          if (warmHues.length > 0 && coolHues.length > 0) {
            this.analysis.dominantTheme = 'warm_cool_split';
          }

          // Check for high contrast
          const lightnessSpread = this.analysis.lightnessRange.max - this.analysis.lightnessRange.min;
          this.analysis.hasContrasts = lightnessSpread > 40;
        }

        hasEnoughDataForPattern() {
          // Need at least 3 colors for testing (was 8) or noon deadline
          const hour = new Date().getHours();
          return this.colors.length >= 3 || hour >= 12;
        }

        getAnalysis() {
          return { ...this.analysis };
        }

        hexToHsl(hex) {
          // Convert hex to HSL (simplified version)
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return { h: h * 360, s: s * 100, l: l * 100 };
        }
      }

      // ===== PATTERN GENERATOR =====
      class PatternGenerator {
        constructor(logger) {
          this.logger = logger;
          this.currentPattern = null;
          this.patternTemplates = {
            'spiral': new SpiralPattern(),
            'gradient_flow': new GradientPattern(),
            'radial': new RadialPattern(),
            'warm_cool_split': new SplitPattern(),
            'checkerboard': new CheckerboardPattern()
          };
        }

        selectPattern(analysis) {
          let selectedPattern;

          if (analysis.isMonochromatic) {
            selectedPattern = 'gradient_flow';
          } else if (analysis.dominantTheme === 'warm_cool_split') {
            selectedPattern = 'warm_cool_split';
          } else if (analysis.hasContrasts) {
            selectedPattern = 'checkerboard';
          } else if (analysis.hueDistribution.size > 4) {
            selectedPattern = 'spiral';
          } else {
            selectedPattern = 'radial';
          }

          this.currentPattern = selectedPattern;
          this.logger.log(`Pattern selected: ${selectedPattern} based on analysis`);
          return selectedPattern;
        }

        getOptimalPosition(color, occupiedPositions = new Set()) {
          if (!this.currentPattern) {
            // Auto-select a default pattern if none is chosen yet
            this.currentPattern = 'gradient_flow';
            this.logger.log(`🎯 Auto-selected gradient_flow pattern (no pattern was set)`);
          }
          return this.patternTemplates[this.currentPattern].getNextPosition(color, occupiedPositions);
        }

        canAcceptColor(color) {
          if (!this.currentPattern) return false;
          return this.patternTemplates[this.currentPattern].canAcceptMore();
        }

        getFinalizationPosition(color) {
          return this.patternTemplates[this.currentPattern].getAccentPosition(color);
        }

        getCurrentPattern() {
          return this.currentPattern;
        }
        
        resetPattern() {
          if (this.currentPattern) {
            // Create fresh instance of current pattern
            const PatternClass = this.patternTemplates[this.currentPattern].constructor;
            this.patternTemplates[this.currentPattern] = new PatternClass();
            this.logger.log(`Reset ${this.currentPattern} pattern for reorganization`);
          }
        }
        
        resetPatternWithColors(allColors) {
          if (this.currentPattern) {
            // Create fresh instance and pre-populate with all colors
            const PatternClass = this.patternTemplates[this.currentPattern].constructor;
            this.patternTemplates[this.currentPattern] = new PatternClass();
            this.patternTemplates[this.currentPattern].initializeWithColors(allColors);
            this.logger.log(`Reset ${this.currentPattern} pattern with ${allColors.length} colors for reorganization`);
          }
        }
      }

      // ===== GRID STATE =====
      class GridState {
        constructor(logger) {
          this.logger = logger;
          this.grid = new Map(); // position -> color
          this.colorQueue = [];
          this.maxSize = { width: 20, height: 20 };
          this.currentSize = { width: 1, height: 1 };
          
          // Collection phase: quilter's workspace with color family columns
          this.colorColumns = new Map(); // hue range -> column info
          this.columnSpacing = 1.2; // NO OVERLAP - spread columns to see available space
          this.nextColumnX = 0; // Track where to place next new column
        }

        addColor(color, position) {
          const key = `${position.x},${position.y}`;
          
          // Check for position collisions (warn but allow)
          if (this.grid.has(key)) {
            const existing = this.grid.get(key);
            this.logger.log(`⚠️ Position collision at (${position.x}, ${position.y}): replacing ${existing.color} with ${color}`);
          }
          
          this.grid.set(key, { color, position, timestamp: Date.now() });
          this.expandIfNeeded(position);
        }

        addColorToQueue(color) {
          this.colorQueue.push(color);
        }

        getQueuedColors() {
          return [...this.colorQueue];
        }

        clearQueue() {
          this.colorQueue = [];
        }

        getNextScatterPosition(color = null) {
          if (!color) {
            // Fallback for when no color is provided
            const x = Math.floor(Math.random() * this.currentSize.width);
            const y = Math.floor(Math.random() * this.currentSize.height);
            return { x, y };
          }
          
          // Quilter's workspace: stack colors in family columns
          return this.getColorFamilyPosition(color);
        }
        
        getColorFamilyPosition(color) {
          const hue = this.getColorHue(color);
          const saturation = this.getColorSaturation(color);
          
          // Override to neutrals if saturation is very low (grays, whites, blacks)
          let colorFamily;
          if (saturation < 15) { // Less than 15% saturation = neutral
            colorFamily = 'neutrals';
          } else {
            colorFamily = this.getColorFamily(hue);
          }
          
          // Find or create column for this color family
          let column = this.colorColumns.get(colorFamily);
          
          if (!column) {
            // Create new column for this color family
            column = {
              family: colorFamily,
              x: this.nextColumnX,
              colors: [],
              stackHeight: 0
            };
            this.colorColumns.set(colorFamily, column);
            this.nextColumnX += this.columnSpacing;
            this.logger.log(`🎨 Created new color family column: ${colorFamily} at x=${column.x}`);
          }
          
          // Add color to this column's stack
          const stackPosition = column.colors.length;
          
          // Create gentle organic stacking with slight offsets (reduced for tight columns)
          const offsetX = (Math.random() - 0.5) * 0.3; // Minimal horizontal jitter for tight spacing
          const offsetY = (Math.random() - 0.5) * 0.3; // Minimal vertical jitter
          
          // Adaptive overlap: more overlap as columns get longer (mobile-friendly)
          const totalInColumn = column.colors.length + 1; // Including the one we're adding
          let overlapFactor;
          
          if (totalInColumn <= 3) {
            overlapFactor = 0.75; // 75% overlap - gentle stacking for short columns
          } else if (totalInColumn <= 6) {
            overlapFactor = 0.6; // 60% overlap - more compression for medium columns
          } else if (totalInColumn <= 10) {
            overlapFactor = 0.45; // 45% overlap - significant compression for mobile
          } else if (totalInColumn <= 15) {
            overlapFactor = 0.3; // 30% overlap - heavy compression for tall columns
          } else {
            overlapFactor = 0.2; // 20% overlap - maximum compression for very tall mobile columns
          }
          
          // Calculate position relative to previous block to avoid gaps
          let yPosition;
          if (stackPosition === 0) {
            // First block in column
            yPosition = 0 + offsetY;
          } else {
            // Position relative to previous block's actual position
            const previousBlock = column.colors[stackPosition - 1];
            const spacing = 1 - overlapFactor; // How much space between blocks
            yPosition = previousBlock.position.y + spacing + offsetY;
          }
          
          const position = {
            x: column.x + offsetX,
            y: yPosition,
            stackLevel: stackPosition,
            colorFamily: colorFamily,
            isStacked: true,
            overlapFactor: overlapFactor // Store for debugging
          };
          
          column.colors.push({ color, position });
          column.stackHeight = Math.max(column.stackHeight, position.y + 1);
          
          this.logger.log(`📚 Stacked ${color} in ${colorFamily} column (level ${stackPosition}, ${Math.round(overlapFactor * 100)}% overlap, y=${yPosition.toFixed(1)}) - continuous stacking`);
          
          if (totalInColumn > 6) {
            this.logger.log(`📱 Mobile optimization: High overlap (${Math.round(overlapFactor * 100)}%) for tall ${colorFamily} column (${totalInColumn} blocks)`);
          }
          
          return position;
        }
        
        getColorHue(hexColor) {
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;

          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return h * 360; // Convert to degrees
        }
        
        getColorSaturation(hexColor) {
          // Convert hex to RGB
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;
          
          // Calculate saturation
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const delta = max - min;
          
          if (max === 0) return 0; // Black
          return (delta / max) * 100; // Return as percentage
        }
        
        getColorFamily(hue) {
          // First check if this is a neutral color (low saturation)
          // Note: This function only gets hue, so we need to check saturation in getColorFamilyPosition
          
          // Define color families based on hue ranges
          if (hue >= 345 || hue < 15) return 'reds';
          if (hue >= 15 && hue < 45) return 'oranges';
          if (hue >= 45 && hue < 75) return 'yellows';
          if (hue >= 75 && hue < 165) return 'greens';
          if (hue >= 165 && hue < 255) return 'blues';
          if (hue >= 255 && hue < 285) return 'purples';
          if (hue >= 285 && hue < 345) return 'magentas';
          return 'neutrals'; // Fallback for edge cases
        }

        getAllColors() {
          return Array.from(this.grid.values());
        }

        getOccupiedPositions() {
          return new Set(this.grid.keys());
        }

        expandIfNeeded(position) {
          this.currentSize.width = Math.max(this.currentSize.width, position.x + 2);
          this.currentSize.height = Math.max(this.currentSize.height, position.y + 2);
        }
        
        clearAll() {
          this.grid.clear();
          this.colorQueue = [];
          this.currentSize = { width: 1, height: 1 };
          
          // Reset collection phase workspace
          this.colorColumns.clear();
          this.nextColumnX = 0;
        }
      }

      // ===== TRANSITION MANAGER =====
      class TransitionManager {
        constructor(logger) {
          this.logger = logger;
        }

        reorganizeToPattern(colors, patternName) {
          this.logger.log(`Reorganizing ${colors.length} colors to ${patternName} pattern`);
          // TODO: Implement smooth transitions between scattered and organized layouts
          // This will involve CSS animations and position calculations
        }
      }

      // ===== PATTERN TEMPLATES =====
      class SpiralPattern {
        constructor() {
          this.center = { x: 10, y: 10 };
          this.currentRadius = 1;
          this.currentAngle = 0;
          this.positionsUsed = 0;
        }

        initializeWithColors(allColors) {
          // Simple initialization for spiral - positions are calculated sequentially
          this.positionsUsed = 0;
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          // Spiral pattern is inherently sequential, works for both modes
          const angle = this.currentAngle;
          const x = this.center.x + Math.round(this.currentRadius * Math.cos(angle));
          const y = this.center.y + Math.round(this.currentRadius * Math.sin(angle));
          
          this.currentAngle += 0.5; // Spiral outward
          if (this.currentAngle > Math.PI * 2) {
            this.currentAngle = 0;
            this.currentRadius += 1;
          }
          
          this.positionsUsed++;
          return { x, y };
        }

        canAcceptMore() {
          return this.positionsUsed < 100; // Arbitrary limit
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }
      }

      class GradientPattern {
        constructor() {
          this.placedColors = [];
          this.sortedColors = [];
          this.totalExpectedColors = 0;
        }

        initializeWithColors(allColors) {
          // Pre-sort ALL colors by hue for proper organization
          this.sortedColors = this.sortColorsByHue([...allColors]);
          this.totalExpectedColors = allColors.length;
          this.placedColors = []; // Track which we've placed so far
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          // Add this color to placed list
          this.placedColors.push(color);
          
          console.log(`🎨 GradientPattern.getNextPosition(${color})`);
          console.log(`- placedColors now: ${this.placedColors.length} [${this.placedColors.join(', ')}]`);
          console.log(`- sortedColors: ${this.sortedColors.length} [${this.sortedColors.join(', ')}]`);
          console.log(`- totalExpectedColors: ${this.totalExpectedColors}`);
          console.log(`- occupiedPositions: [${Array.from(occupiedPositions).join('], [')}]`);
          
          // If this is a reorganization (pattern was pre-initialized)
          if (this.sortedColors.length > 0 && this.totalExpectedColors > 0) {
            console.log(`📐 Using reorganization mode`);
            // Find where this color should go in the pre-sorted order
            const colorIndex = this.sortedColors.findIndex(c => c === color);
            console.log(`- colorIndex in sorted array: ${colorIndex}`);
            
            // If color not found in sorted array, it's a new color added after reorganization
            if (colorIndex === -1) {
              console.log(`➕ Adding new color to sorted array for smart placement`);
              // Add the new color to sortedColors in the right position (by hue)
              const newColorHue = this.getHue(color);
              let insertIndex = this.sortedColors.length;
              for (let i = 0; i < this.sortedColors.length; i++) {
                const existingHue = this.getHue(this.sortedColors[i]);
                if (newColorHue < existingHue) {
                  insertIndex = i;
                  break;
                }
              }
              this.sortedColors.splice(insertIndex, 0, color);
              this.totalExpectedColors++;
              console.log(`- inserted at index ${insertIndex}, new total: ${this.totalExpectedColors}`);
              
              // Find the next available position using actual occupied positions
              const gridSize = Math.ceil(Math.sqrt(this.totalExpectedColors));
              console.log(`- smart placement: finding available position in ${gridSize}x${gridSize} grid`);
              
              // Find first available position in the new grid
              for (let i = 0; i < gridSize * gridSize; i++) {
                const x = i % gridSize;
                const y = Math.floor(i / gridSize);
                const posKey = `${x},${y}`;
                
                if (!occupiedPositions.has(posKey)) {
                  console.log(`- found available position: (${x}, ${y})`);
                  return { x, y };
                }
              }
              
              // Fallback: expand grid if all positions filled
              console.log(`- fallback: expanding to (${gridSize}, 0)`);
              return { x: gridSize, y: 0 };
            }
            
            // Calculate grid size based on TOTAL expected colors
            const gridSize = Math.ceil(Math.sqrt(this.totalExpectedColors));
            
            // Calculate position based on sorted index in the complete grid
            const x = colorIndex % gridSize;
            const y = Math.floor(colorIndex / gridSize);
            
            console.log(`- reorganization: colorIndex=${colorIndex}, grid=${gridSize} → (${x}, ${y})`);
            console.log(`- checking if position (${x},${y}) is occupied: ${occupiedPositions.has(`${x},${y}`)}`);
            
            // During reorganization, positions SHOULD be deterministic and collision-free
            // But if there's a collision, find the next available position
            if (occupiedPositions.has(`${x},${y}`)) {
              console.warn(`⚠️ REORGANIZATION COLLISION: Position (${x},${y}) occupied, finding alternative...`);
              
              // Find the next available position in the grid
              const maxPositions = gridSize * gridSize * 2; // Prevent infinite loop
              for (let offset = 1; offset < maxPositions; offset++) {
                const altIndex = colorIndex + offset;
                const altX = altIndex % gridSize;
                const altY = Math.floor(altIndex / gridSize);
                const altKey = `${altX},${altY}`;
                
                if (!occupiedPositions.has(altKey)) {
                  console.log(`✅ Found alternative position: (${altX}, ${altY}) for color ${color}`);
                  return { x: altX, y: altY };
                }
              }
              
              // If we still can't find a spot, expand the grid
              console.log(`🔄 No space in ${gridSize}x${gridSize} grid, expanding...`);
              return { x: gridSize, y: 0 };
            }
            
            return { x, y };
          } else {
            console.log(`📍 Using sequential mode`);
            // For normal operation, place sequentially to avoid collisions
            // Reorganization will sort them later
            const colorCount = this.placedColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(colorCount)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, colorCount - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            console.log(`- sequential: count=${colorCount}, grid=${gridSize}, index=${index} → (${x}, ${y})`);
            return { x, y };
          }
        }

        sortColorsByHue(colors) {
          return colors.sort((a, b) => {
            const hueA = this.getHue(a);
            const hueB = this.getHue(b);
            return hueA - hueB;
          });
        }

        getHue(hexColor) {
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;

          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return h * 360; // Return hue in degrees
        }

        canAcceptMore() {
          return true; // No limit - expand as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }

        // When we need to reposition all colors (for transitions)
        repositionAllColors() {
          const sortedColors = this.sortColorsByHue([...this.placedColors]);
          const positions = [];
          
          sortedColors.forEach((color, index) => {
            const x = index % this.gridWidth;
            const y = Math.floor(index / this.gridWidth);
            positions.push({ color, position: { x, y } });
          });
          
          return positions;
        }
      }

      class RadialPattern {
        constructor() {
          this.center = { x: 8, y: 6 };
          this.placedColors = [];
          this.maxRadius = 6;
          this.sortedColors = [];
          this.totalExpectedColors = 0;
        }

        initializeWithColors(allColors) {
          this.sortedColors = this.sortColorsByVibrancy([...allColors]);
          this.totalExpectedColors = allColors.length;
          this.placedColors = [];
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          this.placedColors.push(color);
          
          // If this is a reorganization (pattern was pre-initialized)
          if (this.sortedColors.length > 0 && this.totalExpectedColors > 0) {
            const colorIndex = this.sortedColors.findIndex(c => c === color);
            
            if (colorIndex === 0) {
              // Most vibrant color goes in center
              return this.center;
            }
            
            // Calculate ring and position on ring based on vibrancy ranking
            const ringIndex = Math.ceil(Math.sqrt(colorIndex));
            const colorsInThisRing = this.getColorsInRing(this.sortedColors, ringIndex);
            const positionInRing = colorsInThisRing.findIndex(c => c === color);
            
            // Calculate angle based on position in ring
            const colorsOnRing = Math.max(6, ringIndex * 6); // More positions on outer rings
            const angle = (2 * Math.PI * positionInRing) / colorsOnRing;
            
            const x = this.center.x + Math.round(ringIndex * Math.cos(angle));
            const y = this.center.y + Math.round(ringIndex * Math.sin(angle));
            
            // Check for collision and find alternative if needed
            const posKey = `${x},${y}`;
            if (occupiedPositions.has(posKey)) {
              console.warn(`⚠️ RADIAL COLLISION: Position (${x},${y}) occupied, finding alternative...`);
              
              // Try nearby positions in expanding spiral
              for (let radius = 1; radius <= 10; radius++) {
                for (let angleOffset = 0; angleOffset < 2 * Math.PI; angleOffset += Math.PI / 4) {
                  const altX = Math.max(0, Math.round(x + radius * Math.cos(angleOffset))); // Prevent negative
                  const altY = Math.max(0, Math.round(y + radius * Math.sin(angleOffset))); // Prevent negative
                  const altKey = `${altX},${altY}`;
                  
                  if (!occupiedPositions.has(altKey)) {
                    console.log(`✅ Found alternative radial position: (${altX}, ${altY}) for color ${color}`);
                    return { x: altX, y: altY };
                  }
                }
              }
              
              // Ultimate fallback: extend outward (but keep reasonable bounds)
              console.log(`🔄 No nearby space, extending outward...`);
              const fallbackX = Math.max(0, Math.min(x + 10, 50)); // Keep within reasonable bounds
              const fallbackY = Math.max(0, Math.min(y, 50));
              return { x: fallbackX, y: fallbackY };
            }
            
            return { x, y };
          } else {
            // For normal operation, place sequentially to avoid collisions
            const colorCount = this.placedColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(colorCount)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, colorCount - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            return { x, y };
          }
        }

        sortColorsByVibrancy(colors) {
          return colors.sort((a, b) => {
            const vibrancyA = this.getVibrancy(a);
            const vibrancyB = this.getVibrancy(b);
            return vibrancyB - vibrancyA; // Most vibrant first
          });
        }

        getVibrancy(hexColor) {
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const saturation = max === 0 ? 0 : (max - min) / max;
          const brightness = max;
          
          // Combine saturation and brightness for vibrancy
          return saturation * 0.7 + brightness * 0.3;
        }

        getColorsInRing(sortedColors, ringIndex) {
          const startIndex = ringIndex === 1 ? 1 : Math.pow(ringIndex - 1, 2);
          const endIndex = Math.pow(ringIndex, 2);
          return sortedColors.slice(startIndex, endIndex + 1);
        }

        canAcceptMore() {
          return true; // No limit - expand rings as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }
      }

      class SplitPattern {
        constructor() {
          this.warmColors = [];
          this.coolColors = [];
          this.gridWidth = 8;
          this.gridHeight = 10;
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          const hsl = this.hexToHsl(color);
          const isWarm = this.isWarmColor(hsl);
          
          // Add to appropriate list
          if (isWarm) {
            this.warmColors.push(color);
          } else {
            this.coolColors.push(color);
          }
          
          // For normal operation, place sequentially to avoid collisions
          if (this.sortedWarmColors.length === 0 && this.sortedCoolColors.length === 0) {
            const totalPlaced = this.warmColors.length + this.coolColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(totalPlaced)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, totalPlaced - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            return { x, y };
          } else {
            // Reorganization mode - use proper warm/cool split pattern
            if (isWarm) {
              const colorIndex = this.sortedWarmColors.findIndex(c => c === color);
              const warmGridSize = Math.ceil(Math.sqrt(this.sortedWarmColors.length));
              const x = colorIndex % warmGridSize;
              const y = Math.floor(colorIndex / warmGridSize);
              
              // Check for collision and find alternative if needed
              const posKey = `${x},${y}`;
              if (occupiedPositions.has(posKey)) {
                console.warn(`⚠️ WARM SPLIT COLLISION: Position (${x},${y}) occupied, finding alternative...`);
                
                // Find next available position in warm side
                for (let offset = 1; offset < warmGridSize * warmGridSize; offset++) {
                  const altIndex = colorIndex + offset;
                  const altX = altIndex % warmGridSize;
                  const altY = Math.floor(altIndex / warmGridSize);
                  const altKey = `${altX},${altY}`;
                  
                  if (!occupiedPositions.has(altKey)) {
                    console.log(`✅ Found alternative warm position: (${altX}, ${altY}) for color ${color}`);
                    return { x: altX, y: altY };
                  }
                }
                
                // Fallback: expand warm grid
                console.log(`🔄 Expanding warm grid for color ${color}`);
                return { x: warmGridSize, y: 0 };
              }
              
              return { x, y }; // Left side
            } else {
              const colorIndex = this.sortedCoolColors.findIndex(c => c === color);
              const coolGridSize = Math.ceil(Math.sqrt(this.sortedCoolColors.length));
              const totalGridSize = Math.max(Math.ceil(Math.sqrt(this.sortedWarmColors.length)), coolGridSize);
              
              const x = (colorIndex % coolGridSize) + totalGridSize + 1; // Right side with gap
              const y = Math.floor(colorIndex / coolGridSize);
              
              // Check for collision and find alternative if needed
              const posKey = `${x},${y}`;
              if (occupiedPositions.has(posKey)) {
                console.warn(`⚠️ COOL SPLIT COLLISION: Position (${x},${y}) occupied, finding alternative...`);
                
                // Find next available position in cool side
                for (let offset = 1; offset < coolGridSize * coolGridSize; offset++) {
                  const altIndex = colorIndex + offset;
                  const altX = (altIndex % coolGridSize) + totalGridSize + 1;
                  const altY = Math.floor(altIndex / coolGridSize);
                  const altKey = `${altX},${altY}`;
                  
                  if (!occupiedPositions.has(altKey)) {
                    console.log(`✅ Found alternative cool position: (${altX}, ${altY}) for color ${color}`);
                    return { x: altX, y: altY };
                  }
                }
                
                // Fallback: expand cool grid
                console.log(`🔄 Expanding cool grid for color ${color}`);
                return { x: totalGridSize + coolGridSize + 1, y: 0 };
              }
              
              return { x, y };
            }
          }
        }

        isWarmColor(hsl) {
          // More nuanced warm/cool detection
          if (hsl.h >= 315 || hsl.h <= 45) return true; // Reds, oranges
          if (hsl.h >= 45 && hsl.h <= 90) return true; // Yellows
          return false; // Blues, greens, purples are cool
        }

        sortWarmColors(colors) {
          return colors.sort((a, b) => {
            const hueA = this.hexToHsl(a).h;
            const hueB = this.hexToHsl(b).h;
            
            // Sort reds → oranges → yellows
            const warmOrderA = hueA <= 45 ? hueA + 360 : hueA; // Put reds at end
            const warmOrderB = hueB <= 45 ? hueB + 360 : hueB;
            
            return warmOrderA - warmOrderB;
          });
        }

        sortCoolColors(colors) {
          return colors.sort((a, b) => {
            const hueA = this.hexToHsl(a).h;
            const hueB = this.hexToHsl(b).h;
            
            // Sort greens → blues → purples
            return hueA - hueB;
          });
        }

        initializeWithColors(allColors) {
          // Basic initialization - split patterns handle colors as they come
          this.warmColors = [];
          this.coolColors = [];
        }

        canAcceptMore() {
          return true; // No limit - expand sides as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }

        hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;
          
          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          
          return { h: h * 360 };
        }
      }

      class CheckerboardPattern {
        constructor() {
          this.lightColors = [];
          this.darkColors = [];
          this.gridWidth = 16;
          this.gridHeight = 10;
          this.placed = new Set(); // Track which positions are filled
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          const hsl = this.hexToHsl(color);
          const isColorDark = hsl.l < 50;
          
          // Add to appropriate list
          if (isColorDark) {
            this.darkColors.push(color);
          } else {
            this.lightColors.push(color);
          }
          
          // For normal operation, place sequentially to avoid collisions
          if (this.sortedLightColors.length === 0 && this.sortedDarkColors.length === 0) {
            const totalPlaced = this.lightColors.length + this.darkColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(totalPlaced)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, totalPlaced - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            return { x, y };
          } else {
            // Reorganization mode - use proper checkerboard pattern
            if (isColorDark) {
              return this.findBestDarkPosition(occupiedPositions);
            } else {
              return this.findBestLightPosition(occupiedPositions);
            }
          }
        }

        findBestDarkPosition(occupiedPositions = new Set()) {
          // Calculate dynamic grid size based on total colors
          const totalColors = this.lightColors.length + this.darkColors.length;
          const gridSize = Math.ceil(Math.sqrt(totalColors));
          
          // Find next available dark square (even sum of coordinates)
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const posKey = `${x},${y}`;
              const shouldBeDark = (x + y) % 2 === 0;
              
              if (shouldBeDark && !this.placed.has(posKey) && !occupiedPositions.has(posKey)) {
                this.placed.add(posKey);
                return { x, y };
              }
            }
          }
          
          // Fallback: find any available position
          return this.findAnyAvailablePosition(occupiedPositions);
        }

        findBestLightPosition(occupiedPositions = new Set()) {
          // Calculate dynamic grid size based on total colors
          const totalColors = this.lightColors.length + this.darkColors.length;
          const gridSize = Math.ceil(Math.sqrt(totalColors));
          
          // Find next available light square (odd sum of coordinates)
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const posKey = `${x},${y}`;
              const shouldBeLight = (x + y) % 2 === 1;
              
              if (shouldBeLight && !this.placed.has(posKey) && !occupiedPositions.has(posKey)) {
                this.placed.add(posKey);
                return { x, y };
              }
            }
          }
          
          // Fallback: find any available position
          return this.findAnyAvailablePosition(occupiedPositions);
        }

        findAnyAvailablePosition(occupiedPositions = new Set()) {
          const totalColors = this.lightColors.length + this.darkColors.length;
          const gridSize = Math.ceil(Math.sqrt(totalColors));
          
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const posKey = `${x},${y}`;
              if (!this.placed.has(posKey) && !occupiedPositions.has(posKey)) {
                this.placed.add(posKey);
                return { x, y };
              }
            }
          }
          
          // Expand grid if needed
          const expandedSize = gridSize + 1;
          const posKey = `0,${gridSize}`;
          this.placed.add(posKey);
          return { x: 0, y: gridSize };
        }

        initializeWithColors(allColors) {
          // Basic initialization for checkerboard
          this.lightColors = [];
          this.darkColors = [];
          this.placed = new Set();
        }

        canAcceptMore() {
          return true; // No limit - expand checkerboard as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }

        hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          
          return { h: h * 360, s: s * 100, l: l * 100 };
        }
      }

      // ===== TESTING FUNCTIONS =====
      // Expose multiple test functions to global scope for debugging
      globalThis.testBasicClasses = function() {
        console.log('🧪 Testing basic class availability...');
        
        try {
          console.log('Logger available:', typeof Logger);
          console.log('ErrorHandler available:', typeof ErrorHandler);
          console.log('TimeBasedQuiltEngine available:', typeof TimeBasedQuiltEngine);
          console.log('ColorAnalyzer available:', typeof ColorAnalyzer);
          console.log('PatternGenerator available:', typeof PatternGenerator);
          return '✅ All classes available';
        } catch (error) {
          console.error('❌ Error testing classes:', error);
          return '❌ Class test failed';
        }
      };

      globalThis.testTimeBasedEngine = function() {
        console.log('🧪 Testing TimeBasedQuiltEngine...');
        
        try {
          const logger = new Logger(true);
          const errorHandler = new ErrorHandler(null, logger);
          const engine = new TimeBasedQuiltEngine(logger, errorHandler);
          
          console.log('✅ Engine created successfully');
          
          // Test color analysis
          const testColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
          
          console.log('📊 Testing color analysis...');
          testColors.forEach((color, i) => {
            const result = engine.addColor(color);
            console.log(`Color ${i + 1} (${color}): ${result.phase} phase, position:`, result.position);
          });
          
          // Test pattern selection
          console.log('🎨 Testing pattern selection...');
          const state = engine.getState();
          console.log('Engine state:', state);
          console.log('Pattern selected:', state.pattern);
          console.log('Color analysis:', state.analysis);
          
          console.log('✅ TimeBasedQuiltEngine test complete!');
          return engine;
        } catch (error) {
          console.error('❌ TimeBasedEngine test failed:', error);
          return '❌ Test failed';
        }
      };

      // Add a simple marker to verify this code loaded
      globalThis.testCodeLoaded = function() {
        return '✅ Test code is loaded and accessible!';
      };

      // Expose classes globally for testing
      globalThis.Logger = Logger;
      globalThis.ErrorHandler = ErrorHandler;
      globalThis.TimeBasedQuiltEngine = TimeBasedQuiltEngine;
      globalThis.ColorAnalyzer = ColorAnalyzer;
      globalThis.PatternGenerator = PatternGenerator;

      // Global test function for the integrated system
      globalThis.testIntegratedSystem = function() {
        console.log('🧪 Testing integrated TimeBasedEngine system...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          // Test adding a color through the integrated system
          const testColor = '#' + Math.floor(Math.random()*16777215).toString(16);
          console.log(`🎨 Adding test color: ${testColor}`);
          
          const result = window.app.timeBasedEngine.addColor(testColor);
          console.log('✅ Color added via integrated engine:', result);
          
          // Sync state and render
          window.app.syncEngineStateToLegacyState();
          window.app.renderTimeBasedQuilt();
          
          // Show engine state
          const engineState = window.app.timeBasedEngine.getState();
          console.log('🎨 Current engine state:');
          console.log('- Phase:', engineState.phase);
          console.log('- Pattern:', engineState.pattern);
          console.log('- Colors placed:', engineState.colors.length);
          console.log('- Colors queued:', engineState.queuedColors.length);
          console.log('- Analysis:', engineState.analysis);
          
          return '✅ Integrated system test complete!';
        } catch (error) {
          console.error('❌ Integrated test failed:', error);
          return '❌ Test failed';
        }
      };
      
      // Reset the quilt for clean testing
      globalThis.resetQuilt = function() {
        console.log('🔄 Resetting quilt for clean testing...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        // Create fresh engine
        window.app.timeBasedEngine = new TimeBasedQuiltEngine(window.app.logger, window.app.errorHandler);
        console.log('✅ Fresh quilt engine created');
        
        const state = window.app.timeBasedEngine.getState();
        console.log(`State: Phase: ${state.phase}, Colors: ${state.colors.length}, Queued: ${state.queuedColors.length}, Pattern: ${state.pattern}`);
        
        return '✅ Reset complete!';
      };

      // Test single color addition
      globalThis.testSingleColor = function() {
        console.log('🧪 Testing single color addition...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          const state = window.app.timeBasedEngine.getState();
          console.log(`🎯 Current phase: ${state.phase}`);
          
          const color = '#ff0000';
          console.log(`Adding single color: ${color}`);
          
          const result = window.app.timeBasedEngine.addColor(color);
          console.log(`Result:`, result);
          
          const newState = window.app.timeBasedEngine.getState();
          console.log(`After: Phase: ${newState.phase}, Colors: ${newState.colors.length}, Queued: ${newState.queuedColors.length}, Pattern: ${newState.pattern}`);
          
          return '✅ Single color test complete!';
        } catch (e) {
          console.error('❌ Single color test failed:', e);
          return '❌ Test failed';
        }
      };

      // Test specific phase behavior
      globalThis.testCurrentPhase = function() {
        console.log('🧪 Testing current phase behavior...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          const state = window.app.timeBasedEngine.getState();
          console.log(`🎯 Current phase: ${state.phase}`);
          console.log('Adding colors one by one to avoid reorganization trigger...');
          
          const colors = ['#ff0000', '#ff8000', '#ffff00'];
          
          colors.forEach((color, index) => {
            console.log(`\n=== Adding Color ${index + 1}: ${color} ===`);
            const result = window.app.timeBasedEngine.addColor(color);
            console.log(`Result:`, result);
            
            window.app.syncEngineStateToLegacyState();
            window.app.renderTimeBasedQuilt();
            
            const newState = window.app.timeBasedEngine.getState();
            console.log(`Phase: ${newState.phase}, Colors: ${newState.colors.length}, Queued: ${newState.queuedColors.length}, Pattern: ${newState.pattern}`);
          });
          
          return '✅ Phase test complete!';
        } catch (e) {
          console.error('❌ Phase test failed:', e);
          return '❌ Test failed';
        }
      };
      
      // Test reorganization system with color preservation and position tracking
      globalThis.testReorganization = function() {
        console.log('🔄 Testing reorganization system with ZERO color loss...');
        console.log('🎯 Also checking for position collisions!');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          console.log('Adding colors to trigger reorganization at every 5th color...');
          console.log('🛡️ IMPORTANT: Every single color will be preserved with unique positions!');
          
          const colors = ['#ff0000', '#ff8000', '#ffff00', '#80ff00', '#00ff00', '#00ff80', '#00ffff', '#0080ff'];
          let totalAdded = 0;
          
          colors.forEach((color, index) => {
            console.log(`\nAdding color ${index + 1}: ${color}`);
            const beforeState = window.app.timeBasedEngine.getState();
            const beforeCount = beforeState.colors.length + beforeState.queuedColors.length;
            
            const result = window.app.timeBasedEngine.addColor(color);
            totalAdded++;
            
            window.app.syncEngineStateToLegacyState();
            window.app.renderTimeBasedQuilt();
            
            const afterState = window.app.timeBasedEngine.getState();
            const afterCount = afterState.colors.length + afterState.queuedColors.length;
            
            console.log(`✅ Color count: ${beforeCount} → ${afterCount} (expected: ${totalAdded})`);
            
            // Check for position collisions
            const positions = new Set();
            const duplicatePositions = [];
            afterState.colors.forEach(colorData => {
              const posKey = `${colorData.position.x},${colorData.position.y}`;
              if (positions.has(posKey)) {
                duplicatePositions.push(posKey);
              }
              positions.add(posKey);
            });
            
            if (duplicatePositions.length > 0) {
              console.warn(`⚠️ Position collisions detected at: ${duplicatePositions.join(', ')}`);
            } else {
              console.log(`✅ All positions unique (${positions.size} positions)`);
            }
            
            if ((index + 1) % 5 === 0) {
              console.log('🔄 Reorganization triggered - check logs above for color preservation!');
            }
            
            // Verify no colors lost
            if (afterCount !== totalAdded) {
              throw new Error(`🚨 COLOR LOSS! Expected ${totalAdded}, got ${afterCount}`);
            }
          });
          
          console.log(`\n🎉 SUCCESS: All ${totalAdded} colors preserved through reorganizations!`);
          return '✅ Reorganization test complete - ZERO colors lost, positions tracked!';
        } catch (e) {
          console.error('❌ Reorganization test failed:', e);
          return '❌ Test failed';
        }
      };

      // ===== MAIN APPLICATION =====
       class OurDailyApp {
         constructor() {
           // Initialize services
           this.logger = new Logger(CONFIG.APP.debugMode);
           this.uiService = new UIService(this.logger);
           this.errorHandler = new ErrorHandler(this.uiService, this.logger);
           this.state = new QuiltState(this.logger);
           this.dataService = new QuiltDataService(this.logger, this.errorHandler);
           this.quoteService = new QuoteService();
           
           // NEW: Time-based quilt engine
           this.timeBasedEngine = new TimeBasedQuiltEngine(this.logger, this.errorHandler);
           
           // LEGACY: Keep these for now during transition
           this.positioningService = new PositioningService(this.logger);
           this.renderingService = new RenderingService(this.logger, this.errorHandler);
           this.universalMatchingService = new UniversalMatchingService(this.logger);
           
           // Color picker state
           this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
           this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
           this.colorHasBeenSelected = false;
           
           // Share state
           this.lastAddedForShare = null;
           
           this.logger.log('OurDailyApp initialized');
         }

         async initialize() {
           try {
             this.uiService.showLoading(true);
             
             await this.dataService.initialize();
             this.setupEventListeners();
             this.initializeUI();
             await this.loadQuilt();
             
             this.renderingService.initialize();
             
             // Force initial render with time-based engine
             setTimeout(() => {
               this.renderTimeBasedQuilt();
               this.updateUI();
             }, 100);
             
                         this.uiService.showLoading(false);
            this.logger.log('App initialization complete');
            
            // ROOT CAUSE FIX: All renderQuilt calls now use time-based engine
           } catch (error) {
             this.errorHandler.handleError(error, 'App initialization');
             this.uiService.showLoading(false);
           }
         }

         setupEventListeners() {
           // Navigation
           document.querySelectorAll(".btn[data-next]").forEach(btn => {
             btn.addEventListener("click", e => {
               e.preventDefault();
               const targetId = btn.getAttribute("data-next");
               if (targetId) this.uiService.showScreen(targetId);
             });
           });

           // Add color button
           const addColorBtn = document.getElementById('addColorBtn');
           if (addColorBtn) {
             addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
           }

           // Share button
           const shareBtnCompleted = document.getElementById('shareBtnCompleted');
           if (shareBtnCompleted) {
             shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
           }

           // Test buttons
           const testAddBlock = document.getElementById('testAddBlock');
           if (testAddBlock) {
             testAddBlock.addEventListener('click', this.handleTestAddBlock.bind(this));
           }

           const showMyPieceBtn = document.getElementById('showMyPieceBtn');
           if (showMyPieceBtn) {
             showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
           }

           const testDifferentUserBtn = document.getElementById('testDifferentUserBtn');
           if (testDifferentUserBtn) {
             testDifferentUserBtn.addEventListener('click', this.handleTestDifferentUser.bind(this));
           }

           const testUniversalMatchingBtn = document.getElementById('testUniversalMatchingBtn');
           if (testUniversalMatchingBtn) {
             testUniversalMatchingBtn.addEventListener('click', this.testUniversalMatching.bind(this));
           }

           // Color picker
           this.setupColorPicker();
           
           // Keyboard navigation
           document.addEventListener('keydown', this.handleKeyDown.bind(this));
         }

         initializeUI() {
           const dateText = document.getElementById("date-text");
           if (dateText) {
             dateText.textContent = Utils.formatDate();
           }
           this.quoteService.displayQuote();
           this.uiService.showScreen('screen-portal');
         }

         async loadQuilt() {
           try {
             this.uiService.showLoading(true);
                         const blocks = await this.dataService.loadQuilt();
            this.state.blocks = blocks;
            
            if (this.renderingService.isInitialized) {
              this.renderTimeBasedQuilt();
            }
             this.uiService.showLoading(false);
           } catch (error) {
             this.errorHandler.handleError(error, 'loadQuilt');
             this.uiService.showLoading(false);
                         this.state.blocks = [];
            if (this.renderingService.isInitialized) {
              this.renderTimeBasedQuilt();
            }
           }
         }

         async saveQuilt() {
           try {
             await this.dataService.saveQuilt();
           } catch (error) {
             this.errorHandler.handleError(error, 'saveQuilt');
             throw error;
           }
         }

         addPieceToQuilt(newColor) {
           try {
             this.logger.log(`🔄 Starting addPieceToQuilt with color: ${newColor}`);
             
             this.errorHandler.validateColor(newColor);
             this.logger.log('✅ Color validation passed');
             
             this.state.incrementSubmission();
             this.logger.log(`📊 Submission count incremented to: ${this.state.submissionCount}`);
             
             // Determine pieces to create based on submission count
             const piecesToCreate = CONFIG.PHASES.collection.piecesPerSubmission[this.state.submissionCount - 1] || 1;
             this.logger.log(`🎯 Creating ${piecesToCreate} pieces for submission ${this.state.submissionCount}`);
             
             // Create pieces for this submission
             const startIndex = this.state.pieces.length;
             this.logger.log(`📍 Starting piece creation at index: ${startIndex}`);
             
             for (let i = 0; i < piecesToCreate; i++) {
               const currentIndex = startIndex + i;
               this.logger.log(`🔧 Creating piece ${i + 1}/${piecesToCreate} at index ${currentIndex}`);
               
               const piece = this.positioningService.createPiece(
                 newColor, 
                 currentIndex, 
                 this.state.currentUserId, 
                 this.state.submissionCount
               );
               
               this.logger.log(`✅ Piece created:`, piece);
               this.state.addPiece(piece);
             }
             
             this.logger.log(`📈 Total pieces after addition: ${this.state.pieces.length}`);
             
             // Handle phase transitions
             this.logger.log('🔄 Checking for phase transitions');
             this.handlePhaseTransitions();
             
             this.state.lastAddedIndex = this.state.blocks.length - 1;
             this.logger.log(`🎯 Last added index set to: ${this.state.lastAddedIndex}`);
             
             this.logger.log('✅ addPieceToQuilt completed successfully');
             return true;
             
           } catch (error) {
             this.logger.error(`❌ Error in addPieceToQuilt: ${error.message}`);
             this.errorHandler.handleError(error, 'addPieceToQuilt');
             return false;
           }
         }

         handlePhaseTransitions() {
           const submissionCount = this.state.submissionCount;
           this.logger.log(`🔄 Checking phase transitions at submission ${submissionCount}`);
           
           if (submissionCount === CONFIG.PHASES.patchFormation.triggerSubmission) {
             this.logger.log('🔄 Transitioning to patch-formation phase');
             this.state.setPhase('block-formation');
             
             // Form patches from all pieces (24 pieces → 12 patches)
             const allPatches = this.formPatchesFromPieces(this.state.allPieces);
             this.logger.log(`📊 Formed ${allPatches.length} patches from all pieces`);
             
             // Form blocks from patches (12 patches → 6 blocks)
             const blockFormationResult = this.formBlocksFromPatches(allPatches);
             this.state.blocks = blockFormationResult.blocks;
             this.state.unmatchedPatches = blockFormationResult.unmatchedPatches;
             this.state.originalPatches = [...allPatches];
             
             // Clear pieces and patches, show blocks
             this.state.pieces = [];
             this.state.patches = [];
             this.state.allPieces = [];
             
             this.logger.log(`📊 User 6 sees ${this.state.blocks.length} blocks`);
             this.uiService.showToast('Block formation phase activated!');
                       } else if (submissionCount === CONFIG.PHASES.blockFormation.triggerSubmission && submissionCount > 6) {
              this.logger.log('🔄 User 7+ adding piece to existing blocks');
              
              // Create the new piece
              const newPiece = this.createPiece();
              this.state.pieces = [newPiece];
              
              // Position the piece to attach to the existing quilt
              this.positioningService.positionPieceWithQuilt(newPiece, this.state.blocks);
              
              this.logger.log(`📊 User ${submissionCount} adds piece to existing ${this.state.blocks.length} blocks`);
              this.uiService.showToast(`Your piece added to the quilt!`);
           } else if (submissionCount === CONFIG.PHASES.quiltFormation.triggerSubmission) {
             this.logger.log('🔄 Transitioning to quilt-formation phase');
             this.state.setPhase('quilt-formation');
             const allPatches = this.formPatchesFromPieces(this.state.allPieces);
             this.logger.log(`📊 Processing ${allPatches.length} patches for quilt formation`);
             const allBlocks = this.formBlocksFromPatches(allPatches);
             this.logger.log(`📊 Processing ${allBlocks.blocks.length} blocks for quilt formation`);
             this.state.quilt = this.formQuiltFromBlocks(allBlocks);
             this.state.blocks = [];
             this.state.patches = [];
             this.state.pieces = [];
             this.state.unmatchedPieces = [];
             this.state.allPieces = [];
             this.logger.log('📊 Quilt formation completed');
             this.uiService.showToast('Quilt formation phase activated! All pieces included!');
           } else {
             this.logger.log(`📊 No phase transition needed at submission ${submissionCount}`);
           }
         }

         formPatchesFromPieces(specificPieces = null) {
           const pieces = specificPieces ? [...specificPieces] : [...this.state.pieces];
           
           this.logger.log(`formPatchesFromPieces: Starting with ${pieces.length} pieces`);
           
           const result = this.universalMatchingService.formCompositeElements(
             pieces,
             'patch',
             {
               edgeTolerance: CONFIG.PHASES.patchFormation.edgeTolerance,
               valueContrastWeight: CONFIG.PHASES.patchFormation.valueContrastWeight,
               createCompositeFunction: this.createPatch.bind(this),
               maxMatches: Math.floor(pieces.length / 2)
             }
           );
           
           this.state.unmatchedPieces = result.unmatchedElements;
           this.logger.log(`formPatchesFromPieces: Created ${result.compositeElements.length} patches and ${result.unmatchedElements.length} unmatched pieces`);
           
           this.positioningService.positionElementsInGrid(result.compositeElements, 0, 'patches');
           
           return result.compositeElements;
         }

         formBlocksFromPatches(specificPatches = null) {
           const patches = specificPatches ? [...specificPatches] : [...this.state.patches];
           
           this.logger.log(`Starting block formation with ${patches.length} patches`);
           
           const result = this.universalMatchingService.formCompositeElements(
             patches,
             'block',
             {
               edgeTolerance: CONFIG.PHASES.blockFormation.edgeTolerance,
               valueContrastWeight: CONFIG.PHASES.blockFormation.valueContrastWeight,
               createCompositeFunction: this.createBlock.bind(this),
               maxMatches: Math.floor(patches.length / 2)
             }
           );
           
           this.logger.log(`Block formation summary: ${result.compositeElements.length} blocks created, ${result.unmatchedElements.length} unmatched patches`);
           
           this.positioningService.positionElementsInGrid(result.compositeElements, 0, 'blocks');
           
           return {
             blocks: result.compositeElements,
             unmatchedPatches: result.unmatchedElements
           };
         }



         formQuiltFromBlocks(blocks) {
           const allBlocks = [...blocks];
           
           this.logger.log(`Starting quilt formation with ${allBlocks.length} blocks`);
           
           const result = this.universalMatchingService.formCompositeElements(
             allBlocks,
             'quilt_block',
             {
               edgeTolerance: CONFIG.PHASES.blockFormation.edgeTolerance,
               valueContrastWeight: CONFIG.PHASES.blockFormation.valueContrastWeight,
               createCompositeFunction: this.createQuiltBlock.bind(this),
               maxMatches: Math.floor(allBlocks.length / 2)
             }
           );
           
           // Handle single unmatched blocks
           result.unmatchedElements.forEach(block => {
             if (block) {
               const singleQuiltBlock = this.createQuiltBlock([block]);
               if (singleQuiltBlock) {
                 result.compositeElements.push(singleQuiltBlock);
               }
             }
           });
           
           this.positionQuiltBlocks(result.compositeElements);
           
           return {
             id: `quilt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             type: 'quilt',
             blocks: result.compositeElements,
             width: 600,
             height: 600
           };
         }

         findBestMatch(items, targetItem) {
           let bestMatch = null;
           let bestScore = Infinity;
           const tolerance = CONFIG.PHASES.patchFormation.edgeTolerance;
           
           this.logger.log(`Finding best match for item ${targetItem.id || 'unknown'} among ${items.length} candidates`);
           
           for (let i = 0; i < items.length; i++) {
             const item = items[i];
             if (item === targetItem) continue;
             
             const targetEdges = targetItem.edges;
             const itemEdges = item.edges;
             
             const horizontalEdgeScore = this.calculateEdgeScore(targetEdges.right, itemEdges.left);
             const verticalEdgeScore = this.calculateEdgeScore(targetEdges.bottom, itemEdges.top);
             const valueContrastScore = this.calculateValueContrastScore(targetItem.color, item.color);
             const sameColorPenalty = targetItem.color === item.color ? 1.0 : 0;
             
             const horizontalScore = horizontalEdgeScore - valueContrastScore * CONFIG.PHASES.patchFormation.valueContrastWeight + sameColorPenalty;
             const verticalScore = verticalEdgeScore - valueContrastScore * CONFIG.PHASES.patchFormation.valueContrastWeight + sameColorPenalty;
             
             const score = Math.min(horizontalScore, verticalScore);
             const sameColor = targetItem.color === item.color;
             
             this.logger.log(`  Candidate ${i}: edge scores (H:${horizontalEdgeScore.toFixed(3)}, V:${verticalEdgeScore.toFixed(3)}), contrast:${valueContrastScore.toFixed(3)}, sameColor:${sameColor}, final score:${score.toFixed(3)}`);
             
             if (score < bestScore) {
               bestScore = score;
               bestMatch = {
                 item: item,
                 score: score,
                 joinType: score === horizontalScore ? 'horizontal' : 'vertical',
                 edgeScore: Math.min(horizontalEdgeScore, verticalEdgeScore),
                 valueContrastScore: valueContrastScore
               };
               this.logger.log(`  New best match found with score ${score.toFixed(3)}`);
             }
           }
           
           this.logger.log(`Best match score: ${bestMatch ? bestMatch.score.toFixed(3) : 'none'}`);
           return bestMatch;
         }

         calculateEdgeScore(length1, length2) {
           const difference = Math.abs(length1 - length2);
           const averageLength = (length1 + length2) / 2;
           return difference / averageLength;
         }

         calculateValueContrastScore(color1, color2) {
           const hsl1 = Utils.hexToHsl(color1);
           const hsl2 = Utils.hexToHsl(color2);
           const valueDifference = Math.abs(hsl1.l - hsl2.l);
           const normalizedContrast = valueDifference / 100;
           const contrastScore = Math.pow(normalizedContrast, 0.7);
           return contrastScore;
         }

         combineItems(item1, item2, joinType) {
           let combinedWidth, combinedHeight, combinedX, combinedY;
           
           if (joinType === 'horizontal') {
             const targetLength = (item1.edges.right + item2.edges.left) / 2;
             const adjustedWidth1 = item1.width;
             const adjustedWidth2 = item2.width;
             
             combinedWidth = item1.width + adjustedWidth2;
             combinedHeight = Math.max(item1.height, item2.height);
             combinedX = item1.x;
             combinedY = Math.min(item1.y, item2.y);
           } else {
             const targetLength = (item1.edges.bottom + item2.edges.top) / 2;
             const adjustedHeight1 = item1.height;
             const adjustedHeight2 = item2.height;
             
             combinedWidth = Math.max(item1.width, item2.width);
             combinedHeight = item1.height + adjustedHeight2;
             combinedX = Math.min(item1.x, item2.x);
             combinedY = item1.y;
           }
           
           return {
             width: combinedWidth,
             height: combinedHeight,
             x: combinedX,
             y: combinedY
           };
         }

         createPatch(pieces) {
           if (pieces.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           pieces.forEach(piece => {
             minX = Math.min(minX, piece.x);
             minY = Math.min(minY, piece.y);
             maxX = Math.max(maxX, piece.x + piece.width);
             maxY = Math.max(maxY, piece.y + piece.height);
           });
           
           return {
             id: `patch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             color: pieces[0].color,
             type: 'patch',
             pieces: pieces,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         createBlock(patches) {
           if (patches.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           patches.forEach(patch => {
             minX = Math.min(minX, patch.x);
             minY = Math.min(minY, patch.y);
             maxX = Math.max(maxX, patch.x + patch.width);
             maxY = Math.max(maxY, patch.y + patch.height);
           });
           
           return {
             id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             color: patches[0].color,
             type: 'block',
             patches: patches,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         createQuiltBlock(blocks) {
           if (blocks.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           blocks.forEach(block => {
             minX = Math.min(minX, block.x);
             minY = Math.min(minY, block.y);
             maxX = Math.max(maxX, block.x + block.width);
             maxY = Math.max(maxY, block.y + block.height);
           });
           
           return {
             id: `quilt_block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             type: 'quilt_block',
             blocks: blocks,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         positionQuiltBlocks(quiltBlocks) {
           const quiltSize = 600;
           const padding = 20;
           const availableSize = quiltSize - 2 * padding;
           
           this.logger.log(`Positioning ${quiltBlocks.length} quilt blocks in touching layout`);
           
           if (quiltBlocks.length === 0) return;
           
           quiltBlocks[0].x = padding;
           quiltBlocks[0].y = padding;
           this.logger.log(`Quilt block 0 positioned at (${quiltBlocks[0].x}, ${quiltBlocks[0].y})`);
           
           for (let i = 1; i < quiltBlocks.length; i++) {
             const block = quiltBlocks[i];
             
             if (!block || typeof block.width === 'undefined' || typeof block.height === 'undefined') {
               this.logger.warn(`Skipping invalid quilt block at index ${i}:`, block);
               continue;
             }
             
             let bestX = padding;
             let bestY = padding;
             let bestScore = Infinity;
             
             for (let attempt = 0; attempt < 100; attempt++) {
               const testX = padding + Math.random() * (availableSize - block.width);
               const testY = padding + Math.random() * (availableSize - block.height);
               
               let touchesExisting = false;
               let minDistance = Infinity;
               
               for (let j = 0; j < i; j++) {
                 const existingBlock = quiltBlocks[j];
                 if (!existingBlock) continue;
                 
                 const horizontalOverlap = !(testX + block.width <= existingBlock.x || 
                                          testX >= existingBlock.x + existingBlock.width);
                 const verticalOverlap = !(testY + block.height <= existingBlock.y || 
                                         testY >= existingBlock.y + existingBlock.height);
                 
                 if (horizontalOverlap && verticalOverlap) {
                   touchesExisting = false;
                   break;
                 }
                 
                 const horizontalTouch = (testX + block.width === existingBlock.x) || 
                                      (existingBlock.x + existingBlock.width === testX);
                 const verticalTouch = (testY + block.height === existingBlock.y) || 
                                    (existingBlock.y + existingBlock.height === testY);
                 
                 if (horizontalTouch && verticalTouch) {
                   touchesExisting = true;
                 }
                 
                 const distance = Math.sqrt(
                   Math.pow(testX - existingBlock.x, 2) + 
                   Math.pow(testY - existingBlock.y, 2)
                 );
                 if (distance < minDistance) {
                   minDistance = distance;
                 }
               }
               
               const score = touchesExisting ? -minDistance : minDistance + 1000;
               
               if (score < bestScore) {
                 bestScore = score;
                 bestX = testX;
                 bestY = testY;
               }
             }
             
             block.x = bestX;
             block.y = bestY;
             this.logger.log(`Quilt block ${i} positioned at (${block.x}, ${block.y})`);
           }
         }

         updateUI() {
           this.uiService.updatePhaseIndicator(this.state.currentPhase, this.state.submissionCount);
           this.uiService.updateUserCounter(this.state.submissionCount, this.state.currentPhase, this.state.getElementCounts());
         }

         async handleAddColor() {
           try {
             this.logger.log('🎨 Starting color addition process');
             this.logger.log(`Selected hue: ${this.selectedHue}`);
             this.logger.log(`Selected lightness: ${this.selectedLightness}`);
             this.logger.log(`Config saturation: ${CONFIG.COLOR_PICKER.saturation}`);
             
             const selectedColor = Utils.hslToHex(this.selectedHue, CONFIG.COLOR_PICKER.saturation, this.selectedLightness);
             
             this.logger.log(`Converted color: ${selectedColor}`);
             
             if (!selectedColor) {
               this.logger.warn('No color selected');
               this.uiService.showToast('Please select a color first');
               return;
             }

             // Validate the color
             if (!Utils.validateHexColor(selectedColor)) {
               this.logger.error(`Invalid color generated: ${selectedColor}`);
               this.uiService.showToast('Invalid color generated. Please try again.');
               return;
             }

             // NEW: Use TimeBasedQuiltEngine
             this.logger.log(`Adding color to time-based engine: ${selectedColor}`);
             const result = this.timeBasedEngine.addColor(selectedColor);
             
             if (result.success) {
               this.logger.log('Color added successfully to time-based engine');
               
               // Update the legacy state for UI compatibility
               this.syncEngineStateToLegacyState();
               
               this.logger.log('Saving quilt data');
               await this.saveQuilt();
               
               this.logger.log('Rendering updated quilt');
               this.renderTimeBasedQuilt();
               
               this.updateUI();
               this.showPhaseMessage(result);
               this.uiService.showScreen('screen-quilt');
             } else {
               this.logger.warn('Failed to add color to time-based engine:', result.reason);
               this.uiService.showToast(result.reason || 'Failed to add color');
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'handleAddColor');
             this.uiService.showToast('Failed to add color. Please try again.');
           }
         }

         // NEW: Helper methods for TimeBasedEngine integration
         syncEngineStateToLegacyState() {
           const engineState = this.timeBasedEngine.getState();
           
           // Update legacy state for UI compatibility
           this.state.currentPhase = engineState.phase;
           this.state.submissionCount = engineState.colors.length + engineState.queuedColors.length;
           
           // Clear old data and populate with new
           this.state.pieces = [];
           this.state.patches = [];
           this.state.blocks = [];
           
           // Convert engine colors to legacy format for UI components
           engineState.colors.forEach((colorObj, index) => {
             this.state.pieces.push({
               id: `piece_${index}`,
               color: colorObj.color,
               x: colorObj.position.x * 30, // Scale for display
               y: colorObj.position.y * 30,
               width: 25,
               height: 25,
               userId: this.state.currentUserId,
               timestamp: colorObj.timestamp
             });
           });
           
           this.logger.log(`Synced engine state: ${engineState.colors.length} colors, phase: ${engineState.phase}, pattern: ${engineState.pattern}`);
         }

         renderTimeBasedQuilt() {
           console.log('🎨 DEBUG: Starting renderTimeBasedQuilt...');
           const engineState = this.timeBasedEngine.getState();
           console.log('🎨 DEBUG: Engine state:', engineState);
           console.log('🎨 DEBUG: Colors in state:', engineState.colors?.length || 0);
           
           const quiltSVG = document.getElementById('quilt');
           console.log('🎨 DEBUG: Quilt SVG element:', quiltSVG);
           
           if (!quiltSVG) {
             this.logger.warn('Quilt SVG not found');
             return;
           }
           
           // Mark that time-based rendering is active to prevent legacy interference
           quiltSVG.setAttribute('data-time-based-active', 'true');
           
           // Calculate grid bounds for mobile-first sizing
          if (engineState.colors.length === 0) {
            console.log('🎨 DEBUG: No colors to render');
            return;
          }
          
          const positions = engineState.colors.map(c => c.position);
          const minX = Math.min(...positions.map(p => p.x));
          const maxX = Math.max(...positions.map(p => p.x));
          const minY = Math.min(...positions.map(p => p.y));
          const maxY = Math.max(...positions.map(p => p.y));
          
          const gridWidth = maxX - minX + 1;
          const gridHeight = maxY - minY + 1;
          
          // MOBILE-FIRST: MAXIMIZE block size for 8 color families
          const screenWidth = window.innerWidth;
          const numberOfColorFamilies = 8;
          const smallPadding = 4; // Even less padding for bigger blocks
          const columnSpacing = 3; // Tighter spacing for more block space
          
          // Use maximum screen width for bigger blocks
          const availableWidthForBlocks = screenWidth - smallPadding - (columnSpacing * (numberOfColorFamilies - 1));
          const optimalBlockSize = Math.floor(availableWidthForBlocks / numberOfColorFamilies);
          
          // MUCH bigger blocks using all available space!
          const minBlockSize = 70; // Much bigger for excellent mobile experience
          const maxBlockSize = 120; // Even bigger maximum to use available space
          const scale = Math.min(maxBlockSize, Math.max(minBlockSize, optimalBlockSize));
          
          console.log(`📱 MAXIMIZE WIDTH: screen=${screenWidth}px - ${smallPadding}px padding = ${availableWidthForBlocks}px ÷ 8 = ${optimalBlockSize}px → 🎯 ${scale}px final`);
          console.log(`📱 LAYOUT: ${numberOfColorFamilies} columns × 🎯 ${scale}px blocks + ${columnSpacing}px spacing = ${(numberOfColorFamilies * scale) + (columnSpacing * (numberOfColorFamilies - 1))}px total width`);
          console.log(`🔍 SCALE CHECK: Using ${scale}px scale for all blocks in this render`);
          
          // Calculate how much horizontal space we're actually using
          const actualUsedWidth = (numberOfColorFamilies * scale) + (columnSpacing * (numberOfColorFamilies - 1));
          const remainingSpace = screenWidth - actualUsedWidth;
          const spacePercentage = ((actualUsedWidth / screenWidth) * 100).toFixed(1);
          console.log(`📏 SPACE USAGE: Using ${actualUsedWidth}px of ${screenWidth}px (${spacePercentage}%) - ${remainingSpace}px remaining`);
          
          // MOBILE-FIRST: Calculate available height by measuring actual DOM elements
          const availableHeight = this.calculateAvailableCanvasHeight();
          
          // Calculate ideal quilt height without compression
          const idealQuiltHeight = gridHeight * scale;
          
          // MOBILE-FIRST: Canvas should use full screen width for bigger visual impact
          const canvasWidth = screenWidth; // Use full screen width, not just grid width
          
          // Apply dynamic compression based on individual column needs
          let compressionApplied = false;
          const targetCanvasHeight = availableHeight - 30; // Reserve minimal padding since we're using full height
          
          console.log(`📱 COMPRESSION CHECK: Overall quilt needs ${idealQuiltHeight}px, full canvas height = ${targetCanvasHeight}px`);
          
          // Check if ANY column might need compression (smarter trigger)
          const columnGroups = new Map();
          engineState.colors.forEach(colorObj => {
            const family = colorObj.position.colorFamily || 'unknown';
            if (!columnGroups.has(family)) {
              columnGroups.set(family, []);
            }
            columnGroups.get(family).push(colorObj);
          });
          
          let anyColumnNeedsCompression = false;
          columnGroups.forEach((columnColors, family) => {
            const columnMaxY = Math.max(...columnColors.map(c => c.position.y));
            const columnMinY = Math.min(...columnColors.map(c => c.position.y));
            const columnHeight = (columnMaxY - columnMinY) * scale;
            const columnHeightRatio = columnHeight / targetCanvasHeight;
            
            if (columnHeightRatio > 0.9) { // More conservative since we have much more space now
              anyColumnNeedsCompression = true;
              console.log(`📱 TRIGGER: ${family} column (${columnHeight.toFixed(0)}px, ${Math.round(columnHeightRatio * 100)}%) needs compression`);
            }
          });
          
          if (anyColumnNeedsCompression) {
            console.log(`📱 🚨 COLUMN-SPECIFIC COMPRESSION TRIGGERED`);
            compressionApplied = this.applyDynamicCompression(engineState.colors, targetCanvasHeight, scale);
            console.log(`📱 Compression result: ${compressionApplied ? 'SUCCESS' : 'FAILED'}`);
          } else {
            console.log(`📱 ✅ NO COMPRESSION NEEDED: All columns fit comfortably`);
          }
          
          // USE FULL AVAILABLE HEIGHT instead of just fitting content
          const actualQuiltHeight = compressionApplied ? 
            this.calculateCompressedQuiltHeight(engineState.colors, scale) : idealQuiltHeight;
          
          // Reserve small buffer for padding, but use most of available space
          const canvasHeight = availableHeight - 30; // Use nearly all available height!
          
          console.log(`📱 MAXIMIZED CANVAS: Using ${canvasHeight}px of ${availableHeight}px available (quilt needs ${actualQuiltHeight.toFixed(1)}px)`);
          console.log(`📱 🎯 CANVAS SIZE: ${canvasWidth}px × ${canvasHeight}px - FULL VIEWPORT USAGE`);
          
          // Setup SVG with responsive canvas size
          quiltSVG.innerHTML = '';
          console.log('🎨 DEBUG: Cleared SVG content');
          
          // MOBILE-FIRST: Use full screen width, no artificial minimums!
          const finalWidth = canvasWidth; // Use full screen width (412px)
          const finalHeight = canvasHeight; // Use full available height
          
          quiltSVG.setAttribute('width', finalWidth);
          quiltSVG.setAttribute('height', finalHeight);
          quiltSVG.setAttribute('viewBox', `0 0 ${finalWidth} ${finalHeight}`);
          
          // AGGRESSIVE HEIGHT FORCING - prevent any CSS override
          quiltSVG.style.setProperty('width', finalWidth + 'px', 'important');
          quiltSVG.style.setProperty('height', finalHeight + 'px', 'important');
          quiltSVG.style.setProperty('max-height', 'none', 'important');
          quiltSVG.style.setProperty('min-height', 'auto', 'important');
          
          console.log(`📱 SVG ATTRIBUTES: width=${finalWidth}px, height=${finalHeight}px (using full viewport!)`);
          console.log(`📱 SVG VIEWBOX: 0 0 ${finalWidth} ${finalHeight}`);
          console.log('🔧 AGGRESSIVE HEIGHT FORCING: Applied !important styles to prevent CSS override');
          console.log(`🔧 AGGRESSIVE HEIGHT FORCING: Applied style.cssText: ${quiltSVG.style.cssText}`);
          console.log(`🔧 AGGRESSIVE HEIGHT FORCING: Computed style height: ${window.getComputedStyle(quiltSVG).height}`);
          console.log(`🔧 AGGRESSIVE HEIGHT FORCING: Computed style width: ${window.getComputedStyle(quiltSVG).width}`);
          
          // Height monitor is now debug-only - run manually with startHeightMonitor() if needed
          console.log('🔍 Height monitor available for debugging: startHeightMonitor() / stopHeightMonitor()');
          
          // Verify we're using the viewport space properly
          const usagePercent = Math.round((finalHeight / availableHeight) * 100);
          console.log(`📱 ✅ VIEWPORT USAGE: ${usagePercent}% of available height (${finalHeight}px / ${availableHeight}px)`);
          
          // Add background
          const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          background.setAttribute('width', '100%');
          background.setAttribute('height', '100%');
          background.setAttribute('fill', '#f6f4f1');
          quiltSVG.appendChild(background);
          console.log('🎨 DEBUG: Added background');
          
          // MOBILE-FIRST: Center the quilt properly based on actual width used
          const actualQuiltWidth = gridWidth * scale; // How wide the quilt actually is
          const remainingWidth = canvasWidth - actualQuiltWidth; // How much space is left
          
          // Horizontal centering: simply center the actual quilt width within the canvas
          const offsetX = remainingWidth / 2; // Fixed to remove min padding and gridXAdjustment
          
          // MOBILE-FIRST: Calculate offsetY to prevent off-screen rendering
          // Account for negative grid bounds and add minimal top padding
          const baseTopPadding = 20; // Minimal top padding for mobile
          const gridAdjustment = (minY < 0) ? Math.abs(minY * scale) : 0; // Account for negative Y bounds
          const offsetY = baseTopPadding + gridAdjustment;
          
          console.log(`📱 MOBILE OFFSET: baseTopPadding=${baseTopPadding}, gridAdjustment=${gridAdjustment.toFixed(1)}, final offsetY=${offsetY.toFixed(1)}`);
          console.log(`🎯 CENTERING: actualQuiltWidth=${actualQuiltWidth.toFixed(1)}px, remainingWidth=${remainingWidth.toFixed(1)}px`);
          console.log(`🎯 X-OFFSET: remainingWidth=${remainingWidth.toFixed(1)}px / 2 = ${offsetX.toFixed(1)}px final`);
          
          console.log(`🎨 DEBUG: Grid bounds: (${minX},${minY}) to (${maxX},${maxY})`);
          console.log(`🎨 DEBUG: Grid size: ${gridWidth}x${gridHeight}, scale: ${scale.toFixed(1)}px (${engineState.phase} phase)`);
          console.log(`🎨 DEBUG: Offset: (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)})`);
          
          if (engineState.phase === 'collection') {
            if (compressionApplied) {
              console.log(`📱 Mobile-first: Fixed ${scale}px blocks + DYNAMIC COMPRESSION applied to fit ${availableHeight}px viewport`);
            } else {
              console.log(`📱 Mobile-first: Fixed block size (${scale}px) for touch-friendly interaction - no compression needed`);
            }
          } else {
            console.log(`📱 Mobile-first: Fixed block size (${scale}px) - no shrinking as grid grows`);
          }
          
          // Render placed colors with phase-specific styling
          console.log(`🎨 DEBUG: About to render colors with scale: ${scale}`);
          console.log('🎨 DEBUG: About to render colors...', engineState.colors);
          engineState.colors.forEach((colorObj, index) => {
            console.log(`🎨 DEBUG: Rendering color ${index + 1}:`, colorObj);
            
            // Normalize position relative to grid bounds and apply scaling
            const normalizedX = colorObj.position.x - minX;
            const normalizedY = colorObj.position.y - minY;
            const x = normalizedX * scale + offsetX;
            const y = normalizedY * scale + offsetY;
            
            console.log(`🎨 DEBUG: Position (${colorObj.position.x}, ${colorObj.position.y}) → normalized (${normalizedX}, ${normalizedY}) → SVG (${x.toFixed(1)}, ${y.toFixed(1)})`);
            
            // Create group for stacking effects (collection phase)
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Collection phase: quilter's workspace stacking
            if (engineState.phase === 'collection' && colorObj.position.isStacked) {
              this.renderStackedBlock(group, colorObj, x, y, scale, index);
            } else {
              // Standard rendering for other phases
              this.renderStandardBlock(group, colorObj, x, y, scale, index);
            }
            
            quiltSVG.appendChild(group);
            console.log(`🎨 DEBUG: Added ${engineState.phase} styled block for color ${colorObj.color}`);
          });
           
           console.log('🎨 DEBUG: Finished rendering all colors');
           console.log('🎨 DEBUG: Final SVG children count:', quiltSVG.children.length);
           
           // Show queued colors if in pattern_selection phase
           if (engineState.phase === 'pattern_selection' && engineState.queuedColors.length > 0) {
             const queuedGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
             
             // Background for queued area
             const queueBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
             queueBg.setAttribute('x', '10');
             queueBg.setAttribute('y', '10');
             queueBg.setAttribute('width', '200');
             queueBg.setAttribute('height', '40');
             queueBg.setAttribute('fill', 'rgba(0, 0, 0, 0.1)');
             queueBg.setAttribute('rx', '5');
             queuedGroup.appendChild(queueBg);
             
             // Queue text
             const queueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             queueText.setAttribute('x', '15');
             queueText.setAttribute('y', '25');
             queueText.setAttribute('font-family', 'Arial, sans-serif');
             queueText.setAttribute('font-size', '12');
             queueText.setAttribute('fill', '#000');
             queueText.textContent = `Analyzing ${engineState.queuedColors.length} colors...`;
             queuedGroup.appendChild(queueText);
             
             // Show queued colors as small squares
             engineState.queuedColors.forEach((color, index) => {
               const queueRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
               queueRect.setAttribute('x', 15 + index * 20);
               queueRect.setAttribute('y', '32');
               queueRect.setAttribute('width', '15');
               queueRect.setAttribute('height', '15');
               queueRect.setAttribute('fill', color);
               queueRect.setAttribute('stroke', '#000');
               queueRect.setAttribute('stroke-width', '0.5');
               queuedGroup.appendChild(queueRect);
             });
             
             quiltSVG.appendChild(queuedGroup);
           }
           
           // Show current pattern info
           if (engineState.pattern) {
             const patternText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             patternText.setAttribute('x', '450');
             patternText.setAttribute('y', '25');
             patternText.setAttribute('font-family', 'Arial, sans-serif');
             patternText.setAttribute('font-size', '14');
             patternText.setAttribute('font-weight', 'bold');
             patternText.setAttribute('fill', '#333');
             patternText.textContent = `Pattern: ${engineState.pattern}`;
             quiltSVG.appendChild(patternText);
           }
           
           // Show phase info and progress
           const totalColors = engineState.colors.length + engineState.queuedColors.length;
           const phaseText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
           phaseText.setAttribute('x', '450');
           phaseText.setAttribute('y', '45');
           phaseText.setAttribute('font-family', 'Arial, sans-serif');
           phaseText.setAttribute('font-size', '12');
           phaseText.setAttribute('fill', '#666');
           phaseText.textContent = `Phase: ${engineState.phase}`;
           quiltSVG.appendChild(phaseText);
           
           // Show progress
           const progressText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
           progressText.setAttribute('x', '450');
           progressText.setAttribute('y', '65');
           progressText.setAttribute('font-family', 'Arial, sans-serif');
           progressText.setAttribute('font-size', '12');
           progressText.setAttribute('fill', '#666');
           progressText.textContent = `Colors: ${totalColors}`;
           quiltSVG.appendChild(progressText);
           
           // Show daily cycle info at bottom (mobile-friendly positioning)  
           const hour = new Date().getHours();
           const dayInfo = document.createElementNS('http://www.w3.org/2000/svg', 'text');
           dayInfo.setAttribute('x', '20'); // Left-aligned, doesn't constrain canvas width
           dayInfo.setAttribute('y', Math.max(600, canvasHeight) - 20); // Bottom of canvas
           dayInfo.setAttribute('font-family', 'Arial, sans-serif');
           dayInfo.setAttribute('font-size', '11');
           dayInfo.setAttribute('fill', '#666');
           
           // Show phase-specific info with mobile optimization status
           if (engineState.phase === 'collection') {
             // Check if any columns have high overlap (mobile optimization active)
             const hasLongColumns = engineState.colors.some(colorObj => {
               return colorObj.position.overlapFactor && colorObj.position.overlapFactor <= 0.45;
             });
             
            // Check if compression is active and count compressed columns
            const compressedColumns = new Set();
            const uncompressedColumns = new Set();
            
            engineState.colors.forEach(colorObj => {
              const family = colorObj.position.colorFamily;
              if (colorObj.position.compressionLevel === 'none') {
                uncompressedColumns.add(family);
              } else if (colorObj.position.compressionLevel !== undefined) {
                compressedColumns.add(family);
              }
            });
            
            if (compressedColumns.size > 0) {
              if (uncompressedColumns.size > 0) {
                dayInfo.textContent = `Collection: ${compressedColumns.size}/${compressedColumns.size + uncompressedColumns.size} columns compressed`;
              } else {
                dayInfo.textContent = 'Collection: All columns compressed';
              }
            } else if (hasLongColumns) {
              dayInfo.textContent = 'Collection: Mobile-optimized columns';
            } else {
              dayInfo.textContent = 'Collection: Family columns';
            }
           } else if (engineState.phase === 'pattern_selection') {
             dayInfo.textContent = 'Pattern: Organized layout';
           } else if (engineState.phase === 'pattern_filling') {
             dayInfo.textContent = 'Filling: Completing pattern';
           } else {
             dayInfo.textContent = 'Final: Polishing touches';
           }
           quiltSVG.appendChild(dayInfo);
           
           this.logger.log(`Time-based quilt rendered: ${engineState.colors.length} colors, pattern: ${engineState.pattern}`);
         }

         // Helper method: Render stacked blocks for collection phase (quilter's workspace)
         renderStackedBlock(group, colorObj, x, y, scale, index) {
           const stackLevel = colorObj.position.stackLevel || 0;
           const colorFamily = colorObj.position.colorFamily || 'unknown';
           
           // Create drop shadow for depth (more prominent for larger blocks)
           const shadowOffset = Math.max(2, scale * 0.08); // Scale shadow with block size
           const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
           shadow.setAttribute('x', x + shadowOffset);
           shadow.setAttribute('y', y + shadowOffset);
           shadow.setAttribute('width', Math.max(scale - 2, 5));
           shadow.setAttribute('height', Math.max(scale - 2, 5));
           shadow.setAttribute('fill', 'rgba(0, 0, 0, 0.2)'); // Slightly more prominent
           shadow.setAttribute('rx', Math.max(2, scale * 0.06)); // Scale corner radius
           group.appendChild(shadow);
           
           // Main color block
           const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
           rect.setAttribute('x', x);
           rect.setAttribute('y', y);
           
           // DEBUG: Log block size calculation
           const blockWidth = Math.max(scale - 2, 5);
           const blockHeight = Math.max(scale - 2, 5);
           if (window.debugBlockRendering) {
             console.log(`🎨 RENDERING: Block scale=${scale} → size=${blockWidth}×${blockHeight} at (${x}, ${y})`);
           }
           
           rect.setAttribute('width', blockWidth);
           rect.setAttribute('height', blockHeight);
           rect.setAttribute('fill', colorObj.color);
           rect.setAttribute('rx', Math.max(2, scale * 0.06)); // Scale corner radius with block size
           
           // Stacking opacity: lower in stack = more transparent
           const stackOpacity = Math.max(0.6, 1 - (stackLevel * 0.1));
           rect.setAttribute('opacity', stackOpacity);
           
           // Soft border that gets lighter for stacked pieces (scale with block size)
           const borderColor = stackLevel > 0 ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.2)';
           const strokeWidth = Math.max(0.5, scale * 0.02); // Scale stroke with block size
           rect.setAttribute('stroke', borderColor);
           rect.setAttribute('stroke-width', strokeWidth);
           
           // Settling animation for new blocks (scale with block size)
           const dropDistance = Math.max(10, scale * 0.2); // Scale drop distance
           const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');
           animate.setAttribute('attributeName', 'transform');
           animate.setAttribute('type', 'translate');
           animate.setAttribute('values', `0,-${dropDistance}; 0,0`); // Gentle drop scaled to block size
           animate.setAttribute('dur', '0.8s');
           animate.setAttribute('begin', '0s');
           animate.setAttribute('fill', 'freeze');
           rect.appendChild(animate);
           
           // Opacity fade-in
           const fadeIn = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           fadeIn.setAttribute('attributeName', 'opacity');
           fadeIn.setAttribute('values', `0; ${stackOpacity}`);
           fadeIn.setAttribute('dur', '0.8s');
           fadeIn.setAttribute('begin', '0s');
           fadeIn.setAttribute('fill', 'freeze');
           rect.appendChild(fadeIn);
           
           group.appendChild(rect);
           
           // Add family label for first block in each column (scale with block size)
           if (stackLevel === 0) {
             const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             label.setAttribute('x', x + (scale / 2));
             label.setAttribute('y', y - Math.max(8, scale * 0.15)); // Scale label distance
             label.setAttribute('text-anchor', 'middle');
             label.setAttribute('font-family', 'Arial, sans-serif');
             label.setAttribute('font-size', Math.max(9, scale * 0.25)); // Scale font size
             label.setAttribute('fill', '#666');
             label.setAttribute('opacity', '0.7');
             label.textContent = colorFamily;
             group.appendChild(label);
           }
         }

         // Helper method: Standard block rendering for non-collection phases
         renderStandardBlock(group, colorObj, x, y, scale, index) {
           const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
           rect.setAttribute('x', x);
           rect.setAttribute('y', y);
           
           // DEBUG: Log standard block size calculation
           const blockWidth = Math.max(scale - 2, 5);
           const blockHeight = Math.max(scale - 2, 5);
           if (window.debugBlockRendering) {
             console.log(`🎨 STANDARD BLOCK: scale=${scale} → size=${blockWidth}×${blockHeight} at (${x}, ${y})`);
           }
           
           rect.setAttribute('width', blockWidth);
           rect.setAttribute('height', blockHeight);
           rect.setAttribute('fill', colorObj.color);
           rect.setAttribute('stroke', '#000');
           rect.setAttribute('stroke-width', '0.5');
           rect.setAttribute('opacity', '0.9');
           
           // Standard scale animation for new pieces
           const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');
           animate.setAttribute('attributeName', 'transform');
           animate.setAttribute('type', 'scale');
           animate.setAttribute('values', '0;1.2;1');
           animate.setAttribute('dur', '0.5s');
           animate.setAttribute('begin', '0s');
           rect.appendChild(animate);
           
           group.appendChild(rect);
         }

         showPhaseMessage(result) {
           const engineState = this.timeBasedEngine.getState();
           const totalColors = engineState.colors.length + engineState.queuedColors.length;
           let message = '';
           
           switch (result.phase) {
             case 'collection':
               // Check column-specific compression status
               const compressedCols = new Set();
               const uncompressedCols = new Set();
               
               engineState.colors.forEach(colorObj => {
                 const family = colorObj.position.colorFamily;
                 if (colorObj.position.compressionLevel === 'none') {
                   uncompressedCols.add(family);
                 } else if (colorObj.position.compressionLevel !== undefined) {
                   compressedCols.add(family);
                 }
               });
               
               // Check if mobile optimization is active  
               const hasCompressedColumns = engineState.colors.some(colorObj => {
                 return colorObj.position.overlapFactor && colorObj.position.overlapFactor <= 0.45;
               });
               
               if (compressedCols.size > 0) {
                 if (uncompressedCols.size > 0) {
                   message = `Column compressed! ${compressedCols.size} of ${compressedCols.size + uncompressedCols.size} columns optimized... (${totalColors} colors)`;
                 } else {
                   message = `All columns compressed! Mobile-optimized... (${totalColors} colors)`;
                 }
               } else if (hasCompressedColumns) {
                 message = `Color stacked! Mobile-optimized workspace... (${totalColors} colors)`;
               } else {
                 message = `Color added! Collecting in family columns... (${totalColors} colors)`;
               }
               break;
             case 'pattern_selection':
               if (engineState.pattern) {
                 message = `Color queued! Organizing into ${engineState.pattern} pattern... (${totalColors} colors)`;
               } else {
                 message = `Color queued! Analyzing ${engineState.queuedColors.length} colors for pattern... (${totalColors} colors)`;
               }
               break;
             case 'pattern_filling':
               message = `Color placed in ${engineState.pattern} pattern! (${totalColors} colors)`;
               break;
             case 'finalization':
               message = `Perfect finishing touch added to the ${engineState.pattern}! (${totalColors} colors)`;
               break;
             default:
               message = 'Color added to the community quilt!';
           }
           
                     this.uiService.showToast(message);
        }

        // MOBILE-FIRST: Dynamic compression helper methods for fitting quilt in viewport
        calculateAvailableCanvasHeight() {
          try {
            // Simple, reliable calculation instead of complex DOM measurement
            const viewportHeight = window.innerHeight;
            console.log(`📱 DEBUG: Viewport height = ${viewportHeight}px`);
            
            // MAXIMIZE CANVAS: Minimize UI height estimate to push more content below fold
            // Only keep thank you message + first button visible, push rest below
            const estimatedUIHeight = 120; // Only essential elements above canvas
            
            const availableHeight = viewportHeight - estimatedUIHeight;
            console.log(`📱 SIMPLE CALC: viewport ${viewportHeight}px - estimated UI ${estimatedUIHeight}px = ${availableHeight}px available for canvas`);
            
            return Math.max(300, availableHeight); // Minimum 300px canvas for proper testing
          } catch (error) {
            console.warn('Height calculation failed, using fallback:', error);
            const fallback = Math.max(300, window.innerHeight - 170);
            console.log(`📱 FALLBACK HEIGHT: ${fallback}px`);
            return fallback;
          }
        }

        applyDynamicCompression(colors, targetHeight, scale) {
          if (!colors || colors.length === 0) return false;
          
          // Group colors by their columns for individual column analysis
          const columnGroups = new Map();
          colors.forEach(colorObj => {
            const family = colorObj.position.colorFamily || 'unknown';
            if (!columnGroups.has(family)) {
              columnGroups.set(family, []);
            }
            columnGroups.get(family).push(colorObj);
          });
          
          console.log(`📱 COLUMN-SPECIFIC COMPRESSION: Analyzing ${columnGroups.size} columns for individual compression needs`);
          
          let totalRepositioned = 0;
          let columnsCompressed = 0;
          
          // Apply compression column by column based on individual needs
          columnGroups.forEach((columnColors, family) => {
            // Sort by original stack level to maintain order
            columnColors.sort((a, b) => (a.position.stackLevel || 0) - (b.position.stackLevel || 0));
            
            // Calculate this column's natural height
            const columnMaxY = Math.max(...columnColors.map(c => c.position.y));
            const columnMinY = Math.min(...columnColors.map(c => c.position.y));
            const columnHeight = (columnMaxY - columnMinY) * scale;
            const columnHeightRatio = columnHeight / targetHeight;
            
            // Determine if this column needs compression and how much
            let compressionLevel = null;
            
            if (columnHeightRatio <= 0.8) {
              // Column fits comfortably - no compression needed
              console.log(`📱 ${family.toUpperCase()}: ${columnHeight.toFixed(0)}px (${Math.round(columnHeightRatio * 100)}%) - NO COMPRESSION`);
              columnColors.forEach(colorObj => {
                colorObj.position.compressionLevel = 'none';
              });
              return; // Skip this column entirely
            } else if (columnHeightRatio <= 1.2) {
              compressionLevel = 0.85; // 85% overlap - gentle compression
            } else if (columnHeightRatio <= 1.5) {
              compressionLevel = 0.75; // 75% overlap - medium compression
            } else if (columnHeightRatio <= 2.0) {
              compressionLevel = 0.65; // 65% overlap - heavy compression
            } else if (columnHeightRatio <= 3.0) {
              compressionLevel = 0.55; // 55% overlap - extreme compression
            } else {
              compressionLevel = 0.45; // 45% overlap - maximum compression
            }
            
            console.log(`📱 ${family.toUpperCase()}: ${columnHeight.toFixed(0)}px (${Math.round(columnHeightRatio * 100)}%) - COMPRESSING to ${Math.round((1 - compressionLevel) * 100)}% overlap`);
            columnsCompressed++;
            
            // Apply compression to this specific column
            columnColors.forEach((colorObj, index) => {
              const oldY = colorObj.position.y;
              
              if (index === 0) {
                // First block stays at base position
                colorObj.position.compressionLevel = compressionLevel;
                return;
              }
              
              // Calculate compressed position relative to previous block
              const previousBlock = columnColors[index - 1];
              const spacing = 1 - compressionLevel;
              colorObj.position.y = previousBlock.position.y + spacing;
              colorObj.position.compressionLevel = compressionLevel;
              
              console.log(`📱   ${family} Block ${index}: y ${oldY.toFixed(1)} → ${colorObj.position.y.toFixed(1)} (spacing ${spacing.toFixed(2)})`);
              totalRepositioned++;
            });
          });
          
          console.log(`📱 COMPRESSION COMPLETE: ${columnsCompressed}/${columnGroups.size} columns compressed, ${totalRepositioned} blocks repositioned`);
          
          return columnsCompressed > 0; // Compression applied if any columns were compressed
        }

        calculateCompressedQuiltHeight(colors, scale) {
          if (!colors || colors.length === 0) return 0;
          const maxY = Math.max(...colors.map(c => c.position.y));
          const height = maxY * scale;
          console.log(`📱 COMPRESSED HEIGHT: maxY=${maxY.toFixed(1)} × scale=${scale} = ${height.toFixed(1)}px`);
          return height;
        }

        async handleTestAddBlock() {
           try {
             const randomHue = Math.floor(Math.random() * 360);
             
             // 20% chance to generate a neutral color (low saturation)
             let randomSaturation, randomLightness;
             if (Math.random() < 0.2) {
               // Generate neutral color (gray/white/black)
               randomSaturation = Math.floor(Math.random() * 10); // 0-10% saturation
               randomLightness = 20 + Math.floor(Math.random() * 60); // 20-80% lightness
             } else {
               // Generate colorful color
               randomSaturation = CONFIG.COLOR_PICKER.saturation;
               randomLightness = 35 + Math.floor(Math.random() * 56);
             }
             
             const warmHue = (randomHue + 25) % 360;
             const warmSaturation = Math.min(randomSaturation + 5, 100);
             const randomColor = Utils.hslToHex(warmHue, warmSaturation, randomLightness);
             
             // NEW: Use TimeBasedQuiltEngine for testing too
             const result = this.timeBasedEngine.addColor(randomColor);
             
             if (result.success) {
               // Update the legacy state for UI compatibility
               this.syncEngineStateToLegacyState();
               
               await this.saveQuilt();
               this.renderTimeBasedQuilt();
               this.updateUI();
               
               // Show test-specific message
               const engineState = this.timeBasedEngine.getState();
               const message = `🧪 Test color added! Phase: ${result.phase}, Pattern: ${engineState.pattern || 'analyzing'}, Total: ${engineState.colors.length + engineState.queuedColors.length}`;
               this.uiService.showToast(message);
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'handleTestAddBlock');
             this.uiService.showToast('Test add failed.');
           }
         }

         handleShowMyPiece() {
           try {
             this.state.userPiecesHighlighted = !this.state.userPiecesHighlighted;
             
             const userPieces = this.state.pieces.filter(piece => piece.userId === this.state.currentUserId);
             const userPatches = this.state.patches.filter(patch => 
               patch.pieces && patch.pieces.some(piece => piece.userId === this.state.currentUserId)
             );
             const userBlocks = this.state.blocks.filter(block => 
               block.patches && block.patches.some(patch => 
                 patch.pieces && patch.pieces.some(piece => piece.userId === this.state.currentUserId)
               )
             );
             
             const totalUserPieces = userPieces.length + userPatches.length + userBlocks.length;
             
             if (this.state.userPiecesHighlighted) {
               if (totalUserPieces > 0) {
                 this.uiService.showToast(`Found ${totalUserPieces} of your pieces! ✨`);
               } else {
                 this.uiService.showToast("You haven't added any pieces yet. Try adding your first color!");
               }
                         } else {
              this.uiService.showToast('Highlighting turned off');
            }
            
            this.renderTimeBasedQuilt();
             
           } catch (error) {
             this.errorHandler.handleError(error, 'handleShowMyPiece');
             this.uiService.showToast('Failed to highlight your pieces. Please try again.');
           }
         }

         handleTestDifferentUser() {
           try {
             const originalUserId = this.state.currentUserId;
             this.state.currentUserId = `test_user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
             
             this.uiService.showToast(`Now simulating user: ${this.state.currentUserId.substring(0, 20)}...`);
             
             const randomColor = Utils.hslToHex(Math.floor(Math.random() * 360), 65, 50);
             const success = this.addPieceToQuilt(randomColor);
             
             this.updateUI();
             
                         if (success) {
              this.lastAddedForShare = this.state.lastAddedIndex;
              this.renderTimeBasedQuilt();
               
               // Update user counter to reflect multiple contributors
               const uniqueUsers = new Set(this.state.pieces.map(piece => piece.userId));
               window.updateUserCounter(uniqueUsers.size);
               
               this.uiService.showToast(`Added piece for different user! Now try "SHOW ME MY PIECE"`);
             }
             
             setTimeout(() => {
               this.state.currentUserId = originalUserId;
               this.uiService.showToast('Switched back to original user');
             }, 5000);
             
           } catch (error) {
             this.errorHandler.handleError(error, 'handleTestDifferentUser');
             this.uiService.showToast('Failed to simulate different user.');
           }
         }

         async handleShare() {
           try {
             const shareBtn = document.getElementById('shareBtnCompleted');
             if (shareBtn) shareBtn.disabled = true;
             
             this.uiService.showToast("Preparing flyer...");
             await this.shareFlow();
             
             if (shareBtn) shareBtn.disabled = false;
           } catch (error) {
             this.errorHandler.handleError(error, 'handleShare');
             this.uiService.showToast('Share failed. Saving instead.');
             
             const shareBtn = document.getElementById('shareBtnCompleted');
             if (shareBtn) shareBtn.disabled = false;
           }
         }

         async shareFlow() {
           // Share flow implementation would go here
           // This is a simplified version - the full implementation would be quite long
           this.uiService.showToast("Share functionality would be implemented here");
         }

         setupColorPicker() {
           const colorWheel = document.getElementById('colorWheelCanvas');
           const indicator = document.getElementById('colorIndicator');
           const valueSlider = document.getElementById('valueSlider');

           if (!colorWheel || !indicator || !valueSlider) return;
           
           const previewElement = document.getElementById('selectedColorPreview');
           if (previewElement) {
             previewElement.remove();
           }

           this.drawColorWheel();
           this.updatePreview();
           
           valueSlider.value = this.selectedLightness;
           
           setTimeout(() => {
             valueSlider.value = this.selectedLightness;
           }, 100);
           
           const rect = colorWheel.getBoundingClientRect();
           const centerX = rect.width / 2;
           const centerY = rect.height / 2;
           const radius = rect.width / 2;
           const angleRad = (this.selectedHue - 90) * Math.PI / 180;
           const x = centerX + radius * Math.cos(angleRad);
           const y = centerY + radius * Math.sin(angleRad);
           
           if (indicator) {
             const container = colorWheel.parentElement;
             const containerRect = container.getBoundingClientRect();
             const relativeX = x + rect.left - containerRect.left;
             const relativeY = y + rect.top - containerRect.top;
             indicator.style.left = `${relativeX}px`;
             indicator.style.top = `${relativeY}px`;
           }

           const debouncedSetHue = Utils.debounce(this.setHueFromCoords.bind(this), 16);
           
           colorWheel.addEventListener('click', e => {
             const rect = colorWheel.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
             const radius = rect.width / 2;
             
             if (distance <= radius) {
               this.setHueFromCoords(x, y);
             }
           });

           colorWheel.addEventListener('mousedown', e => {
             const rect = colorWheel.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
             const radius = rect.width / 2;
             
             if (distance <= radius) {
               this.setHueFromCoords(x, y);
             }
           });

           document.addEventListener('mousemove', e => {
             if (e.buttons === 1) {
               const rect = colorWheel.getBoundingClientRect();
               const x = e.clientX - rect.left;
               const y = e.clientY - rect.top;
               
               const centerX = rect.width / 2;
               const centerY = rect.height / 2;
               const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
               const radius = rect.width / 2;
               
               if (distance <= radius) {
                 debouncedSetHue(x, y);
               }
             }
           });

           valueSlider.addEventListener('input', () => {
             this.selectedLightness = Number(valueSlider.value);
             this.updatePreview();
           });
         }

         drawColorWheel() {
           // CSS-based color wheel doesn't need drawing
         }

         updatePreview() {
           const valueSlider = document.getElementById('valueSlider');
           
           const hslColor = `hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, ${this.selectedLightness}%)`;
           const hexColor = Utils.hslToHex(this.selectedHue, CONFIG.COLOR_PICKER.saturation, this.selectedLightness);
           
           const colorScreen = document.getElementById('screen-color');
           if (colorScreen && this.colorHasBeenSelected) {
             colorScreen.style.backgroundColor = hexColor;
           }
           
           if (valueSlider) {
             valueSlider.style.background = `linear-gradient(to right,
               hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 20%), 
               hsl(${this.selectedHue}, ${CONFIG.COLOR_PICKER.saturation}%, 90%))`;
           }
         }

         setHueFromCoords(x, y) {
           const colorWheel = document.getElementById('colorWheelCanvas');
           const indicator = document.getElementById('colorIndicator');
           const rect = colorWheel.getBoundingClientRect();
           const centerX = rect.width / 2;
           const centerY = rect.height / 2;
           
           const dx = x - centerX;
           const dy = y - centerY;
           const distance = Math.sqrt(dx * dx + dy * dy);
           const radius = rect.width / 2;

           if (distance > radius) {
             const clampedDistance = radius;
             const clampedX = centerX + (dx / distance) * clampedDistance;
             const clampedY = centerY + (dy / distance) * clampedDistance;
             
             let angle = Math.atan2(dy, dx) * 180 / Math.PI;
             if (angle < 0) angle += 360;
             this.selectedHue = Math.round((angle + 90) % 360);
             
             if (indicator) {
               const container = colorWheel.parentElement;
               const containerRect = container.getBoundingClientRect();
               const relativeX = clampedX + rect.left - containerRect.left;
               const relativeY = clampedY + rect.top - containerRect.top;
               indicator.style.left = `${relativeX}px`;
               indicator.style.top = `${relativeY}px`;
             }
           } else {
             let angle = Math.atan2(dy, dx) * 180 / Math.PI;
             if (angle < 0) angle += 360;
             
             this.selectedHue = Math.round((angle + 90) % 360);
             
             if (indicator) {
               const container = colorWheel.parentElement;
               const containerRect = container.getBoundingClientRect();
               const relativeX = x + rect.left - containerRect.left;
               const relativeY = y + rect.top - containerRect.top;
               indicator.style.left = `${relativeX}px`;
               indicator.style.top = `${relativeY}px`;
             }
           }
           
           this.colorHasBeenSelected = true;
           this.updatePreview();
         }

         handleKeyDown(event) {
           if (event.key === 'Escape') {
             const currentScreen = document.querySelector('.screen.active');
             if (currentScreen) {
               const currentId = currentScreen.id;
               if (currentId === 'screen-quote') {
                 this.uiService.showScreen('screen-portal');
               } else if (currentId === 'screen-color') {
                 this.uiService.showScreen('screen-quote');
               } else if (currentId === 'screen-quilt') {
                 this.uiService.showScreen('screen-color');
               }
             }
           }
         }

         // ===== UNIVERSAL MATCHING TEST FUNCTIONS =====
         
         /**
          * Test function to verify universal matching produces same results as current system
          */
         testUniversalMatching() {
           this.logger.log('🧪 Testing universal matching system...');
           
           // Test 1: Patch formation
           const testPieces = this.state.pieces.slice(0, 4); // Use first 4 pieces
           if (testPieces.length >= 2) {
             this.logger.log('Testing patch formation with universal service...');
             
             // Current method
             const currentPatches = this.formPatchesFromPieces(testPieces);
             
             // Universal method
             const universalResult = this.universalMatchingService.formCompositeElements(
               testPieces, 
               'patch',
               {
                 edgeTolerance: CONFIG.PHASES.patchFormation.edgeTolerance,
                 valueContrastWeight: CONFIG.PHASES.patchFormation.valueContrastWeight,
                 createCompositeFunction: this.createPatch.bind(this)
               }
             );
             
             this.logger.log(`Current method created ${currentPatches.length} patches`);
             this.logger.log(`Universal method created ${universalResult.compositeElements.length} patches`);
             
             if (currentPatches.length === universalResult.compositeElements.length) {
               this.uiService.showToast('✅ Universal matching test passed!');
             } else {
               this.uiService.showToast('❌ Universal matching test failed - different results');
             }
           } else {
             this.uiService.showToast('Need at least 2 pieces to test universal matching');
           }
         }
       }

             // Global function to update user counter in community message
      window.updateUserCounter = function(userCount) {
        const userCountSpan = document.getElementById('user-count');
        if (userCountSpan) {
          const suffix = userCount === 1 ? 'quilter' : 'quilters';
          userCountSpan.textContent = `${userCount} ${suffix}`;
          console.log(`Updated user counter to: ${userCount} ${suffix}`);
        } else {
          console.log('Could not find user-count element');
        }
      }

      // ===== ADMIN SYSTEM =====
      class AdminController {
        constructor(app) {
          this.app = app;
          this.isVisible = false;
          this.isAddingBlocks = false; // Prevent rapid successive additions
          this.setupEventListeners();
        }

        setupEventListeners() {
          // Toggle admin panel
          document.getElementById('adminToggle').addEventListener('click', () => {
            this.togglePanel();
          });

          // Add sample blocks
          document.getElementById('addSampleBlocks').addEventListener('click', () => {
            const count = parseInt(document.getElementById('blockCount').value) || 10;
            this.addSampleBlocks(count);
          });

          // Pattern control
          document.getElementById('applyPattern').addEventListener('click', () => {
            const pattern = document.getElementById('forcePattern').value;
            this.forcePattern(pattern);
          });

          // System control
          document.getElementById('forceReorganize').addEventListener('click', () => {
            this.forceReorganize();
          });

          document.getElementById('resetQuiltAdmin').addEventListener('click', () => {
            this.resetQuilt();
          });

          document.getElementById('updateThreshold').addEventListener('click', () => {
            const threshold = parseInt(document.getElementById('reorganizeThreshold').value) || 5;
            this.updateReorganizeThreshold(threshold);
          });

          document.getElementById('emergencyResetBtn').addEventListener('click', () => {
            this.emergencyReset();
          });

          // Diagnostics
          document.getElementById('showDiagnostics').addEventListener('click', () => {
            this.showDiagnostics();
          });

          document.getElementById('exportQuilt').addEventListener('click', () => {
            this.exportQuiltData();
          });

          // Hide panel when clicking outside
          document.addEventListener('click', (e) => {
            const panel = document.getElementById('adminPanel');
            const toggle = document.getElementById('adminToggle');
            if (this.isVisible && !panel.contains(e.target) && e.target !== toggle) {
              this.hidePanel();
            }
          });

          // Keyboard shortcut to toggle admin (Cmd+Shift+A on Mac, Ctrl+Shift+A on PC)
          document.addEventListener('keydown', (e) => {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const correctModifier = isMac ? e.metaKey : e.ctrlKey;
            
            // Use e.code for more reliable key detection (KeyA regardless of case/modifiers)
            if (correctModifier && e.shiftKey && e.code === 'KeyA') {
              e.preventDefault();
              this.togglePanel();
              console.log('🛠️ Admin panel toggled via keyboard shortcut');
            }
          });
        }

        togglePanel() {
          if (this.isVisible) {
            this.hidePanel();
          } else {
            this.showPanel();
          }
        }

        showPanel() {
          document.getElementById('adminPanel').classList.add('visible');
          this.isVisible = true;
          console.log('🛠️ Admin panel activated');
        }

        hidePanel() {
          document.getElementById('adminPanel').classList.remove('visible');
          this.isVisible = false;
        }

        // CORE FUNCTION: Sample from existing colors and add N blocks
        async addSampleBlocks(count) {
          if (!this.app.timeBasedEngine) {
            this.app.uiService.showToast('❌ Engine not initialized');
            return;
          }
          
          // Prevent rapid successive additions
          if (this.isAddingBlocks) {
            this.app.uiService.showToast('⏳ Please wait, still adding blocks...');
            return;
          }
          
          this.isAddingBlocks = true;
          
          try {
            console.log(`🎨 Admin: Adding ${count} sample blocks...`);

            // Get all existing colors
            const existingColors = this.getExistingColors();
            
            if (existingColors.length === 0) {
              this.app.uiService.showToast('❌ No existing colors to sample from');
              return;
            }

          console.log(`📊 Found ${existingColors.length} existing colors to sample from`);

          // Generate representative samples
          const samples = this.generateRepresentativeSamples(existingColors, count);

          // Add each sample with a small delay for smooth addition
          let successCount = 0;
          for (let i = 0; i < samples.length; i++) {
            const color = samples[i];
            
            try {
              const result = this.app.timeBasedEngine.addColor(color);
              
              if (result.success) {
                successCount++;
                console.log(`✅ Added sample ${i + 1}/${samples.length}: ${color}`);
              } else {
                console.log(`❌ Failed to add sample ${i + 1}: ${color} (${result.reason || 'unknown'})`);
              }
            } catch (error) {
              console.error(`💥 Error adding sample ${i + 1}: ${color}`, error);
              // Continue with next color even if this one fails
            }

            // Small delay to prevent overwhelming the system
            if (i < samples.length - 1) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }

          // Update UI
          console.log('🔄 Admin: Syncing engine state to legacy state...');
          this.app.syncEngineStateToLegacyState();
          
          console.log('🎨 Admin: Rendering time-based quilt...');
          this.app.renderTimeBasedQuilt();

          // Debug: Check final state
          const finalColors = this.app.timeBasedEngine.gridState.getAllColors();
          console.log(`📊 Admin: Final engine state: ${finalColors.length} colors in grid`);
          console.log(`📊 Admin: Colors:`, finalColors.map(c => c.color));

            this.app.uiService.showToast(`✅ Added ${successCount}/${count} sample blocks`);
            console.log(`🎨 Admin: Successfully added ${successCount}/${count} sample blocks`);
          } finally {
            // Always reset the flag, even if there was an error
            this.isAddingBlocks = false;
          }
        }

        getExistingColors() {
          // Get colors from the time-based engine
          const allColorObjects = this.app.timeBasedEngine.gridState.getAllColors();
          const queuedColors = this.app.timeBasedEngine.gridState.getQueuedColors();
          
          // Extract just the color values
          const colors = [
            ...allColorObjects.map(obj => obj.color),
            ...queuedColors
          ];

          // Remove duplicates
          return [...new Set(colors)];
        }

        generateRepresentativeSamples(existingColors, count) {
          if (existingColors.length === 0) return [];

          const samples = [];
          const usedColors = new Set(); // Prevent duplicates
          
          // If we have fewer existing colors than requested, repeat them intelligently
          if (existingColors.length <= count) {
            // Create a weighted distribution - more frequent colors appear more often
            const colorFrequency = this.analyzeColorFrequency(existingColors);
            
            for (let i = 0; i < count; i++) {
              let attempts = 0;
              let randomColor;
              
              // Try to find a color we haven't used yet
              do {
                randomColor = this.weightedRandomSelection(colorFrequency);
                attempts++;
              } while (usedColors.has(randomColor) && attempts < 50 && usedColors.size < existingColors.length);
              
              // If we've used all unique colors, start over (allows duplicates when necessary)
              if (usedColors.size >= existingColors.length) {
                usedColors.clear();
              }
              
              samples.push(randomColor);
              usedColors.add(randomColor);
            }
          } else {
            // We have more colors than needed - create a representative sample
            const diverseSample = this.createDiverseSample(existingColors, count);
            samples.push(...diverseSample);
          }

          // Final duplicate check and removal
          const uniqueSamples = [...new Set(samples)];
          
          // If we removed duplicates and now have fewer than requested, fill up to count
          while (uniqueSamples.length < count && uniqueSamples.length < existingColors.length) {
            const remaining = existingColors.filter(color => !uniqueSamples.includes(color));
            if (remaining.length > 0) {
              uniqueSamples.push(remaining[Math.floor(Math.random() * remaining.length)]);
            } else {
              break;
            }
          }
          
          // If we still don't have enough (fewer unique colors than requested), cycle through existing colors
          if (uniqueSamples.length < count && existingColors.length > 0) {
            const needed = count - uniqueSamples.length;
            for (let i = 0; i < needed; i++) {
              const randomColor = existingColors[i % existingColors.length];
              uniqueSamples.push(randomColor);
            }
          }

          console.log(`🎯 Generated ${uniqueSamples.length} representative samples (removed ${samples.length - uniqueSamples.length} duplicates)`);
          return uniqueSamples;
        }

        analyzeColorFrequency(colors) {
          const frequency = {};
          colors.forEach(color => {
            frequency[color] = (frequency[color] || 0) + 1;
          });
          return frequency;
        }

        weightedRandomSelection(colorFrequency) {
          const colors = Object.keys(colorFrequency);
          const weights = Object.values(colorFrequency);
          const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
          
          let random = Math.random() * totalWeight;
          for (let i = 0; i < colors.length; i++) {
            random -= weights[i];
            if (random <= 0) {
              return colors[i];
            }
          }
          
          // Fallback
          return colors[Math.floor(Math.random() * colors.length)];
        }

        createDiverseSample(colors, count) {
          // Convert colors to HSL for better diversity analysis
          const colorsWithHSL = colors.map(color => ({
            color,
            hsl: this.hexToHsl(color)
          }));

          // Sort by hue for diverse selection
          colorsWithHSL.sort((a, b) => a.hsl.h - b.hsl.h);

          const samples = [];
          const step = Math.floor(colorsWithHSL.length / count);

          for (let i = 0; i < count; i++) {
            const index = (i * step) % colorsWithHSL.length;
            samples.push(colorsWithHSL[index].color);
          }

          return samples;
        }

        hexToHsl(hex) {
          // Simple hex to HSL conversion (matches the one in ColorAnalyzer)
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return { h: h * 360, s: s * 100, l: l * 100 };
        }

        forcePattern(patternName) {
          if (!patternName) {
            console.log('🎯 Admin: Resetting to auto-pattern selection');
            this.app.uiService.showToast('🎯 Pattern selection reset to auto');
            return;
          }

          console.log(`🎯 Admin: Forcing pattern to ${patternName}`);
          this.app.timeBasedEngine.patternGenerator.currentPattern = patternName;
          
          // Trigger reorganization to apply the new pattern
          this.app.timeBasedEngine.reorganizeQuilt();
          this.app.syncEngineStateToLegacyState();
          this.app.renderTimeBasedQuilt();

          this.app.uiService.showToast(`🎯 Forced pattern: ${patternName}`);
        }

        forceReorganize() {
          console.log('🔄 Admin: Forcing reorganization...');
          this.app.timeBasedEngine.reorganizeQuilt();
          this.app.syncEngineStateToLegacyState();
          this.app.renderTimeBasedQuilt();
          this.app.uiService.showToast('🔄 Quilt reorganized');
        }

        resetQuilt() {
          if (confirm('⚠️ This will delete all colors and reset the quilt. Are you sure?')) {
            console.log('🗑️ Admin: Resetting quilt...');
            this.app.timeBasedEngine.gridState.clearAll();
            this.app.timeBasedEngine.colorsSinceReorganization = 0;
            this.app.syncEngineStateToLegacyState();
            this.app.renderTimeBasedQuilt();
            this.app.uiService.showToast('🗑️ Quilt reset');
          }
        }

        emergencyReset() {
          if (confirm('🚨 EMERGENCY RESET: This will clear ALL data and reset system state. Continue?')) {
            console.log('🚨 Admin: Emergency reset...');
            this.app.timeBasedEngine.gridState.clearAll();
            this.app.timeBasedEngine.colorsSinceReorganization = 0;
            this.app.timeBasedEngine.isReorganizing = false; // Force release lock
            this.app.syncEngineStateToLegacyState();
            this.app.renderTimeBasedQuilt();
            this.app.uiService.showToast('🚨 Emergency reset complete');
            this.hidePanel(); // Close admin panel after reset
          }
        }

        updateReorganizeThreshold(threshold) {
          this.app.timeBasedEngine.reorganizationThreshold = threshold;
          console.log(`⚙️ Admin: Updated reorganization threshold to ${threshold}`);
          this.app.uiService.showToast(`⚙️ Threshold updated: ${threshold}`);
        }

        showDiagnostics() {
          const engine = this.app.timeBasedEngine;
          const colors = engine.gridState.getAllColors();
          const queued = engine.gridState.getQueuedColors();
          const analysis = engine.colorAnalyzer.getAnalysis();

          const stats = {
            'Total Colors': colors.length,
            'Queued Colors': queued.length,
            'Current Pattern': engine.patternGenerator.getCurrentPattern() || 'None',
            'Current Phase': engine.getCurrentPhase(),
            'Colors Since Reorganization': engine.colorsSinceReorganization,
            'Reorganization Threshold': engine.reorganizationThreshold,
            'Dominant Theme': analysis.dominantTheme || 'None',
            'Has Contrasts': analysis.hasContrasts || false
          };

          console.log('📊 ADMIN DIAGNOSTICS:', stats);
          
          let message = '📊 SYSTEM STATS:\\n';
          Object.entries(stats).forEach(([key, value]) => {
            message += `${key}: ${value}\\n`;
          });

          alert(message);
        }

        exportQuiltData() {
          const data = {
            timestamp: new Date().toISOString(),
            colors: this.app.timeBasedEngine.gridState.getAllColors(),
            queued: this.app.timeBasedEngine.gridState.getQueuedColors(),
            pattern: this.app.timeBasedEngine.patternGenerator.getCurrentPattern(),
            phase: this.app.timeBasedEngine.getCurrentPhase(),
            analysis: this.app.timeBasedEngine.colorAnalyzer.getAnalysis()
          };

          const jsonString = JSON.stringify(data, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = `quilt-export-${new Date().toISOString().slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          this.app.uiService.showToast('📁 Quilt data exported');
          console.log('📁 Admin: Quilt data exported');
        }
      }

      // Initialize the application
      document.addEventListener('DOMContentLoaded', async () => {
        const app = new OurDailyApp();
        await app.initialize();
        
        // Initialize admin controller
        const adminController = new AdminController(app);
        
        // Expose app and admin globally for testing
        window.app = app;
        window.admin = adminController;
        
        // Global admin convenience functions
        window.addBlocks = (count = 10) => adminController.addSampleBlocks(count);
        window.forcePattern = (pattern) => adminController.forcePattern(pattern);
        window.showStats = () => adminController.showDiagnostics();
        window.toggleAdmin = () => adminController.togglePanel();
        
        // Debug function to check state and force render
        window.debugRender = () => {
          console.log('🔍 DEBUG: Checking system state...');
          
          const engine = app.timeBasedEngine;
          const colors = engine.gridState.getAllColors();
          const queued = engine.gridState.getQueuedColors();
          
          console.log(`📊 Engine colors: ${colors.length}`);
          console.log(`📊 Queued colors: ${queued.length}`);
          console.log(`📊 Current pattern: ${engine.patternGenerator.getCurrentPattern()}`);
          console.log(`📊 Current phase: ${engine.getCurrentPhase()}`);
          console.log(`📊 Colors in detail:`, colors);
          
          console.log('🔄 Forcing UI sync and render...');
          app.syncEngineStateToLegacyState();
          app.renderTimeBasedQuilt();
          
          console.log('✅ Debug render complete');
        };
        
        // Test function to add sample blocks from console
        window.testAddSamples = (count = 5) => adminController.addSampleBlocks(count);
        
        // Emergency reset function for when things go wrong
        window.emergencyReset = () => {
          console.log('🚨 EMERGENCY RESET: Clearing all data...');
          app.timeBasedEngine.gridState.clearAll();
          app.timeBasedEngine.colorsSinceReorganization = 0;
          app.timeBasedEngine.isReorganizing = false; // Force release lock
          app.syncEngineStateToLegacyState();
          app.renderTimeBasedQuilt();
          console.log('🆕 System reset complete - ready for fresh start');
        };
        
        // Force visual update function
        window.forceRender = () => {
          console.log('🔄 FORCE RENDER: Updating visual quilt...');
          app.syncEngineStateToLegacyState();
          app.renderTimeBasedQuilt();
          const colors = app.timeBasedEngine.gridState.getAllColors();
          console.log(`✅ Rendered ${colors.length} colors to screen`);
        };

        // BLOCK SIZE DEBUGGING - Let's see what's actually happening!
        window.debugBlockSizes = function() {
          console.log('\n🔍 === BLOCK SIZE DEBUG ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log(`📐 SVG Dimensions: ${svg.getAttribute('width')} × ${svg.getAttribute('height')}`);
          console.log(`📐 SVG ViewBox: ${svg.getAttribute('viewBox')}`);
          console.log(`🏷️ Data attribute: data-time-based-active="${svg.getAttribute('data-time-based-active')}"`);
          
          const blocks = svg.querySelectorAll('rect');
          console.log(`🎨 Total blocks found: ${blocks.length}`);
          
          if (blocks.length > 0) {
            const firstBlock = blocks[0];
            console.log(`📦 First block: width=${firstBlock.getAttribute('width')} height=${firstBlock.getAttribute('height')}`);
            console.log(`📍 First block position: x=${firstBlock.getAttribute('x')} y=${firstBlock.getAttribute('y')}`);
            
            // Check a few more blocks
            for (let i = 0; i < Math.min(5, blocks.length); i++) {
              const block = blocks[i];
              console.log(`Block ${i}: ${block.getAttribute('width')}×${block.getAttribute('height')} at (${block.getAttribute('x')}, ${block.getAttribute('y')})`);
            }
          }
          
          // Check CSS that might be affecting size
          const computedStyle = window.getComputedStyle(svg);
          console.log(`💄 SVG CSS: width=${computedStyle.width}, height=${computedStyle.height}`);
          console.log(`💄 Max dimensions: max-width=${computedStyle.maxWidth}, max-height=${computedStyle.maxHeight}`);
          console.log(`💄 Min dimensions: min-width=${computedStyle.minWidth}, min-height=${computedStyle.minHeight}`);
          
          return { svg, blocks: Array.from(blocks) };
        };

        window.debugRenderProcess = function() {
          console.log('\n🎨 === RENDER PROCESS DEBUG ===');
          console.log('Screen width:', window.innerWidth);
          console.log('Screen height:', window.innerHeight);
          
          if (window.app && window.app.timeBasedEngine) {
            const engine = window.app.timeBasedEngine;
            const state = engine.getState();
            console.log('Phase:', state.phase);
            console.log('Colors count:', state.colors.length);
            console.log('Grid bounds:', {
              minX: Math.min(...state.colors.map(c => c.position.x)),
              maxX: Math.max(...state.colors.map(c => c.position.x)),
              minY: Math.min(...state.colors.map(c => c.position.y)),
              maxY: Math.max(...state.colors.map(c => c.position.y))
            });
          }
        };

        // Toggle detailed block rendering debug
        window.toggleBlockDebug = function() {
          window.debugBlockRendering = !window.debugBlockRendering;
          console.log(`🔧 Block rendering debug: ${window.debugBlockRendering ? 'ON' : 'OFF'}`);
          if (window.debugBlockRendering) {
            console.log('Next blocks rendered will show size details...');
          }
        };

        // Quick debug combo - run all debug functions
        window.debugAll = function() {
          console.log('\n🚀 === FULL DEBUG COMBO ===');
          window.debugRenderProcess();
          window.debugBlockSizes();
          window.debugStatus();
        };

        // Test ultra-big blocks manually
        window.testUltraBigBlocks = function() {
          console.log('🚀 TESTING ULTRA-BIG BLOCKS');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Clear and create one massive test block
          svg.innerHTML = '';
          svg.setAttribute('width', '412');
          svg.setAttribute('height', '765');
          svg.setAttribute('viewBox', '0 0 412 765');
          svg.setAttribute('data-time-based-active', 'true');
          
          // AGGRESSIVE HEIGHT FORCING
          svg.style.setProperty('height', '765px', 'important');
          svg.style.setProperty('width', '412px', 'important');
          svg.style.setProperty('max-height', 'none', 'important');
          svg.style.setProperty('min-height', 'auto', 'important');
          
          // Create background
          const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          bg.setAttribute('width', '100%');
          bg.setAttribute('height', '100%');
          bg.setAttribute('fill', '#f8f9fa');
          svg.appendChild(bg);
          
          // Create one massive test block to see maximum size
          const testBlock = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          testBlock.setAttribute('x', '50');
          testBlock.setAttribute('y', '100');
          testBlock.setAttribute('width', '100'); // Much bigger test block
          testBlock.setAttribute('height', '100');
          testBlock.setAttribute('fill', '#ff6b6b');
          testBlock.setAttribute('stroke', '#000');
          testBlock.setAttribute('stroke-width', '2');
          svg.appendChild(testBlock);
          
          console.log('✅ Ultra-big test block created (100×100px) with aggressive height forcing!');
          setTimeout(() => window.debugBlockSizes(), 200);
        };

        // Force SVG to use proper dimensions during normal rendering
        window.aggressivelyFixSVGHeight = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) return false;
          
          const currentWidth = svg.getAttribute('width') || '412';
          const currentHeight = svg.getAttribute('height') || '765';
          
          console.log(`🔧 AGGRESSIVE FIX: Setting SVG to ${currentWidth}×${currentHeight}`);
          
          // Multiple ways to force the height
          svg.style.setProperty('width', currentWidth + 'px', 'important');
          svg.style.setProperty('height', currentHeight + 'px', 'important');
          svg.style.setProperty('max-width', 'none', 'important');
          svg.style.setProperty('max-height', 'none', 'important');
          svg.style.setProperty('min-width', 'auto', 'important');
          svg.style.setProperty('min-height', 'auto', 'important');
          
          return true;
        };

        // Height monitoring system to catch when something overrides our styles
        window.startHeightMonitor = function() {
          if (window.heightMonitorInterval) {
            clearInterval(window.heightMonitorInterval);
          }
          
          console.log('🔍 Starting SVG height monitor...');
          
          window.heightMonitorInterval = setInterval(() => {
            const svg = document.querySelector('#quilt');
            if (!svg) return;
            
            const attributeHeight = svg.getAttribute('height');
            const computedStyle = window.getComputedStyle(svg);
            const cssHeight = computedStyle.height;
            
            // Only log when there's a mismatch
            if (attributeHeight && cssHeight !== attributeHeight + 'px') {
              console.log(`🚨 HEIGHT OVERRIDE DETECTED!`);
              console.log(`   Attribute: ${attributeHeight}px`);
              console.log(`   CSS: ${cssHeight}`);
              
              // Get detailed CSS information
              const computedStyle = window.getComputedStyle(svg);
              console.log(`   Max-height: ${computedStyle.maxHeight}`);
              console.log(`   Min-height: ${computedStyle.minHeight}`);
              console.log(`   Box-sizing: ${computedStyle.boxSizing}`);
              console.log(`   Display: ${computedStyle.display}`);
              console.log(`   Position: ${computedStyle.position}`);
              
              // Check for aspect ratio constraints
              if (computedStyle.aspectRatio && computedStyle.aspectRatio !== 'auto') {
                console.log(`   🎯 ASPECT RATIO CONSTRAINT: ${computedStyle.aspectRatio}`);
              }
              
              // Check parent container constraints
              const parent = svg.parentElement;
              if (parent) {
                const parentStyle = window.getComputedStyle(parent);
                console.log(`   Parent height: ${parentStyle.height}`);
                console.log(`   Parent max-height: ${parentStyle.maxHeight}`);
                console.log(`   Parent overflow: ${parentStyle.overflow}`);
              }
              
              console.log(`   Forcing back to ${attributeHeight}px with nuclear option...`);
              
              // NUCLEAR OPTION: Multiple aggressive overrides
              svg.style.cssText += `
                width: ${svg.getAttribute('width')}px !important;
                height: ${attributeHeight}px !important;
                max-width: none !important;
                max-height: none !important;
                min-width: auto !important;
                min-height: auto !important;
                aspect-ratio: auto !important;
                flex: none !important;
                flex-shrink: 0 !important;
                flex-grow: 0 !important;
              `;
            }
          }, 100); // Check every 100ms
        };

        window.stopHeightMonitor = function() {
          if (window.heightMonitorInterval) {
            clearInterval(window.heightMonitorInterval);
            window.heightMonitorInterval = null;
            console.log('🔍 Height monitor stopped');
          }
        };

        // Deep dive into what's constraining the SVG
        window.debugSVGConstraints = function() {
          console.log('\n🔬 === SVG CONSTRAINT ANALYSIS ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          const computedStyle = window.getComputedStyle(svg);
          
          console.log('📏 SVG Attributes:');
          console.log(`   width="${svg.getAttribute('width')}" height="${svg.getAttribute('height')}"`);
          console.log(`   viewBox="${svg.getAttribute('viewBox')}"`);
          
          console.log('🎨 Computed CSS:');
          console.log(`   width: ${computedStyle.width}`);
          console.log(`   height: ${computedStyle.height}`);
          console.log(`   max-width: ${computedStyle.maxWidth}`);
          console.log(`   max-height: ${computedStyle.maxHeight}`);
          console.log(`   min-width: ${computedStyle.minWidth}`);
          console.log(`   min-height: ${computedStyle.minHeight}`);
          console.log(`   aspect-ratio: ${computedStyle.aspectRatio}`);
          console.log(`   box-sizing: ${computedStyle.boxSizing}`);
          console.log(`   display: ${computedStyle.display}`);
          console.log(`   position: ${computedStyle.position}`);
          console.log(`   flex: ${computedStyle.flex}`);
          console.log(`   flex-shrink: ${computedStyle.flexShrink}`);
          console.log(`   flex-grow: ${computedStyle.flexGrow}`);
          
          // Check parent constraints
          let parent = svg.parentElement;
          let level = 1;
          while (parent && level <= 3) {
            const parentStyle = window.getComputedStyle(parent);
            console.log(`🏠 Parent ${level} (${parent.tagName}#${parent.id || 'no-id'}.${parent.className || 'no-class'}):`);
            console.log(`   height: ${parentStyle.height}`);
            console.log(`   max-height: ${parentStyle.maxHeight}`);
            console.log(`   overflow: ${parentStyle.overflow}`);
            console.log(`   display: ${parentStyle.display}`);
            console.log(`   position: ${parentStyle.position}`);
            
            parent = parent.parentElement;
            level++;
          }
          
          // Check specific CSS rules targeting #quilt
          const rules = Array.from(document.styleSheets).flatMap(sheet => {
            try {
              return Array.from(sheet.cssRules || []);
            } catch (e) {
              return [];
            }
          });
          
          console.log('📋 CSS Rules affecting #quilt:');
          rules.forEach((rule, index) => {
            if (rule.selectorText && rule.selectorText.includes('#quilt')) {
              console.log(`   Rule ${index}: ${rule.selectorText}`);
              console.log(`      ${rule.cssText}`);
            }
          });
        };

        // Debug current scale calculation
        window.debugScaleCalculation = function() {
          console.log('\n🔢 === SCALE CALCULATION DEBUG ===');
          
          const screenWidth = window.innerWidth;
          const numberOfColorFamilies = 8;
          const smallPadding = 8;
          const columnSpacing = 4;
          
          const availableWidthForBlocks = screenWidth - smallPadding - (columnSpacing * (numberOfColorFamilies - 1));
          const optimalBlockSize = Math.floor(availableWidthForBlocks / numberOfColorFamilies);
          
          const minBlockSize = 40;
          const maxBlockSize = 80;
          const scale = Math.min(maxBlockSize, Math.max(minBlockSize, optimalBlockSize));
          
          console.log(`📱 Screen width: ${screenWidth}px`);
          console.log(`📏 Small padding: ${smallPadding}px`);
          console.log(`📏 Column spacing: ${columnSpacing}px × 7 gaps = ${columnSpacing * 7}px`);
          console.log(`📦 Available for blocks: ${availableWidthForBlocks}px`);
          console.log(`🔢 Optimal block size: ${optimalBlockSize}px`);
          console.log(`🎯 Final scale (min=${minBlockSize}, max=${maxBlockSize}): ${scale}px`);
          console.log(`📐 Rendered block size: ${scale - 2}px × ${scale - 2}px (scale - 2px padding)`);
          
          return scale;
        };

        // Emergency visual scaling debug
        window.debugVisualScaling = function() {
          console.log('\n🔍 === VISUAL SCALING DEBUG ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Get actual visual measurements
          const svgRect = svg.getBoundingClientRect();
          const svgStyle = window.getComputedStyle(svg);
          
          console.log('📏 VISUAL MEASUREMENTS:');
          console.log(`   getBoundingClientRect: ${svgRect.width.toFixed(1)}×${svgRect.height.toFixed(1)}`);
          console.log(`   CSS width/height: ${svgStyle.width} / ${svgStyle.height}`);
          console.log(`   SVG attributes: ${svg.getAttribute('width')}×${svg.getAttribute('height')}`);
          
          // Check viewport scaling
          console.log('📱 VIEWPORT SCALING:');
          console.log(`   window.devicePixelRatio: ${window.devicePixelRatio}`);
          console.log(`   window.innerWidth: ${window.innerWidth}`);
          console.log(`   screen.width: ${screen.width}`);
          console.log(`   document.documentElement.clientWidth: ${document.documentElement.clientWidth}`);
          
          // Check for zoom/transform
          const transform = svgStyle.transform;
          const zoom = svgStyle.zoom;
          console.log(`   CSS transform: ${transform}`);
          console.log(`   CSS zoom: ${zoom}`);
          
          // Check viewport meta tag
          const viewportMeta = document.querySelector('meta[name="viewport"]');
          console.log(`   Viewport meta: ${viewportMeta ? viewportMeta.content : 'MISSING!'}`);
          
          // Check actual block measurements
          const blocks = svg.querySelectorAll('rect:not([width="100%"])');
          if (blocks.length > 0) {
            const firstBlock = blocks[0];
            const blockRect = firstBlock.getBoundingClientRect();
            console.log('🎨 FIRST BLOCK:');
            console.log(`   SVG attributes: ${firstBlock.getAttribute('width')}×${firstBlock.getAttribute('height')}`);
            console.log(`   Visual size: ${blockRect.width.toFixed(1)}×${blockRect.height.toFixed(1)}`);
            console.log(`   Visual/Attribute ratio: ${(blockRect.width / parseFloat(firstBlock.getAttribute('width'))).toFixed(2)}x`);
            
            // Calculate what size they SHOULD be for good mobile visibility
            const screenWidth = window.innerWidth;
            const idealBlockSize = Math.floor(screenWidth / 8); // 8 color families
            console.log(`🎯 IDEAL MOBILE SIZE: ${idealBlockSize}px (screen ${screenWidth}px ÷ 8 families)`);
            console.log(`🔍 SIZE COMPARISON: Current ${firstBlock.getAttribute('width')}px vs Ideal ${idealBlockSize}px`);
          }
        };

        // Fix visual scaling by making blocks actually bigger
        window.makeMobileFriendlyBlocks = function() {
          console.log('🔧 MAKING BLOCKS MOBILE-FRIENDLY...');
          
          const screenWidth = window.innerWidth;
          const optimalSize = Math.floor(screenWidth / 6); // 6 instead of 8 for bigger blocks
          const biggerSize = Math.max(60, optimalSize); // Minimum 60px
          
          console.log(`📱 Screen: ${screenWidth}px → Making blocks ${biggerSize}px (vs current 47px)`);
          
          // Force bigger scale in the engine
          if (window.app && window.app.timeBasedEngine) {
            console.log('🎯 Forcing bigger scale in time-based engine...');
            
            // Override the scale calculation temporarily
            const originalRender = window.app.renderTimeBasedQuilt;
            window.app.renderTimeBasedQuilt = function() {
              console.log(`🔧 OVERRIDE: Using ${biggerSize}px blocks instead of calculated size`);
              
              // Temporarily override scale calculation
              const originalCalc = window.innerWidth;
              window.innerWidth = biggerSize * 8 + 50; // Fake screen width to get bigger blocks
              
              const result = originalRender.call(this);
              
              // Restore original
              window.innerWidth = originalCalc;
              
              return result;
            };
            
            // Re-render with bigger blocks
            window.app.renderTimeBasedQuilt();
          }
        };

        // Manual CSS fix test
        window.fixSVGSize = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log('🔧 MANUAL CSS FIX: Applying inline styles to override all constraints');
          svg.style.setProperty('width', '100vw', 'important');
          svg.style.setProperty('height', 'auto', 'important');
          svg.style.setProperty('max-width', 'none', 'important');
          svg.style.setProperty('max-height', 'none', 'important');
          svg.style.setProperty('min-width', 'unset', 'important');
          svg.style.setProperty('min-height', 'unset', 'important');
          svg.style.setProperty('margin', '0', 'important');
          svg.style.setProperty('padding', '0', 'important');
          
          console.log('✅ Inline styles applied - check visual result');
          setTimeout(() => window.debugBlockSizes(), 100);
        };

        // Check parent container constraints
        window.debugParents = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log('\n🏗️ === PARENT CONTAINER DEBUG ===');
          let element = svg;
          let level = 0;
          
          while (element && level < 5) {
            const styles = window.getComputedStyle(element);
            console.log(`Level ${level}: <${element.tagName.toLowerCase()}${element.id ? ' id="' + element.id + '"' : ''}${element.className ? ' class="' + element.className + '"' : ''}>`);
            console.log(`  width: ${styles.width}, height: ${styles.height}`);
            console.log(`  max-width: ${styles.maxWidth}, max-height: ${styles.maxHeight}`);
            console.log(`  overflow: ${styles.overflow}, position: ${styles.position}`);
            
            element = element.parentElement;
            level++;
          }
        };

        // Force parent containers to not constrain
        window.fixParents = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log('🔧 FIXING PARENT CONTAINERS');
          let element = svg.parentElement;
          let level = 1;
          
          while (element && level < 4) {
            console.log(`Fixing parent level ${level}: ${element.tagName}`);
            element.style.setProperty('height', 'auto', 'important');
            element.style.setProperty('max-height', 'none', 'important');
            element.style.setProperty('min-height', 'unset', 'important');
            element.style.setProperty('overflow', 'visible', 'important');
            
            element = element.parentElement;
            level++;
          }
          
          console.log('✅ Parent fixes applied');
          setTimeout(() => window.debugBlockSizes(), 100);
        };

        // Force time-based engine to activate
        window.forceTimeBasedEngine = function() {
          console.log('🚀 FORCING TIME-BASED ENGINE ACTIVATION');
          
          if (!window.app || !window.app.timeBasedEngine) {
            console.log('❌ No time-based engine found');
            return;
          }
          
          const svg = document.querySelector('#quilt');
          if (svg) {
            console.log('🧹 Clearing old legacy content...');
            svg.innerHTML = '';
            svg.removeAttribute('width');
            svg.removeAttribute('height'); 
            svg.removeAttribute('viewBox');
          }
          
          console.log('🔄 Triggering renderTimeBasedQuilt...');
          window.app.renderTimeBasedQuilt();
          
          setTimeout(() => {
            console.log('✅ Time-based engine should now be active');
            window.debugBlockSizes();
          }, 200);
        };

        // Clear everything and start fresh
        window.resetToTimeBasedEngine = function() {
          console.log('🔄 COMPLETE RESET TO TIME-BASED ENGINE');
          
          const svg = document.querySelector('#quilt');
          if (svg) {
            console.log('🧹 Completely clearing SVG...');
            svg.innerHTML = '';
            svg.removeAttribute('width');
            svg.removeAttribute('height'); 
            svg.removeAttribute('viewBox');
            svg.setAttribute('data-time-based-active', 'true');
          }
          
          if (window.app && window.app.timeBasedEngine) {
            console.log('🎨 Forcing fresh render with current colors...');
            const state = window.app.timeBasedEngine.getState();
            console.log(`Colors in engine: ${state.colors.length}`);
            
            // Force a complete re-render
            window.app.renderTimeBasedQuilt();
          }
          
          setTimeout(() => {
            console.log('✅ Fresh time-based render complete');
            window.debugBlockSizes();
          }, 300);
        };

        // Diagnose why blocks become small again
        window.diagnoseSmallBlocks = function() {
          console.log('🔍 DIAGNOSING SMALL BLOCKS ISSUE...');
          
          const svg = document.getElementById('quilt');
          if (!svg) {
            console.error('❌ SVG element not found');
            return;
          }
          
          // Check if time-based engine is active
          const isTimeBasedActive = svg.getAttribute('data-time-based-active');
          console.log(`🔍 Time-based engine active: ${isTimeBasedActive}`);
          
          // Check SVG dimensions vs computed style
          const svgAttribs = {
            width: svg.getAttribute('width'),
            height: svg.getAttribute('height'),
            viewBox: svg.getAttribute('viewBox')
          };
          console.log('🔍 SVG Attributes:', svgAttribs);
          
          const computedStyle = window.getComputedStyle(svg);
          const computedDims = {
            width: computedStyle.width,
            height: computedStyle.height,
            maxHeight: computedStyle.maxHeight,
            minHeight: computedStyle.minHeight
          };
          console.log('🔍 Computed SVG Style:', computedDims);
          
          // Check inline styles
          console.log('🔍 SVG Inline Style:', svg.style.cssText);
          
          // Check blocks
          const blocks = svg.querySelectorAll('rect[data-color]');
          console.log(`🔍 Total blocks found: ${blocks.length}`);
          
          if (blocks.length > 0) {
            const firstBlock = blocks[0];
            const blockAttribs = {
              width: firstBlock.getAttribute('width'),
              height: firstBlock.getAttribute('height'),
              x: firstBlock.getAttribute('x'),
              y: firstBlock.getAttribute('y')
            };
            console.log('🔍 First block attributes:', blockAttribs);
          }
          
          // Check engine state
          if (window.app && window.app.timeBasedEngine) {
            const engineState = window.app.timeBasedEngine.getState();
            console.log('🔍 Engine state:', {
              phase: engineState.phase,
              colorCount: engineState.colors.length,
              isReorganizing: engineState.isReorganizing
            });
          }
          
          // Check if legacy system took over
          const legacyBlocks = svg.querySelectorAll('rect:not([data-color])');
          if (legacyBlocks.length > 0) {
            console.warn(`🚨 LEGACY BLOCKS DETECTED: ${legacyBlocks.length} blocks without data-color attribute`);
            console.warn('🚨 This suggests the legacy rendering system has taken over');
          }
          
          console.log('🔍 Diagnosis complete. Run resetToTimeBasedEngine() if legacy system detected.');
        };

        // Check engine state and add a test block if needed
        window.testWithBlock = function() {
          console.log('🧪 TESTING WITH BLOCK ADDITION');
          
          if (!window.app || !window.app.timeBasedEngine) {
            console.log('❌ No time-based engine found');
            return;
          }
          
          const state = window.app.timeBasedEngine.getState();
          console.log(`Current colors in engine: ${state.colors.length}`);
          console.log(`Phase: ${state.phase}`);
          
          if (state.colors.length === 0) {
            console.log('🎨 No colors found, adding a test color...');
            window.app.timeBasedEngine.addColor('#ff6b6b');
          } else {
            console.log('🔄 Colors exist, forcing re-render...');
            window.app.renderTimeBasedQuilt();
          }
          
          setTimeout(() => {
            console.log('✅ Test complete');
            window.debugBlockSizes();
          }, 500);
        };

        // Check for viewport scaling issues
        window.checkViewportScaling = function() {
          console.log('\n🔍 === VIEWPORT SCALING DEBUG ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Get actual visual dimensions
          const rect = svg.getBoundingClientRect();
          console.log(`🖼️ Visual SVG size: ${rect.width.toFixed(1)} × ${rect.height.toFixed(1)}`);
          
          // Compare to computed style
          const computed = window.getComputedStyle(svg);
          console.log(`💄 Computed style: ${computed.width} × ${computed.height}`);
          
          // Check for scaling
          const scaleX = rect.width / parseFloat(computed.width);
          const scaleY = rect.height / parseFloat(computed.height);
          console.log(`📏 Scale factors: X=${scaleX.toFixed(3)}, Y=${scaleY.toFixed(3)}`);
          
          // Check viewport meta tag
          const viewport = document.querySelector('meta[name="viewport"]');
          console.log(`📱 Viewport meta: ${viewport ? viewport.content : 'MISSING!'}`);
          
          // Check zoom level
          console.log(`🔍 Browser zoom: ${(window.devicePixelRatio || 1)}x`);
          console.log(`📺 Screen: ${screen.width}×${screen.height}, Window: ${window.innerWidth}×${window.innerHeight}`);
          
          return { rect, computed, scaleX, scaleY };
        };

        // Force proper viewport and remove all scaling
        window.fixViewportScaling = function() {
          console.log('🔧 FIXING VIEWPORT SCALING');
          
          // Fix viewport meta tag
          let viewport = document.querySelector('meta[name="viewport"]');
          if (!viewport) {
            viewport = document.createElement('meta');
            viewport.name = 'viewport';
            document.head.appendChild(viewport);
          }
          viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
          console.log('✅ Viewport meta tag fixed');
          
          // Remove any transforms on the SVG and parents
          const svg = document.querySelector('#quilt');
          if (svg) {
            let element = svg;
            let level = 0;
            while (element && level < 5) {
              element.style.setProperty('transform', 'none', 'important');
              element.style.setProperty('zoom', '1', 'important');
              element.style.setProperty('scale', '1', 'important');
              element = element.parentElement;
              level++;
            }
            console.log('✅ Removed scaling transforms');
          }
          
          setTimeout(() => {
            console.log('📊 Post-fix scaling check:');
            window.checkViewportScaling();
          }, 200);
        };

        // Nuclear option - completely disable old system and force time-based
        window.forceTimeBasedOnly = function() {
          console.log('💥 NUCLEAR OPTION: Completely disabling old system');
          
          // Disable old rendering functions
          if (window.app && window.app.renderBlocks) {
            window.app.renderBlocks = function() {
              console.log('🚫 Old renderBlocks() disabled - using time-based engine instead');
              return window.app.renderTimeBasedQuilt();
            };
          }
          
          if (window.app && window.app.renderQuilt) {
            window.app.renderQuilt = function() {
              console.log('🚫 Old renderQuilt() disabled - using time-based engine instead');
              return window.app.renderTimeBasedQuilt();
            };
          }
          
          // Clear and setup SVG
          const svg = document.querySelector('#quilt');
          if (svg) {
            console.log('🧹 Clearing and setting up SVG...');
            svg.innerHTML = '';
            svg.removeAttribute('width');
            svg.removeAttribute('height'); 
            svg.removeAttribute('viewBox');
            svg.setAttribute('data-time-based-active', 'true');
            
            // Apply CSS overrides directly
            svg.style.setProperty('width', '100vw', 'important');
            svg.style.setProperty('height', 'auto', 'important');
            svg.style.setProperty('max-width', 'none', 'important');
            svg.style.setProperty('max-height', 'none', 'important');
            svg.style.setProperty('min-width', 'unset', 'important');
            svg.style.setProperty('min-height', 'unset', 'important');
          }
          
          // Force time-based engine render
          if (window.app && window.app.timeBasedEngine) {
            console.log('🚀 Forcing time-based engine render...');
            const state = window.app.timeBasedEngine.getState();
            
            if (state.colors.length === 0) {
              console.log('Adding test colors...');
              window.app.timeBasedEngine.addColor('#ff6b6b');
              window.app.timeBasedEngine.addColor('#4ecdc4');
              window.app.timeBasedEngine.addColor('#45b7d1');
            }
            
            window.app.renderTimeBasedQuilt();
          }
          
          setTimeout(() => {
            console.log('✅ Nuclear option complete - check results');
            window.debugBlockSizes();
          }, 800);
        };

        // Test ultra-big blocks to see maximum possible size
        window.testUltraBigBlocks = function() {
          console.log('🚀 TESTING ULTRA-BIG BLOCKS');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Clear and create one massive test block
          svg.innerHTML = '';
          svg.setAttribute('width', '412');
          svg.setAttribute('height', '765');
          svg.setAttribute('viewBox', '0 0 412 765');
          svg.setAttribute('data-time-based-active', 'true');
          
          // Create background
          const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          bg.setAttribute('width', '100%');
          bg.setAttribute('height', '100%');
          bg.setAttribute('fill', '#f8f9fa');
          svg.appendChild(bg);
          
          // Create one massive test block to see maximum size
          const testBlock = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          testBlock.setAttribute('x', '50');
          testBlock.setAttribute('y', '100');
          testBlock.setAttribute('width', '100'); // Much bigger test block
          testBlock.setAttribute('height', '100');
          testBlock.setAttribute('fill', '#ff6b6b');
          testBlock.setAttribute('stroke', '#000');
          testBlock.setAttribute('stroke-width', '2');
          svg.appendChild(testBlock);
          
          console.log('✅ Ultra-big test block created (100×100px)');
          setTimeout(() => window.debugBlockSizes(), 200);
        };

        // DEBUG STATUS - comprehensive status check
        window.debugStatus = () => {
          console.log('🔍 === DEBUG STATUS ===');
          const state = app.timeBasedEngine.getState();
          console.log('Engine State:', state);
          console.log('Total Colors (including duplicates):', state.colors?.length || 0);
          console.log('Queued Colors:', state.queuedColors?.length || 0);
          console.log('Current Phase:', state.phase);
          console.log('Colors Since Reorganization:', app.timeBasedEngine.colorsSinceReorganization);
          console.log('Is Reorganizing:', app.timeBasedEngine.isReorganizing);
          
          // Show duplicate analysis
          if (state.colors?.length > 0) {
            const colorCounts = {};
            state.colors.forEach(colorObj => {
              colorCounts[colorObj.color] = (colorCounts[colorObj.color] || 0) + 1;
            });
            const uniqueColors = Object.keys(colorCounts).length;
            const duplicates = Object.entries(colorCounts).filter(([color, count]) => count > 1);
            console.log(`Unique Colors: ${uniqueColors}`);
            console.log(`Duplicate Colors: ${duplicates.length > 0 ? duplicates.map(([color, count]) => `${color}(${count}x)`).join(', ') : 'None'}`);
            
            // Show coordinate bounds
            const positions = state.colors.map(c => c.position);
            const minX = Math.min(...positions.map(p => p.x));
            const maxX = Math.max(...positions.map(p => p.x));
            const minY = Math.min(...positions.map(p => p.y));
            const maxY = Math.max(...positions.map(p => p.y));
            console.log(`Grid Bounds: X(${minX} to ${maxX}), Y(${minY} to ${maxY})`);
            console.log(`Grid Size: ${maxX - minX + 1} x ${maxY - minY + 1}`);
            
            // Collection phase: show color family columns
            if (state.phase === 'collection') {
              const columnInfo = Array.from(app.timeBasedEngine.gridState.colorColumns.entries())
                .map(([family, column]) => `${family}(${column.colors.length})`);
              console.log(`🧵 Color Family Columns: ${columnInfo.join(', ')}`);
              console.log(`🧵 Tight column spacing (1.2) - no reorganization in collection phase!`);
              
              // Show column positions for tight spacing analysis
              const columnPositions = Array.from(app.timeBasedEngine.gridState.colorColumns.entries())
                .map(([family, column]) => `${family}@x${column.x.toFixed(1)}`);
              console.log(`🧵 Column positions: ${columnPositions.join(' | ')}`);
              
              // Mobile optimization analysis
              const columnHeights = Array.from(app.timeBasedEngine.gridState.colorColumns.entries())
                .map(([family, column]) => {
                  const height = column.colors.length;
                  let overlap;
                  if (height <= 3) overlap = '0.8';
                  else if (height <= 6) overlap = '0.6';
                  else if (height <= 10) overlap = '0.45';
                  else overlap = '0.35';
                  return `${family}(${height}@${overlap})`;
                });
              console.log(`📱 Mobile columns: ${columnHeights.join(' | ')}`);
            }
            
            // Check for negative coordinates
            const negativeCoords = positions.filter(p => p.x < 0 || p.y < 0);
            if (negativeCoords.length > 0) {
              console.warn(`⚠️ ${negativeCoords.length} blocks have negative coordinates:`, negativeCoords);
            }
          }
          
          const svg = document.getElementById('quilt');
          console.log('SVG Element Found:', !!svg);
          console.log('SVG Children Count:', svg?.children?.length || 0);
          console.log('Time-based Active:', svg?.getAttribute('data-time-based-active'));
          
          if (svg?.children?.length > 0) {
            console.log('SVG First Few Children:');
            for (let i = 0; i < Math.min(5, svg.children.length); i++) {
              const child = svg.children[i];
              console.log(`  ${i}: ${child.tagName} fill="${child.getAttribute('fill')}" x="${child.getAttribute('x')}" y="${child.getAttribute('y')}"`);
            }
          } else {
            console.log('❌ No children found in SVG element');
          }
          
          return {
            totalColors: state.colors?.length || 0,
            queuedColors: state.queuedColors?.length || 0,
            svgChildren: svg?.children?.length || 0,
            timeBasedActive: svg?.getAttribute('data-time-based-active'),
            isReorganizing: app.timeBasedEngine.isReorganizing
          };
        };
        
        // GRID BOUNDS DEBUG - quick check for positioning issues
        window.checkGridBounds = () => {
          const state = app.timeBasedEngine.getState();
          if (state.colors?.length === 0) {
            console.log('No colors to check');
            return;
          }
          
          const positions = state.colors.map(c => c.position);
          const bounds = {
            minX: Math.min(...positions.map(p => p.x)),
            maxX: Math.max(...positions.map(p => p.x)),
            minY: Math.min(...positions.map(p => p.y)),
            maxY: Math.max(...positions.map(p => p.y))
          };
          
          console.log('🗂️ Grid Analysis:');
          console.log(`   Bounds: (${bounds.minX},${bounds.minY}) to (${bounds.maxX},${bounds.maxY})`);
          console.log(`   Size: ${bounds.maxX - bounds.minX + 1} x ${bounds.maxY - bounds.minY + 1}`);
          
          // Calculate what the rendering scale would be (phase-aware)
          const gridWidth = bounds.maxX - bounds.minX + 1;
          const gridHeight = bounds.maxY - bounds.minY + 1;
          
          let availableWidth, availableHeight, maxScale;
          if (state.phase === 'collection') {
            availableWidth = 500;
            availableHeight = 450;
            maxScale = 50;
          } else {
            availableWidth = 400;
            availableHeight = 400;
            maxScale = 30;
          }
          
          const scaleX = availableWidth / gridWidth;
          const scaleY = availableHeight / gridHeight;
          const scale = Math.min(scaleX, scaleY, maxScale);
          
          console.log(`   Render scale: ${scale.toFixed(1)}px per block (${state.phase} phase)`);
          console.log(`   Block size: ${Math.max(scale - 2, 5)}px`);
          
          if (state.phase === 'collection') {
            console.log(`   🧵 Large blocks for quilter's workspace!`);
          }
          
          // Check for problematic coordinates
          const negativeCoords = positions.filter(p => p.x < 0 || p.y < 0);
          const largeCoords = positions.filter(p => p.x > 100 || p.y > 100);
          
          if (negativeCoords.length > 0) console.warn(`⚠️ ${negativeCoords.length} negative coordinates`);
          if (largeCoords.length > 0) console.warn(`⚠️ ${largeCoords.length} very large coordinates (>100)`);
          
          return bounds;
        };
        
        // Set initial user counter (will be updated as users are added)
        window.updateUserCounter(1);
        
        console.log('🛠️ Admin system initialized. Use Ctrl+Shift+A or click ADMIN button to access.');
      });
     </script>
   </body>
   </html> 