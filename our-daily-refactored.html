<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Quilt</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* ===== SCREENS ===== */
    .screen {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out;
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 0.5rem 0 0 0;
      align-items: center;
      justify-content: flex-start;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 500;
      font-size: clamp(2rem, 5vw, 3rem);
      margin-bottom: 0.0em;
      letter-spacing:.02em;
    }
    
    .portal-header .quilt-text {
      font-weight: 900;
      font-size: clamp(3.25rem, 7vw, 8rem);
      margin-top: -.5rem;
      margin-bottom: 1rem;
      letter-spacing: 0.05em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.2rem, 3vw, 1.6rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.5rem;
      margin: 2rem auto 2rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 150px;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(1rem, 2.5vw, 1.2rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: fit-content;
      gap: 1.5rem;
    }
    
    #colorWheelCanvas {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      position: relative;
      /* Warm-casted color wheel: hue around circumference (+25° warm shift) */
      background: conic-gradient(
        hsl(25, 100%, 50%),
        hsl(40, 100%, 50%),
        hsl(55, 100%, 50%),
        hsl(70, 100%, 50%),
        hsl(85, 100%, 50%),
        hsl(100, 100%, 50%),
        hsl(115, 100%, 50%),
        hsl(130, 100%, 50%),
        hsl(145, 100%, 50%),
        hsl(160, 100%, 50%),
        hsl(175, 100%, 50%),
        hsl(190, 100%, 50%),
        hsl(205, 100%, 50%),
        hsl(220, 100%, 50%),
        hsl(235, 100%, 50%),
        hsl(250, 100%, 50%),
        hsl(265, 100%, 50%),
        hsl(280, 100%, 50%),
        hsl(295, 100%, 50%),
        hsl(310, 100%, 50%),
        hsl(325, 100%, 50%),
        hsl(340, 100%, 50%),
        hsl(355, 100%, 50%),
        hsl(10, 100%, 50%),
        hsl(25, 100%, 50%)
      );
    }
    
    /* Saturation gradient overlay: white center to transparent edge */
    .css-color-wheel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, white 0%, transparent 70%);
      pointer-events: none;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
  

    
    #colorWheelCanvas:hover {
      transform: scale(1.02);
    }
    
    #colorWheelCanvas:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; 
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 300px;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    

    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
      justify-content: center;
    }
    
    #screen-quote {
      justify-content: center;
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
        justify-content: center;
      }
      
      .css-color-wheel {
        width: 224px !important;
        height: 224px !important;
        /* Warm-casted color wheel for mobile: hue around circumference (+25° warm shift) */
        background: -webkit-conic-gradient(
          hsl(25, 100%, 50%),
          hsl(40, 100%, 50%),
          hsl(55, 100%, 50%),
          hsl(70, 100%, 50%),
          hsl(85, 100%, 50%),
          hsl(100, 100%, 50%),
          hsl(115, 100%, 50%),
          hsl(130, 100%, 50%),
          hsl(145, 100%, 50%),
          hsl(160, 100%, 50%),
          hsl(175, 100%, 50%),
          hsl(190, 100%, 50%),
          hsl(205, 100%, 50%),
          hsl(220, 100%, 50%),
          hsl(235, 100%, 50%),
          hsl(250, 100%, 50%),
          hsl(265, 100%, 50%),
          hsl(280, 100%, 50%),
          hsl(295, 100%, 50%),
          hsl(310, 100%, 50%),
          hsl(325, 100%, 50%),
          hsl(340, 100%, 50%),
          hsl(355, 100%, 50%),
          hsl(10, 100%, 50%),
          hsl(25, 100%, 50%)
        );
        background: conic-gradient(
          hsl(25, 100%, 50%),
          hsl(40, 100%, 50%),
          hsl(55, 100%, 50%),
          hsl(70, 100%, 50%),
          hsl(85, 100%, 50%),
          hsl(100, 100%, 50%),
          hsl(115, 100%, 50%),
          hsl(130, 100%, 50%),
          hsl(145, 100%, 50%),
          hsl(160, 100%, 50%),
          hsl(175, 100%, 50%),
          hsl(190, 100%, 50%),
          hsl(205, 100%, 50%),
          hsl(220, 100%, 50%),
          hsl(235, 100%, 50%),
          hsl(250, 100%, 50%),
          hsl(265, 100%, 50%),
          hsl(280, 100%, 50%),
          hsl(295, 100%, 50%),
          hsl(310, 100%, 50%),
          hsl(325, 100%, 50%),
          hsl(340, 100%, 50%),
          hsl(355, 100%, 50%),
          hsl(10, 100%, 50%),
          hsl(25, 100%, 50%)
        );
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    /* Debug: Ensure proper vertical centering */
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }
    
    /* ===== ADMIN TREND SUMMARY ===== */
    .admin-trend-summary {
      background: #f6f4f1;
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem auto 2rem;
      max-width: 600px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .trend-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    
    .trend-header h2 {
      font-size: 1.4rem;
      font-weight: 900;
      margin: 0;
      color: #000;
    }
    
    .trend-select {
      background: #fff;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      color: #333;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    
    .trend-select:hover {
      border-color: #666;
    }
    
    .trend-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 1rem;
    }
    
    .trend-card {
      background: #fff;
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease;
    }
    
    .trend-card:hover {
      transform: translateY(-2px);
    }
    
    .trend-icon {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .trend-label {
      font-size: 0.8rem;
      color: #666;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    
    .trend-value {
      font-size: 1.2rem;
      font-weight: 900;
      color: #000;
      margin-bottom: 0.25rem;
    }
    
    .trend-change {
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    .trend-change.positive {
      color: #22c55e;
    }
    
    .trend-change.negative {
      color: #ef4444;
    }
    
    .trend-change.neutral {
      color: #666;
    }
    
    @media (max-width: 768px) {
      .admin-trend-summary {
        margin: 1rem;
        padding: 1rem;
      }
      
      .trend-header {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }
      
      .trend-cards {
        grid-template-columns: repeat(3, 1fr);
        gap: 0.75rem;
      }
      
      .trend-card {
        padding: 0.75rem;
      }
      
      .trend-icon {
        font-size: 1.2rem;
      }
      
      .trend-value {
        font-size: 1rem;
      }
    }

    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: center;
    }
    
    /* ===== ARCHIVE FEED (Instagram Style) ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
      padding: 0 1rem;
    }
    
    .archive-header h1 {
      font-size: 2rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
    }
    
    .archive-subtitle {
      font-size: 1.1rem;
      color: #666;
      margin: 0;
    }
    
    .archive-feed {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    /* Individual Archive Post (Instagram-style) */
    .archive-post {
      margin-bottom: 3rem;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .archive-post-image {
      width: 100%;
      height: auto;
      display: block;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .archive-post-image:hover {
      opacity: 0.95;
    }
    
    .archive-post-caption {
      padding: 1rem 1.5rem;
      background: #f6f4f1;
    }
    
    .archive-post-quote-author {
      font-size: 1.1rem;
      font-style: italic;
      line-height: 1.4;
      margin-bottom: 0.75rem;
      color: #333;
      text-align: left;
    }
    
    .archive-post-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      color: #888;
    }
    
    .archive-post-date {
      font-weight: 500;
    }
    
    .archive-post-contributors {
      color: #666;
    }
    
    .archive-share-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease;
      margin-left: auto;
    }
    
    .archive-share-btn:hover {
      background: #0056b3;
    }
    
    /* Archive Post Admin Analytics */
    .archive-post-content {
      display: flex;
      flex-direction: column;
    }
    
    .archive-post-public {
      /* Default public content styling */
    }
    
    .archive-post-admin {
      background: #f0f8ff;
      border-top: 2px solid #e0e0e0;
      padding: 1rem;
      margin-top: 1rem;
      border-radius: 0 0 8px 8px;
    }
    
    .admin-analytics-header {
      font-size: 0.9rem;
      font-weight: 700;
      color: #333;
      margin-bottom: 0.75rem;
      text-align: center;
    }
    
    .admin-analytics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }
    
    .admin-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.25rem 0;
      font-size: 0.8rem;
    }
    
    .metric-label {
      color: #666;
      font-weight: 500;
    }
    
    .metric-value {
      font-weight: 700;
      color: #000;
    }
    
    @media (max-width: 768px) {
      .admin-analytics-grid {
        grid-template-columns: 1fr;
        gap: 0.25rem;
      }
      
      .admin-metric {
        padding: 0.2rem 0;
      }
    }
    
    /* Load More Button */
    .archive-load-more {
      margin: 2rem auto;
      display: block;
      background: #666;
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 24px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .archive-load-more:hover {
      background: #333;
    }
    
    .archive-load-more:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    /* Loading Indicator */
    .archive-loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }
    
    /* Archive Modal */
    .archive-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .archive-modal-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      cursor: pointer;
    }
    
    .archive-modal-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .archive-modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .archive-modal-image-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f6f4f1;
    }
    
    .archive-modal-image {
      max-width: 100%;
      max-height: 70vh;
      height: auto;
      object-fit: contain;
    }
    
    .archive-modal-caption {
      padding: 1.5rem;
      background: #f6f4f1;
      border-top: 1px solid #eee;
    }
    
    .archive-modal-quote {
      font-size: 1.2rem;
      font-style: italic;
      line-height: 1.4;
      margin-bottom: 0.5rem;
      color: #333;
      text-align: left;
    }
    
    .archive-modal-author {
      font-size: 1rem;
      color: #666;
      margin-bottom: 1rem;
    }
    
    .archive-modal-meta {
      font-size: 0.9rem;
      color: #888;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      .archive-feed {
        padding: 0 0.5rem;
      }
      
      .archive-post-caption {
        padding: 1rem;
      }
      
      .archive-modal-content {
        max-width: 95vw;
        max-height: 95vh;
      }
      
      .archive-modal-caption {
        padding: 1rem;
      }
    }
    
    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */

    
    #quilt {
      /* REMOVED: width: 90vw; height: 90vw; - THIS WAS FORCING 90% VIEWPORT WIDTH! */
      max-width: 600px; /* REMOVED: max-height: 600px - WAS FORCING SQUARE! */
      margin: 1rem auto; /* Reduced margins */
      background: transparent;
      position: relative;
      display: block;
      flex-grow: 1; /* Take up available space and push buttons down! */
      min-height: 70vh; /* Ensure SVG takes up most of viewport to push buttons below fold */
    }

    /* MOBILE-FIRST: Override constraints when time-based engine is active */
    #quilt[data-time-based-active="true"] {
      width: 100vw !important;
      height: 80vh !important; /* FORCE HEIGHT: Take up 80% of viewport to push buttons below! */
      max-width: none !important;
      max-height: none !important;
      min-width: 100vw !important;
      margin: 0 !important;
      margin-top: 0 !important;
      padding: 0 !important;
      flex-shrink: 0 !important;
      flex-grow: 1 !important; /* FIXED: Allow SVG to expand and push buttons below fold! */
      position: relative !important;
      top: 0px !important; /* Eliminate internal spacing - text padding handles positioning */
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Fabric texture using CSS */
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== ADMIN PANEL ===== */
    #adminPanel {
      display: none;
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.95);
      color: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      max-width: 350px;
      border: 2px solid #333;
    }

    #adminPanel.visible {
      display: block;
    }

    .admin-header {
      font-weight: 600;
      margin-bottom: 15px;
      color: #ff6b6b;
      border-bottom: 1px solid #333;
      padding-bottom: 8px;
    }

    .admin-section {
      margin-bottom: 20px;
    }

    .admin-section h4 {
      margin: 0 0 10px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #ccc;
    }

    .admin-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .admin-input {
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      width: 80px;
      font-size: 14px;
    }

    .admin-btn {
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .admin-btn:hover {
      background: #444;
      border-color: #666;
    }

    .admin-btn.primary {
      background: #ff6b6b;
      border-color: #ff6b6b;
    }

    .admin-btn.primary:hover {
      background: #ff5252;
    }

    .admin-btn.danger {
      background: #f44336;
      border-color: #f44336;
    }

    .admin-btn.danger:hover {
      background: #d32f2f;
    }

    .admin-info {
      font-size: 11px;
      color: #888;
      margin-top: 5px;
    }

    #adminToggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 12px;
      z-index: 999;
      opacity: 0.3;
      transition: opacity 0.2s ease;
      display: none; /* Hidden by default */
    }

    #adminToggle:hover {
      opacity: 0.8;
    }

    /* ===== QUILT ===== */
    #quilt {
      /* REMOVED CONSTRAINTS: Let JavaScript control the size dynamically */
      /* width: 90vw !important; - REMOVED! */
      /* height: 90vw !important; - REMOVED! */
      /* min-width: 600px !important; - REMOVED! */
      /* min-height: 600px !important; - REMOVED! */
      /* max-width: 1200px !important; - REMOVED! */
      /* max-height: 1200px !important; - REMOVED! */
      margin: 10rem auto 1rem auto !important;
      background: transparent;
      position: relative;
      display: block !important;
      box-sizing: border-box !important;
      border: 3px solid purple !important; /* DEBUG: Base SVG styles */
    }
    
    /* MOBILE-FIRST: Override the !important constraints when time-based engine is active - DEBUG */
    #quilt[data-time-based-active="true"] {
      /* REMOVED: width: 100vw !important; - THIS WAS FORCING VIEWPORT WIDTH! */
      height: auto !important;
      min-width: unset !important;
      min-height: unset !important;
      max-width: unset !important;
      max-height: unset !important;
      margin: 0 !important;
      padding: 0 !important;
      border: 5px solid orange !important; /* DEBUG: SVG container */
    }

    /* Fix screen centering for quilt - DEBUG BORDERS */
    #screen-quilt {
      justify-content: flex-start !important; 
      align-items: center !important;
      padding: 0 !important; /* REMOVED: All padding to eliminate white space */
      border: 3px solid blue !important; /* DEBUG: Screen container */
      min-height: 100vh; /* Ensure full viewport height */
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .screen { 
        padding: 2rem 1rem 0 1rem; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      
      #screen-quilt {
        padding: 0 !important; /* REMOVED: All padding to eliminate top white space */
        margin-top: 0 !important; /* FIXED: Remove excessive margin */
        border: 3px solid green !important; /* DEBUG: Mobile screen container */
      }
      
      /* NUCLEAR OPTION: More specific selector */
      body #screen-quilt.screen {
        padding-top: 0 !important; /* REMOVED: All padding to eliminate white space */
        margin-top: 0 !important; /* FIXED: Remove margin */
      }
      
      /* ULTRA SPECIFIC: Just in case */
      html body #screen-quilt {
        padding-top: 0 !important; /* REMOVED: All padding to eliminate white space */
        margin-top: 0 !important; /* FIXED: Remove margin */
      }
      
      #phase-indicator {
        margin-top: 15px !important; /* PERFECT: 15px breathing room at top */
      }
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      #quilt { 
        width: 90vw !important; 
        height: 90vw !important; 
        min-width: 300px !important;
        min-height: 300px !important;
        max-width: 100vw !important;
        max-height: 100vw !important;
        margin: 1rem auto !important;
        display: block !important;
        position: relative;
      }
      
      /* MOBILE-FIRST: Override responsive constraints for time-based engine */
      #quilt[data-time-based-active="true"] { 
        width: 100vw !important; 
        height: auto !important; 
        min-width: unset !important;
        min-height: unset !important;
        max-width: unset !important;
        max-height: unset !important;
        margin: 0 !important;
        box-sizing: border-box !important;
      }
      
      #screen-quilt {
        padding: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
      
      /* Extra small mobile devices */
      #quilt { 
        width: 95vw !important; 
        height: 95vw !important; 
        min-width: 280px !important;
        min-height: 280px !important;
        margin: 0.5rem auto !important;
      }
      
      /* MOBILE-FIRST: Override extra small device constraints for time-based engine */
      #quilt[data-time-based-active="true"] { 
        width: 100vw !important; 
        height: auto !important; 
        min-width: unset !important;
        min-height: unset !important;
        max-width: unset !important;
        max-height: unset !important;
        margin: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        font-size: 1rem;
        margin-bottom: 0.3rem;
      }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }
  </style>
</head>
<body>
  <main id="app">
    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <h1 class="quilt-text">QUILT</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">↓</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="25" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">
      <!-- ABOVE THE FOLD: Essential text and count -->
      <div id="phase-indicator" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; margin-top: 0; color: #666;">Cutting up squares til noon!<br>Check back later!</div>
      
      <!-- COUNT MESSAGE: Above fold for user feedback -->
      <p class="thank-you-message" aria-live="polite" id="community-message" style="margin: 0 0 1rem 0; font-size: 1.3rem; font-weight: 600; text-align: center;"><span id="user-count">1</span> squares today and counting!</p>

      <!-- MAXIMIZED CANVAS: Sized to push buttons below fold -->
      <svg id="quilt" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      
      <!-- BELOW THE FOLD: All interactive buttons -->
      <div style="margin-top: 1.5rem;">
        <button id="testAddBlock" class="btn" style="background: #ff6b6b; color: white; margin: 0.5rem;">TEST: ADD RANDOM BLOCK</button>
      <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white; margin: 0.5rem;">SHOW ME MY PIECE</button>
      <button id="testDifferentUserBtn" class="btn" style="background: #9C27B0; color: white; margin: 0.5rem;">TEST: Simulate Different User</button>
      </div>
      
      <div style="margin-top: 1rem;">
      <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button>
      <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
      <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
      </div>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      
      <!-- Admin Trend Summary (only visible to admins) -->
      <div class="admin-trend-summary" id="adminTrendSummary" style="display: none;">
        <div class="trend-header">
          <h2>📊 TREND SUMMARY</h2>
          <div class="trend-timeframe">
            <select id="trendTimeframe" class="trend-select">
              <option value="last7days">Last 7 Days</option>
              <option value="alltime">All Time</option>
            </select>
          </div>
        </div>
        
        <div class="trend-cards">
          <div class="trend-card">
            <div class="trend-icon">📊</div>
            <div class="trend-label">Avg Noon</div>
            <div class="trend-value" id="trendNoonSquares">--</div>
            <div class="trend-change" id="trendNoonChange">--</div>
          </div>
          
          <div class="trend-card">
            <div class="trend-icon">👥</div>
            <div class="trend-label">Avg Users</div>
            <div class="trend-value" id="trendUsers">--</div>
            <div class="trend-change" id="trendUsersChange">--</div>
          </div>
          
          <div class="trend-card">
            <div class="trend-icon">⏰</div>
            <div class="trend-label">Peak Time</div>
            <div class="trend-value" id="trendPeakTime">--</div>
            <div class="trend-change" id="trendPeakChange">--</div>
          </div>
          
          <div class="trend-card">
            <div class="trend-icon">🎨</div>
            <div class="trend-label">Colors</div>
            <div class="trend-value" id="trendColors">--</div>
            <div class="trend-change" id="trendColorsChange">--</div>
          </div>
          
          <div class="trend-card">
            <div class="trend-icon">📱</div>
            <div class="trend-label">Mobile</div>
            <div class="trend-value" id="trendMobile">--</div>
            <div class="trend-change" id="trendMobileChange">--</div>
          </div>
          
          <div class="trend-card">
            <div class="trend-icon">📤</div>
            <div class="trend-label">Avg Shares</div>
            <div class="trend-value" id="trendShares">--</div>
            <div class="trend-change" id="trendSharesChange">--</div>
          </div>
        </div>
      </div>
      
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <!-- Archive Feed (Instagram-style) -->
      <div class="archive-feed" id="archiveFeed">
        <!-- Archive posts will be dynamically inserted here -->
      </div>
      
      <!-- Load More Button -->
      <button class="btn archive-load-more" id="archiveLoadMore" style="display: none;">Load More</button>
      
      <!-- Loading Indicator -->
      <div class="archive-loading" id="archiveLoading" style="display: none;">
        <p>Loading quilts...</p>
      </div>
      
      <!-- Back Button -->
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- Archive Modal (for enlarged view) -->
    <div class="archive-modal" id="archiveModal" style="display: none;">
      <div class="archive-modal-backdrop" id="archiveModalBackdrop"></div>
      <div class="archive-modal-content">
        <button class="archive-modal-close" id="archiveModalClose">&times;</button>
        <div class="archive-modal-image-container">
          <img class="archive-modal-image" id="archiveModalImage" alt="Archived quilt" />
        </div>
        <div class="archive-modal-caption">
          <div class="archive-modal-quote" id="archiveModalQuote"></div>
          <div class="archive-modal-author" id="archiveModalAuthor"></div>
          <div class="archive-modal-meta" id="archiveModalMeta"></div>
        </div>
      </div>
    </div>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

  <!-- Toast notifications -->
  <div id="toast" class="toast" role="alert" aria-live="polite"></div>

    <!-- Admin Panel -->
    <button id="adminToggle">ADMIN</button>
    
    <div id="adminPanel">
      <div class="admin-header">🛠️ ADMIN CONTROLS</div>
      
      <div class="admin-section">
        <h4>Phase Override</h4>
        <div class="admin-controls">
          <select id="phaseOverride" class="admin-input">
            <option value="">⏰ Time-Based (Normal)</option>
            <option value="collection">🧵 Force Collection</option>
            <option value="pattern_filling">🎨 Force Pattern Filling</option>
          </select>
          <button id="applyPhaseOverride" class="admin-btn">Apply</button>
        </div>
        <div class="admin-info">Override automatic time-based phase switching for testing</div>
      </div>
      
      <div class="admin-section">
        <h4>Add Sample Blocks</h4>
        <div class="admin-controls">
          <input type="number" id="blockCount" class="admin-input" value="10" min="1" max="100" placeholder="Count">
          <button id="addSampleBlocks" class="admin-btn primary">Add Blocks</button>
        </div>
        <div class="admin-info">Adds blocks using colors already submitted by users</div>
      </div>

      <div class="admin-section">
        <h4>Pattern Control</h4>
        <div class="admin-controls">
          <select id="forcePattern" class="admin-input" style="width: 120px;">
            <option value="">Auto-Select</option>
            <option value="spiral">Spiral</option>
            <option value="gradient_flow">Gradient Flow</option>
            <option value="radial">Radial</option>
            <option value="warm_cool_split">Warm/Cool Split</option>
            <option value="checkerboard">Checkerboard</option>
          </select>
          <button id="applyPattern" class="admin-btn">Apply</button>
        </div>
        <div class="admin-info">Force a specific pattern for testing</div>
      </div>

      <div class="admin-section">
        <h4>System Control</h4>
        <div class="admin-controls">
          <button id="forceReorganize" class="admin-btn">Reorganize Now</button>
          <button id="resetQuiltAdmin" class="admin-btn danger">Reset Quilt</button>
        </div>
        <div class="admin-controls" style="margin-top: 8px;">
          <span style="font-size: 12px; color: #ccc;">Threshold:</span>
          <input type="number" id="reorganizeThreshold" class="admin-input" value="5" min="1" max="50" style="width: 60px;">
          <button id="updateThreshold" class="admin-btn">Update</button>
        </div>
        <div class="admin-info">Control reorganization behavior</div>
      </div>

      <div class="admin-section">
        <h4>Emergency</h4>
        <div class="admin-controls">
          <button id="emergencyResetBtn" class="admin-btn danger">Emergency Reset</button>
        </div>
        <div class="admin-info">⚠️ Clears ALL data and resets system state</div>
      </div>

      <div class="admin-section">
        <h4>Diagnostics</h4>
        <div class="admin-controls">
          <button id="showDiagnostics" class="admin-btn">Show Stats</button>
          <button id="exportQuilt" class="admin-btn">Export Data</button>
        </div>
        <div class="admin-info">View system information and export quilt state</div>
      </div>
    </div>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script type="module">
    // ===== CONFIGURATION OBJECT =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '2.0.0',
        defaultColor: '#f7b733',
        quiltSize: 600,
        minBlockSize: 40,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        viewBoxStartX: 0,
        viewBoxStartY: 0,
        edgePadding: 20,
        gridCols: 5,
        gridRows: 5,
        gridJitter: 15,
        minSpacing: 10,
        maxPieceSizeRatio: 0.8,
        minPieceSizeRatio: 0.4,
        edgeVariation: 0.1,
        organicVariation: 3
      },
      PHASES: {
        collection: {
          maxSubmissions: 5,
          piecesPerSubmission: [4, 4, 4, 4, 4, 4, 1, 1, 1] // pieces for submissions 1-9
        },
        patchFormation: {
          triggerSubmission: 6, // User 6 triggers block formation
          targetPatches: 2,
          edgeTolerance: 0.2,
          valueContrastWeight: 0.8
        },
        blockFormation: {
          triggerSubmission: 6, // User 6 sees blocks, not patches
          edgeTolerance: 1.5, // Increased tolerance to ensure all patches get matched
          valueContrastWeight: 0.8
        },
        quiltFormation: {
          triggerSubmission: 9
        }
      },
      RENDERING: {
        organicEdgesFilter: 'organicEdges',
        userHighlightFilter: 'userHighlight',
        animationClass: 'new-block',
        borderColor: {
          pieces: '#ffa726',
          patches: '#ff6b6b',
          blocks: '#4ecdc4'
        }
      },
      POSITIONING: {
        spacing: {
          pieces: 120,
          patches: 120,
          blocks: 250  // Increased spacing for blocks to prevent overlapping
        },
        jitter: {
          pieces: 8,
          patches: 8,
          blocks: 5  // Reduced jitter for blocks to prevent overlap
        }
      }
    };

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = '🧵';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} ⚠️ ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} ❌ ${message}`, error || '');
      }

      phase(phase, data = null) {
        this.log(`🔄 Phase: ${phase}`, data);
      }

      render(element, count) {
        this.log(`🎨 Rendering ${count} ${element}`);
      }

      position(element, index, x, y) {
        this.log(`📍 ${element} ${index} positioned at (${x.toFixed(1)}, ${y.toFixed(1)})`);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(null, args), delay);
        };
      }

      static hslToHex(h, s, l) {
        // Debug logging
        console.log(`hslToHex input: h=${h}, s=${s}, l=${l}`);
        
        h /= 360;
        s /= 100;
        l /= 100;
        
        console.log(`hslToHex normalized: h=${h}, s=${s}, l=${l}`);
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        console.log(`hslToHex RGB: r=${r}, g=${g}, b=${b}`);
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        const result = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        console.log(`hslToHex result: ${result}`);
        return result;
      }

      static hexToHsl(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return {
          h: Math.round(h * 360),
          s: Math.round(s * 100),
          l: Math.round(l * 100)
        };
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
        const target = document.getElementById(screenId);
        if (target) {
          target.classList.add("active");
          
          // Reset color selection when entering color screen
          if (screenId === 'screen-color') {
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen) {
              colorScreen.style.backgroundColor = '#f6f4f1';
            }
          }
          
          // Initialize archive screen when entering
          if (screenId === 'screen-archive' && window.app) {
            setTimeout(() => {
              window.app.initializeArchiveScreen();
            }, 100);
          }
          
          // Scroll to top
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          
          const app = document.getElementById('app');
          if (app) {
            app.scrollTop = 0;
          }
        }
      }

      updatePhaseIndicator(phase, submissionCount) {
        const phaseIndicator = document.getElementById('phase-indicator');
        if (phaseIndicator) {
          const phaseText = {
            'collection': `Cutting up squares til noon!<br>Check back later!`,
            'pattern_filling': `Making the daily quilt!<br>Come back at midnight for tomorrow's!`,
            'patch-formation': 'Patch Formation Phase',
            'block-formation': 'Block Formation Phase', 
            'quilt-formation': 'Quilt Formation Phase'
          };
          phaseIndicator.innerHTML = phaseText[phase] || 'Unknown Phase';
        }
      }


    }

         // ===== ERROR HANDLING SERVICE =====
     class ErrorHandler {
       constructor(uiService, logger) {
         this.uiService = uiService;
         this.logger = logger;
       }

       handleError(error, context = 'Unknown') {
         this.logger.error(`Error in ${context}:`, error);
         
         const errorMessages = {
           'loadQuilt': 'Failed to load quilt data. Starting fresh.',
           'saveQuilt': 'Failed to save your color. Please try again.',
           'shareFlow': 'Failed to create share image. Saving instead.',
           'colorPicker': 'Color picker error. Please try again.',
           'App initialization': 'Failed to initialize app. Please refresh.',
           'renderBlocks': 'Failed to render quilt. Please try again.',
           'addPieceToQuilt': 'Failed to add piece. Please try again.'
         };
         
         const message = errorMessages[context] || 'Something went wrong. Please try again.';
         this.uiService.showToast(message);
       }

       validatePiece(piece) {
         if (!piece || typeof piece.x === 'undefined' || typeof piece.y === 'undefined' || 
             typeof piece.width === 'undefined' || typeof piece.height === 'undefined') {
           throw new Error(`Invalid piece data: ${JSON.stringify(piece)}`);
         }
         return true;
       }

       validateColor(color) {
         if (!Utils.validateHexColor(color)) {
           throw new Error(`Invalid color format: ${color}`);
         }
         return true;
       }
     }

     // ===== STATE MANAGEMENT =====
     class QuiltState {
       constructor(logger) {
         this.logger = logger;
         this.reset();
       }

       reset() {
         this.blocks = [];
         this.pieces = [];
         this.allPieces = [];
         this.patches = [];
         this.originalPatches = [];
         this.quilt = null;
         this.submissionCount = 0;
         this.currentPhase = 'collection';
         this.lastAddedIndex = null;
         this.unmatchedPieces = [];
         this.unmatchedPatches = [];
         this.userPiecesHighlighted = false;
         this.currentUserId = Utils.getOrCreateUserId();
         this.logger.log('State reset');
       }

       getElementCounts() {
         return {
           pieces: this.pieces.length,
           patches: this.patches.length,
           blocks: this.blocks.length,
           unmatchedPieces: this.unmatchedPieces.length,
           unmatchedPatches: this.unmatchedPatches.length
         };
       }

       addPiece(piece) {
         this.pieces.push(piece);
         this.allPieces.push(piece);
         this.logger.log(`Added piece ${piece.id}`);
       }

       addPatch(patch) {
         this.patches.push(patch);
         this.logger.log(`Added patch ${patch.id}`);
       }

       addBlock(block) {
         this.blocks.push(block);
         this.logger.log(`Added block ${block.id}`);
       }

       setPhase(phase) {
         this.currentPhase = phase;
         this.logger.phase(phase);
       }

       incrementSubmission() {
         this.submissionCount++;
         this.logger.log(`Submission count: ${this.submissionCount}`);
       }
     }

     // ===== DATA LAYER =====
     class QuiltDataService {
       constructor(logger, errorHandler) {
         this.logger = logger;
         this.errorHandler = errorHandler;
         this.db = null;
         this.quiltDoc = null;
       }

             async initialize() {
        try {
          this.logger.log('🔄 Starting Firebase initialization...');
          this.logger.log('🔑 Firebase config:', CONFIG.FIREBASE);
          
          // Initialize Firebase
          const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js');
          const { getFirestore, doc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
          
          this.logger.log('📦 Firebase modules loaded successfully');
          
          const app = initializeApp(CONFIG.FIREBASE);
          this.logger.log('🔥 Firebase app initialized');
          
          this.db = getFirestore(app);
          this.logger.log('📚 Firestore database connected');
          
          this.quiltDoc = doc(this.db, 'quilts', 'daily');
          this.archivesCollection = 'archives'; // Collection name for archives
          
          this.logger.log('✅ Firebase initialization complete - ready to load/save data');
        } catch (error) {
          this.logger.error('❌ Firebase initialization failed:', error);
          this.errorHandler.handleError(error, 'Firebase initialization');
          this.logger.log('⚠️ Firebase failed, falling back to localStorage');
          this.db = null;
          this.quiltDoc = null;
        }
      }

       async loadQuilt() {
         try {
           this.logger.log('🔄 Loading quilt data from Firebase...');
           
           if (!this.db || !this.quiltDoc) {
             this.logger.log('❌ Firebase not initialized - this.db or this.quiltDoc is null');
             this.logger.log(`📊 Debug: db=${!!this.db}, quiltDoc=${!!this.quiltDoc}`);
             return [];
           }
           
           this.logger.log('📚 Firebase connection confirmed, fetching document...');
           const { getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
           const docSnap = await getDoc(this.quiltDoc);
           
           if (docSnap.exists()) {
             const data = docSnap.data();
             const colors = data.colors || [];
             this.logger.log(`✅ Successfully loaded ${colors.length} colors from Firebase`);
             this.logger.log(`🎨 Colors: [${colors.join(', ')}]`);
             return colors;
           } else {
             this.logger.log('📝 No existing quilt document found, starting fresh');
             return [];
           }
         } catch (error) {
           this.logger.error('❌ Firebase load error:', error);
           this.errorHandler.handleError(error, 'loadQuilt');
           return [];
         }
       }

       async saveQuilt(colors) {
         try {
           this.logger.log('Saving quilt data');
           
           if (!this.db || !this.quiltDoc) {
             this.logger.log('Firebase not available, skipping save');
             return true; // Don't fail if Firebase is unavailable
           }
           
           const { setDoc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
           await setDoc(this.quiltDoc, {
             colors: colors,
             lastUpdated: new Date().toISOString(),
             date: new Date().toISOString().split('T')[0] // YYYY-MM-DD
           });
           
           this.logger.log(`🔥 Saved ${colors?.length || 0} colors to Firebase`);
           return true;
         } catch (error) {
           this.errorHandler.handleError(error, 'saveQuilt');
           this.logger.log('⚠️ Firebase save failed');
           return false;
         }
       }
     }

     // ===== QUOTE SERVICE =====
     class QuoteService {
       constructor() {
         this.quotes = [
           { text: "Art washes away from the soul the dust of everyday life.", author: "— Pablo Picasso" },
           { text: "Creativity takes courage.", author: "— Henri Matisse" },
           { text: "Every artist was first an amateur.", author: "— Ralph Waldo Emerson" },
           { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "— Wassily Kandinsky" },
           { text: "Great things are done by a series of small things brought together.", author: "— Vincent Van Gogh" },
           { text: "You can't use up creativity. The more you use, the more you have.", author: "— Maya Angelou" }
         ];
         this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
       }

       getTodayQuote() {
         const today = new Date();
         const year = today.getFullYear();
         const month = String(today.getMonth() + 1).padStart(2, '0');
         const day = String(today.getDate()).padStart(2, '0');
         const todayString = `${year}-${month}-${day}`;
         const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
         const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
         return this.quotes[quoteIndex];
       }

       displayQuote() {
         try {
           const { text, author } = this.getTodayQuote();
           const quoteLine = document.querySelector('.quote-line');
           const quoteAuthor = document.querySelector('.quote-author');
           
           if (quoteLine) quoteLine.textContent = text;
           if (quoteAuthor) quoteAuthor.textContent = author;
         } catch (error) {
           console.error('Error displaying quote:', error);
         }
       }
     }

     // ===== POSITIONING SERVICE =====
     class PositioningService {
       constructor(logger) {
         this.logger = logger;
       }

       createPiece(color, pieceIndex, userId, submissionId) {
         const config = CONFIG.QUILT;
         
         // Calculate grid cell size
         const availableWidth = config.viewBoxWidth - 2 * config.edgePadding;
         const availableHeight = config.viewBoxHeight - 2 * config.edgePadding;
         const cellWidth = availableWidth / config.gridCols;
         const cellHeight = availableHeight / config.gridRows;
         
         // Calculate piece size
         const maxPieceSize = Math.min(cellWidth, cellHeight) * config.maxPieceSizeRatio;
         const minSize = Math.max(CONFIG.APP.minBlockSize, maxPieceSize * config.minPieceSizeRatio);
         const maxSize = maxPieceSize;
         const baseSize = minSize + Math.random() * (maxSize - minSize);
         
         // Determine shape
         const isSquare = Math.random() < 0.7;
         let width, height;
         
         if (isSquare) {
           width = baseSize;
           height = baseSize;
         } else {
           const aspectRatio = 1 + (Math.random() - 0.5) * 0.5;
           width = baseSize;
           height = baseSize * aspectRatio;
         }
         
         // Add organic edge variations
         width += (Math.random() - 0.5) * width * config.edgeVariation;
         height += (Math.random() - 0.5) * height * config.edgeVariation;
         
         // Calculate position
         const gridX = pieceIndex % config.gridCols;
         const gridY = Math.floor(pieceIndex / config.gridCols);
         
         const totalGridWidth = config.gridCols * cellWidth;
         const totalGridHeight = config.gridRows * cellHeight;
         const gridStartX = config.viewBoxStartX + (config.viewBoxWidth - totalGridWidth) / 2;
         const gridStartY = config.viewBoxStartY + (config.viewBoxHeight - totalGridHeight) / 2;
         
         const baseX = gridStartX + gridX * cellWidth + cellWidth / 2;
         const baseY = gridStartY + gridY * cellHeight + cellHeight / 2;
         
         // Add jitter
         const maxJitter = Math.min(config.gridJitter, (Math.min(cellWidth, cellHeight) - maxPieceSize) / 2);
         const jitterX = (Math.random() - 0.5) * Math.min(maxJitter, 8);
         const jitterY = (Math.random() - 0.5) * Math.min(maxJitter, 8);
         
         let x = baseX + jitterX;
         let y = baseY + jitterY;
         
         // Constrain to cell bounds
         const minSpacingFromEdge = 5;
         const cellLeft = gridStartX + gridX * cellWidth;
         const cellRight = gridStartX + (gridX + 1) * cellWidth;
         const cellTop = gridStartY + gridY * cellHeight;
         const cellBottom = gridStartY + (gridY + 1) * cellHeight;
         
         x = Math.max(cellLeft + minSpacingFromEdge, Math.min(x, cellRight - width - minSpacingFromEdge));
         y = Math.max(cellTop + minSpacingFromEdge, Math.min(y, cellBottom - height - minSpacingFromEdge));
         
         // Final bounds check
         x = Math.max(config.viewBoxStartX, Math.min(x, config.viewBoxStartX + config.viewBoxWidth - width));
         y = Math.max(config.viewBoxStartY, Math.min(y, config.viewBoxStartY + config.viewBoxHeight - height));
         
         const piece = {
           id: `piece_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
           userId: userId,
           submissionId: submissionId,
           pieceIndex: pieceIndex,
           timestamp: Date.now(),
           x: x,
           y: y,
           width: width,
           height: height,
           color: color,
           type: 'piece',
           edges: this.calculateEdges(width, height)
         };
         
         this.logger.position('piece', pieceIndex, x, y);
         return piece;
       }

       calculateEdges(width, height) {
         return {
           top: width,
           right: height,
           bottom: width,
           left: height
         };
       }

                positionElementsInGrid(elements, startIndex = 0, type = 'pieces') {
           if (elements.length === 0) return;
           
           const config = CONFIG.QUILT;
           const spacing = CONFIG.POSITIONING.spacing[type] || 120;
           const jitter = CONFIG.POSITIONING.jitter[type] || 8;
           
           // For blocks, use touching layout instead of grid
           if (type === 'blocks') {
             this.positionBlocksInTouchingLayout(elements);
             return;
           }
           
           // Calculate optimal grid dimensions for pieces/patches
           const elementCount = elements.length;
           const aspectRatio = config.viewBoxWidth / config.viewBoxHeight;
           const cols = Math.ceil(Math.sqrt(elementCount * aspectRatio));
           const rows = Math.ceil(elementCount / cols);
           
           const availableWidth = config.viewBoxWidth - (2 * config.edgePadding);
           const availableHeight = config.viewBoxHeight - (2 * config.edgePadding);
           const cellWidth = availableWidth / cols;
           const cellHeight = availableHeight / rows;
           
           this.logger.log(`Positioning ${elements.length} ${type} in ${rows}x${cols} grid`);
           
           elements.forEach((element, index) => {
             const gridIndex = startIndex + index;
             const row = Math.floor(gridIndex / cols);
             const col = gridIndex % cols;
             
             const x = config.viewBoxStartX + config.edgePadding + (col * cellWidth);
             const y = config.viewBoxStartY + config.edgePadding + (row * cellHeight);
             
             // Center element in cell
             const centerX = x + (cellWidth - element.width) / 2;
             const centerY = y + (cellHeight - element.height) / 2;
             
             // Add jitter
             const jitterX = (Math.random() - 0.5) * jitter;
             const jitterY = (Math.random() - 0.5) * jitter;
             
             // Ensure element stays within bounds
             const maxX = config.viewBoxStartX + config.viewBoxWidth - config.edgePadding - element.width;
             const maxY = config.viewBoxStartY + config.viewBoxHeight - config.edgePadding - element.height;
             
             element.x = Math.max(config.viewBoxStartX + config.edgePadding, Math.min(maxX, centerX + jitterX));
             element.y = Math.max(config.viewBoxStartY + config.edgePadding, Math.min(maxY, centerY + jitterY));
             
             this.logger.position(type, index, element.x, element.y);
           });
         }
         
         positionBlocksInTouchingLayout(blocks) {
           if (blocks.length === 0) return;
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning ${blocks.length} blocks using pairing logic`);
           
           // For 6 blocks, use the new pairing approach
           if (blocks.length === 6) {
             this.positionBlocksWithPairing(blocks);
             return;
           }
           
           // Fallback to original logic for other block counts
           this.positionBlocksIteratively(blocks);
         }
         
         positionBlocksWithPairing(blocks) {
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log('Using pairing approach for 6 blocks');
           
           // Phase 1: Create 3 paired blocks
           const pairedBlocks = this.createPairedBlocks(blocks);
           
           // Phase 2: Combine 2 paired blocks into a 4-block section
           const fourBlockSection = this.combinePairedBlocks(pairedBlocks);
           
           // Phase 3: Add the remaining paired block
           this.addFinalPairedBlock(fourBlockSection, pairedBlocks[2]);
           
           // Position the final quilt at the center
           this.centerQuilt(blocks);
         }
         
         createPairedBlocks(blocks) {
           this.logger.log('Phase 1: Creating paired blocks');
           this.logger.log(`Initial blocks:`, blocks.map(b => ({ id: b.id, width: b.width, height: b.height, color: b.color })));
           
           // Generate all possible pairs
           const allPairs = [];
           for (let i = 0; i < blocks.length; i++) {
             for (let j = i + 1; j < blocks.length; j++) {
               const pair = this.evaluateBlockPair(blocks[i], blocks[j]);
               allPairs.push(pair);
               this.logger.log(`Pair ${i}-${j}: score=${pair.score.toFixed(2)}, joinType=${pair.joinType}, edgeDiff=${Math.abs(pair.edgeMatch?.edge1.length - pair.edgeMatch?.edge2.length) || 'N/A'}`);
             }
           }
           
           // Sort by score (lower is better)
           allPairs.sort((a, b) => a.score - b.score);
           
           // Select the 3 best pairs, ensuring no block is used twice
           const selectedPairs = [];
           const usedBlocks = new Set();
           
           for (const pair of allPairs) {
             if (!usedBlocks.has(pair.block1) && !usedBlocks.has(pair.block2)) {
               selectedPairs.push(pair);
               usedBlocks.add(pair.block1);
               usedBlocks.add(pair.block2);
               
               if (selectedPairs.length === 3) break;
             }
           }
           
           // Create paired blocks
           const pairedBlocks = selectedPairs.map(pair => this.createPairedBlock(pair));
           
           this.logger.log(`Created ${pairedBlocks.length} paired blocks`);
           this.logger.log('Paired blocks details:', pairedBlocks.map(pb => ({
             width: pb.width,
             height: pb.height,
             joinType: pb.joinType,
             score: pb.score,
             blockIds: pb.blocks.map(b => b.id)
           })));
           return pairedBlocks;
         }
         
         evaluateBlockPair(block1, block2) {
           let bestScore = Infinity;
           let bestJoinType = null;
           let bestEdgeMatch = null;
           
           // Check all possible edge combinations
           const edges1 = [
             { type: 'horizontal', length: block1.width, side: 'right' },
             { type: 'horizontal', length: block1.width, side: 'left' },
             { type: 'vertical', length: block1.height, side: 'bottom' },
             { type: 'vertical', length: block1.height, side: 'top' }
           ];
           
           const edges2 = [
             { type: 'horizontal', length: block2.width, side: 'right' },
             { type: 'horizontal', length: block2.width, side: 'left' },
             { type: 'vertical', length: block2.height, side: 'bottom' },
             { type: 'vertical', length: block2.height, side: 'top' }
           ];
           
           for (const edge1 of edges1) {
             for (const edge2 of edges2) {
               if (edge1.type === edge2.type) {
                 const lengthDiff = Math.abs(edge1.length - edge2.length);
                 const valueContrast = this.calculateValueContrastScore(block1.color, block2.color);
                 
                 // Combined score: edge compatibility + value contrast
                 const score = lengthDiff + (1 - valueContrast) * 50;
                 
                 if (score < bestScore) {
                   bestScore = score;
                   bestJoinType = edge1.type;
                   bestEdgeMatch = { edge1, edge2 };
                 }
               }
             }
           }
           
           return {
             block1,
             block2,
             score: bestScore,
             joinType: bestJoinType,
             edgeMatch: bestEdgeMatch
           };
         }
         
         createPairedBlock(pair) {
           const { block1, block2, joinType, edgeMatch } = pair;
           
           this.logger.log(`Creating paired block: ${block1.id} + ${block2.id}, joinType=${joinType}`);
           this.logger.log(`Before resize: block1=${block1.width}x${block1.height}, block2=${block2.width}x${block2.height}`);
           
           // Resize blocks slightly if needed for better edge alignment
           if (joinType === 'horizontal') {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               block1.width = targetLength;
               this.logger.log(`Resized block1 width to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               block2.width = targetLength;
               this.logger.log(`Resized block2 width to ${targetLength}`);
             }
           } else {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               block1.height = targetLength;
               this.logger.log(`Resized block1 height to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               block2.height = targetLength;
               this.logger.log(`Resized block2 height to ${targetLength}`);
             }
           }
           
           this.logger.log(`After resize: block1=${block1.width}x${block1.height}, block2=${block2.width}x${block2.height}`);
           
           // Calculate combined dimensions
           let combinedWidth, combinedHeight;
           if (joinType === 'horizontal') {
             combinedWidth = block1.width + block2.width;
             combinedHeight = Math.max(block1.height, block2.height);
           } else {
             combinedWidth = Math.max(block1.width, block2.width);
             combinedHeight = block1.height + block2.height;
           }
           
           // Position the two blocks within the paired block
           block1.x = 0;
           block1.y = 0;
           
           if (joinType === 'horizontal') {
             // For horizontal join, place block2 to the right of block1
             block2.x = block1.width;
             block2.y = 0;
           } else {
             // For vertical join, place block2 below block1
             block2.x = 0;
             block2.y = block1.height;
           }
           
           this.logger.log(`Positioned blocks in pair: ${block1.id} at (${block1.x}, ${block1.y}), ${block2.id} at (${block2.x}, ${block2.y})`);
           this.logger.log(`Paired block dimensions: ${combinedWidth}x${combinedHeight}, joinType=${joinType}`);
           
           return {
             blocks: [block1, block2],
             width: combinedWidth,
             height: combinedHeight,
             joinType,
             score: pair.score
           };
         }
         
         combinePairedBlocks(pairedBlocks) {
           this.logger.log('Phase 2: Combining paired blocks');
           
           // Evaluate all possible combinations of 2 paired blocks
           const combinations = [];
           for (let i = 0; i < pairedBlocks.length; i++) {
             for (let j = i + 1; j < pairedBlocks.length; j++) {
               const combination = this.evaluatePairedBlockCombination(pairedBlocks[i], pairedBlocks[j]);
               combinations.push(combination);
               this.logger.log(`Combination ${i}-${j}: score=${combination.score.toFixed(2)}, joinType=${combination.joinType}`);
             }
           }
           
           // Select the best combination
           combinations.sort((a, b) => a.score - b.score);
           const bestCombination = combinations[0];
           
           // Create the 4-block section
           const fourBlockSection = this.createFourBlockSection(bestCombination);
           
           this.logger.log('Created 4-block section');
           return fourBlockSection;
         }
         
         evaluatePairedBlockCombination(pair1, pair2) {
           let bestScore = Infinity;
           let bestJoinType = null;
           let bestEdgeMatch = null;
           
           // Check all possible edge combinations between the paired blocks
           const edges1 = [
             { type: 'horizontal', length: pair1.width, side: 'right' },
             { type: 'horizontal', length: pair1.width, side: 'left' },
             { type: 'vertical', length: pair1.height, side: 'bottom' },
             { type: 'vertical', length: pair1.height, side: 'top' }
           ];
           
           const edges2 = [
             { type: 'horizontal', length: pair2.width, side: 'right' },
             { type: 'horizontal', length: pair2.width, side: 'left' },
             { type: 'vertical', length: pair2.height, side: 'bottom' },
             { type: 'vertical', length: pair2.height, side: 'top' }
           ];
           
           for (const edge1 of edges1) {
             for (const edge2 of edges2) {
               if (edge1.type === edge2.type) {
                 const lengthDiff = Math.abs(edge1.length - edge2.length);
                 const score = lengthDiff;
                 
                 if (score < bestScore) {
                   bestScore = score;
                   bestJoinType = edge1.type;
                   bestEdgeMatch = { edge1, edge2 };
                 }
               }
             }
           }
           
           return {
             pair1,
             pair2,
             score: bestScore,
             joinType: bestJoinType,
             edgeMatch: bestEdgeMatch
           };
         }
         
         createFourBlockSection(combination) {
           const { pair1, pair2, joinType, edgeMatch } = combination;
           
           this.logger.log(`Creating four-block section: pair1=${pair1.width}x${pair1.height}, pair2=${pair2.width}x${pair2.height}, joinType=${joinType}`);
           
           // Resize paired blocks slightly if needed
           if (joinType === 'horizontal') {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               pair1.width = targetLength;
               this.logger.log(`Resized pair1 width to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               pair2.width = targetLength;
               this.logger.log(`Resized pair2 width to ${targetLength}`);
             }
           } else {
             const targetLength = Math.max(edgeMatch.edge1.length, edgeMatch.edge2.length);
             if (edgeMatch.edge1.length < targetLength) {
               pair1.height = targetLength;
               this.logger.log(`Resized pair1 height to ${targetLength}`);
             }
             if (edgeMatch.edge2.length < targetLength) {
               pair2.height = targetLength;
               this.logger.log(`Resized pair2 height to ${targetLength}`);
             }
           }
           
           // Calculate combined dimensions
           let combinedWidth, combinedHeight;
           if (joinType === 'horizontal') {
             combinedWidth = pair1.width + pair2.width;
             combinedHeight = Math.max(pair1.height, pair2.height);
           } else {
             combinedWidth = Math.max(pair1.width, pair2.width);
             combinedHeight = pair1.height + pair2.height;
           }
           
           this.logger.log(`Four-block section dimensions: ${combinedWidth}x${combinedHeight}`);
           
                       // Position the blocks within the four-block section
            let currentX = 0;
            let currentY = 0;
            
            // Position blocks from pair1 first
            for (const block of pair1.blocks) {
              // Add the pair1 offset to the block's existing relative position
              block.x = currentX + block.x;
              block.y = currentY + block.y;
              
              if (pair1.joinType === 'horizontal') {
                currentX += block.width;
              } else {
                currentY += block.height;
              }
              
              this.logger.log(`Positioned pair1 block ${block.id} at (${block.x}, ${block.y})`);
            }
            
            // Reset position for pair2
            if (joinType === 'horizontal') {
              // Attach pair2 to the right of pair1 - ensure they touch
              currentX = pair1.width;
              currentY = 0;
            } else {
              // Attach pair2 below pair1 - ensure they touch
              currentX = 0;
              currentY = pair1.height;
            }
            
            // Position blocks from pair2
            for (const block of pair2.blocks) {
              // Add the pair2 offset to the block's existing relative position
              block.x = currentX + block.x;
              block.y = currentY + block.y;
              
              // Update current position based on the four-block section's join type, not the pair's join type
              if (joinType === 'horizontal') {
                currentX += block.width;
              } else {
                currentY += block.height;
              }
              
              this.logger.log(`Positioned pair2 block ${block.id} at (${block.x}, ${block.y})`);
            }
           
           this.logger.log('Final four-block section positions:', [...pair1.blocks, ...pair2.blocks].map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Check for overlaps in the four-block section
           this.logger.log('Checking for overlaps in four-block section...');
           const allBlocks = [...pair1.blocks, ...pair2.blocks];
           for (let i = 0; i < allBlocks.length; i++) {
             for (let j = i + 1; j < allBlocks.length; j++) {
               const block1 = allBlocks[i];
               const block2 = allBlocks[j];
               
               // Check for horizontal overlap
               const horizontalOverlap = Math.min(block1.x + block1.width, block2.x + block2.width) - Math.max(block1.x, block2.x);
               if (horizontalOverlap > 0) {
                 const verticalOverlap = Math.min(block1.y + block1.height, block2.y + block2.height) - Math.max(block1.y, block2.y);
                 if (verticalOverlap > 0) {
                   this.logger.log(`FOUR-BLOCK OVERLAP detected between ${block1.id} and ${block2.id}: ${horizontalOverlap}x${verticalOverlap}px`);
                 }
               }
             }
           }
           
           return {
             blocks: [...pair1.blocks, ...pair2.blocks],
             width: combinedWidth,
             height: combinedHeight,
             joinType,
             score: combination.score
           };
         }
         
         addFinalPairedBlock(fourBlockSection, remainingPairedBlock) {
           this.logger.log('Phase 3: Adding final paired block');
           
           // Find the best way to add the remaining paired block
           const bestAttachment = this.findBestAttachment(fourBlockSection, remainingPairedBlock);
           
           // Apply the attachment
           this.applyAttachment(fourBlockSection, remainingPairedBlock, bestAttachment);
           
           this.logger.log('Final quilt layout complete');
         }
         
         findBestAttachment(fourBlockSection, pairedBlock) {
           let bestScore = Infinity;
           let bestPosition = null;
           let bestJoinType = null;
           
           // Try different attachment positions
           const attachmentPositions = [
             { side: 'right', x: fourBlockSection.width, y: 0 },
             { side: 'left', x: -pairedBlock.width, y: 0 },
             { side: 'bottom', x: 0, y: fourBlockSection.height },
             { side: 'top', x: 0, y: -pairedBlock.height }
           ];
           
           for (const position of attachmentPositions) {
             const score = this.evaluateAttachmentPosition(fourBlockSection, pairedBlock, position);
             if (score < bestScore) {
               bestScore = score;
               bestPosition = position;
               bestJoinType = position.side === 'right' || position.side === 'left' ? 'horizontal' : 'vertical';
             }
           }
           
           return {
             position: bestPosition,
             joinType: bestJoinType,
             score: bestScore
           };
         }
         
         evaluateAttachmentPosition(fourBlockSection, pairedBlock, position) {
           // Simple scoring based on edge alignment and shape balance
           let score = 0;
           
           // Edge alignment score
           if (position.side === 'right' || position.side === 'left') {
             const lengthDiff = Math.abs(fourBlockSection.height - pairedBlock.height);
             score += lengthDiff;
           } else {
             const lengthDiff = Math.abs(fourBlockSection.width - pairedBlock.width);
             score += lengthDiff;
           }
           
           // Shape balance score (prefer more square shapes)
           const combinedWidth = position.side === 'right' || position.side === 'left' 
             ? fourBlockSection.width + pairedBlock.width 
             : Math.max(fourBlockSection.width, pairedBlock.width);
           const combinedHeight = position.side === 'top' || position.side === 'bottom'
             ? fourBlockSection.height + pairedBlock.height
             : Math.max(fourBlockSection.height, pairedBlock.height);
           
           const aspectRatio = Math.max(combinedWidth, combinedHeight) / Math.min(combinedWidth, combinedHeight);
           score += (aspectRatio - 1) * 10; // Penalize very long/thin shapes
           
           return score;
         }
         
         applyAttachment(fourBlockSection, pairedBlock, attachment) {
           const { position, joinType } = attachment;
           
           this.logger.log(`Applying attachment: joinType=${joinType}, position=${JSON.stringify(position)}`);
           this.logger.log(`Before attachment: fourBlockSection=${fourBlockSection.width}x${fourBlockSection.height}, pairedBlock=${pairedBlock.width}x${pairedBlock.height}`);
           
           // Resize if needed for better alignment
           if (joinType === 'horizontal') {
             const targetHeight = Math.max(fourBlockSection.height, pairedBlock.height);
             if (fourBlockSection.height < targetHeight) {
               fourBlockSection.height = targetHeight;
               this.logger.log(`Resized fourBlockSection height to ${targetHeight}`);
             }
             if (pairedBlock.height < targetHeight) {
               pairedBlock.height = targetHeight;
               this.logger.log(`Resized pairedBlock height to ${targetHeight}`);
             }
           } else {
             const targetWidth = Math.max(fourBlockSection.width, pairedBlock.width);
             if (fourBlockSection.width < targetWidth) {
               fourBlockSection.width = targetWidth;
               this.logger.log(`Resized fourBlockSection width to ${targetWidth}`);
             }
             if (pairedBlock.width < targetWidth) {
               pairedBlock.width = targetWidth;
               this.logger.log(`Resized pairedBlock width to ${targetWidth}`);
             }
           }
           
           // Position blocks based on the attachment position
           const allBlocks = [...fourBlockSection.blocks, ...pairedBlock.blocks];
           
           this.logger.log(`Positioning ${allBlocks.length} blocks based on attachment position`);
           
           // Calculate the offset for the paired block based on attachment position
           let pairedBlockOffsetX = 0;
           let pairedBlockOffsetY = 0;
           
           if (position.side === 'right') {
             // Attach to the right - paired block starts where four-block section ends
             pairedBlockOffsetX = fourBlockSection.width;
             pairedBlockOffsetY = 0;
           } else if (position.side === 'left') {
             // Attach to the left - paired block ends where four-block section starts
             pairedBlockOffsetX = -pairedBlock.width;
             pairedBlockOffsetY = 0;
           } else if (position.side === 'bottom') {
             // Attach below - paired block starts where four-block section ends
             pairedBlockOffsetX = 0;
             pairedBlockOffsetY = fourBlockSection.height;
           } else if (position.side === 'top') {
             // Attach above - paired block ends where four-block section starts
             pairedBlockOffsetX = 0;
             pairedBlockOffsetY = -pairedBlock.height;
           }
           
           this.logger.log(`Paired block offset: (${pairedBlockOffsetX}, ${pairedBlockOffsetY})`);
           
           // Position blocks from the four-block section (they stay at their current positions)
           for (const block of fourBlockSection.blocks) {
             this.logger.log(`Four-block section block ${block.id} stays at (${block.x}, ${block.y})`);
           }
           
           // Position blocks from the paired block with the calculated offset
           for (const block of pairedBlock.blocks) {
             // Add the paired block offset to the block's existing relative position
             block.x = pairedBlockOffsetX + block.x;
             block.y = pairedBlockOffsetY + block.y;
             
             this.logger.log(`Positioned paired block ${block.id} at (${block.x}, ${block.y})`);
           }
           
           this.logger.log('Final block positions:', allBlocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Check for overlaps and gaps by analyzing all block pairs
           this.logger.log('Checking for overlaps and gaps between blocks...');
           for (let i = 0; i < allBlocks.length; i++) {
             for (let j = i + 1; j < allBlocks.length; j++) {
               const block1 = allBlocks[i];
               const block2 = allBlocks[j];
               
               // Check for horizontal overlap
               const horizontalOverlap = Math.min(block1.x + block1.width, block2.x + block2.width) - Math.max(block1.x, block2.x);
               if (horizontalOverlap > 0) {
                 const verticalOverlap = Math.min(block1.y + block1.height, block2.y + block2.height) - Math.max(block1.y, block2.y);
                 if (verticalOverlap > 0) {
                   this.logger.log(`OVERLAP detected between ${block1.id} and ${block2.id}: ${horizontalOverlap}x${verticalOverlap}px`);
                 }
               }
               
               // Check if blocks are adjacent horizontally
               if (Math.abs(block1.y - block2.y) < 1) {
                 const gap = Math.abs(block1.x + block1.width - block2.x);
                 if (gap > 1) {
                   this.logger.log(`Gap detected between ${block1.id} and ${block2.id}: ${gap}px`);
                 }
               }
               
               // Check if blocks are adjacent vertically
               if (Math.abs(block1.x - block2.x) < 1) {
                 const gap = Math.abs(block1.y + block1.height - block2.y);
                 if (gap > 1) {
                   this.logger.log(`Gap detected between ${block1.id} and ${block2.id}: ${gap}px`);
                 }
               }
             }
           }
         }
         
         centerQuilt(blocks) {
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log('Centering quilt...');
           this.logger.log('Before centering:', blocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
           
           // Calculate quilt bounds
           const bounds = this.getQuiltBounds(blocks);
           this.logger.log('Quilt bounds:', bounds);
           
           // Calculate center position
           const centerX = config.viewBoxStartX + (config.viewBoxWidth / 2) - (bounds.width / 2);
           const centerY = config.viewBoxStartY + (config.viewBoxHeight / 2) - (bounds.height / 2);
           
           this.logger.log(`Target center: (${centerX}, ${centerY})`);
           
           // Adjust all block positions
           const offsetX = centerX - bounds.x;
           const offsetY = centerY - bounds.y;
           
           this.logger.log(`Applying offset: (${offsetX}, ${offsetY})`);
           
           for (const block of blocks) {
             const oldX = block.x;
             const oldY = block.y;
             
             block.x += offsetX;
             block.y += offsetY;
             
             // Ensure blocks stay within bounds
             const newX = Math.max(config.viewBoxStartX + padding, 
                              Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - block.width, block.x));
             const newY = Math.max(config.viewBoxStartY + padding, 
                              Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - block.height, block.y));
             
             if (newX !== block.x || newY !== block.y) {
               this.logger.log(`Bounds adjustment for block ${block.id}: (${block.x}, ${block.y}) -> (${newX}, ${newY})`);
             }
             
             block.x = newX;
             block.y = newY;
           }
           
           this.logger.log('After centering:', blocks.map(b => ({ id: b.id, x: b.x, y: b.y, width: b.width, height: b.height })));
         }
         
         positionBlocksIteratively(blocks) {
           if (blocks.length === 0) return;
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning ${blocks.length} blocks using iterative edge-matching logic`);
           
           // Start with the first block at the center
           blocks[0].x = config.viewBoxStartX + (config.viewBoxWidth / 2) - (blocks[0].width / 2);
           blocks[0].y = config.viewBoxStartY + (config.viewBoxHeight / 2) - (blocks[0].height / 2);
           
           // Create a list of available blocks to join
           const availableBlocks = blocks.slice(1);
           const joinedBlocks = [blocks[0]];
           
           // Iteratively join blocks using edge matching
           while (availableBlocks.length > 0) {
             let bestMatch = null;
             let bestScore = Infinity;
             let bestJoinType = null;
             let bestBlockIndex = -1;
             let bestJoinedIndex = -1;
             
             // Find the best edge match between available blocks and joined blocks
             for (let i = 0; i < availableBlocks.length; i++) {
               const availableBlock = availableBlocks[i];
               
               for (let j = 0; j < joinedBlocks.length; j++) {
                 const joinedBlock = joinedBlocks[j];
                 
                 // Check all four edges of each block
                 const edges = [
                   { type: 'horizontal', length: availableBlock.width, block: availableBlock, side: 'right' },
                   { type: 'horizontal', length: availableBlock.width, block: availableBlock, side: 'left' },
                   { type: 'vertical', length: availableBlock.height, block: availableBlock, side: 'bottom' },
                   { type: 'vertical', length: availableBlock.height, block: availableBlock, side: 'top' }
                 ];
                 
                 const joinedEdges = [
                   { type: 'horizontal', length: joinedBlock.width, block: joinedBlock, side: 'right' },
                   { type: 'horizontal', length: joinedBlock.width, block: joinedBlock, side: 'left' },
                   { type: 'vertical', length: joinedBlock.height, block: joinedBlock, side: 'bottom' },
                   { type: 'vertical', length: joinedBlock.height, block: joinedBlock, side: 'top' }
                 ];
                 
                 // Find best matching edges
                 for (const edge of edges) {
                   for (const joinedEdge of joinedEdges) {
                     if (edge.type === joinedEdge.type) {
                       const lengthDiff = Math.abs(edge.length - joinedEdge.length);
                       const score = lengthDiff;
                       
                       if (score < bestScore) {
                         bestScore = score;
                         bestMatch = { available: edge, joined: joinedEdge };
                         bestJoinType = edge.type;
                         bestBlockIndex = i;
                         bestJoinedIndex = j;
                       }
                     }
                   }
                 }
               }
             }
             
             if (bestMatch) {
               // Join the blocks
               const availableBlock = availableBlocks[bestBlockIndex];
               const joinedBlock = joinedBlocks[bestJoinedIndex];
               
               // Calculate position based on join type
               let newX, newY;
               
               if (bestJoinType === 'horizontal') {
                 // Join horizontally
                 if (bestMatch.available.side === 'right' && bestMatch.joined.side === 'left') {
                   newX = joinedBlock.x + joinedBlock.width;
                   newY = joinedBlock.y;
                 } else if (bestMatch.available.side === 'left' && bestMatch.joined.side === 'right') {
                   newX = joinedBlock.x - availableBlock.width;
                   newY = joinedBlock.y;
                 } else {
                   // Resize to match
                   const targetLength = Math.max(bestMatch.available.length, bestMatch.joined.length);
                   if (bestMatch.available.length < targetLength) {
                     availableBlock.width = targetLength;
                   }
                   if (bestMatch.joined.length < targetLength) {
                     joinedBlock.width = targetLength;
                   }
                   newX = joinedBlock.x + joinedBlock.width;
                   newY = joinedBlock.y;
                 }
               } else {
                 // Join vertically
                 if (bestMatch.available.side === 'bottom' && bestMatch.joined.side === 'top') {
                   newX = joinedBlock.x;
                   newY = joinedBlock.y + joinedBlock.height;
                 } else if (bestMatch.available.side === 'top' && bestMatch.joined.side === 'bottom') {
                   newX = joinedBlock.x;
                   newY = joinedBlock.y - availableBlock.height;
                 } else {
                   // Resize to match
                   const targetLength = Math.max(bestMatch.available.length, bestMatch.joined.length);
                   if (bestMatch.available.length < targetLength) {
                     availableBlock.height = targetLength;
                   }
                   if (bestMatch.joined.length < targetLength) {
                     joinedBlock.height = targetLength;
                   }
                   newX = joinedBlock.x;
                   newY = joinedBlock.y + joinedBlock.height;
                 }
               }
               
               // Ensure the block stays within bounds
               newX = Math.max(config.viewBoxStartX + padding, 
                              Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - availableBlock.width, newX));
               newY = Math.max(config.viewBoxStartY + padding, 
                              Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - availableBlock.height, newY));
               
               availableBlock.x = newX;
               availableBlock.y = newY;
               
               // Move block from available to joined
               joinedBlocks.push(availableBlock);
               availableBlocks.splice(bestBlockIndex, 1);
               
               this.logger.log(`Joined block ${bestBlockIndex} to block ${bestJoinedIndex} with score ${bestScore}`);
             } else {
               // Fallback: position remaining blocks around the quilt
               const remainingBlock = availableBlocks[0];
               const quiltBounds = this.getQuiltBounds(joinedBlocks);
               
               remainingBlock.x = quiltBounds.x + quiltBounds.width;
               remainingBlock.y = quiltBounds.y;
               
               joinedBlocks.push(remainingBlock);
               availableBlocks.splice(0, 1);
               
               this.logger.log(`Fallback positioning for remaining block`);
             }
           }
         }
         
         positionPieceWithQuilt(piece, existingBlocks) {
           if (existingBlocks.length === 0) {
             // If no existing blocks, position piece normally
             piece.x = CONFIG.QUILT.viewBoxStartX + CONFIG.QUILT.edgePadding;
             piece.y = CONFIG.QUILT.viewBoxStartY + CONFIG.QUILT.edgePadding;
             return;
           }
           
           const config = CONFIG.QUILT;
           const padding = config.edgePadding;
           
           this.logger.log(`Positioning piece with ${existingBlocks.length} existing blocks`);
           
           // Find the best position to attach the piece to the quilt
           let bestX = config.viewBoxStartX + padding;
           let bestY = config.viewBoxStartY + padding;
           let bestScore = Infinity;
           
           // Try different attachment points around the existing quilt
           for (let attempt = 0; attempt < 20; attempt++) {
             let testX, testY;
             
             if (attempt < 5) {
               // Try attaching to the right edge of the quilt
               const rightmostBlock = existingBlocks.reduce((rightmost, block) => 
                 block.x + block.width > rightmost.x + rightmost.width ? block : rightmost
               );
               testX = rightmostBlock.x + rightmostBlock.width;
               testY = rightmostBlock.y + (Math.random() - 0.5) * rightmostBlock.height;
             } else if (attempt < 10) {
               // Try attaching to the bottom edge of the quilt
               const bottommostBlock = existingBlocks.reduce((bottommost, block) => 
                 block.y + block.height > bottommost.y + bottommost.height ? block : bottommost
               );
               testX = bottommostBlock.x + (Math.random() - 0.5) * bottommostBlock.width;
               testY = bottommostBlock.y + bottommostBlock.height;
             } else {
               // Try random positions near the quilt
               const quiltBounds = this.getQuiltBounds(existingBlocks);
               testX = quiltBounds.x + (Math.random() - 0.5) * quiltBounds.width;
               testY = quiltBounds.y + (Math.random() - 0.5) * quiltBounds.height;
             }
             
             // Ensure piece stays within bounds
             testX = Math.max(config.viewBoxStartX + padding, 
                            Math.min(config.viewBoxStartX + config.viewBoxWidth - padding - piece.width, testX));
             testY = Math.max(config.viewBoxStartY + padding, 
                            Math.min(config.viewBoxStartY + config.viewBoxHeight - padding - piece.height, testY));
             
             // Check if this position touches at least one existing block
             let touchesExisting = false;
             let minDistance = Infinity;
             
             for (const block of existingBlocks) {
               const horizontalTouch = (testX + piece.width === block.x) || 
                                    (block.x + block.width === testX);
               const verticalTouch = (testY + piece.height === block.y) || 
                                  (block.y + block.height === testY);
               
               if (horizontalTouch || verticalTouch) {
                 touchesExisting = true;
                 break;
               }
               
               // Calculate distance to block
               const distance = Math.sqrt(
                 Math.pow(testX - block.x, 2) + Math.pow(testY - block.y, 2)
               );
               minDistance = Math.min(minDistance, distance);
             }
             
             // Prefer positions that touch existing blocks
             const score = touchesExisting ? minDistance : minDistance + 1000;
             
             if (score < bestScore) {
               bestScore = score;
               bestX = testX;
               bestY = testY;
             }
           }
           
           piece.x = bestX;
           piece.y = bestY;
           
           this.logger.log(`Piece positioned at (${piece.x}, ${piece.y}) with score ${bestScore}`);
         }
         
         getQuiltBounds(blocks) {
           if (blocks.length === 0) {
             return { x: 0, y: 0, width: 0, height: 0 };
           }
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           
           blocks.forEach(block => {
             minX = Math.min(minX, block.x);
             minY = Math.min(minY, block.y);
             maxX = Math.max(maxX, block.x + block.width);
             maxY = Math.max(maxY, block.y + block.height);
           });
           
           return {
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY
           };
         }
         
         calculateValueContrastScore(color1, color2) {
           const hsl1 = Utils.hexToHsl(color1);
           const hsl2 = Utils.hexToHsl(color2);
           const valueDifference = Math.abs(hsl1.l - hsl2.l);
           const normalizedContrast = valueDifference / 100;
           const contrastScore = Math.pow(normalizedContrast, 0.7);
           return contrastScore;
         }
     }

     // ===== UNIVERSAL MATCHING SERVICE =====
     class UniversalMatchingService {
       constructor(logger) {
         this.logger = logger;
       }

       /**
        * Universal matching algorithm that works for any element type
        * @param {Array} elements - Array of elements to match against
        * @param {Object} targetElement - The element to find a match for
        * @param {Object} options - Matching options (tolerance, valueContrastWeight, etc.)
        * @returns {Object|null} - Best match or null
        */
       findBestMatch(elements, targetElement, options = {}) {
         const {
           edgeTolerance = CONFIG.PHASES.patchFormation.edgeTolerance,
           valueContrastWeight = CONFIG.PHASES.patchFormation.valueContrastWeight
         } = options;

         let bestMatch = null;
         let bestScore = Infinity;
         
         this.logger.log(`Universal matching: Finding best match for ${targetElement.type || 'element'} ${targetElement.id || 'unknown'} among ${elements.length} candidates`);
         
         for (let i = 0; i < elements.length; i++) {
           const element = elements[i];
           if (element === targetElement) continue;
           
           const targetEdges = targetElement.edges;
           const elementEdges = element.edges;
           
           const horizontalEdgeScore = this.calculateEdgeScore(targetEdges.right, elementEdges.left);
           const verticalEdgeScore = this.calculateEdgeScore(targetEdges.bottom, elementEdges.top);
           const valueContrastScore = this.calculateValueContrastScore(targetElement.color, element.color);
           const sameColorPenalty = targetElement.color === element.color ? 1.0 : 0;
           
           const horizontalScore = horizontalEdgeScore - valueContrastScore * valueContrastWeight + sameColorPenalty;
           const verticalScore = verticalEdgeScore - valueContrastScore * valueContrastWeight + sameColorPenalty;
           
           const score = Math.min(horizontalScore, verticalScore);
           const sameColor = targetElement.color === element.color;
           
           this.logger.log(`  Candidate ${i}: edge scores (H:${horizontalEdgeScore.toFixed(3)}, V:${verticalEdgeScore.toFixed(3)}), contrast:${valueContrastScore.toFixed(3)}, sameColor:${sameColor}, final score:${score.toFixed(3)}`);
           
           if (score < bestScore) {
             bestScore = score;
             bestMatch = {
               item: element,
               score: score,
               joinType: score === horizontalScore ? 'horizontal' : 'vertical',
               edgeScore: Math.min(horizontalEdgeScore, verticalEdgeScore),
               valueContrastScore: valueContrastScore
             };
             this.logger.log(`  New best match found with score ${score.toFixed(3)}`);
           }
         }
         
         this.logger.log(`Best match score: ${bestMatch ? bestMatch.score.toFixed(3) : 'none'}`);
         return bestMatch;
       }

       /**
        * Universal edge scoring algorithm
        */
       calculateEdgeScore(length1, length2) {
         const difference = Math.abs(length1 - length2);
         const averageLength = (length1 + length2) / 2;
         return difference / averageLength;
       }

       /**
        * Universal value contrast scoring
        */
       calculateValueContrastScore(color1, color2) {
         const hsl1 = Utils.hexToHsl(color1);
         const hsl2 = Utils.hexToHsl(color2);
         const valueDifference = Math.abs(hsl1.l - hsl2.l);
         const normalizedContrast = valueDifference / 100;
         const contrastScore = Math.pow(normalizedContrast, 0.7);
         return contrastScore;
       }

       /**
        * Universal element joining logic
        */
       combineElements(element1, element2, joinType) {
         let combinedWidth, combinedHeight, combinedX, combinedY;
         
         if (joinType === 'horizontal') {
           const targetLength = (element1.edges.right + element2.edges.left) / 2;
           const adjustedWidth1 = element1.width;
           const adjustedWidth2 = element2.width;
           
           combinedWidth = element1.width + adjustedWidth2;
           combinedHeight = Math.max(element1.height, element2.height);
           combinedX = element1.x;
           combinedY = Math.min(element1.y, element2.y);
         } else {
           const targetLength = (element1.edges.bottom + element2.edges.top) / 2;
           const adjustedHeight1 = element1.height;
           const adjustedHeight2 = element2.height;
           
           combinedWidth = Math.max(element1.width, element2.width);
           combinedHeight = element1.height + adjustedHeight2;
           combinedX = Math.min(element1.x, element2.x);
           combinedY = element1.y;
         }
         
         return {
           width: combinedWidth,
           height: combinedHeight,
           x: combinedX,
           y: combinedY
         };
       }

       /**
        * Universal element resizing for better edge alignment
        */
       resizeElementsForAlignment(element1, element2, joinType) {
         let resizedElement1 = { ...element1 };
         let resizedElement2 = { ...element2 };
         
         if (joinType === 'horizontal') {
           const targetHeight = Math.max(element1.height, element2.height);
           if (element1.height !== targetHeight) resizedElement1.height = targetHeight;
           if (element2.height !== targetHeight) resizedElement2.height = targetHeight;
         } else {
           const targetWidth = Math.max(element1.width, element2.width);
           if (element1.width !== targetWidth) resizedElement1.width = targetWidth;
           if (element2.width !== targetWidth) resizedElement2.width = targetWidth;
         }
         
         return { resizedElement1, resizedElement2 };
       }

                /**
          * Universal formation algorithm that works for any element type
          */
         formCompositeElements(elements, targetType, options = {}) {
           const {
             edgeTolerance = CONFIG.PHASES.patchFormation.edgeTolerance,
             valueContrastWeight = CONFIG.PHASES.patchFormation.valueContrastWeight,
             createCompositeFunction = null,
             maxMatches = Math.floor(elements.length / 2) // Default to half the elements
           } = options;

           const compositeElements = [];
           const unmatchedElements = [];
           const workingElements = [...elements];
           
           this.logger.log(`Universal formation: Starting with ${workingElements.length} elements to form ${targetType}, max matches: ${maxMatches}`);
           
           let matchesMade = 0;
           
           while (workingElements.length >= 2 && matchesMade < maxMatches) {
             const element1 = workingElements.shift();
             
             if (!element1) {
               this.logger.warn('Skipping null element1');
               continue;
             }
             
             const bestMatch = this.findBestMatch(workingElements, element1, { edgeTolerance, valueContrastWeight });
             
             // Use fallback mechanism like the current system
             if (matchesMade < maxMatches) {
               const element2 = bestMatch ? bestMatch.item : workingElements[0];
               if (!bestMatch) {
                 workingElements.splice(0, 1);
               } else {
                 workingElements.splice(workingElements.indexOf(element2), 1);
               }
               
               this.logger.log(`Creating composite: ${element1.type || 'element'} ${element1.id || 'unknown'} + ${element2.type || 'element'} ${element2.id || 'unknown'} (score: ${bestMatch ? bestMatch.score.toFixed(3) : 'fallback'})`);
               
               // Resize elements for better alignment
               const { resizedElement1, resizedElement2 } = this.resizeElementsForAlignment(element1, element2, bestMatch ? bestMatch.joinType : 'horizontal');
               
               // Combine elements
               const combined = this.combineElements(resizedElement1, resizedElement2, bestMatch ? bestMatch.joinType : 'horizontal');
               
               // Create composite element
               if (createCompositeFunction) {
                 const compositeElement = createCompositeFunction([resizedElement1, resizedElement2]);
                 if (compositeElement) {
                   compositeElement.x = combined.x;
                   compositeElement.y = combined.y;
                   compositeElement.width = combined.width;
                   compositeElement.height = combined.height;
                   compositeElements.push(compositeElement);
                 }
               }
               matchesMade++;
             } else {
               unmatchedElements.push(element1);
             }
           }
           
           // Handle remaining elements
           while (workingElements.length > 0) {
             unmatchedElements.push(workingElements.shift());
           }
           
           this.logger.log(`Universal formation summary: ${compositeElements.length} composite elements created, ${unmatchedElements.length} unmatched elements`);
           
           return {
             compositeElements,
             unmatchedElements
           };
         }
     }

     // ===== RENDERING SERVICE =====
     class RenderingService {
       constructor(logger, errorHandler) {
         this.logger = logger;
         this.errorHandler = errorHandler;
         this.quiltSVG = null;
         this.isInitialized = false;
       }

       initialize() {
         this.quiltSVG = document.getElementById('quilt');
         if (!this.quiltSVG) {
           throw new Error('Quilt SVG element not found');
         }
         this.isInitialized = true;
         this.logger.log('Rendering service initialized');
       }

       renderBlocks(state) {
         if (!this.isInitialized) {
           this.logger.warn('Rendering service not initialized');
           return;
         }
         
         if (!this.quiltSVG) {
           this.logger.warn('Quilt SVG not found');
           return;
         }

         // Check if time-based rendering is active - if so, don't interfere
         if (this.quiltSVG.getAttribute('data-time-based-active') === 'true') {
           this.logger.log('🚫 Skipping legacy renderBlocks - time-based rendering is active');
           return;
         }

         try {
           // Clear existing content
           this.quiltSVG.innerHTML = '';
           
           // Create SVG definitions
           this.createSVGDefinitions();
           
           // Add viewBox border for debugging
           this.addViewBoxBorder();
           
           // Render based on current phase
           this.renderByPhase(state);
           
           // Update UI
           this.updateUI(state);
           
           this.logger.render('elements', this.getTotalElements(state));
         } catch (error) {
           this.errorHandler.handleError(error, 'renderBlocks');
         }
       }

       createSVGDefinitions() {
         const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
         defs.innerHTML = `
           <filter id="organicEdges" x="0" y="0" width="200%" height="200%">
             <feTurbulence baseFrequency="0.015" numOctaves="2" result="turb"/>
             <feDisplacementMap in="SourceGraphic" in2="turb" scale="2"/>
           </filter>
           <filter id="userHighlight" x="0" y="0" width="200%" height="200%">
             <feGaussianBlur stdDeviation="3" result="blur"/>
             <feFlood flood-color="#FFD700" flood-opacity="0.6" result="glow"/>
             <feComposite in="glow" in2="blur" operator="in" result="glowBlur"/>
             <feMerge>
               <feMergeNode in="glowBlur"/>
               <feMergeNode in="SourceGraphic"/>
             </feMerge>
           </filter>`;
         this.quiltSVG.appendChild(defs);
       }

       addViewBoxBorder() {
         const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         border.setAttribute('x', '0');
         border.setAttribute('y', '0');
         border.setAttribute('width', '800');
         border.setAttribute('height', '800');
         border.setAttribute('fill', 'none');
         border.setAttribute('stroke', '#ff0000');
         border.setAttribute('stroke-width', '2');
         border.setAttribute('stroke-dasharray', '5,5');
         this.quiltSVG.appendChild(border);
       }

       renderByPhase(state) {
         this.logger.log(`🎨 renderByPhase called for phase: ${state.currentPhase}`);
         
         switch (state.currentPhase) {
           case 'collection':
             this.logger.log(`🎨 Rendering pieces in collection phase`);
             this.renderPieces(state.pieces);
             break;
           case 'patch-formation':
             this.logger.log(`🎨 Rendering patches in patch-formation phase`);
             this.renderPatches(state.patches);
             this.renderUnmatchedPieces(state.unmatchedPieces);
             break;
           case 'block-formation':
             this.logger.log(`🎨 Rendering blocks in block-formation phase`);
             this.renderBlockList(state.blocks);
             this.renderUnmatchedPieces(state.unmatchedPieces);
             this.renderUnmatchedPatches(state.unmatchedPatches);
             break;
           case 'quilt-formation':
             this.logger.log(`🎨 Rendering quilt in quilt-formation phase`);
             this.renderQuilt(state.quilt);
             break;
           default:
             this.logger.log(`🎨 Default case: rendering blocks`);
             this.renderBlockList(state.blocks);
         }
         
         this.logger.log(`🎨 renderByPhase completed for phase: ${state.currentPhase}`);
       }

       renderPieces(pieces) {
         pieces.forEach((piece, i) => {
           this.renderPiece(piece, i);
         });
       }

       renderPatches(patches) {
         patches.forEach((patch, i) => {
           this.renderPatch(patch, i);
         });
       }

       renderBlockList(blocks) {
         if (!blocks || !Array.isArray(blocks)) {
           this.logger.warn('No blocks to render');
           return;
         }
         blocks.forEach((block, i) => {
           this.renderBlock(block, i);
         });
       }

       renderBlocks(state) {
         if (!state || !state.currentPhase) {
           this.logger.warn('❌ State or currentPhase is undefined, using default phase');
           state = { currentPhase: 'collection' };
         }
         
         this.logger.log(`🎨 Starting renderBlocks for phase: ${state.currentPhase}`);
         
         if (!this.quiltSVG) {
           this.logger.error('❌ quiltSVG element not found!');
           return;
         }
         
         // Check if time-based rendering is active - if so, don't interfere
         if (this.quiltSVG.getAttribute('data-time-based-active') === 'true') {
           this.logger.log('🚫 Skipping legacy renderBlocks - time-based rendering is active');
           return;
         }
         
         this.logger.log(`🎨 Found quiltSVG element, clearing content`);
         this.quiltSVG.innerHTML = '';
         
         // Create SVG definitions
         this.createSVGDefinitions();
         
         // Add viewBox border for debugging
         this.addViewBoxBorder();
         
         // Render based on current phase
         this.renderByPhase(state);
         
         this.logger.log('✅ renderBlocks completed');
       }

       renderUnmatchedPieces(pieces) {
         if (pieces && pieces.length > 0) {
           pieces.forEach((piece, i) => {
             this.renderPiece(piece, i);
           });
         }
       }

       renderUnmatchedPatches(patches) {
         if (patches && patches.length > 0) {
           patches.forEach((patch, i) => {
             this.renderPatch(patch, i);
           });
         }
       }

       renderQuilt(state) {
         this.logger.log('🎨 renderQuilt called, delegating to renderBlocks');
         this.renderBlocks(state);
       }



       renderQuiltBlocks(quilt) {
         if (quilt && quilt.blocks) {
           quilt.blocks.forEach((quiltBlock, index) => {
             if (quiltBlock && quiltBlock.blocks) {
               quiltBlock.blocks.forEach((block, blockIndex) => {
                 this.renderBlock(block, blockIndex);
               });
             }
           });
         }
       }

       renderPiece(piece, index) {
         this.logger.log(`🎨 Rendering piece ${index}:`, piece);
         
         const pathData = this.createOrganicPath(piece);
         this.logger.log(`🎨 Created path data for piece ${index}`);
         
         const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
         path.setAttribute('d', pathData);
         path.setAttribute('fill', piece.color);
         
         // Apply filters
         if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
           this.logger.log(`🎨 Applying user highlight filter to piece ${index}`);
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.userHighlightFilter})`);
         } else {
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.organicEdgesFilter})`);
         }
         
         // Animate new pieces
         const isCurrentUserPiece = piece.userId === this.currentUserId;
         const isLatestSubmission = piece.submissionId === this.submissionCount;
         if (isCurrentUserPiece && isLatestSubmission) {
           this.logger.log(`🎨 Adding animation class to piece ${index}`);
           path.classList.add(CONFIG.RENDERING.animationClass);
         }
         
         this.quiltSVG.appendChild(path);
         this.logger.log(`✅ Piece ${index} rendered successfully`);
       }

       renderPatch(patch, index) {
         if (!patch || !patch.pieces || patch.pieces.length === 0) return;
         
         const piece1 = patch.pieces[0];
         const piece2 = patch.pieces[1];
         
         // Add organic jitter
         const jitterX = (Math.random() - 0.5) * 8;
         const jitterY = (Math.random() - 0.5) * 8;
         const jitteredPatchX = patch.x + jitterX;
         const jitteredPatchY = patch.y + jitterY;
         
         const isRotated = patch.rotation === 90;
         const effectiveWidth = isRotated ? patch.height : patch.width;
         const effectiveHeight = isRotated ? patch.width : patch.height;
         
         let positionedPiece1, positionedPiece2;
         
         if (effectiveWidth > effectiveHeight) {
           // Horizontal join
           const piece1Ratio = piece1.width / (piece1.width + piece2.width);
           const piece2Ratio = piece2.width / (piece1.width + piece2.width);
           const joinJitter = (Math.random() - 0.5) * 6;
           
           positionedPiece1 = {
             ...piece1,
             x: jitteredPatchX,
             y: jitteredPatchY,
             width: (effectiveWidth * piece1Ratio) + joinJitter,
             height: effectiveHeight + (Math.random() - 0.5) * 4
           };
           positionedPiece2 = {
             ...piece2,
             x: jitteredPatchX + (effectiveWidth * piece1Ratio) + joinJitter,
             y: jitteredPatchY,
             width: (effectiveWidth * piece2Ratio) - joinJitter,
             height: effectiveHeight + (Math.random() - 0.5) * 4
           };
         } else {
           // Vertical join
           const piece1Ratio = piece1.height / (piece1.height + piece2.height);
           const piece2Ratio = piece2.height / (piece1.height + piece2.height);
           const joinJitter = (Math.random() - 0.5) * 6;
           
           positionedPiece1 = {
             ...piece1,
             x: jitteredPatchX,
             y: jitteredPatchY,
             width: effectiveWidth + (Math.random() - 0.5) * 4,
             height: (effectiveHeight * piece1Ratio) + joinJitter
           };
           positionedPiece2 = {
             ...piece2,
             x: jitteredPatchX,
             y: jitteredPatchY + (effectiveHeight * piece1Ratio) + joinJitter,
             width: effectiveWidth + (Math.random() - 0.5) * 4,
             height: (effectiveHeight * piece2Ratio) - joinJitter
           };
         }
         
         [positionedPiece1, positionedPiece2].forEach((piece, pieceIndex) => {
           const pathData = this.createOrganicPath(piece);
           if (!pathData) return;
           
           const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
           path.setAttribute('d', pathData);
           path.setAttribute('fill', piece.color);
           path.setAttribute('filter', `url(#${CONFIG.RENDERING.organicEdgesFilter})`);
           
           if (patch.rotation === 90) {
             const centerX = piece.x + piece.width / 2;
             const centerY = piece.y + piece.height / 2;
             path.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`);
           }
           
           if (piece.userId === this.currentUserId && this.userPiecesHighlighted) {
             path.setAttribute('filter', `url(#${CONFIG.RENDERING.userHighlightFilter})`);
           }
           
           const isCurrentUserPiece = piece.userId === this.currentUserId;
           const isLatestSubmission = piece.submissionId === this.submissionCount;
           if (isCurrentUserPiece && isLatestSubmission) {
             path.classList.add(CONFIG.RENDERING.animationClass);
           }
           
           this.quiltSVG.appendChild(path);
         });
       }

       renderBlock(block, index) {
         if (!block || !block.patches || block.patches.length === 0) return;
         
         const blockJitterX = (Math.random() - 0.5) * 8;
         const blockJitterY = (Math.random() - 0.5) * 8;
         const jitteredBlockX = block.x + blockJitterX;
         const jitteredBlockY = block.y + blockJitterY;
         
         if (block.patches.length >= 2) {
           const patch1 = block.patches[0];
           const patch2 = block.patches[1];
           
           let positionedPatch1, positionedPatch2;
           
           if (block.width > block.height) {
             // Horizontal join
             const patch1Ratio = patch1.width / (patch1.width + patch2.width);
             const patch2Ratio = patch2.width / (patch1.width + patch2.width);
             const joinJitter = (Math.random() - 0.5) * 6;
             
             positionedPatch1 = {
               ...patch1,
               x: jitteredBlockX,
               y: jitteredBlockY,
               width: (block.width * patch1Ratio) + joinJitter,
               height: block.height + (Math.random() - 0.5) * 4
             };
             positionedPatch2 = {
               ...patch2,
               x: jitteredBlockX + (block.width * patch1Ratio) + joinJitter,
               y: jitteredBlockY,
               width: (block.width * patch2Ratio) - joinJitter,
               height: block.height + (Math.random() - 0.5) * 4
             };
           } else {
             // Vertical join
             const patch1Ratio = patch1.height / (patch1.height + patch2.height);
             const patch2Ratio = patch2.height / (patch1.height + patch2.height);
             const joinJitter = (Math.random() - 0.5) * 6;
             
             positionedPatch1 = {
               ...patch1,
               x: jitteredBlockX,
               y: jitteredBlockY,
               width: block.width + (Math.random() - 0.5) * 4,
               height: (block.height * patch1Ratio) + joinJitter
             };
             positionedPatch2 = {
               ...patch2,
               x: jitteredBlockX,
               y: jitteredBlockY + (block.height * patch1Ratio) + joinJitter,
               width: block.width + (Math.random() - 0.5) * 4,
               height: (block.height * patch2Ratio) - joinJitter
             };
           }
           
           [positionedPatch1, positionedPatch2].forEach((patch, patchIndex) => {
             this.renderPatch(patch);
           });
         }
       }

       createOrganicPath(item) {
         if (!item || typeof item.x === 'undefined' || typeof item.y === 'undefined' || 
             typeof item.width === 'undefined' || typeof item.height === 'undefined') {
           this.logger.error('Invalid item for createOrganicPath:', item);
           return '';
         }
         
         const variation = CONFIG.QUILT.organicVariation;
         const x1 = item.x + (Math.random() - 0.5) * variation;
         const y1 = item.y + (Math.random() - 0.5) * variation;
         const x2 = item.x + item.width + (Math.random() - 0.5) * variation;
         const y2 = item.y + (Math.random() - 0.5) * variation;
         const x3 = item.x + item.width + (Math.random() - 0.5) * variation;
         const y3 = item.y + item.height + (Math.random() - 0.5) * variation;
         const x4 = item.x + (Math.random() - 0.5) * variation;
         const y4 = item.y + item.height + (Math.random() - 0.5) * variation;
         
         return `M ${x1},${y1} L ${x2},${y2} L ${x3},${y3} L ${x4},${y4} Z`;
       }

       updateUI(state) {
         // Update phase indicator and user counter
         // This will be handled by the main app
       }

                getTotalElements(state) {
           return (state.pieces ? state.pieces.length : 0) + 
                  (state.patches ? state.patches.length : 0) + 
                  (state.blocks ? state.blocks.length : 0) + 
                  (state.unmatchedPieces ? state.unmatchedPieces.length : 0) + 
                  (state.unmatchedPatches ? state.unmatchedPatches.length : 0);
         }
       }

      // ===== TIME-BASED QUILT ENGINE =====
      class TimeBasedQuiltEngine {
        constructor(logger, errorHandler) {
          this.logger = logger;
          this.errorHandler = errorHandler;
          this.colorAnalyzer = new ColorAnalyzer(logger);
          this.patternGenerator = new PatternGenerator(logger);
          this.transitionManager = new TransitionManager(logger);
          this.gridState = new GridState(logger);
          
          // Reorganization tracking
          this.colorsSinceReorganization = 0;
          this.reorganizationThreshold = 5;
          this.isReorganizing = false; // Prevent race conditions
          
          this.logger.log('TimeBasedQuiltEngine initialized');
        }

        // Load colors from Firebase data - ONLY called on page load
        loadQuiltData(colors) {
          this.logger.log(`🔄 INITIAL LOAD: Loading ${colors.length} colors from Firebase into fresh time-based engine`);
          
          // This should only be called once on page load, so we start fresh
          // Clear existing state and rebuild from Firebase data
          this.gridState = new GridState(this.logger);
          this.colorsSinceReorganization = 0;
          
          if (colors.length === 0) {
            this.logger.log(`📝 Starting with empty quilt - no colors in Firebase`);
            return;
          }
          
          // Add each color using proper collection phase logic
          colors.forEach((colorObj, index) => {
            this.logger.log(`🎨 Loading color ${index + 1}/${colors.length}: ${colorObj} (type: ${typeof colorObj})`);
            
            // Handle both string colors and color objects
            let colorString;
            if (typeof colorObj === 'string') {
              colorString = colorObj;
            } else if (typeof colorObj === 'object' && colorObj.color) {
              colorString = colorObj.color;
              this.logger.log(`🔄 Extracted color string from object: ${colorString}`);
            } else {
              this.logger.error(`❌ Invalid color format at index ${index}: ${colorObj} (type: ${typeof colorObj})`);
              return; // Skip this color
            }
            
            // Validate the extracted color string
            if (!colorString.startsWith('#')) {
              this.logger.error(`❌ Invalid color string at index ${index}: ${colorString}`);
              return; // Skip this color
            }
            
            // Use the same logic as collection phase for consistent positioning
            const position = this.gridState.getColorFamilyPosition(colorString);
            this.gridState.addColor(colorString, position);
            this.colorAnalyzer.analyzeColor(colorString);
          });
          
          this.logger.log(`✅ INITIAL LOAD COMPLETE: ${colors.length} colors loaded into engine`);
          this.logger.log(`🔍 Grid state now has ${this.gridState.getAllColors().length} colors`);
        }

        getCurrentPhase() {
          // ADMIN OVERRIDE: Check for manual phase override
          if (this.adminPhaseOverride) {
            return this.adminPhaseOverride;
          }
          
          // TIME-BASED LOGIC: Chicago time
          const now = new Date();
          const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          const hour = chicagoTime.getHours();
          
          // 12 AM - 12 PM (0-11): Collection phase
          if (hour >= 0 && hour < 12) {
            // Pre-analysis window: 11:55 AM - 12:00 PM
            if (hour === 11 && chicagoTime.getMinutes() >= 55) {
              this.preparePatternSelection();
            }
            return 'collection';
          }
          
          // 12:00 PM - 12:01 PM: Pattern selection phase (instant transition)
          if (hour === 12 && chicagoTime.getMinutes() === 0) {
            // Trigger pattern selection if not already done
            if (!this.patternGenerator.getCurrentPattern()) {
              this.triggerPatternSelection();
            }
            return 'pattern_selection';
          }
          
          // 12:01 PM - 11:59 PM (12-23): Pattern filling phase  
          if (hour >= 12 && hour <= 23) {
            return 'pattern_filling';
          }
          
          // Fallback (should never happen)
          return 'collection';
        }
        
                 // Helper method to check current time and phase
         getCurrentTimeAndPhase() {
           const now = new Date();
           const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
           const hour = chicagoTime.getHours();
           const phase = this.getCurrentPhase();
           
           return {
             currentTime: chicagoTime.toLocaleString("en-US", {timeZone: "America/Chicago"}),
             hour: hour,
             phase: phase,
             isCollection: hour >= 0 && hour < 12,
             isPatternFilling: hour >= 12 && hour <= 23
           };
         }
         
         // Helper method to force pattern selection if needed
         forcePatternSelectionIfNeeded() {
           const state = this.getState();
           const currentPhase = this.getCurrentPhase();
           
           if (currentPhase === 'pattern_filling' && !state.pattern) {
             this.logger.log('🔧 Forcing pattern selection for pattern filling phase...');
             
             // Analyze colors and select a pattern
             const colors = state.colors;
             if (colors.length >= 3) {
               const selectedPattern = this.patternGenerator.selectPattern(colors);
               this.patternGenerator.setCurrentPattern(selectedPattern);
               this.logger.log(`🎯 Pattern selected: ${selectedPattern}`);
               
               // Reorganize existing colors to the pattern
               this.transitionManager.reorganizeToPattern(colors, selectedPattern);
               
               return true;
             } else {
               this.logger.log('⚠️ Not enough colors for pattern selection (need 3+)');
               return false;
             }
           }
           return false;
         }

        setPhaseOverride(phase) {
          if (phase === '') {
            this.adminPhaseOverride = null;
            this.logger.log('🕐 Admin override cleared - using time-based phases');
          } else {
            this.adminPhaseOverride = phase;
            this.logger.log(`🎯 Admin override set to: ${phase}`);
          }
          
          // Re-render with new phase
          if (window.app && window.app.renderTimeBasedQuilt) {
            window.app.renderTimeBasedQuilt();
          }
        }

        preparePatternSelection() {
          if (!this.patternAnalysisStarted) {
            this.patternAnalysisStarted = true;
            this.logger.log('🔮 Pre-analyzing colors for noon transition...');
            
            // Reset flag at midnight for next day
            setTimeout(() => {
              this.patternAnalysisStarted = false;
            }, 300000); // 5 minutes
            
            // Analyze current colors and select pattern
            // This will be ready for instant switch at noon
            const colors = this.getState().colors;
            this.logger.log(`✅ Pattern analysis complete for ${colors.length} colors`);
            this.logger.log('⏰ Ready for instant noon transition!');
          }
        }

        addColor(color) {
          // Accept ALL submissions always (never reject user contributions)
          
          // Reject new colors during reorganization to prevent race conditions
          if (this.isReorganizing) {
            this.logger.log(`🔒 Rejecting color ${color} - reorganization in progress`);
            return { success: false, reason: 'reorganization_in_progress' };
          }
          
          const phase = this.getCurrentPhase();
          this.logger.log(`Adding color ${color} in ${phase} phase`);
          
          let result;
          switch (phase) {
            case 'collection':
              result = this.addColorInCollectionPhase(color);
              break;
            case 'pattern_selection':
              result = this.addColorInPatternPhase(color);
              break;
            case 'pattern_filling':
              result = this.addColorInFillingPhase(color);
              break;
            case 'finalization':
              result = this.addColorInFinalizationPhase(color);
              break;
          }
          
          // Check if reorganization is needed (but NOT during collection phase)
          if (result.success) {
            this.colorsSinceReorganization++;
            const currentPhase = this.getCurrentPhase();
            
            if (currentPhase === 'collection') {
              this.logger.log(`🧵 Collection phase: keeping loose columns (${this.colorsSinceReorganization} colors added)`);
            } else if (this.colorsSinceReorganization >= this.reorganizationThreshold) {
              this.reorganizeQuilt();
              this.colorsSinceReorganization = 0;
            }
          }
          
          return result;
        }

        addColorInCollectionPhase(color) {
          // Place colors in quilter's workspace columns by color family
          const position = this.gridState.getNextScatterPosition(color);
          this.gridState.addColor(color, position);
          this.colorAnalyzer.analyzeColor(color);
          
          // Collection phase: Just collect and analyze - NO pattern selection yet!
          // Pattern selection will happen when phase transitions to 'pattern_selection'
          
          return { success: true, phase: 'collection', position };
        }

        addColorInPatternPhase(color) {
          // If pattern is already selected, process this color immediately (no queuing needed)
          if (this.patternGenerator.getCurrentPattern()) {
            const occupiedPositions = this.gridState.getOccupiedPositions();
            const position = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
            this.gridState.addColor(color, position);
            this.colorAnalyzer.analyzeColor(color); // Still analyze for ongoing insights
            return { success: true, phase: 'pattern_selection', position: position };
          }
          
          // No pattern yet - add to queue and continue analysis
          this.gridState.addColorToQueue(color);
          this.colorAnalyzer.analyzeColor(color);
          
          // Check if we should select pattern now
          if (this.colorAnalyzer.hasEnoughDataForPattern()) {
            this.triggerPatternSelection();
            // triggerPatternSelection() already processed ALL queued colors (including this one)
            // So we're done - don't process this color again
            return { success: true, phase: 'pattern_selection', processed_in_batch: true };
          }
          
          return { success: true, phase: 'pattern_selection', queued: true };
        }

        addColorInFillingPhase(color) {
          // Pattern is chosen, place optimally
          const occupiedPositions = this.gridState.getOccupiedPositions();
          const optimalPosition = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
          this.gridState.addColor(color, optimalPosition);
          return { success: true, phase: 'pattern_filling', position: optimalPosition };
        }

        addColorInFinalizationPhase(color) {
          // Accept colors throughout the night - no limit
          const occupiedPositions = this.gridState.getOccupiedPositions();
          const position = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
          this.gridState.addColor(color, position);
          return { success: true, phase: 'finalization', position };
        }

        triggerPatternSelection() {
          this.logger.log('Triggering pattern selection...');
          const analysis = this.colorAnalyzer.getAnalysis();
          const selectedPattern = this.patternGenerator.selectPattern(analysis);
          
          this.logger.log(`Selected pattern: ${selectedPattern}`);
          
          // Process any queued colors with the new pattern
          const queuedColors = this.gridState.getQueuedColors();
          this.logger.log(`Processing ${queuedColors.length} queued colors into ${selectedPattern} pattern`);
          
          queuedColors.forEach((color, index) => {
            const position = this.patternGenerator.getOptimalPosition(color);
            this.gridState.addColor(color, position);
            this.logger.log(`Placed queued color ${index + 1}/${queuedColors.length}: ${color} at position (${position.x}, ${position.y})`);
          });
          this.gridState.clearQueue();
          
          this.logger.log(`Pattern selection complete: ${this.gridState.getAllColors().length} colors now placed`);
          
          // Reorganize existing colors into pattern
          this.transitionManager.reorganizeToPattern(
            this.gridState.getAllColors(), 
            selectedPattern
          );
        }

        getState() {
          return {
            phase: this.getCurrentPhase(),
            colors: this.gridState.getAllColors(),
            queuedColors: this.gridState.getQueuedColors(),
            pattern: this.patternGenerator.getCurrentPattern(),
            analysis: this.colorAnalyzer.getAnalysis()
          };
        }
        
        reorganizeQuilt() {
          this.logger.log('🔄 Reorganizing quilt for optimal compactness...');
          
          // Set reorganization lock to prevent race conditions
          this.isReorganizing = true;
          this.logger.log('🔒 Reorganization lock ACQUIRED');
          
          // Get all current colors - PRESERVE EVERY SINGLE ONE
          const allColors = this.gridState.getAllColors();
          const queuedColors = this.gridState.getQueuedColors();
          const totalColors = [...allColors.map(c => c.color), ...queuedColors];
          
          // Keep ALL colors including duplicates - admin wants duplicate colors!
          if (totalColors.length === 0) {
            // Release lock even if no colors to reorganize
            this.isReorganizing = false;
            this.logger.log('🔓 Reorganization lock RELEASED (no colors)');
            return;
          }
          
          try {
            const originalCount = totalColors.length;
            this.logger.log(`📊 BEFORE: ${originalCount} total colors to reorganize (including duplicates)`);
            this.logger.log(`📊 Colors: [${totalColors.join(', ')}]`);
            
            // Clear current state
            this.gridState.clearAll();
            
            // Reset pattern and give it the FULL color set (including duplicates)
            this.patternGenerator.resetPatternWithColors(totalColors);
            
            // Re-add ALL colors (including duplicates) with proper position calculation
            this.logger.log(`🔄 Re-adding ${totalColors.length} total colors with atomic reorganization...`);
            totalColors.forEach((color, index) => {
              const occupiedPositions = this.gridState.getOccupiedPositions();
              const position = this.patternGenerator.getOptimalPosition(color, occupiedPositions);
              this.gridState.addColor(color, position);
            });
            
            // SAFETY CHECK: Verify no colors were lost
            const finalColors = this.gridState.getAllColors();
            const finalCount = finalColors.length;
            
            if (finalCount !== originalCount) {
              this.logger.error(`🚨 COLOR LOSS DETECTED! Original: ${originalCount}, Final: ${finalCount}`);
              throw new Error('Color preservation failed during reorganization!');
            }
            
            this.logger.log(`✅ AFTER: ${finalCount} colors preserved - NO LOSSES!`);
            this.logger.log(`✨ Reorganized into compact formation - all contributions safe`);
          } catch (error) {
            this.logger.error('🚨 Reorganization failed:', error);
            throw error;
          } finally {
            // ALWAYS release reorganization lock, even if there's an error
            this.isReorganizing = false;
            this.logger.log('🔓 Reorganization lock RELEASED');
          }
        }
      }

      // ===== COLOR ANALYZER =====
      class ColorAnalyzer {
        constructor(logger) {
          this.logger = logger;
          this.colors = [];
          this.analysis = {
            hueDistribution: new Map(),
            saturationRange: { min: 100, max: 0 },
            lightnessRange: { min: 100, max: 0 },
            dominantTheme: null,
            hasContrasts: false,
            isMonochromatic: false
          };
        }

        analyzeColor(hexColor) {
          this.colors.push(hexColor);
          const hsl = this.hexToHsl(hexColor);
          
          // Update hue distribution
          const hueGroup = Math.floor(hsl.h / 30) * 30; // Group into 30-degree segments
          this.analysis.hueDistribution.set(hueGroup, 
            (this.analysis.hueDistribution.get(hueGroup) || 0) + 1
          );

          // Update ranges
          this.analysis.saturationRange.min = Math.min(this.analysis.saturationRange.min, hsl.s);
          this.analysis.saturationRange.max = Math.max(this.analysis.saturationRange.max, hsl.s);
          this.analysis.lightnessRange.min = Math.min(this.analysis.lightnessRange.min, hsl.l);
          this.analysis.lightnessRange.max = Math.max(this.analysis.lightnessRange.max, hsl.l);

          this.updateThemeAnalysis();
        }

        updateThemeAnalysis() {
          const hueGroups = Array.from(this.analysis.hueDistribution.keys());
          
          // Check if monochromatic (within 60 degrees)
          if (hueGroups.length <= 2) {
            this.analysis.isMonochromatic = true;
            this.analysis.dominantTheme = 'monochromatic';
          }
          
          // Check for warm/cool split
          const warmHues = hueGroups.filter(h => h >= 300 || h <= 60);
          const coolHues = hueGroups.filter(h => h > 60 && h < 300);
          
          if (warmHues.length > 0 && coolHues.length > 0) {
            this.analysis.dominantTheme = 'warm_cool_split';
          }

          // Check for high contrast
          const lightnessSpread = this.analysis.lightnessRange.max - this.analysis.lightnessRange.min;
          this.analysis.hasContrasts = lightnessSpread > 40;
        }

        hasEnoughDataForPattern() {
          // Need at least 3 colors for testing (was 8) or noon deadline
          const hour = new Date().getHours();
          return this.colors.length >= 3 || hour >= 12;
        }

        getAnalysis() {
          return { ...this.analysis };
        }

        hexToHsl(hex) {
          // Convert hex to HSL (simplified version)
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return { h: h * 360, s: s * 100, l: l * 100 };
        }
      }

      // ===== PATTERN GENERATOR =====
      class PatternGenerator {
        constructor(logger) {
          this.logger = logger;
          this.currentPattern = null;
          this.patternTemplates = {
            'spiral': new SpiralPattern(),
            'gradient_flow': new GradientPattern(),
            'radial': new RadialPattern(),
            'warm_cool_split': new SplitPattern(),
            'checkerboard': new CheckerboardPattern()
          };
        }

        selectPattern(analysis) {
          let selectedPattern;

          if (analysis.isMonochromatic) {
            selectedPattern = 'gradient_flow';
          } else if (analysis.dominantTheme === 'warm_cool_split') {
            selectedPattern = 'warm_cool_split';
          } else if (analysis.hasContrasts) {
            selectedPattern = 'checkerboard';
          } else if (analysis.hueDistribution && analysis.hueDistribution.size > 4) {
            selectedPattern = 'spiral';
          } else {
            selectedPattern = 'radial';
          }

          this.currentPattern = selectedPattern;
          this.logger.log(`Pattern selected: ${selectedPattern} based on analysis`);
          return selectedPattern;
        }

        getOptimalPosition(color, occupiedPositions = new Set()) {
          if (!this.currentPattern) {
            // Auto-select a default pattern if none is chosen yet
            this.currentPattern = 'gradient_flow';
            this.logger.log(`🎯 Auto-selected gradient_flow pattern (no pattern was set)`);
          }
          return this.patternTemplates[this.currentPattern].getNextPosition(color, occupiedPositions);
        }

        canAcceptColor(color) {
          if (!this.currentPattern) return false;
          return this.patternTemplates[this.currentPattern].canAcceptMore();
        }

        getFinalizationPosition(color) {
          return this.patternTemplates[this.currentPattern].getAccentPosition(color);
        }

        getCurrentPattern() {
          return this.currentPattern;
        }
        
        resetPattern() {
          if (this.currentPattern) {
            // Create fresh instance of current pattern
            const PatternClass = this.patternTemplates[this.currentPattern].constructor;
            this.patternTemplates[this.currentPattern] = new PatternClass();
            this.logger.log(`Reset ${this.currentPattern} pattern for reorganization`);
          }
        }
        
        resetPatternWithColors(allColors) {
          if (this.currentPattern) {
            // Create fresh instance and pre-populate with all colors
            const PatternClass = this.patternTemplates[this.currentPattern].constructor;
            this.patternTemplates[this.currentPattern] = new PatternClass();
            this.patternTemplates[this.currentPattern].initializeWithColors(allColors);
            this.logger.log(`Reset ${this.currentPattern} pattern with ${allColors.length} colors for reorganization`);
          }
        }
      }

      // ===== GRID STATE =====
      class GridState {
        constructor(logger) {
          this.logger = logger;
          this.grid = new Map(); // position -> color
          this.colorQueue = [];
          this.maxSize = { width: 20, height: 20 };
          this.currentSize = { width: 1, height: 1 };
          
          // Collection phase: quilter's workspace with color family columns
          this.colorColumns = new Map(); // hue range -> column info
          this.columnSpacing = 0.8; // BALANCED - proper spacing between columns while keeping blocks big
          this.nextColumnX = 0; // Track where to place next new column
        }

        addColor(color, position) {
          const key = `${position.x},${position.y}`;
          
          // Check for position collisions (warn but allow)
          if (this.grid.has(key)) {
            const existing = this.grid.get(key);
            this.logger.log(`⚠️ Position collision at (${position.x}, ${position.y}): replacing ${existing.color} with ${color}`);
          }
          
          this.grid.set(key, { color, position, timestamp: Date.now() });
          this.expandIfNeeded(position);
        }

        addColorToQueue(color) {
          this.colorQueue.push(color);
        }

        getQueuedColors() {
          return [...this.colorQueue];
        }

        clearQueue() {
          this.colorQueue = [];
        }

        getNextScatterPosition(color = null) {
          if (!color) {
            // Fallback for when no color is provided
            const x = Math.floor(Math.random() * this.currentSize.width);
            const y = Math.floor(Math.random() * this.currentSize.height);
            return { x, y };
          }
          
          // Quilter's workspace: stack colors in family columns
          return this.getColorFamilyPosition(color);
        }
        
        getColorFamilyPosition(color) {
          const hue = this.getColorHue(color);
          const saturation = this.getColorSaturation(color);
          
          // Override to neutrals if saturation is very low (grays, whites, blacks)
          let colorFamily;
          if (saturation < 15) { // Less than 15% saturation = neutral
            colorFamily = 'neutrals';
          } else {
            colorFamily = this.getColorFamily(hue);
          }
          
          // Find or create column for this color family
          let column = this.colorColumns.get(colorFamily);
          
          if (!column) {
            // Create new column for this color family
            column = {
              family: colorFamily,
              x: this.nextColumnX,
              colors: [],
              stackHeight: 0
            };
            this.colorColumns.set(colorFamily, column);
            this.nextColumnX += this.columnSpacing;
            this.logger.log(`🎨 Created new color family column: ${colorFamily} at x=${column.x}`);
          }
          
          // Add color to this column's stack
          const stackPosition = column.colors.length;
          
          // Create gentle organic stacking with slight offsets (reduced for tight columns)
          const offsetX = (Math.random() - 0.5) * 0.3; // Minimal horizontal jitter for tight spacing
          const offsetY = (Math.random() - 0.5) * 0.3; // Minimal vertical jitter
          
          // Adaptive overlap: more overlap as columns get longer (mobile-friendly)
          const totalInColumn = column.colors.length + 1; // Including the one we're adding
          let overlapFactor;
          
          if (totalInColumn <= 3) {
            overlapFactor = 0.75; // 75% overlap - gentle stacking for short columns
          } else if (totalInColumn <= 6) {
            overlapFactor = 0.6; // 60% overlap - more compression for medium columns
          } else if (totalInColumn <= 10) {
            overlapFactor = 0.45; // 45% overlap - significant compression for mobile
          } else if (totalInColumn <= 15) {
            overlapFactor = 0.3; // 30% overlap - heavy compression for tall columns
          } else {
            overlapFactor = 0.2; // 20% overlap - maximum compression for very tall mobile columns
          }
          
          // Calculate position relative to previous block to avoid gaps
          let yPosition;
          if (stackPosition === 0) {
            // First block in column
            yPosition = 0 + offsetY;
          } else {
            // Position relative to previous block's actual position
            const previousBlock = column.colors[stackPosition - 1];
            const spacing = 1 - overlapFactor; // How much space between blocks
            yPosition = previousBlock.position.y + spacing + offsetY;
          }
          
          const position = {
            x: column.x + offsetX,
            y: yPosition,
            stackLevel: stackPosition,
            colorFamily: colorFamily,
            isStacked: true,
            overlapFactor: overlapFactor // Store for debugging
          };
          
          column.colors.push({ color, position });
          column.stackHeight = Math.max(column.stackHeight, position.y + 1);
          
          this.logger.log(`📚 Stacked ${color} in ${colorFamily} column (level ${stackPosition}, ${Math.round(overlapFactor * 100)}% overlap, y=${yPosition.toFixed(1)}) - continuous stacking`);
          
          if (totalInColumn > 6) {
            this.logger.log(`📱 Mobile optimization: High overlap (${Math.round(overlapFactor * 100)}%) for tall ${colorFamily} column (${totalInColumn} blocks)`);
          }
          
          return position;
        }
        
        getColorHue(hexColor) {
          // Debug: Check what we're receiving
          if (typeof hexColor !== 'string') {
            this.logger.error(`❌ getColorHue received non-string: ${typeof hexColor} - ${JSON.stringify(hexColor)}`);
            return 0; // Default hue
          }
          
          if (!hexColor.startsWith('#')) {
            this.logger.error(`❌ getColorHue received non-hex color: ${hexColor}`);
            return 0; // Default hue
          }
          
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;

          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return h * 360; // Convert to degrees
        }
        
        getColorSaturation(hexColor) {
          // Convert hex to RGB
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;
          
          // Calculate saturation
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const delta = max - min;
          
          if (max === 0) return 0; // Black
          return (delta / max) * 100; // Return as percentage
        }
        
        getColorFamily(hue) {
          // First check if this is a neutral color (low saturation)
          // Note: This function only gets hue, so we need to check saturation in getColorFamilyPosition
          
          // Define color families based on hue ranges
          if (hue >= 345 || hue < 15) return 'reds';
          if (hue >= 15 && hue < 45) return 'oranges';
          if (hue >= 45 && hue < 75) return 'yellows';
          if (hue >= 75 && hue < 165) return 'greens';
          if (hue >= 165 && hue < 255) return 'blues';
          if (hue >= 255 && hue < 285) return 'purples';
          if (hue >= 285 && hue < 345) return 'magentas';
          return 'neutrals'; // Fallback for edge cases
        }

        getAllColors() {
          return Array.from(this.grid.values());
        }

        getOccupiedPositions() {
          return new Set(this.grid.keys());
        }

        expandIfNeeded(position) {
          this.currentSize.width = Math.max(this.currentSize.width, position.x + 2);
          this.currentSize.height = Math.max(this.currentSize.height, position.y + 2);
        }
        
        clearAll() {
          this.grid.clear();
          this.colorQueue = [];
          this.currentSize = { width: 1, height: 1 };
          
          // Reset collection phase workspace
          this.colorColumns.clear();
          this.nextColumnX = 0;
        }
      }

      // ===== TRANSITION MANAGER =====
      class TransitionManager {
        constructor(logger) {
          this.logger = logger;
        }

        reorganizeToPattern(colors, patternName) {
          this.logger.log(`Reorganizing ${colors.length} colors to ${patternName} pattern`);
          // TODO: Implement smooth transitions between scattered and organized layouts
          // This will involve CSS animations and position calculations
        }
      }

      // ===== PATTERN TEMPLATES =====
      class SpiralPattern {
        constructor() {
          this.center = { x: 10, y: 10 };
          this.currentRadius = 1;
          this.currentAngle = 0;
          this.positionsUsed = 0;
        }

        initializeWithColors(allColors) {
          // Simple initialization for spiral - positions are calculated sequentially
          this.positionsUsed = 0;
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          // Spiral pattern is inherently sequential, works for both modes
          const angle = this.currentAngle;
          const x = this.center.x + Math.round(this.currentRadius * Math.cos(angle));
          const y = this.center.y + Math.round(this.currentRadius * Math.sin(angle));
          
          this.currentAngle += 0.5; // Spiral outward
          if (this.currentAngle > Math.PI * 2) {
            this.currentAngle = 0;
            this.currentRadius += 1;
          }
          
          this.positionsUsed++;
          return { x, y };
        }

        canAcceptMore() {
          return this.positionsUsed < 100; // Arbitrary limit
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }
      }

      class GradientPattern {
        constructor() {
          this.placedColors = [];
          this.sortedColors = [];
          this.totalExpectedColors = 0;
        }

        initializeWithColors(allColors) {
          // Pre-sort ALL colors by hue for proper organization
          this.sortedColors = this.sortColorsByHue([...allColors]);
          this.totalExpectedColors = allColors.length;
          this.placedColors = []; // Track which we've placed so far
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          // Add this color to placed list
          this.placedColors.push(color);
          
          console.log(`🎨 GradientPattern.getNextPosition(${color})`);
          console.log(`- placedColors now: ${this.placedColors.length} [${this.placedColors.join(', ')}]`);
          console.log(`- sortedColors: ${this.sortedColors.length} [${this.sortedColors.join(', ')}]`);
          console.log(`- totalExpectedColors: ${this.totalExpectedColors}`);
          console.log(`- occupiedPositions: [${Array.from(occupiedPositions).join('], [')}]`);
          
          // If this is a reorganization (pattern was pre-initialized)
          if (this.sortedColors.length > 0 && this.totalExpectedColors > 0) {
            console.log(`📐 Using reorganization mode`);
            // Find where this color should go in the pre-sorted order
            const colorIndex = this.sortedColors.findIndex(c => c === color);
            console.log(`- colorIndex in sorted array: ${colorIndex}`);
            
            // If color not found in sorted array, it's a new color added after reorganization
            if (colorIndex === -1) {
              console.log(`➕ Adding new color to sorted array for smart placement`);
              // Add the new color to sortedColors in the right position (by hue)
              const newColorHue = this.getHue(color);
              let insertIndex = this.sortedColors.length;
              for (let i = 0; i < this.sortedColors.length; i++) {
                const existingHue = this.getHue(this.sortedColors[i]);
                if (newColorHue < existingHue) {
                  insertIndex = i;
                  break;
                }
              }
              this.sortedColors.splice(insertIndex, 0, color);
              this.totalExpectedColors++;
              console.log(`- inserted at index ${insertIndex}, new total: ${this.totalExpectedColors}`);
              
              // Find the next available position using actual occupied positions
              const gridSize = Math.ceil(Math.sqrt(this.totalExpectedColors));
              console.log(`- smart placement: finding available position in ${gridSize}x${gridSize} grid`);
              
              // Find first available position in the new grid
              for (let i = 0; i < gridSize * gridSize; i++) {
                const x = i % gridSize;
                const y = Math.floor(i / gridSize);
                const posKey = `${x},${y}`;
                
                if (!occupiedPositions.has(posKey)) {
                  console.log(`- found available position: (${x}, ${y})`);
                  return { x, y };
                }
              }
              
              // Fallback: expand grid if all positions filled
              console.log(`- fallback: expanding to (${gridSize}, 0)`);
              return { x: gridSize, y: 0 };
            }
            
            // Calculate grid size based on TOTAL expected colors
            const gridSize = Math.ceil(Math.sqrt(this.totalExpectedColors));
            
            // Calculate position based on sorted index in the complete grid
            const x = colorIndex % gridSize;
            const y = Math.floor(colorIndex / gridSize);
            
            console.log(`- reorganization: colorIndex=${colorIndex}, grid=${gridSize} → (${x}, ${y})`);
            console.log(`- checking if position (${x},${y}) is occupied: ${occupiedPositions.has(`${x},${y}`)}`);
            
            // During reorganization, positions SHOULD be deterministic and collision-free
            // But if there's a collision, find the next available position
            if (occupiedPositions.has(`${x},${y}`)) {
              console.warn(`⚠️ REORGANIZATION COLLISION: Position (${x},${y}) occupied, finding alternative...`);
              
              // Find the next available position in the grid
              const maxPositions = gridSize * gridSize * 2; // Prevent infinite loop
              for (let offset = 1; offset < maxPositions; offset++) {
                const altIndex = colorIndex + offset;
                const altX = altIndex % gridSize;
                const altY = Math.floor(altIndex / gridSize);
                const altKey = `${altX},${altY}`;
                
                if (!occupiedPositions.has(altKey)) {
                  console.log(`✅ Found alternative position: (${altX}, ${altY}) for color ${color}`);
                  return { x: altX, y: altY };
                }
              }
              
              // If we still can't find a spot, expand the grid
              console.log(`🔄 No space in ${gridSize}x${gridSize} grid, expanding...`);
              return { x: gridSize, y: 0 };
            }
            
            return { x, y };
          } else {
            console.log(`📍 Using sequential mode`);
            // For normal operation, place sequentially to avoid collisions
            // Reorganization will sort them later
            const colorCount = this.placedColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(colorCount)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, colorCount - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            console.log(`- sequential: count=${colorCount}, grid=${gridSize}, index=${index} → (${x}, ${y})`);
            return { x, y };
          }
        }

        sortColorsByHue(colors) {
          return colors.sort((a, b) => {
            const hueA = this.getHue(a);
            const hueB = this.getHue(b);
            return hueA - hueB;
          });
        }

        getHue(hexColor) {
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;

          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return h * 360; // Return hue in degrees
        }

        canAcceptMore() {
          return true; // No limit - expand as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }

        // When we need to reposition all colors (for transitions)
        repositionAllColors() {
          const sortedColors = this.sortColorsByHue([...this.placedColors]);
          const positions = [];
          
          sortedColors.forEach((color, index) => {
            const x = index % this.gridWidth;
            const y = Math.floor(index / this.gridWidth);
            positions.push({ color, position: { x, y } });
          });
          
          return positions;
        }
      }

      class RadialPattern {
        constructor() {
          this.center = { x: 8, y: 6 };
          this.placedColors = [];
          this.maxRadius = 6;
          this.sortedColors = [];
          this.totalExpectedColors = 0;
        }

        initializeWithColors(allColors) {
          this.sortedColors = this.sortColorsByVibrancy([...allColors]);
          this.totalExpectedColors = allColors.length;
          this.placedColors = [];
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          this.placedColors.push(color);
          
          // If this is a reorganization (pattern was pre-initialized)
          if (this.sortedColors.length > 0 && this.totalExpectedColors > 0) {
            const colorIndex = this.sortedColors.findIndex(c => c === color);
            
            if (colorIndex === 0) {
              // Most vibrant color goes in center
              return this.center;
            }
            
            // Calculate ring and position on ring based on vibrancy ranking
            const ringIndex = Math.ceil(Math.sqrt(colorIndex));
            const colorsInThisRing = this.getColorsInRing(this.sortedColors, ringIndex);
            const positionInRing = colorsInThisRing.findIndex(c => c === color);
            
            // Calculate angle based on position in ring
            const colorsOnRing = Math.max(6, ringIndex * 6); // More positions on outer rings
            const angle = (2 * Math.PI * positionInRing) / colorsOnRing;
            
            const x = this.center.x + Math.round(ringIndex * Math.cos(angle));
            const y = this.center.y + Math.round(ringIndex * Math.sin(angle));
            
            // Check for collision and find alternative if needed
            const posKey = `${x},${y}`;
            if (occupiedPositions.has(posKey)) {
              console.warn(`⚠️ RADIAL COLLISION: Position (${x},${y}) occupied, finding alternative...`);
              
              // Try nearby positions in expanding spiral
              for (let radius = 1; radius <= 10; radius++) {
                for (let angleOffset = 0; angleOffset < 2 * Math.PI; angleOffset += Math.PI / 4) {
                  const altX = Math.max(0, Math.round(x + radius * Math.cos(angleOffset))); // Prevent negative
                  const altY = Math.max(0, Math.round(y + radius * Math.sin(angleOffset))); // Prevent negative
                  const altKey = `${altX},${altY}`;
                  
                  if (!occupiedPositions.has(altKey)) {
                    console.log(`✅ Found alternative radial position: (${altX}, ${altY}) for color ${color}`);
                    return { x: altX, y: altY };
                  }
                }
              }
              
              // Ultimate fallback: extend outward (but keep reasonable bounds)
              console.log(`🔄 No nearby space, extending outward...`);
              const fallbackX = Math.max(0, Math.min(x + 10, 50)); // Keep within reasonable bounds
              const fallbackY = Math.max(0, Math.min(y, 50));
              return { x: fallbackX, y: fallbackY };
            }
            
            return { x, y };
          } else {
            // For normal operation, place sequentially to avoid collisions
            const colorCount = this.placedColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(colorCount)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, colorCount - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            return { x, y };
          }
        }

        sortColorsByVibrancy(colors) {
          return colors.sort((a, b) => {
            const vibrancyA = this.getVibrancy(a);
            const vibrancyB = this.getVibrancy(b);
            return vibrancyB - vibrancyA; // Most vibrant first
          });
        }

        getVibrancy(hexColor) {
          const r = parseInt(hexColor.slice(1, 3), 16) / 255;
          const g = parseInt(hexColor.slice(3, 5), 16) / 255;
          const b = parseInt(hexColor.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const saturation = max === 0 ? 0 : (max - min) / max;
          const brightness = max;
          
          // Combine saturation and brightness for vibrancy
          return saturation * 0.7 + brightness * 0.3;
        }

        getColorsInRing(sortedColors, ringIndex) {
          const startIndex = ringIndex === 1 ? 1 : Math.pow(ringIndex - 1, 2);
          const endIndex = Math.pow(ringIndex, 2);
          return sortedColors.slice(startIndex, endIndex + 1);
        }

        canAcceptMore() {
          return true; // No limit - expand rings as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }
      }

      class SplitPattern {
        constructor() {
          this.warmColors = [];
          this.coolColors = [];
          this.gridWidth = 8;
          this.gridHeight = 10;
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          const hsl = this.hexToHsl(color);
          const isWarm = this.isWarmColor(hsl);
          
          // Add to appropriate list
          if (isWarm) {
            this.warmColors.push(color);
          } else {
            this.coolColors.push(color);
          }
          
          // For normal operation, place sequentially to avoid collisions
          if (this.sortedWarmColors.length === 0 && this.sortedCoolColors.length === 0) {
            const totalPlaced = this.warmColors.length + this.coolColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(totalPlaced)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, totalPlaced - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            return { x, y };
          } else {
            // Reorganization mode - use proper warm/cool split pattern
            if (isWarm) {
              const colorIndex = this.sortedWarmColors.findIndex(c => c === color);
              const warmGridSize = Math.ceil(Math.sqrt(this.sortedWarmColors.length));
              const x = colorIndex % warmGridSize;
              const y = Math.floor(colorIndex / warmGridSize);
              
              // Check for collision and find alternative if needed
              const posKey = `${x},${y}`;
              if (occupiedPositions.has(posKey)) {
                console.warn(`⚠️ WARM SPLIT COLLISION: Position (${x},${y}) occupied, finding alternative...`);
                
                // Find next available position in warm side
                for (let offset = 1; offset < warmGridSize * warmGridSize; offset++) {
                  const altIndex = colorIndex + offset;
                  const altX = altIndex % warmGridSize;
                  const altY = Math.floor(altIndex / warmGridSize);
                  const altKey = `${altX},${altY}`;
                  
                  if (!occupiedPositions.has(altKey)) {
                    console.log(`✅ Found alternative warm position: (${altX}, ${altY}) for color ${color}`);
                    return { x: altX, y: altY };
                  }
                }
                
                // Fallback: expand warm grid
                console.log(`🔄 Expanding warm grid for color ${color}`);
                return { x: warmGridSize, y: 0 };
              }
              
              return { x, y }; // Left side
            } else {
              const colorIndex = this.sortedCoolColors.findIndex(c => c === color);
              const coolGridSize = Math.ceil(Math.sqrt(this.sortedCoolColors.length));
              const totalGridSize = Math.max(Math.ceil(Math.sqrt(this.sortedWarmColors.length)), coolGridSize);
              
              const x = (colorIndex % coolGridSize) + totalGridSize + 1; // Right side with gap
              const y = Math.floor(colorIndex / coolGridSize);
              
              // Check for collision and find alternative if needed
              const posKey = `${x},${y}`;
              if (occupiedPositions.has(posKey)) {
                console.warn(`⚠️ COOL SPLIT COLLISION: Position (${x},${y}) occupied, finding alternative...`);
                
                // Find next available position in cool side
                for (let offset = 1; offset < coolGridSize * coolGridSize; offset++) {
                  const altIndex = colorIndex + offset;
                  const altX = (altIndex % coolGridSize) + totalGridSize + 1;
                  const altY = Math.floor(altIndex / coolGridSize);
                  const altKey = `${altX},${altY}`;
                  
                  if (!occupiedPositions.has(altKey)) {
                    console.log(`✅ Found alternative cool position: (${altX}, ${altY}) for color ${color}`);
                    return { x: altX, y: altY };
                  }
                }
                
                // Fallback: expand cool grid
                console.log(`🔄 Expanding cool grid for color ${color}`);
                return { x: totalGridSize + coolGridSize + 1, y: 0 };
              }
              
              return { x, y };
            }
          }
        }

        isWarmColor(hsl) {
          // More nuanced warm/cool detection
          if (hsl.h >= 315 || hsl.h <= 45) return true; // Reds, oranges
          if (hsl.h >= 45 && hsl.h <= 90) return true; // Yellows
          return false; // Blues, greens, purples are cool
        }

        sortWarmColors(colors) {
          return colors.sort((a, b) => {
            const hueA = this.hexToHsl(a).h;
            const hueB = this.hexToHsl(b).h;
            
            // Sort reds → oranges → yellows
            const warmOrderA = hueA <= 45 ? hueA + 360 : hueA; // Put reds at end
            const warmOrderB = hueB <= 45 ? hueB + 360 : hueB;
            
            return warmOrderA - warmOrderB;
          });
        }

        sortCoolColors(colors) {
          return colors.sort((a, b) => {
            const hueA = this.hexToHsl(a).h;
            const hueB = this.hexToHsl(b).h;
            
            // Sort greens → blues → purples
            return hueA - hueB;
          });
        }

        initializeWithColors(allColors) {
          // Basic initialization - split patterns handle colors as they come
          this.warmColors = [];
          this.coolColors = [];
        }

        canAcceptMore() {
          return true; // No limit - expand sides as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }

        hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h = 0;
          
          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          
          return { h: h * 360 };
        }
      }

      class CheckerboardPattern {
        constructor() {
          this.lightColors = [];
          this.darkColors = [];
          this.gridWidth = 16;
          this.gridHeight = 10;
          this.placed = new Set(); // Track which positions are filled
        }

        getNextPosition(color, occupiedPositions = new Set()) {
          const hsl = this.hexToHsl(color);
          const isColorDark = hsl.l < 50;
          
          // Add to appropriate list
          if (isColorDark) {
            this.darkColors.push(color);
          } else {
            this.lightColors.push(color);
          }
          
          // For normal operation, place sequentially to avoid collisions
          if ((!this.sortedLightColors || this.sortedLightColors.length === 0) && 
              (!this.sortedDarkColors || this.sortedDarkColors.length === 0)) {
            const totalPlaced = this.lightColors.length + this.darkColors.length;
            const gridSize = Math.max(1, Math.ceil(Math.sqrt(totalPlaced)));
            
            // Ensure we never get negative positions
            const index = Math.max(0, totalPlaced - 1);
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            
            return { x, y };
          } else {
            // Reorganization mode - use proper checkerboard pattern
            if (isColorDark) {
              return this.findBestDarkPosition(occupiedPositions);
            } else {
              return this.findBestLightPosition(occupiedPositions);
            }
          }
        }

        findBestDarkPosition(occupiedPositions = new Set()) {
          // Calculate dynamic grid size based on total colors
          const totalColors = this.lightColors.length + this.darkColors.length;
          const gridSize = Math.ceil(Math.sqrt(totalColors));
          
          // Find next available dark square (even sum of coordinates)
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const posKey = `${x},${y}`;
              const shouldBeDark = (x + y) % 2 === 0;
              
              if (shouldBeDark && !this.placed.has(posKey) && !occupiedPositions.has(posKey)) {
                this.placed.add(posKey);
                return { x, y };
              }
            }
          }
          
          // Fallback: find any available position
          return this.findAnyAvailablePosition(occupiedPositions);
        }

        findBestLightPosition(occupiedPositions = new Set()) {
          // Calculate dynamic grid size based on total colors
          const totalColors = this.lightColors.length + this.darkColors.length;
          const gridSize = Math.ceil(Math.sqrt(totalColors));
          
          // Find next available light square (odd sum of coordinates)
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const posKey = `${x},${y}`;
              const shouldBeLight = (x + y) % 2 === 1;
              
              if (shouldBeLight && !this.placed.has(posKey) && !occupiedPositions.has(posKey)) {
                this.placed.add(posKey);
                return { x, y };
              }
            }
          }
          
          // Fallback: find any available position
          return this.findAnyAvailablePosition(occupiedPositions);
        }

        findAnyAvailablePosition(occupiedPositions = new Set()) {
          const totalColors = this.lightColors.length + this.darkColors.length;
          const gridSize = Math.ceil(Math.sqrt(totalColors));
          
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const posKey = `${x},${y}`;
              if (!this.placed.has(posKey) && !occupiedPositions.has(posKey)) {
                this.placed.add(posKey);
                return { x, y };
              }
            }
          }
          
          // Expand grid if needed
          const expandedSize = gridSize + 1;
          const posKey = `0,${gridSize}`;
          this.placed.add(posKey);
          return { x: 0, y: gridSize };
        }

        initializeWithColors(allColors) {
          // Basic initialization for checkerboard
          this.lightColors = [];
          this.darkColors = [];
          this.placed = new Set();
        }

        canAcceptMore() {
          return true; // No limit - expand checkerboard as needed
        }

        getAccentPosition(color) {
          return this.getNextPosition(color);
        }

        hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          
          return { h: h * 360, s: s * 100, l: l * 100 };
        }
      }

      // ===== TESTING FUNCTIONS =====
      // Expose multiple test functions to global scope for debugging
      globalThis.testBasicClasses = function() {
        console.log('🧪 Testing basic class availability...');
        
        try {
          console.log('Logger available:', typeof Logger);
          console.log('ErrorHandler available:', typeof ErrorHandler);
          console.log('TimeBasedQuiltEngine available:', typeof TimeBasedQuiltEngine);
          console.log('ColorAnalyzer available:', typeof ColorAnalyzer);
          console.log('PatternGenerator available:', typeof PatternGenerator);
          return '✅ All classes available';
        } catch (error) {
          console.error('❌ Error testing classes:', error);
          return '❌ Class test failed';
        }
      };

      globalThis.testTimeBasedEngine = function() {
        console.log('🧪 Testing TimeBasedQuiltEngine...');
        
        try {
          const logger = new Logger(true);
          const errorHandler = new ErrorHandler(null, logger);
          const engine = new TimeBasedQuiltEngine(logger, errorHandler);
          
          console.log('✅ Engine created successfully');
          
          // Test color analysis
          const testColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
          
          console.log('📊 Testing color analysis...');
          testColors.forEach((color, i) => {
            const result = engine.addColor(color);
            console.log(`Color ${i + 1} (${color}): ${result.phase} phase, position:`, result.position);
          });
          
          // Test pattern selection
          console.log('🎨 Testing pattern selection...');
          const state = engine.getState();
          console.log('Engine state:', state);
          console.log('Pattern selected:', state.pattern);
          console.log('Color analysis:', state.analysis);
          
          console.log('✅ TimeBasedQuiltEngine test complete!');
          return engine;
        } catch (error) {
          console.error('❌ TimeBasedEngine test failed:', error);
          return '❌ Test failed';
        }
      };

      // Add a simple marker to verify this code loaded
      globalThis.testCodeLoaded = function() {
        return '✅ Test code is loaded and accessible!';
      };

      // Expose classes globally for testing
      globalThis.Logger = Logger;
      globalThis.ErrorHandler = ErrorHandler;
      globalThis.TimeBasedQuiltEngine = TimeBasedQuiltEngine;
      globalThis.ColorAnalyzer = ColorAnalyzer;
      globalThis.PatternGenerator = PatternGenerator;

      // Global test function for the integrated system
      globalThis.testIntegratedSystem = function() {
        console.log('🧪 Testing integrated TimeBasedEngine system...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          // Test adding a color through the integrated system
          const testColor = '#' + Math.floor(Math.random()*16777215).toString(16);
          console.log(`🎨 Adding test color: ${testColor}`);
          
          const result = window.app.timeBasedEngine.addColor(testColor);
          console.log('✅ Color added via integrated engine:', result);
          
          // Sync state and render
          window.app.syncEngineStateToLegacyState();
          window.app.renderTimeBasedQuilt();
          
          // Show engine state
          const engineState = window.app.timeBasedEngine.getState();
          console.log('🎨 Current engine state:');
          console.log('- Phase:', engineState.phase);
          console.log('- Pattern:', engineState.pattern);
          console.log('- Colors placed:', engineState.colors.length);
          console.log('- Colors queued:', engineState.queuedColors.length);
          console.log('- Analysis:', engineState.analysis);
          
          return '✅ Integrated system test complete!';
        } catch (error) {
          console.error('❌ Integrated test failed:', error);
          return '❌ Test failed';
        }
      };
      
      // Reset the quilt for clean testing
      globalThis.resetQuilt = function() {
        console.log('🔄 Resetting quilt for clean testing...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        // Create fresh engine
        window.app.timeBasedEngine = new TimeBasedQuiltEngine(window.app.logger, window.app.errorHandler);
        console.log('✅ Fresh quilt engine created');
        
        const state = window.app.timeBasedEngine.getState();
        console.log(`State: Phase: ${state.phase}, Colors: ${state.colors.length}, Queued: ${state.queuedColors.length}, Pattern: ${state.pattern}`);
        
        return '✅ Reset complete!';
      };

      // Test single color addition
      globalThis.testSingleColor = function() {
        console.log('🧪 Testing single color addition...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          const state = window.app.timeBasedEngine.getState();
          console.log(`🎯 Current phase: ${state.phase}`);
          
          const color = '#ff0000';
          console.log(`Adding single color: ${color}`);
          
          const result = window.app.timeBasedEngine.addColor(color);
          console.log(`Result:`, result);
          
          const newState = window.app.timeBasedEngine.getState();
          console.log(`After: Phase: ${newState.phase}, Colors: ${newState.colors.length}, Queued: ${newState.queuedColors.length}, Pattern: ${newState.pattern}`);
          
          return '✅ Single color test complete!';
        } catch (e) {
          console.error('❌ Single color test failed:', e);
          return '❌ Test failed';
        }
      };

      // Test specific phase behavior
      globalThis.testCurrentPhase = function() {
        console.log('🧪 Testing current phase behavior...');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          const state = window.app.timeBasedEngine.getState();
          console.log(`🎯 Current phase: ${state.phase}`);
          console.log('Adding colors one by one to avoid reorganization trigger...');
          
          const colors = ['#ff0000', '#ff8000', '#ffff00'];
          
          colors.forEach((color, index) => {
            console.log(`\n=== Adding Color ${index + 1}: ${color} ===`);
            const result = window.app.timeBasedEngine.addColor(color);
            console.log(`Result:`, result);
            
            window.app.syncEngineStateToLegacyState();
            window.app.renderTimeBasedQuilt();
            
            const newState = window.app.timeBasedEngine.getState();
            console.log(`Phase: ${newState.phase}, Colors: ${newState.colors.length}, Queued: ${newState.queuedColors.length}, Pattern: ${newState.pattern}`);
          });
          
          return '✅ Phase test complete!';
        } catch (e) {
          console.error('❌ Phase test failed:', e);
          return '❌ Test failed';
        }
      };
      
      // Test reorganization system with color preservation and position tracking
      globalThis.testReorganization = function() {
        console.log('🔄 Testing reorganization system with ZERO color loss...');
        console.log('🎯 Also checking for position collisions!');
        
        if (typeof window.app === 'undefined') {
          console.error('❌ App not found. Make sure page is fully loaded.');
          return;
        }
        
        try {
          console.log('Adding colors to trigger reorganization at every 5th color...');
          console.log('🛡️ IMPORTANT: Every single color will be preserved with unique positions!');
          
          const colors = ['#ff0000', '#ff8000', '#ffff00', '#80ff00', '#00ff00', '#00ff80', '#00ffff', '#0080ff'];
          let totalAdded = 0;
          
          colors.forEach((color, index) => {
            console.log(`\nAdding color ${index + 1}: ${color}`);
            const beforeState = window.app.timeBasedEngine.getState();
            const beforeCount = beforeState.colors.length + beforeState.queuedColors.length;
            
            const result = window.app.timeBasedEngine.addColor(color);
            totalAdded++;
            
            window.app.syncEngineStateToLegacyState();
            window.app.renderTimeBasedQuilt();
            
            const afterState = window.app.timeBasedEngine.getState();
            const afterCount = afterState.colors.length + afterState.queuedColors.length;
            
            console.log(`✅ Color count: ${beforeCount} → ${afterCount} (expected: ${totalAdded})`);
            
            // Check for position collisions
            const positions = new Set();
            const duplicatePositions = [];
            afterState.colors.forEach(colorData => {
              const posKey = `${colorData.position.x},${colorData.position.y}`;
              if (positions.has(posKey)) {
                duplicatePositions.push(posKey);
              }
              positions.add(posKey);
            });
            
            if (duplicatePositions.length > 0) {
              console.warn(`⚠️ Position collisions detected at: ${duplicatePositions.join(', ')}`);
            } else {
              console.log(`✅ All positions unique (${positions.size} positions)`);
            }
            
            if ((index + 1) % 5 === 0) {
              console.log('🔄 Reorganization triggered - check logs above for color preservation!');
            }
            
            // Verify no colors lost
            if (afterCount !== totalAdded) {
              throw new Error(`🚨 COLOR LOSS! Expected ${totalAdded}, got ${afterCount}`);
            }
          });
          
          console.log(`\n🎉 SUCCESS: All ${totalAdded} colors preserved through reorganizations!`);
          return '✅ Reorganization test complete - ZERO colors lost, positions tracked!';
        } catch (e) {
          console.error('❌ Reorganization test failed:', e);
          return '❌ Test failed';
        }
      };

       // ===== ARCHIVE SERVICE =====
       class ArchiveService {
         constructor(logger, dataService) {
           this.logger = logger;
           this.dataService = dataService;
           this.archives = new Map(); // Date string -> archive data (cached)
           this.isLoading = false;
           this.currentPage = 0;
           this.postsPerPage = 10;
         }

         // Archive data structure for each day
         createArchiveEntry(date, quilt, quote, userCount) {
           return {
             date: date, // "2024-01-15"
             quilt: quilt, // SVG data/state
             quote: quote, // { text: "...", author: "..." }
             userCount: userCount, // Number of users who contributed
             shareCount: 0, // Number of times this quilt has been shared
             thumbnail: null, // Will be generated
             isComplete: true // Whether the day finished properly
           };
         }

         // Get archives for feed (with pagination)
         getArchives(page = 0, limit = this.postsPerPage) {
           const allArchives = Array.from(this.archives.values())
             .sort((a, b) => new Date(b.date) - new Date(a.date)); // Newest first
           
           const start = page * limit;
           const end = start + limit;
           const pageArchives = allArchives.slice(start, end);
           
           return {
             archives: pageArchives,
             hasMore: end < allArchives.length,
             totalCount: allArchives.length
           };
         }

         // Load archives from Firebase
         async loadArchivesFromFirebase() {
           if (!this.dataService.db) {
             this.logger.log('Firebase not available, using cached archives only');
             return;
           }
           
           try {
             const { collection, getDocs, orderBy, query } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
             const archivesRef = collection(this.dataService.db, 'archives');
             const q = query(archivesRef, orderBy('date', 'desc'));
             const querySnapshot = await getDocs(q);
             
             querySnapshot.forEach((doc) => {
               const archiveData = doc.data();
               this.archives.set(archiveData.date, archiveData);
             });
             
             this.logger.log(`🔥 Loaded ${querySnapshot.size} archives from Firebase`);
           } catch (error) {
             this.logger.error('❌ Failed to load archives from Firebase:', error);
           }
         }

         // Track share count for archives
         async trackArchiveShare(date) {
           const archive = this.archives.get(date);
           if (archive) {
             archive.shareCount = (archive.shareCount || 0) + 1;
             this.logger.log(`📊 Share tracked for ${date}: ${archive.shareCount} total shares`);
             
             // Update in Firebase
             if (this.dataService.db) {
               try {
                 const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
                 const archiveDoc = doc(this.dataService.db, 'archives', date);
                 await updateDoc(archiveDoc, { shareCount: archive.shareCount });
                 this.logger.log(`🔥 Share count updated in Firebase for ${date}`);
               } catch (error) {
                 this.logger.error('❌ Failed to update share count in Firebase:', error);
               }
             }
             
             return archive.shareCount;
           }
           return 0;
         }

         // Track share count for current quilt
         trackCurrentQuiltShare() {
           const today = new Date().toISOString().split('T')[0];
           this.logger.log(`📊 Current quilt shared for ${today}`);
           
           // Store in localStorage for now (could be enhanced to track in Firebase)
           const currentShares = parseInt(localStorage.getItem(`currentQuiltShares_${today}`) || '0');
           const newCount = currentShares + 1;
           localStorage.setItem(`currentQuiltShares_${today}`, newCount.toString());
           
           this.logger.log(`📊 Current quilt share count: ${newCount}`);
           return newCount;
         }

         // Share an archived quilt
         async shareArchiveQuilt(date) {
           try {
             // Track the share
             const shareCount = await this.trackArchiveShare(date);
             
             // Get archive entry for share content
             const archiveEntry = this.archives.get(date);
             if (!archiveEntry) {
               throw new Error('Archive entry not found');
             }
             
             const formattedDate = new Date(date).toLocaleDateString('en-US', {
               year: 'numeric',
               month: 'long',
               day: 'numeric'
             });
             
             // Use the Web Share API if available
             if (navigator.share) {
               try {
                 await navigator.share({
                   title: `Community Quilt - ${formattedDate}`,
                   text: `"${archiveEntry.quote.text}" ${archiveEntry.quote.author} - Made by ${archiveEntry.userCount} contributors`,
                   url: `${window.location.href}?date=${date}`
                 });
                 
                 this.logger.log(`📤 Archive quilt shared: ${date} - total: ${shareCount}`);
                 return;
               } catch (shareError) {
                 // User cancelled or share failed
                 if (shareError.name !== 'AbortError') {
                   this.logger.log('Web Share failed, falling back to copy link');
                 }
               }
             }
             
             // Fallback: Copy link to clipboard
             try {
               const shareUrl = `${window.location.href}?date=${date}`;
               await navigator.clipboard.writeText(shareUrl);
               this.logger.log(`📤 Archive link copied: ${date} - total: ${shareCount}`);
             } catch (clipboardError) {
               // Final fallback: Just show a message
               const shareUrl = `${window.location.href}?date=${date}`;
               this.logger.log(`📤 Archive share link: ${shareUrl} - total: ${shareCount}`);
             }
             
           } catch (error) {
             this.logger.error('Archive share failed:', error);
           }
         }

         // Add new archive entry
         async addArchive(archiveEntry) {
           // Add to local cache
           this.archives.set(archiveEntry.date, archiveEntry);
           
           // Save to Firebase
           if (this.dataService.db) {
             try {
               const { doc, setDoc } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
               const archiveDoc = doc(this.dataService.db, 'archives', archiveEntry.date);
               await setDoc(archiveDoc, archiveEntry);
               this.logger.log(`🔥 Archive saved to Firebase: ${archiveEntry.date}`);
             } catch (error) {
               this.logger.error('❌ Failed to save archive to Firebase:', error);
             }
           } else {
             this.logger.log(`📝 Archive cached locally: ${archiveEntry.date}`);
           }
         }

         // Generate thumbnail from SVG (back to simple working version)
         async generateThumbnail(svgElement) {
           try {
             if (!svgElement) {
               svgElement = document.getElementById('quilt');
             }
             
             if (!svgElement) {
               this.logger.warn('No SVG element found for thumbnail generation');
               return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+Tm8gUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
             }

             // Clone SVG to avoid modifying original
             const svgClone = svgElement.cloneNode(true);
             
             // Get SVG dimensions
             const svgRect = svgElement.getBoundingClientRect();
             const width = Math.max(400, svgRect.width);
             const height = Math.max(400, svgRect.height);
             
             // Ensure SVG has proper attributes and remove animations
             svgClone.setAttribute('width', width);
             svgClone.setAttribute('height', height);
             svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
             
             // Remove all animation elements that corrupt fill attributes
             const animations = svgClone.querySelectorAll('animate, animateTransform, animateMotion, set');
             animations.forEach(anim => anim.remove());
             
             // Force CSS colors into inline attributes for canvas conversion
             const originalRects = svgElement.querySelectorAll('rect');
             const clonedRects = svgClone.querySelectorAll('rect');
             
             let coloredElements = 0;
             originalRects.forEach((originalRect, index) => {
               const clonedRect = clonedRects[index];
               if (clonedRect) {
                 // Get the color from the original rect
                 let fillColor = originalRect.getAttribute('fill') || 
                                window.getComputedStyle(originalRect).fill;
                                
                 // Debug first few
                 if (coloredElements < 5) {
                   this.logger.log(`🔍 Rect ${index}: fill=${fillColor}`);
                   coloredElements++;
                 }
                 
                 // Clean the color value and apply it
                 if (fillColor && fillColor !== 'none' && fillColor !== 'rgb(0, 0, 0)') {
                   // Remove any non-color properties
                   fillColor = fillColor.replace(/freeze|ease|linear|infinite/g, '').trim();
                   if (fillColor.match(/^(#[0-9a-fA-F]{3,6}|rgb|rgba)/)) {
                     clonedRect.setAttribute('fill', fillColor);
                     // Remove any animation attributes
                     clonedRect.removeAttribute('fill-opacity');
                     clonedRect.removeAttribute('animate');
                   }
                 }
               }
             });
             
             this.logger.log(`🎨 Applied colors to ${clonedRects.length} rect elements`);
             
             // Convert SVG to string
             const svgData = new XMLSerializer().serializeToString(svgClone);
             
             const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
             
             // Create canvas for conversion
             const canvas = document.createElement('canvas');
             const ctx = canvas.getContext('2d');
             canvas.width = width;
             canvas.height = height;
             
             // Create image from SVG
             const img = new Image();
             const url = URL.createObjectURL(svgBlob);
             
             return new Promise((resolve) => {
               img.onload = () => {
                 // Draw to canvas
                 ctx.fillStyle = '#f6f4f1'; // Background color
                 ctx.fillRect(0, 0, width, height);
                 ctx.drawImage(img, 0, 0, width, height);
                 
                 // Convert to data URL
                 const dataURL = canvas.toDataURL('image/png', 0.8);
                 URL.revokeObjectURL(url);
                 
                 this.logger.log(`✅ Generated thumbnail: ${width}x${height}`);
                 resolve(dataURL);
               };
               
               img.onerror = () => {
                 URL.revokeObjectURL(url);
                 this.logger.error('Failed to generate thumbnail');
                 resolve('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==');
               };
               
               img.src = url;
             });
             
           } catch (error) {
             this.logger.error('Thumbnail generation failed:', error);
             return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==';
           }
         }

         // Load more archives (for "Load More" button)
         async loadMore() {
           if (this.isLoading) return null;
           
           this.isLoading = true;
           this.currentPage++;
           
           try {
             // TODO: Load from storage/API
             const result = this.getArchives(this.currentPage);
             this.isLoading = false;
             return result;
           } catch (error) {
             this.isLoading = false;
             this.logger.error('Failed to load more archives:', error);
             return null;
           }
         }

         // Generate admin analytics for an archive entry
         generateAdminAnalytics(archiveEntry) {
           // Mock data for now - will be enhanced with real analytics
           return {
             noonSquares: Math.floor(Math.random() * 20) + 5,
             pattern: archiveEntry.pattern || 'Gradient Flow',
             peakTime: ['2-4pm', '6-8pm', '12-2pm', '8-10pm'][Math.floor(Math.random() * 4)],
             mobilePercent: Math.floor(Math.random() * 30) + 65,
             colorTrend: ['Warm 60%', 'Cool 65%', 'Mixed 55%'][Math.floor(Math.random() * 3)],
             returnRate: Math.floor(Math.random() * 40) + 30,
             shareCount: archiveEntry.shareCount || 0
           };
         }

         // Create HTML for a single archive post
         createArchivePostHTML(archiveEntry) {
           const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
             year: 'numeric',
             month: 'long',
             day: 'numeric'
           });

           // Admin analytics data (placeholder for now, will be enhanced)
           const adminAnalytics = this.generateAdminAnalytics(archiveEntry);

           return `
             <div class="archive-post" data-date="${archiveEntry.date}">
               <img class="archive-post-image" 
                    src="${archiveEntry.thumbnail || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+TG9hZGluZy4uLjwvdGV4dD4KPHN2Zz4='}" 
                    alt="Quilt from ${formattedDate}"
                    loading="lazy" />
               <div class="archive-post-caption">
                 <div class="archive-post-content">
                   <div class="archive-post-public">
                     <div class="archive-post-quote-author">"${archiveEntry.quote.text}" ${archiveEntry.quote.author}</div>
                     <div class="archive-post-meta">
                       <span class="archive-post-date">${formattedDate}</span>
                       <span class="archive-post-contributors">${archiveEntry.userCount} contributors</span>
                       <button class="archive-share-btn" data-date="${archiveEntry.date}" title="Share this quilt">
                         📤 Share
                       </button>
                     </div>
                   </div>
                   
                   <!-- Admin Analytics (only visible to admins) -->
                   <div class="archive-post-admin" style="display: none;">
                     <div class="admin-analytics-header">📊 ADMIN ANALYTICS</div>
                     <div class="admin-analytics-grid">
                       <div class="admin-metric">
                         <span class="metric-label">At Noon:</span>
                         <span class="metric-value">${adminAnalytics.noonSquares}</span>
                       </div>
                       <div class="admin-metric">
                         <span class="metric-label">Pattern:</span>
                         <span class="metric-value">${adminAnalytics.pattern}</span>
                       </div>
                       <div class="admin-metric">
                         <span class="metric-label">Peak Time:</span>
                         <span class="metric-value">${adminAnalytics.peakTime}</span>
                       </div>
                       <div class="admin-metric">
                         <span class="metric-label">Device:</span>
                         <span class="metric-value">${adminAnalytics.mobilePercent}% mobile</span>
                       </div>
                       <div class="admin-metric">
                         <span class="metric-label">Colors:</span>
                         <span class="metric-value">${adminAnalytics.colorTrend}</span>
                       </div>
                       <div class="admin-metric">
                         <span class="metric-label">Return Rate:</span>
                         <span class="metric-value">${adminAnalytics.returnRate}%</span>
                       </div>
                       <div class="admin-metric">
                         <span class="metric-label">Shares:</span>
                         <span class="metric-value">${adminAnalytics.shareCount}</span>
                       </div>
                     </div>
                   </div>
                 </div>
               </div>
             </div>
           `;
         }

         // Render archive feed
         renderArchiveFeed(containerId = 'archiveFeed') {
           const container = document.getElementById(containerId);
           if (!container) {
             this.logger.error('Archive feed container not found');
             return;
           }

           // Get first page of archives
           const result = this.getArchives(0);
           
           if (result.archives.length === 0) {
             container.innerHTML = '<p class="archive-loading">No quilts archived yet. Check back soon!</p>';
             return;
           }

           // Render posts
           container.innerHTML = result.archives
             .map(archive => this.createArchivePostHTML(archive))
             .join('');

           // Setup click handlers for images
           this.setupImageClickHandlers(container);

           // Show/hide Load More button
           this.updateLoadMoreButton(result.hasMore);

           this.logger.log(`Rendered ${result.archives.length} archive posts`);
           
           // Trigger admin analytics visibility if admin is logged in
           setTimeout(() => {
             if (localStorage.getItem('isAdmin') === 'true') {
               console.log('🔧 Admin detected in archive feed, showing analytics...');
               
               // Show trend summary
               const trendSummary = document.getElementById('adminTrendSummary');
               if (trendSummary) {
                 trendSummary.style.display = 'block';
                 console.log('✅ Trend summary shown');
               }
               
               // Show admin sections in archive posts
               const adminSections = document.querySelectorAll('.archive-post-admin');
               console.log(`🔧 Found ${adminSections.length} admin sections`);
               adminSections.forEach(section => {
                 section.style.display = 'block';
               });
               
               // Update trend data
               if (window.app && window.app.updateTrendSummary) {
                 window.app.updateTrendSummary();
               }
             }
           }, 200);
         }

         // Setup click handlers for archive post images and share buttons
         setupImageClickHandlers(container) {
           // Archive image click handlers
           const images = container.querySelectorAll('.archive-post-image');
           images.forEach(img => {
             img.addEventListener('click', (e) => {
               const postElement = e.target.closest('.archive-post');
               const date = postElement.dataset.date;
               const archiveEntry = this.archives.get(date);
               if (archiveEntry) {
                 this.openArchiveModal(archiveEntry);
               }
             });
           });
           
           // Archive share button click handlers
           const shareButtons = container.querySelectorAll('.archive-share-btn');
           shareButtons.forEach(btn => {
             btn.addEventListener('click', async (e) => {
               e.stopPropagation(); // Prevent triggering image click
               const date = btn.getAttribute('data-date');
               await this.shareArchiveQuilt(date);
             });
           });
         }

         // Open archive modal with enlarged view
         openArchiveModal(archiveEntry) {
           const modal = document.getElementById('archiveModal');
           const modalImage = document.getElementById('archiveModalImage');
           const modalQuote = document.getElementById('archiveModalQuote');
           const modalAuthor = document.getElementById('archiveModalAuthor');
           const modalMeta = document.getElementById('archiveModalMeta');

           if (!modal) return;

           // Set modal content
           modalImage.src = archiveEntry.thumbnail || '';
           modalImage.alt = `Quilt from ${archiveEntry.date}`;
           modalQuote.textContent = `"${archiveEntry.quote.text}" ${archiveEntry.quote.author}`;
           modalAuthor.textContent = ''; // Not needed anymore since combined with quote
           
           const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
             year: 'numeric',
             month: 'long',
             day: 'numeric'
           });
           modalMeta.innerHTML = `${formattedDate} • ${archiveEntry.userCount} contributors`;

           // Show modal
           modal.style.display = 'flex';
           document.body.style.overflow = 'hidden'; // Prevent background scroll
         }

         // Close archive modal
         closeArchiveModal() {
           const modal = document.getElementById('archiveModal');
           if (modal) {
             modal.style.display = 'none';
             document.body.style.overflow = ''; // Restore scroll
           }
         }

         // Update Load More button visibility
         updateLoadMoreButton(hasMore) {
           const loadMoreBtn = document.getElementById('archiveLoadMore');
           if (loadMoreBtn) {
             loadMoreBtn.style.display = hasMore ? 'block' : 'none';
           }
         }

         
       }

       // ===== MAIN APPLICATION =====
       class OurDailyApp {
         constructor() {
           // Initialize services
           this.logger = new Logger(CONFIG.APP.debugMode);
           this.uiService = new UIService(this.logger);
           this.errorHandler = new ErrorHandler(this.uiService, this.logger);
           this.state = new QuiltState(this.logger);
           this.dataService = new QuiltDataService(this.logger, this.errorHandler);
           this.quoteService = new QuoteService();
           this.archiveService = new ArchiveService(this.logger, this.dataService);
           
           // NEW: Time-based quilt engine
           this.timeBasedEngine = new TimeBasedQuiltEngine(this.logger, this.errorHandler);
           
           // LEGACY: Keep these for now during transition
           this.positioningService = new PositioningService(this.logger);
           this.renderingService = new RenderingService(this.logger, this.errorHandler);
           this.universalMatchingService = new UniversalMatchingService(this.logger);
           
           // Color picker state
           this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
           this.selectedSaturation = CONFIG.COLOR_PICKER.saturation; // Start with full saturation
           this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
           this.colorHasBeenSelected = false;
           
           // Share state
           this.lastAddedForShare = null;
           
           this.logger.log('OurDailyApp initialized');
         }

         // Add mock archive entry for testing admin analytics
         addMockArchiveEntry() {
           const yesterday = new Date();
           yesterday.setDate(yesterday.getDate() - 1);
           const mockDate = yesterday.toISOString().split('T')[0];
           
           const mockQuote = {
             text: "The Earth does not belong to us; we belong to the Earth.",
             author: "— Chief Seattle"
           };
           
           const mockArchiveEntry = this.archiveService.createArchiveEntry(
             mockDate,
             null, // No actual quilt data for mock
             mockQuote,
             23 // Mock user count
           );
           
           // Add some share activity
           mockArchiveEntry.shareCount = 7;
           mockArchiveEntry.pattern = 'Spiral';
           
           // Add to archive service
           this.archiveService.archives.set(mockDate, mockArchiveEntry);
           
           this.logger.log(`🧪 Mock archive entry added for ${mockDate}`);
         }

         async initialize() {
           try {
            // REMOVED: showLoading - no network calls during init
             
             await this.dataService.initialize();
             this.setupEventListeners();
             this.initializeUI();
             await this.loadQuilt();
             
             // Load existing archives from Firebase
             await this.archiveService.loadArchivesFromFirebase();
             
             // Add mock archive entry for testing admin view
             this.addMockArchiveEntry();
             
             this.renderingService.initialize();
             
            // Force initial render with time-based engine
             setTimeout(() => {
              this.renderTimeBasedQuilt();
               this.updateUI();
             }, 100);
             
             this.logger.log('App initialization complete');
           
           // Auto-transition from portal screen after 1.5 seconds
           this.setupAutoTransition();
           
           // Schedule automatic midnight archive snapshots
           this.setupMidnightArchive();
          
          // ROOT CAUSE FIX: All renderQuilt calls now use time-based engine
           } catch (error) {
             this.errorHandler.handleError(error, 'App initialization');
            // REMOVED: showLoading(false) - wasn't showing loading anyway
           }
         }

         setupEventListeners() {
           // Navigation
           document.querySelectorAll(".btn[data-next]").forEach(btn => {
             btn.addEventListener("click", e => {
               e.preventDefault();
               const targetId = btn.getAttribute("data-next");
               if (targetId) this.uiService.showScreen(targetId);
             });
           });

           // Add color button
           const addColorBtn = document.getElementById('addColorBtn');
           if (addColorBtn) {
             addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
           }

           // Share button
           const shareBtnCompleted = document.getElementById('shareBtnCompleted');
           if (shareBtnCompleted) {
             shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
           }

           // Test buttons
           const testAddBlock = document.getElementById('testAddBlock');
           if (testAddBlock) {
             testAddBlock.addEventListener('click', this.handleTestAddBlock.bind(this));
           }

           const showMyPieceBtn = document.getElementById('showMyPieceBtn');
           if (showMyPieceBtn) {
             showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
           }

           const testDifferentUserBtn = document.getElementById('testDifferentUserBtn');
           if (testDifferentUserBtn) {
             testDifferentUserBtn.addEventListener('click', this.handleTestDifferentUser.bind(this));
           }

           

           // Color picker
           this.setupColorPicker();
           
           // Archive modal event handlers
           this.setupArchiveEventHandlers();

           // Keyboard navigation
           document.addEventListener('keydown', this.handleKeyDown.bind(this));
                  }

        setupArchiveEventHandlers() {
           // Archive Load More button
           const loadMoreBtn = document.getElementById('archiveLoadMore');
           if (loadMoreBtn) {
             loadMoreBtn.addEventListener('click', () => {
               this.handleArchiveLoadMore();
             });
           }

           // Archive modal close handlers
           const modalClose = document.getElementById('archiveModalClose');
           const modalBackdrop = document.getElementById('archiveModalBackdrop');
           
           if (modalClose) {
             modalClose.addEventListener('click', () => {
               this.archiveService.closeArchiveModal();
             });
           }
           
           if (modalBackdrop) {
             modalBackdrop.addEventListener('click', () => {
               this.archiveService.closeArchiveModal();
             });
           }

           // Archive screen initialization
           document.addEventListener('screenChange', (e) => {
             if (e.detail.screenId === 'screen-archive') {
               this.initializeArchiveScreen();
             }
           });
        }

        async handleArchiveLoadMore() {
           const loadMoreBtn = document.getElementById('archiveLoadMore');
           const loadingDiv = document.getElementById('archiveLoading');
           
           if (loadMoreBtn) loadMoreBtn.disabled = true;
           if (loadingDiv) loadingDiv.style.display = 'block';

           try {
             const result = await this.archiveService.loadMore();
             if (result && result.archives.length > 0) {
               // Append new posts to existing feed
               const container = document.getElementById('archiveFeed');
               if (container) {
                 const newPostsHTML = result.archives
                   .map(archive => this.archiveService.createArchivePostHTML(archive))
                   .join('');
                 
                 container.insertAdjacentHTML('beforeend', newPostsHTML);
                 this.archiveService.setupImageClickHandlers(container);
                 this.archiveService.updateLoadMoreButton(result.hasMore);
               }
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'Load more archives');
           } finally {
             if (loadMoreBtn) loadMoreBtn.disabled = false;
             if (loadingDiv) loadingDiv.style.display = 'none';
           }
        }

        initializeArchiveScreen() {
           // Render the archive feed
           this.archiveService.renderArchiveFeed();
           
           // Check if admin is logged in and show admin analytics
           setTimeout(() => {
             if (localStorage.getItem('isAdmin') === 'true') {
               if (window.app && window.app.showAdminAnalytics) {
                 window.app.showAdminAnalytics();
               }
             }
           }, 100);
        }

        // DEBUG: Force create archive snapshot from current quilt
        async forceArchiveSnapshot() {
           const today = new Date().toISOString().split('T')[0];
           const currentQuote = this.quoteService.getTodayQuote();
           const blockCount = this.state?.blocks?.length || 0;
           
           this.logger.log(`🖼️ Generating thumbnail for ${blockCount} blocks...`);
           
           // Generate thumbnail from current SVG
           const thumbnail = await this.archiveService.generateThumbnail();
           
           // Create archive entry
           const archiveEntry = this.archiveService.createArchiveEntry(
             today,
             { blocks: this.state?.blocks || [] }, // Current quilt state
             currentQuote,
             Math.max(blockCount, 12) // Use actual block count or minimum 12
           );
           
           // Set the generated thumbnail
           archiveEntry.thumbnail = thumbnail;
           
           // Add to archive
           this.archiveService.addArchive(archiveEntry);
           
           // Re-render if on archive screen
           const archiveScreen = document.getElementById('screen-archive');
           if (archiveScreen && archiveScreen.classList.contains('active')) {
             this.archiveService.renderArchiveFeed();
           }
           
           this.logger.log(`✅ Created archive snapshot for ${today} with ${blockCount} blocks and thumbnail`);
           return archiveEntry;
        }

        setupMidnightArchive() {
           this.logger.log('🌙 Setting up automatic midnight archive...');
           
           const scheduleNextArchive = () => {
             const now = new Date();
             
             // Convert to Chicago time (Central Time)
             const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
             
             // Calculate next 11:59 PM Chicago time
             const nextArchive = new Date(chicagoTime);
             nextArchive.setHours(23, 59, 0, 0); // 11:59:00 PM
             
             // If it's already past 11:59 PM today, schedule for tomorrow
             if (chicagoTime >= nextArchive) {
               nextArchive.setDate(nextArchive.getDate() + 1);
             }
             
             // Convert back to local time for setTimeout
             const localNextArchive = new Date(nextArchive.toLocaleString("en-US", {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone}));
             const msUntilArchive = localNextArchive.getTime() - now.getTime();
             
             this.logger.log(`🌙 Next archive scheduled for: ${nextArchive.toLocaleString("en-US", {timeZone: "America/Chicago"})} Chicago time`);
             this.logger.log(`🌙 That's in ${Math.round(msUntilArchive / 1000 / 60)} minutes`);
             
             // Schedule the archive
             this.midnightTimer = setTimeout(async () => {
               try {
                 this.logger.log('🌙 MIDNIGHT ARCHIVE: Creating automatic snapshot...');
                 
                 // Create archive snapshot
                 const archiveEntry = await this.forceArchiveSnapshot();
                 
                 if (archiveEntry) {
                   this.logger.log('🌙 ✅ Midnight archive snapshot created successfully!');
                   
                   // Optional: Show a toast notification
                   this.uiService.showToast('🌙 Daily quilt archived!');
                 } else {
                   this.logger.error('🌙 ❌ Failed to create midnight archive');
                 }
                 
               } catch (error) {
                 this.logger.error('🌙 ❌ Midnight archive error:', error);
               }
               
               // Schedule the next archive for tomorrow
               scheduleNextArchive();
               
             }, msUntilArchive);
           };
           
           // Start the scheduling
           scheduleNextArchive();
        }

        initializeUI() {
           const dateText = document.getElementById("date-text");
           if (dateText) {
             dateText.textContent = Utils.formatDate();
           }
           this.quoteService.displayQuote();
           this.uiService.showScreen('screen-portal');
         }

        setupAutoTransition() {
          // Check if user is on portal screen and auto-transition after 1.5 seconds
          const currentScreen = document.querySelector('.screen.active');
          if (currentScreen && currentScreen.id === 'screen-portal') {
            setTimeout(() => {
              this.autoTransitionFromPortal();
            }, 1500);
          }
        }

        autoTransitionFromPortal() {
          // Check if user is a first-time visitor
          const hasVisitedBefore = localStorage.getItem('ourDailyHasVisited');
          
          if (!hasVisitedBefore) {
            // First time - show welcome/instructions screen
            localStorage.setItem('ourDailyHasVisited', 'true');
            this.uiService.showScreen('screen-welcome');
            
            // Then auto-transition from welcome to quote after another 3 seconds
            setTimeout(() => {
              this.uiService.showScreen('screen-quote');
            }, 3000);
          } else {
            // Returning visitor - go straight to quote
            this.uiService.showScreen('screen-quote');
          }
        }

                 async loadQuilt() {
          try {
            this.logger.log('🔄 APP: Starting loadQuilt process...');
            this.logger.log('🔗 APP: About to call dataService.loadQuilt()');
            
            try {
              const colors = await this.dataService.loadQuilt();
              this.logger.log(`📦 APP: Received ${colors?.length || 0} colors from dataService`);
              
              // Load colors into time-based engine
              this.logger.log('🎨 APP: About to call timeBasedEngine.loadQuiltData()');
              this.timeBasedEngine.loadQuiltData(colors);
              this.logger.log('✅ APP: timeBasedEngine.loadQuiltData() completed');
              
              // Also maintain legacy state for compatibility
              this.state.blocks = colors;
              
              if (this.renderingService.isInitialized) {
               this.logger.log('🎨 APP: About to render time-based quilt');
               this.renderTimeBasedQuilt();
               
               // Update square counter when loading existing data
               const engineState = this.timeBasedEngine.getState();
               const totalSquares = engineState.colors.length + engineState.queuedColors.length;
               console.log(`🏁 LOAD QUILT: Engine loaded with ${engineState.colors.length} placed + ${engineState.queuedColors.length} queued = ${totalSquares} total squares`);
               window.updateUserCounter(totalSquares);
              }
            } catch (dataServiceError) {
              this.logger.error('❌ APP: dataService.loadQuilt() failed:', dataServiceError);
              throw dataServiceError; // Re-throw to be caught by outer catch
            }
            // REMOVED: showLoading(false) - not needed since we don't show loading
          } catch (error) {
            this.logger.error('❌ APP: loadQuilt failed with error:', error);
            this.errorHandler.handleError(error, 'loadQuilt');
            // REMOVED: showLoading(false) - not showing loading anyway
            this.state.blocks = [];
            if (this.renderingService.isInitialized) {
             this.renderTimeBasedQuilt();
             
             // Update square counter (starts at 0 if loading failed)
             const engineState = this.timeBasedEngine.getState();
              const totalSquares = engineState.colors.length + engineState.queuedColors.length;
              window.updateUserCounter(totalSquares);
             }
           }
         }

         async saveQuilt() {
           try {
             // Get current colors from the time-based engine
             const currentState = this.timeBasedEngine.getState();
             
             // Extract just the color strings from the color objects
             const colorStrings = currentState.colors.map(colorObj => colorObj.color);
             
             this.logger.log(`💾 Saving ${colorStrings.length} colors to Firebase: [${colorStrings.join(', ')}]`);
             await this.dataService.saveQuilt(colorStrings);
           } catch (error) {
             this.errorHandler.handleError(error, 'saveQuilt');
             throw error;
           }
         }

         addPieceToQuilt(newColor) {
           try {
             this.logger.log(`🔄 Starting addPieceToQuilt with color: ${newColor}`);
             
             this.errorHandler.validateColor(newColor);
             this.logger.log('✅ Color validation passed');
             
             this.state.incrementSubmission();
             this.logger.log(`📊 Submission count incremented to: ${this.state.submissionCount}`);
             
             // Determine pieces to create based on submission count
             const piecesToCreate = CONFIG.PHASES.collection.piecesPerSubmission[this.state.submissionCount - 1] || 1;
             this.logger.log(`🎯 Creating ${piecesToCreate} pieces for submission ${this.state.submissionCount}`);
             
             // Create pieces for this submission
             const startIndex = this.state.pieces.length;
             this.logger.log(`📍 Starting piece creation at index: ${startIndex}`);
             
             for (let i = 0; i < piecesToCreate; i++) {
               const currentIndex = startIndex + i;
               this.logger.log(`🔧 Creating piece ${i + 1}/${piecesToCreate} at index ${currentIndex}`);
               
               const piece = this.positioningService.createPiece(
                 newColor, 
                 currentIndex, 
                 this.state.currentUserId, 
                 this.state.submissionCount
               );
               
               this.logger.log(`✅ Piece created:`, piece);
               this.state.addPiece(piece);
             }
             
             this.logger.log(`📈 Total pieces after addition: ${this.state.pieces.length}`);
             
             // Handle phase transitions
             this.logger.log('🔄 Checking for phase transitions');
             this.handlePhaseTransitions();
             
             this.state.lastAddedIndex = this.state.blocks.length - 1;
             this.logger.log(`🎯 Last added index set to: ${this.state.lastAddedIndex}`);
             
             this.logger.log('✅ addPieceToQuilt completed successfully');
             return true;
             
           } catch (error) {
             this.logger.error(`❌ Error in addPieceToQuilt: ${error.message}`);
             this.errorHandler.handleError(error, 'addPieceToQuilt');
             return false;
           }
         }

         handlePhaseTransitions() {
           const submissionCount = this.state.submissionCount;
           this.logger.log(`🔄 Checking phase transitions at submission ${submissionCount}`);
           
           if (submissionCount === CONFIG.PHASES.patchFormation.triggerSubmission) {
             this.logger.log('🔄 Transitioning to patch-formation phase');
             this.state.setPhase('block-formation');
             
             // Form patches from all pieces (24 pieces → 12 patches)
             const allPatches = this.formPatchesFromPieces(this.state.allPieces);
             this.logger.log(`📊 Formed ${allPatches.length} patches from all pieces`);
             
             // Form blocks from patches (12 patches → 6 blocks)
             const blockFormationResult = this.formBlocksFromPatches(allPatches);
             this.state.blocks = blockFormationResult.blocks;
             this.state.unmatchedPatches = blockFormationResult.unmatchedPatches;
             this.state.originalPatches = [...allPatches];
             
             // Clear pieces and patches, show blocks
             this.state.pieces = [];
             this.state.patches = [];
             this.state.allPieces = [];
             
             this.logger.log(`📊 User 6 sees ${this.state.blocks.length} blocks`);
             this.uiService.showToast('Block formation phase activated!');
                       } else if (submissionCount === CONFIG.PHASES.blockFormation.triggerSubmission && submissionCount > 6) {
              this.logger.log('🔄 User 7+ adding piece to existing blocks');
              
              // Create the new piece
              const newPiece = this.createPiece();
              this.state.pieces = [newPiece];
              
              // Position the piece to attach to the existing quilt
              this.positioningService.positionPieceWithQuilt(newPiece, this.state.blocks);
              
              this.logger.log(`📊 User ${submissionCount} adds piece to existing ${this.state.blocks.length} blocks`);
              this.uiService.showToast(`Your piece added to the quilt!`);
           } else if (submissionCount === CONFIG.PHASES.quiltFormation.triggerSubmission) {
             this.logger.log('🔄 Transitioning to quilt-formation phase');
             this.state.setPhase('quilt-formation');
             const allPatches = this.formPatchesFromPieces(this.state.allPieces);
             this.logger.log(`📊 Processing ${allPatches.length} patches for quilt formation`);
             const allBlocks = this.formBlocksFromPatches(allPatches);
             this.logger.log(`📊 Processing ${allBlocks.blocks.length} blocks for quilt formation`);
             this.state.quilt = this.formQuiltFromBlocks(allBlocks);
             this.state.blocks = [];
             this.state.patches = [];
             this.state.pieces = [];
             this.state.unmatchedPieces = [];
             this.state.allPieces = [];
             this.logger.log('📊 Quilt formation completed');
             this.uiService.showToast('Quilt formation phase activated! All pieces included!');
           } else {
             this.logger.log(`📊 No phase transition needed at submission ${submissionCount}`);
           }
         }

         formPatchesFromPieces(specificPieces = null) {
           const pieces = specificPieces ? [...specificPieces] : [...this.state.pieces];
           
           this.logger.log(`formPatchesFromPieces: Starting with ${pieces.length} pieces`);
           
           const result = this.universalMatchingService.formCompositeElements(
             pieces,
             'patch',
             {
               edgeTolerance: CONFIG.PHASES.patchFormation.edgeTolerance,
               valueContrastWeight: CONFIG.PHASES.patchFormation.valueContrastWeight,
               createCompositeFunction: this.createPatch.bind(this),
               maxMatches: Math.floor(pieces.length / 2)
             }
           );
           
           this.state.unmatchedPieces = result.unmatchedElements;
           this.logger.log(`formPatchesFromPieces: Created ${result.compositeElements.length} patches and ${result.unmatchedElements.length} unmatched pieces`);
           
           this.positioningService.positionElementsInGrid(result.compositeElements, 0, 'patches');
           
           return result.compositeElements;
         }

         formBlocksFromPatches(specificPatches = null) {
           const patches = specificPatches ? [...specificPatches] : [...this.state.patches];
           
           this.logger.log(`Starting block formation with ${patches.length} patches`);
           
           const result = this.universalMatchingService.formCompositeElements(
             patches,
             'block',
             {
               edgeTolerance: CONFIG.PHASES.blockFormation.edgeTolerance,
               valueContrastWeight: CONFIG.PHASES.blockFormation.valueContrastWeight,
               createCompositeFunction: this.createBlock.bind(this),
               maxMatches: Math.floor(patches.length / 2)
             }
           );
           
           this.logger.log(`Block formation summary: ${result.compositeElements.length} blocks created, ${result.unmatchedElements.length} unmatched patches`);
           
           this.positioningService.positionElementsInGrid(result.compositeElements, 0, 'blocks');
           
           return {
             blocks: result.compositeElements,
             unmatchedPatches: result.unmatchedElements
           };
         }



         formQuiltFromBlocks(blocks) {
           const allBlocks = [...blocks];
           
           this.logger.log(`Starting quilt formation with ${allBlocks.length} blocks`);
           
           const result = this.universalMatchingService.formCompositeElements(
             allBlocks,
             'quilt_block',
             {
               edgeTolerance: CONFIG.PHASES.blockFormation.edgeTolerance,
               valueContrastWeight: CONFIG.PHASES.blockFormation.valueContrastWeight,
               createCompositeFunction: this.createQuiltBlock.bind(this),
               maxMatches: Math.floor(allBlocks.length / 2)
             }
           );
           
           // Handle single unmatched blocks
           result.unmatchedElements.forEach(block => {
             if (block) {
               const singleQuiltBlock = this.createQuiltBlock([block]);
               if (singleQuiltBlock) {
                 result.compositeElements.push(singleQuiltBlock);
               }
             }
           });
           
           this.positionQuiltBlocks(result.compositeElements);
           
           return {
             id: `quilt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             type: 'quilt',
             blocks: result.compositeElements,
             width: 600,
             height: 600
           };
         }

         findBestMatch(items, targetItem) {
           let bestMatch = null;
           let bestScore = Infinity;
           const tolerance = CONFIG.PHASES.patchFormation.edgeTolerance;
           
           this.logger.log(`Finding best match for item ${targetItem.id || 'unknown'} among ${items.length} candidates`);
           
           for (let i = 0; i < items.length; i++) {
             const item = items[i];
             if (item === targetItem) continue;
             
             const targetEdges = targetItem.edges;
             const itemEdges = item.edges;
             
             const horizontalEdgeScore = this.calculateEdgeScore(targetEdges.right, itemEdges.left);
             const verticalEdgeScore = this.calculateEdgeScore(targetEdges.bottom, itemEdges.top);
             const valueContrastScore = this.calculateValueContrastScore(targetItem.color, item.color);
             const sameColorPenalty = targetItem.color === item.color ? 1.0 : 0;
             
             const horizontalScore = horizontalEdgeScore - valueContrastScore * CONFIG.PHASES.patchFormation.valueContrastWeight + sameColorPenalty;
             const verticalScore = verticalEdgeScore - valueContrastScore * CONFIG.PHASES.patchFormation.valueContrastWeight + sameColorPenalty;
             
             const score = Math.min(horizontalScore, verticalScore);
             const sameColor = targetItem.color === item.color;
             
             this.logger.log(`  Candidate ${i}: edge scores (H:${horizontalEdgeScore.toFixed(3)}, V:${verticalEdgeScore.toFixed(3)}), contrast:${valueContrastScore.toFixed(3)}, sameColor:${sameColor}, final score:${score.toFixed(3)}`);
             
             if (score < bestScore) {
               bestScore = score;
               bestMatch = {
                 item: item,
                 score: score,
                 joinType: score === horizontalScore ? 'horizontal' : 'vertical',
                 edgeScore: Math.min(horizontalEdgeScore, verticalEdgeScore),
                 valueContrastScore: valueContrastScore
               };
               this.logger.log(`  New best match found with score ${score.toFixed(3)}`);
             }
           }
           
           this.logger.log(`Best match score: ${bestMatch ? bestMatch.score.toFixed(3) : 'none'}`);
           return bestMatch;
         }

         calculateEdgeScore(length1, length2) {
           const difference = Math.abs(length1 - length2);
           const averageLength = (length1 + length2) / 2;
           return difference / averageLength;
         }

         calculateValueContrastScore(color1, color2) {
           const hsl1 = Utils.hexToHsl(color1);
           const hsl2 = Utils.hexToHsl(color2);
           const valueDifference = Math.abs(hsl1.l - hsl2.l);
           const normalizedContrast = valueDifference / 100;
           const contrastScore = Math.pow(normalizedContrast, 0.7);
           return contrastScore;
         }

         combineItems(item1, item2, joinType) {
           let combinedWidth, combinedHeight, combinedX, combinedY;
           
           if (joinType === 'horizontal') {
             const targetLength = (item1.edges.right + item2.edges.left) / 2;
             const adjustedWidth1 = item1.width;
             const adjustedWidth2 = item2.width;
             
             combinedWidth = item1.width + adjustedWidth2;
             combinedHeight = Math.max(item1.height, item2.height);
             combinedX = item1.x;
             combinedY = Math.min(item1.y, item2.y);
           } else {
             const targetLength = (item1.edges.bottom + item2.edges.top) / 2;
             const adjustedHeight1 = item1.height;
             const adjustedHeight2 = item2.height;
             
             combinedWidth = Math.max(item1.width, item2.width);
             combinedHeight = item1.height + adjustedHeight2;
             combinedX = Math.min(item1.x, item2.x);
             combinedY = item1.y;
           }
           
           return {
             width: combinedWidth,
             height: combinedHeight,
             x: combinedX,
             y: combinedY
           };
         }

         createPatch(pieces) {
           if (pieces.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           pieces.forEach(piece => {
             minX = Math.min(minX, piece.x);
             minY = Math.min(minY, piece.y);
             maxX = Math.max(maxX, piece.x + piece.width);
             maxY = Math.max(maxY, piece.y + piece.height);
           });
           
           return {
             id: `patch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             color: pieces[0].color,
             type: 'patch',
             pieces: pieces,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         createBlock(patches) {
           if (patches.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           patches.forEach(patch => {
             minX = Math.min(minX, patch.x);
             minY = Math.min(minY, patch.y);
             maxX = Math.max(maxX, patch.x + patch.width);
             maxY = Math.max(maxY, patch.y + patch.height);
           });
           
           return {
             id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             color: patches[0].color,
             type: 'block',
             patches: patches,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         createQuiltBlock(blocks) {
           if (blocks.length < 2) return null;
           
           let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
           blocks.forEach(block => {
             minX = Math.min(minX, block.x);
             minY = Math.min(minY, block.y);
             maxX = Math.max(maxX, block.x + block.width);
             maxY = Math.max(maxY, block.y + block.height);
           });
           
           return {
             id: `quilt_block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
             x: minX,
             y: minY,
             width: maxX - minX,
             height: maxY - minY,
             type: 'quilt_block',
             blocks: blocks,
             edges: this.positioningService.calculateEdges(maxX - minX, maxY - minY)
           };
         }

         positionQuiltBlocks(quiltBlocks) {
           const quiltSize = 600;
           const padding = 20;
           const availableSize = quiltSize - 2 * padding;
           
           this.logger.log(`Positioning ${quiltBlocks.length} quilt blocks in touching layout`);
           
           if (quiltBlocks.length === 0) return;
           
           quiltBlocks[0].x = padding;
           quiltBlocks[0].y = padding;
           this.logger.log(`Quilt block 0 positioned at (${quiltBlocks[0].x}, ${quiltBlocks[0].y})`);
           
           for (let i = 1; i < quiltBlocks.length; i++) {
             const block = quiltBlocks[i];
             
             if (!block || typeof block.width === 'undefined' || typeof block.height === 'undefined') {
               this.logger.warn(`Skipping invalid quilt block at index ${i}:`, block);
               continue;
             }
             
             let bestX = padding;
             let bestY = padding;
             let bestScore = Infinity;
             
             for (let attempt = 0; attempt < 100; attempt++) {
               const testX = padding + Math.random() * (availableSize - block.width);
               const testY = padding + Math.random() * (availableSize - block.height);
               
               let touchesExisting = false;
               let minDistance = Infinity;
               
               for (let j = 0; j < i; j++) {
                 const existingBlock = quiltBlocks[j];
                 if (!existingBlock) continue;
                 
                 const horizontalOverlap = !(testX + block.width <= existingBlock.x || 
                                          testX >= existingBlock.x + existingBlock.width);
                 const verticalOverlap = !(testY + block.height <= existingBlock.y || 
                                         testY >= existingBlock.y + existingBlock.height);
                 
                 if (horizontalOverlap && verticalOverlap) {
                   touchesExisting = false;
                   break;
                 }
                 
                 const horizontalTouch = (testX + block.width === existingBlock.x) || 
                                      (existingBlock.x + existingBlock.width === testX);
                 const verticalTouch = (testY + block.height === existingBlock.y) || 
                                    (existingBlock.y + existingBlock.height === testY);
                 
                 if (horizontalTouch && verticalTouch) {
                   touchesExisting = true;
                 }
                 
                 const distance = Math.sqrt(
                   Math.pow(testX - existingBlock.x, 2) + 
                   Math.pow(testY - existingBlock.y, 2)
                 );
                 if (distance < minDistance) {
                   minDistance = distance;
                 }
               }
               
               const score = touchesExisting ? -minDistance : minDistance + 1000;
               
               if (score < bestScore) {
                 bestScore = score;
                 bestX = testX;
                 bestY = testY;
               }
             }
             
             block.x = bestX;
             block.y = bestY;
             this.logger.log(`Quilt block ${i} positioned at (${block.x}, ${block.y})`);
           }
         }

         updateUI() {
           this.uiService.updatePhaseIndicator(this.state.currentPhase, this.state.submissionCount);
   
         }

         async handleAddColor() {
           try {
             this.logger.log('🎨 Starting color addition process');
             this.logger.log(`Selected hue: ${this.selectedHue}`);
             this.logger.log(`Selected saturation: ${this.selectedSaturation}`);
             this.logger.log(`Selected lightness: ${this.selectedLightness}`);
             
             const selectedColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
             
             this.logger.log(`Converted color: ${selectedColor}`);
             
             if (!selectedColor) {
               this.logger.warn('No color selected');
               // this.uiService.showToast('Please select a color first'); // Toast removed
               return;
             }

             // Validate the color
             if (!Utils.validateHexColor(selectedColor)) {
               this.logger.error(`Invalid color generated: ${selectedColor}`);
               // this.uiService.showToast('Invalid color generated. Please try again.'); // Toast removed
               return;
             }

             // NEW: Use TimeBasedQuiltEngine
             this.logger.log(`Adding color to time-based engine: ${selectedColor}`);
             const result = this.timeBasedEngine.addColor(selectedColor);
             
             if (result.success) {
               this.logger.log('Color added successfully to time-based engine');
               
               // Update the legacy state for UI compatibility
               this.syncEngineStateToLegacyState();
               
               this.logger.log('Saving quilt data');
               await this.saveQuilt();
               
               this.logger.log('Rendering updated quilt');
              this.renderTimeBasedQuilt();
              
              // Update square counter in community message
              const engineState = this.timeBasedEngine.getState();
              const totalSquares = engineState.colors.length + engineState.queuedColors.length;
              console.log(`🔢 DEBUG: About to update counter - colors: ${engineState.colors.length}, queued: ${engineState.queuedColors.length}, total: ${totalSquares}`);
              window.updateUserCounter(totalSquares);
              
               this.updateUI();
              this.showPhaseMessage(result);
               this.uiService.showScreen('screen-quilt');
             } else {
               this.logger.warn('Failed to add color to time-based engine:', result.reason);
               // this.uiService.showToast(result.reason || 'Failed to add color'); // Toast removed
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'handleAddColor');
             // this.uiService.showToast('Failed to add color. Please try again.'); // Toast removed
           }
         }

         // NEW: Helper methods for TimeBasedEngine integration
         syncEngineStateToLegacyState() {
           const engineState = this.timeBasedEngine.getState();
           
           // Update legacy state for UI compatibility
           this.state.currentPhase = engineState.phase;
           this.state.submissionCount = engineState.colors.length + engineState.queuedColors.length;
           
           // Clear old data and populate with new
           this.state.pieces = [];
           this.state.patches = [];
           this.state.blocks = [];
           
           // Convert engine colors to legacy format for UI components
           engineState.colors.forEach((colorObj, index) => {
             this.state.pieces.push({
               id: `piece_${index}`,
               color: colorObj.color,
               x: colorObj.position.x * 30, // Scale for display
               y: colorObj.position.y * 30,
               width: 25,
               height: 25,
               userId: this.state.currentUserId,
               timestamp: colorObj.timestamp
             });
           });
           
           this.logger.log(`Synced engine state: ${engineState.colors.length} colors, phase: ${engineState.phase}, pattern: ${engineState.pattern}`);
         }

         renderTimeBasedQuilt() {
           console.log('🎨 DEBUG: Starting renderTimeBasedQuilt...');
           
           // Force pattern selection if we're in pattern filling phase but no pattern is selected
           this.timeBasedEngine.forcePatternSelectionIfNeeded();
           
           const engineState = this.timeBasedEngine.getState();
           console.log('🎨 DEBUG: Engine state:', engineState);
           console.log('🎨 DEBUG: Colors in state:', engineState.colors?.length || 0);
           
           const quiltSVG = document.getElementById('quilt');
           console.log('🎨 DEBUG: Quilt SVG element:', quiltSVG);
           
           if (!quiltSVG) {
             this.logger.warn('Quilt SVG not found');
             return;
           }
           
           // Mark that time-based rendering is active to prevent legacy interference
           quiltSVG.setAttribute('data-time-based-active', 'true');
           
                     // FIXED OPTIMAL LAYOUT: Design for perfect mobile experience
         const numberOfColorFamilies = 8;
         
         // RESPONSIVE BLOCK SIZING: Scale based on device for optimal touch experience
         let screenWidth = window.innerWidth || 412;
         const isMobile = screenWidth < 768;
         
         // COMPREHENSIVE MOBILE DEBUG
         console.log(`🔍 SCREEN DEBUG: innerWidth=${window.innerWidth}, screenWidth=${screenWidth}, isMobile=${isMobile}`);
         console.log(`🔍 VIEWPORT DEBUG: clientWidth=${document.documentElement.clientWidth}, offsetWidth=${document.documentElement.offsetWidth}`);
         console.log(`🔍 WINDOW DEBUG: outerWidth=${window.outerWidth}, screen.width=${screen.width}`);
         console.log(`🔍 BODY DEBUG: body.clientWidth=${document.body.clientWidth}, body.offsetWidth=${document.body.offsetWidth}`);
         
         // FORCE MAXIMUM WIDTH for mobile debugging
         if (isMobile) {
           const maxPossibleWidth = Math.max(window.innerWidth, document.documentElement.clientWidth, screen.width);
           console.log(`📱 MOBILE OVERRIDE: Using maximum detected width ${maxPossibleWidth}px instead of ${screenWidth}px`);
           screenWidth = maxPossibleWidth;
         }
         
         // Calculate optimal block size to fit 8 columns perfectly with spacing
         const targetSpacing = isMobile ? 1 : 12; // Ultra-minimal spacing on mobile to maximize block size
         const sidePadding = isMobile ? 0 : 16; // ZERO padding on mobile - use every pixel!
         const sideMargin = 16; // Account for canvas margins
         const effectiveWidth = screenWidth - (sideMargin * 2); // Narrower canvas width
         const availableWidth = effectiveWidth - (sidePadding * 2); // Space available for quilt within narrower canvas
         const spacingTotal = (numberOfColorFamilies - 1) * targetSpacing; // Total spacing between columns
         const blockSpaceAvailable = availableWidth - spacingTotal; // Space left for actual blocks
         const optimalBlockSize = Math.floor(blockSpaceAvailable / numberOfColorFamilies); // Perfect fit
         
         // MOBILE UX: Force bigger blocks even if they require horizontal scroll
         let finalBlockSize;
         if (isMobile) {
           // MOBILE: Use calculated size to FIT the screen (no horizontal scroll)
           finalBlockSize = Math.floor(optimalBlockSize); // Use the size that actually fits
           console.log(`📱 MOBILE FIT: ${finalBlockSize}px blocks (calculated to fit ${screenWidth}px screen)`);
         } else {
           // DESKTOP: Even bigger since there's more space
           finalBlockSize = Math.max(75, Math.floor(optimalBlockSize));
           console.log(`🖥️ DESKTOP CHOICE: ${finalBlockSize}px blocks (large and comfortable)`);
         }
         
         console.log(`🔢 SIZE CALC: availableWidth=${availableWidth}, spacingTotal=${spacingTotal}, blockSpace=${blockSpaceAvailable}`);
         console.log(`🔢 BLOCK CALC: optimal=${optimalBlockSize}, FITTED final=${finalBlockSize}`);
         console.log(`🔍 DETAILED MATH: ${screenWidth}px screen - ${sidePadding * 2}px padding = ${availableWidth}px available`);
         console.log(`🔍 DETAILED MATH: ${availableWidth}px - ${spacingTotal}px spacing = ${blockSpaceAvailable}px for blocks`);
         console.log(`🔍 DETAILED MATH: ${blockSpaceAvailable}px ÷ ${numberOfColorFamilies} columns = ${optimalBlockSize}px per block`);
         
         // FORCE MINIMUM for testing
         if (isMobile && finalBlockSize < 40) {
           console.log(`⚠️ WARNING: Calculated size ${finalBlockSize}px is too small! Something is wrong with our math.`);
           console.log(`⚠️ Expected: ~44px blocks with 3px spacing on ~375px screen`);
         }
         
         console.log(`🎯 RESPONSIVE SIZING: ${screenWidth}px screen → ${availableWidth}px available → ${finalBlockSize}px blocks (${numberOfColorFamilies} columns)`);
         console.log(`📱 SPACING: ${targetSpacing}px gaps + ${sidePadding * 2}px padding = ${(numberOfColorFamilies * finalBlockSize) + spacingTotal + (sidePadding * 2)}px total`);
         
         // ADAPTIVE CANVAS: Size for content on mobile, full width on desktop
         const contentWidth = (numberOfColorFamilies * finalBlockSize) + (7 * targetSpacing) + (sidePadding * 2);
         let canvasWidth;
         
         if (isMobile && contentWidth > screenWidth) {
           // MOBILE: If content is wider than screen, allow horizontal scroll
           canvasWidth = contentWidth;
           console.log(`📱 MOBILE SCROLL: Canvas=${canvasWidth}px (wider than ${screenWidth}px screen) - horizontal scroll enabled`);
         } else {
           // DESKTOP or mobile fits: Use full screen width
           canvasWidth = Math.max(screenWidth, contentWidth);
           console.log(`🖥️ FULL WIDTH: Canvas=${canvasWidth}px, Content=${contentWidth}px`);
         }
         
         const scale = finalBlockSize;
         
         console.log(`🎨 RENDER PREP: finalBlockSize=${finalBlockSize}px, scale=${scale}px (should be identical)`);
         
         // Enable block rendering debug
         window.debugBlockRendering = true;
         
         // DEBUG: Check for CSS scaling issues
         setTimeout(() => {
           console.log(`🔍 DELAYED CHECK: width attr="${quiltSVG.getAttribute('width')}", height attr="${quiltSVG.getAttribute('height')}"`);
           
           const svgRect = quiltSVG.getBoundingClientRect();
           const svgStyle = window.getComputedStyle(quiltSVG);
           console.log(`🔍 SVG CONTAINER: width=${svgRect.width}px, height=${svgRect.height}px (actual rendered size)`);
           console.log(`🔍 CSS WIDTH: ${svgStyle.width}, CSS HEIGHT: ${svgStyle.height}`);
           console.log(`🔍 CSS MAX-WIDTH: ${svgStyle.maxWidth}, CSS MAX-HEIGHT: ${svgStyle.maxHeight}`);
           console.log(`🔍 PARENT CONTAINER: ${quiltSVG.parentElement.tagName} - width=${quiltSVG.parentElement.getBoundingClientRect().width}px`);
           
           if (quiltSVG.getAttribute('width') === null) {
             console.log(`⚠️ ATTRIBUTES CLEARED: Something removed the width/height attributes after we set them!`);
           } else if (svgRect.width !== parseInt(quiltSVG.getAttribute('width'))) {
             const scaleRatio = svgRect.width / parseInt(quiltSVG.getAttribute('width'));
             console.log(`⚠️ SCALING DETECTED: SVG is being scaled from ${quiltSVG.getAttribute('width')}px to ${svgRect.width}px (${(scaleRatio * 100).toFixed(1)}% scale)`);
             console.log(`⚠️ This makes 46px blocks appear as ${Math.round(46 * scaleRatio)}px blocks`);
             
             // Check what's causing the scaling
             if (svgStyle.maxWidth && svgStyle.maxWidth !== 'none') {
               console.log(`🚨 CSS MAX-WIDTH CONSTRAINT: ${svgStyle.maxWidth} is limiting SVG size`);
             }
             if (quiltSVG.parentElement.getBoundingClientRect().width < parseInt(quiltSVG.getAttribute('width'))) {
               console.log(`🚨 PARENT CONTAINER CONSTRAINT: Parent is ${quiltSVG.parentElement.getBoundingClientRect().width}px, smaller than SVG ${quiltSVG.getAttribute('width')}px`);
             }
           } else {
             console.log(`✅ NO SCALING: SVG size matches attributes - blocks should appear correctly as 46px`);
           }
         }, 500);
         
         // Skip dynamic bounds calculation entirely - handle empty state
         if (engineState.colors.length === 0) {
           console.log('🎨 DEBUG: No colors to render');
           return;
         }
         
         // Calculate how efficiently we're using screen space
         const spaceEfficiency = ((canvasWidth / screenWidth) * 100).toFixed(1);
         console.log(`📏 SPACE EFFICIENCY: Using ${canvasWidth}px of ${screenWidth}px screen (${spaceEfficiency}%)`);
         
                  // MOBILE-FIRST: Calculate available height by measuring actual DOM elements
         const availableHeight = this.calculateAvailableCanvasHeight();
         
         // MAXIMIZE ABOVE THE FOLD: Leave room only for essential UI elements
         const topSpaceNeeded = 120; // Text + positioning (keep same to preserve text)
         const bottomSpaceNeeded = 80; // Reduced to push UI elements down and make canvas taller
         const targetCanvasHeight = availableHeight - topSpaceNeeded - bottomSpaceNeeded; 
         
         console.log(`📱 FIXED CANVAS: Using ${targetCanvasHeight}px of ${availableHeight}px available height (${topSpaceNeeded + bottomSpaceNeeded}px reserved for UI)`);
          
                            // FIXED CANVAS: Use optimal fixed height regardless of content
         const canvasHeight = targetCanvasHeight;
         
         console.log(`📱 🎯 FIXED CANVAS SIZE: ${canvasWidth}px × ${canvasHeight}px - OPTIMAL FOR ALL DEVICES`);
         console.log(`📐 ASPECT RATIO: ${(canvasHeight/canvasWidth).toFixed(2)}:1 ${canvasHeight > canvasWidth ? '(TALL ✅)' : '(WIDE ❌)'}`);
         
         // Setup SVG with fixed optimal canvas size
         quiltSVG.innerHTML = '';
         console.log('🎨 DEBUG: Cleared SVG content');
         
                  // FIXED LAYOUT: Use our calculated optimal dimensions
         const finalHeight = canvasHeight;
         
         // FULL-WIDTH SVG: Make the coordinate system match the container
         const svgWidth = screenWidth - (sideMargin * 2); // Make canvas narrower to show side margins (sideMargin defined earlier)
         const svgHeight = finalHeight; // Keep calculated height
         
         // FIX COORDINATE MISMATCH: Make content coordinates match container size
         const finalWidth = svgWidth; // Content coordinate system = container size
          
         // DEBUG: Log what we're trying to set vs what actually happens
         console.log(`🔧 SETTING SVG: width=${finalWidth}px, height=${finalHeight}px`);
         
         console.log(`🔧 ABOUT TO SET: svgWidth=${svgWidth}, svgHeight=${svgHeight}, finalWidth=${finalWidth}, finalHeight=${finalHeight}`);
         
         quiltSVG.setAttribute('width', svgWidth);
         // REMOVED: height attribute - let CSS height: 80vh take control!
         quiltSVG.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
         
         console.log(`🔧 AFTER SETTING: width attr="${quiltSVG.getAttribute('width')}", height attr="${quiltSVG.getAttribute('height')}"`);
         console.log(`🔧 FULL-WIDTH SVG: container=${svgWidth}px, content=${finalWidth}px, viewBox="0 0 ${svgWidth} ${svgHeight}"`);
         console.log(`🔧 VIEWBOX DEBUG: svgWidth=${svgWidth}, svgHeight=${svgHeight}, finalWidth=${finalWidth}, finalHeight=${finalHeight}`);
         
         // PROTECT AGAINST ATTRIBUTE CLEARING: Re-enforce periodically
         const protectAttributes = () => {
           if (quiltSVG.getAttribute('width') !== svgWidth.toString()) {
             console.log(`🛡️ RESTORING CLEARED ATTRIBUTES: Re-setting width=${svgWidth} (height controlled by CSS)`);
             quiltSVG.setAttribute('width', svgWidth);
             // REMOVED: height protection - let CSS height: 80vh control it!
             quiltSVG.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
           }
         };
         
         // Set up protection
         setTimeout(protectAttributes, 100);
         setTimeout(protectAttributes, 300);
         setTimeout(protectAttributes, 600);
         setTimeout(protectAttributes, 1000);
         
         // NUCLEAR OPTION: Force the SVG size no matter what
         quiltSVG.style.cssText = `
           width: ${svgWidth}px !important;
           height: ${svgHeight}px !important;
           max-width: none !important;
           min-width: auto !important;
           max-height: none !important;
           min-height: auto !important;
           margin: 0 !important;
           padding: 0 !important;
           border: 5px solid orange !important; /* DEBUG: SVG container */
         `;
         
         // Also try setting it directly
         quiltSVG.setAttribute('style', quiltSVG.style.cssText);
         
         // DEBUG: Check what actually got applied
         setTimeout(() => {
           const computedStyle = window.getComputedStyle(quiltSVG);
           const actualWidth = quiltSVG.getBoundingClientRect().width;
           const actualHeight = quiltSVG.getBoundingClientRect().height;
           console.log(`🔍 ACTUAL SVG: computed width=${computedStyle.width}, computed height=${computedStyle.height}`);
           console.log(`🔍 MEASURED SVG: actual width=${actualWidth}px, actual height=${actualHeight}px`);
           console.log(`🔍 OVERRIDE CHECK: ${finalWidth}px requested vs ${actualWidth}px actual = ${finalWidth === actualWidth ? 'MATCH ✅' : 'MISMATCH ❌'}`);
         }, 100);
          
          console.log(`📱 SVG ATTRIBUTES: width=${finalWidth}px, height=${finalHeight}px (using full viewport!)`);
          console.log(`📱 SVG VIEWBOX: 0 0 ${finalWidth} ${finalHeight}`);
          console.log('🔧 AGGRESSIVE HEIGHT FORCING: Applied !important styles to prevent CSS override');
          console.log(`🔧 AGGRESSIVE HEIGHT FORCING: Applied style.cssText: ${quiltSVG.style.cssText}`);
          console.log(`🔧 AGGRESSIVE HEIGHT FORCING: Computed style height: ${window.getComputedStyle(quiltSVG).height}`);
          console.log(`🔧 AGGRESSIVE HEIGHT FORCING: Computed style width: ${window.getComputedStyle(quiltSVG).width}`);
          
          // Height monitor is now debug-only - run manually with startHeightMonitor() if needed
          console.log('🔍 Height monitor available for debugging: startHeightMonitor() / stopHeightMonitor()');
          
          // Verify we're using the viewport space properly
          const usagePercent = Math.round((finalHeight / availableHeight) * 100);
          console.log(`📱 ✅ VIEWPORT USAGE: ${usagePercent}% of available height (${finalHeight}px / ${availableHeight}px)`);
          
                   // Add background with DEBUG BORDER
         const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         background.setAttribute('width', '100%');
         background.setAttribute('height', '100%');
         background.setAttribute('fill', '#f6f4f1');
         background.setAttribute('stroke', 'red');
         background.setAttribute('stroke-width', '3');
         quiltSVG.appendChild(background);
         console.log('🎨 DEBUG: Added background with RED BORDER');
         
         // Add column highlight animation for new blocks
         this.addColumnHighlightAnimation = (colorFamily, x, y, scale) => {
           const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
           highlight.setAttribute('x', x - 5);
           highlight.setAttribute('y', y - 5);
           highlight.setAttribute('width', scale + 10);
           highlight.setAttribute('height', scale + 10);
           highlight.setAttribute('fill', 'rgba(255, 255, 255, 0.3)');
           highlight.setAttribute('stroke', 'rgba(255, 255, 255, 0.6)');
           highlight.setAttribute('stroke-width', '2');
           highlight.setAttribute('rx', '4');
           
           // Fade in and out animation
           const fadeIn = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           fadeIn.setAttribute('attributeName', 'opacity');
           fadeIn.setAttribute('values', '0; 1; 0');
           fadeIn.setAttribute('dur', '2s');
           fadeIn.setAttribute('begin', '0s');
           fadeIn.setAttribute('fill', 'freeze');
           highlight.appendChild(fadeIn);
           
           quiltSVG.appendChild(highlight);
           
           // Remove highlight after animation
           setTimeout(() => {
             if (highlight.parentNode) {
               highlight.parentNode.removeChild(highlight);
             }
           }, 2000);
         };
         
         // DEBUG: Check what the red background actually represents
         setTimeout(() => {
           // Prevent multiple debug runs
           if (window.debugAlreadyRan) return;
           window.debugAlreadyRan = true;
           const bgRect = background.getBoundingClientRect();
           console.log(`🔴 RED BACKGROUND: ${bgRect.width}px × ${bgRect.height}px (actual rendered size)`);
           console.log(`🔴 RED vs SCREEN: ${bgRect.width}px background vs ${screenWidth}px screen width`);
           console.log(`🔧 SVG ATTRIBUTE: data-time-based-active="${quiltSVG.getAttribute('data-time-based-active')}"`);
           console.log(`🔧 SVG ID: "${quiltSVG.id}"`);
           
           // CHECK ASPECT RATIO: Compare calculated vs actual
           const actualAspectRatio = (bgRect.height / bgRect.width).toFixed(2);
           const expectedAspectRatio = (canvasHeight / canvasWidth).toFixed(2);
           console.log(`📐 EXPECTED: ${canvasWidth}×${canvasHeight} (${expectedAspectRatio}:1)`);
           console.log(`📐 ACTUAL: ${bgRect.width.toFixed(1)}×${bgRect.height.toFixed(1)} (${actualAspectRatio}:1)`);
           console.log(`📐 MATCH: ${actualAspectRatio === expectedAspectRatio ? '✅ Perfect' : '❌ CSS Scaling Issue'}`);
           
           // DEBUG POSITIONING: Where is everything located?
           const svgRect = quiltSVG.getBoundingClientRect();
           console.log(`📍 SVG POSITION: top=${svgRect.top}px, left=${svgRect.left}px, bottom=${svgRect.bottom}px`);
           console.log(`📍 SVG DIMENSIONS: ${svgRect.width.toFixed(1)}×${svgRect.height.toFixed(1)} (${(svgRect.height/svgRect.width).toFixed(2)}:1)`);
           console.log(`📍 SVG VISUAL CHECK: ${svgRect.height > svgRect.width ? 'TALL ✅' : 'WIDE/SQUARE ❌'}`);
           console.log(`📍 VIEWPORT: height=${window.innerHeight}px, width=${window.innerWidth}px`);
           console.log(`📍 CLIPPING CHECK: SVG top=${svgRect.top}px ${svgRect.top < 0 ? '❌ CUT OFF TOP' : '✅ VISIBLE'}`);
           console.log(`📍 SCREEN USAGE: SVG bottom=${svgRect.bottom}px vs screen=${window.innerHeight}px`);
           
           // 🚨 NEW: BUTTON POSITION DEBUGGING
           console.log('\n🔍 === TRUE FOLD CALCULATION ===');
           
           // Calculate different fold measurements
           const viewportHeight = window.innerHeight;
           const documentHeight = document.documentElement.scrollHeight;
           const currentScroll = window.scrollY;
           const visibleBottom = currentScroll + viewportHeight;
           
           console.log(`📱 VIEWPORT HEIGHT: ${viewportHeight}px (device screen)`);
           console.log(`📄 DOCUMENT HEIGHT: ${documentHeight}px (total content)`);
           console.log(`📍 CURRENT SCROLL: ${currentScroll}px`);
           console.log(`👁️ VISIBLE BOTTOM: ${visibleBottom}px (what user sees at bottom)`);
           console.log(`🔍 CONTENT OVERFLOW: ${documentHeight > viewportHeight ? (documentHeight - viewportHeight) + 'px LONGER than screen' : 'fits on screen'}`);
           
           // The TRUE fold is the bottom of the viewport (what's visible without scrolling)
           const trueFold = viewportHeight; // The actual bottom of what users see on page load
           console.log(`📱 TRUE FOLD (actual): ${trueFold}px (bottom of visible area without scrolling)`);
           
           const foldLine = trueFold; // Use actual viewport bottom as fold line
           
           // 🚨 ADD VISUAL FOLD LINE - positioned at TRUE FOLD LINE
           let foldMarker = document.getElementById('fold-line-marker');
           if (!foldMarker) {
             foldMarker = document.createElement('div');
             foldMarker.id = 'fold-line-marker';
             foldMarker.style.cssText = `
               position: fixed;
               top: ${trueFold}px;
               left: 0;
               width: 100vw;
               height: 8px;
               background: red;
               z-index: 9999;
               pointer-events: none;
               box-shadow: 0 0 15px red;
               border: 2px solid darkred;
             `;
             document.body.appendChild(foldMarker);
             console.log(`🔴 FOLD LINE MARKER: Added red line at 90% of viewport (highly visible)`);
           }
           
           // Check each button position
           const buttons = ['testAddBlock', 'showMyPieceBtn', 'testDifferentUserBtn'];
           buttons.forEach(btnId => {
             const btn = document.getElementById(btnId);
             if (btn) {
               const btnRect = btn.getBoundingClientRect();
               const isAboveFold = btnRect.top < foldLine;
               console.log(`🔘 ${btnId}: top=${btnRect.top.toFixed(1)}px ${isAboveFold ? '❌ ABOVE FOLD' : '✅ BELOW FOLD'}`);
             }
           });
           
           // Check SVG bottom vs first button top
           const firstBtn = document.getElementById('testAddBlock');
           if (firstBtn) {
             const btnRect = firstBtn.getBoundingClientRect();
             const gapSize = btnRect.top - svgRect.bottom;
             console.log(`📏 GAP: SVG bottom=${svgRect.bottom.toFixed(1)}px → Button top=${btnRect.top.toFixed(1)}px (gap=${gapSize.toFixed(1)}px)`);
           
           // 🚨 SVG HEIGHT OVERRIDE DEBUG
           const expectedVh = Math.round(window.innerHeight * 0.8);
           console.log(`🎯 EXPECTED 80vh: ${expectedVh}px vs ACTUAL SVG: ${svgRect.height.toFixed(1)}px`);
           console.log(`🎯 HEIGHT DIFFERENCE: ${(expectedVh - svgRect.height).toFixed(1)}px missing!`);
           
           // Check CSS vs SVG attributes
           const svgStyle = window.getComputedStyle(quiltSVG);
           console.log(`🎨 CSS HEIGHT: ${svgStyle.height}`);
           console.log(`🎨 SVG ATTR HEIGHT: ${quiltSVG.getAttribute('height')}px`);
           console.log(`🎨 CSS MAX-HEIGHT: ${svgStyle.maxHeight}`);
           
           // 🚨 CSS OVERRIDE DEBUGGING
           console.log(`🔍 CSS DEBUGGING:`);
           console.log(`   data-time-based-active: ${quiltSVG.getAttribute('data-time-based-active')}`);
           console.log(`   CSS display: ${svgStyle.display}`);
           console.log(`   CSS position: ${svgStyle.position}`);
           console.log(`   CSS flex-grow: ${svgStyle.flexGrow}`);
           console.log(`   CSS min-height: ${svgStyle.minHeight}`);
           
           // 🔍 DEEP DEBUG: What's preventing SVG height expansion?
           console.log(`🔍 === SVG HEIGHT CONSTRAINT ANALYSIS ===`);
           
           // Check if viewBox is constraining height
           const viewBox = quiltSVG.getAttribute('viewBox');
           console.log(`📐 ViewBox: ${viewBox}`);
           
           // Check all parent elements for height constraints
           let currentElement = quiltSVG;
           let level = 0;
           while (currentElement && level < 5) {
             const styles = window.getComputedStyle(currentElement);
             const rect = currentElement.getBoundingClientRect();
             console.log(`🔗 Level ${level} (${currentElement.tagName}#${currentElement.id}): height=${styles.height}, maxHeight=${styles.maxHeight}, overflow=${styles.overflow}, actualHeight=${rect.height.toFixed(1)}px`);
             currentElement = currentElement.parentElement;
             level++;
           }
           
           // 🎯 UNIVERSAL RESPONSIVE HEIGHT: Works on any device size
           const originalViewBox = quiltSVG.getAttribute('viewBox');
           
           // Calculate text space dynamically by measuring actual elements
           const phaseIndicator = document.getElementById('phase-indicator');
           const countMessage = document.getElementById('community-message');
           
           let actualTextHeight = 0;
           if (phaseIndicator) actualTextHeight += phaseIndicator.getBoundingClientRect().height;
           if (countMessage) actualTextHeight += countMessage.getBoundingClientRect().height;
           
           // Add some breathing room (20px margins)
           const textSpaceAbove = Math.ceil(actualTextHeight) + 40; 
           
           // Calculate height to fill viewport but ensure buttons go below fold
           const availableSpace = viewportHeight - textSpaceAbove;
           // Use 90% for maximum canvas space while keeping buttons below fold
           const optimalHeight = Math.floor(availableSpace * 0.90);
           
           const newViewBox = `0 0 380 ${optimalHeight}`;
           quiltSVG.setAttribute('viewBox', newViewBox);
           quiltSVG.style.height = `${optimalHeight}px`;
           
           console.log(`📱 UNIVERSAL CALC: viewport=${viewportHeight}px, textSpace=${textSpaceAbove}px, available=${availableSpace}px`);
           console.log(`🎯 OPTIMAL HEIGHT: ${optimalHeight}px (90% of available space - maximum canvas)`);
           console.log(`🎯 RESPONSIVE CHECK: ${optimalHeight + textSpaceAbove <= viewportHeight ? '✅ Fits any viewport' : '❌ Calculation error'}`);
           console.log(`🔧 FIXED ViewBox: ${originalViewBox} → ${newViewBox}`);
           
           // 🚨 HEIGHT CONSTRAINT DEBUG: What's preventing height changes?
           console.log('\n🔍 === HEIGHT CONSTRAINT DEBUG ===');
           setTimeout(() => {
             const actualRect = quiltSVG.getBoundingClientRect();
             const actualStyle = window.getComputedStyle(quiltSVG);
             console.log(`📏 CALCULATED: ${optimalHeight}px`);
             console.log(`📏 ACTUAL: ${actualRect.height.toFixed(1)}px`);
             console.log(`📏 DIFFERENCE: ${(actualRect.height - optimalHeight).toFixed(1)}px ${actualRect.height === optimalHeight ? '✅ MATCH' : '❌ CONSTRAINED'}`);
             console.log(`🎨 CSS height: ${actualStyle.height}`);
             console.log(`🎨 CSS max-height: ${actualStyle.maxHeight}`);
             console.log(`🎨 CSS min-height: ${actualStyle.minHeight}`);
             console.log(`📐 ViewBox: ${quiltSVG.getAttribute('viewBox')}`);
             
             // Check parent constraints
             const parent = quiltSVG.parentElement;
             const parentStyle = window.getComputedStyle(parent);
             const parentRect = parent.getBoundingClientRect();
             console.log(`📦 PARENT (${parent.tagName}): height=${parentRect.height.toFixed(1)}px, maxHeight=${parentStyle.maxHeight}`);
           }, 50);
           
           // 🚨 WHITE SPACE DEBUG: Find what's creating the top spacing
           console.log('\n🔍 === WHITE SPACE DEBUG ===');
           
           // Check screen container position (reuse existing variable)
           const screenRect = document.getElementById('screen-quilt').getBoundingClientRect();
           const screenStyle = window.getComputedStyle(document.getElementById('screen-quilt'));
           console.log(`📦 SCREEN-QUILT: top=${screenRect.top}px, paddingTop=${screenStyle.paddingTop}, marginTop=${screenStyle.marginTop}`);
           
           // Check text element positions
           if (phaseIndicator) {
             const phaseRect = phaseIndicator.getBoundingClientRect();
             const phaseStyle = window.getComputedStyle(phaseIndicator);
             console.log(`📝 PHASE TEXT: top=${phaseRect.top}px, marginTop=${phaseStyle.marginTop}, paddingTop=${phaseStyle.paddingTop}`);
           }
           
           // Check canvas position
           const canvasRect = quiltSVG.getBoundingClientRect();
           const canvasStyle = window.getComputedStyle(quiltSVG);
           console.log(`🎨 CANVAS: top=${canvasRect.top}px, marginTop=${canvasStyle.marginTop}, paddingTop=${canvasStyle.paddingTop}`);
           
           // Calculate actual white space
           const whiteSpaceHeight = (phaseIndicator ? phaseIndicator.getBoundingClientRect().top : canvasRect.top) - screenRect.top;
           console.log(`⚠️ WHITE SPACE: ${whiteSpaceHeight.toFixed(1)}px between screen container and first content`);
           
           setTimeout(() => {
             const newRect = quiltSVG.getBoundingClientRect();
             console.log(`🎯 FINAL RESULT: SVG height = ${newRect.height.toFixed(1)}px (${newRect.height >= 750 ? '✅ SUCCESS!' : '❌ Still failed'})`);
             
             // Check if buttons moved below fold
             const testBtn = document.getElementById('testAddBlock');
             if (testBtn) {
               const btnRect = testBtn.getBoundingClientRect();
               const nowBelowFold = btnRect.top > window.innerHeight;
               console.log(`🔘 BUTTON RESULT: top=${btnRect.top.toFixed(1)}px ${nowBelowFold ? '✅ NOW BELOW FOLD!' : '❌ Still above fold'}`);
             }
           }, 100);
           
           // 🚨 ALSO FIX PARENT CONTAINERS
           const screenQuilt = document.getElementById('screen-quilt');
           const app = document.getElementById('app');
           
           if (screenQuilt) {
             screenQuilt.style.maxHeight = 'none';
             screenQuilt.style.height = 'auto';
             console.log(`🔧 FIXED SCREEN-QUILT: removed max-height constraints`);
           }
           
           if (app) {
             app.style.maxHeight = 'none';  
             app.style.height = 'auto';
             console.log(`🔧 FIXED APP: removed max-height constraints`);
           }
           
           console.log(`🔧 AFTER FORCE: height=${quiltSVG.style.height}, minHeight=${quiltSVG.style.minHeight}`);
           
           // Re-measure after forcing height
           setTimeout(() => {
             const newRect = quiltSVG.getBoundingClientRect();
             console.log(`🔧 NEW SVG HEIGHT: ${newRect.height.toFixed(1)}px (${newRect.height >= 700 ? '✅ SUCCESS' : '❌ STILL FAILED'})`);
             
             // Check button positions after height change
             const newBtn = document.getElementById('testAddBlock');
             if (newBtn) {
               const newBtnRect = newBtn.getBoundingClientRect();
               const nowBelowFold = newBtnRect.top >= window.innerHeight;
               console.log(`🔘 AFTER HEIGHT FIX: testAddBlock top=${newBtnRect.top.toFixed(1)}px ${nowBelowFold ? '✅ NOW BELOW FOLD!' : '❌ STILL ABOVE FOLD'}`);
             }
           }, 50);
           }
           
           // DEBUG CONTAINER PADDING: Check what's happening with spacing
           const screenQuilt = document.getElementById('screen-quilt');
           if (screenQuilt) {
             const screenRect = screenQuilt.getBoundingClientRect();
             const screenStyle = window.getComputedStyle(screenQuilt);
             console.log(`📦 SCREEN-QUILT: top=${screenRect.top}px, paddingTop=${screenStyle.paddingTop}`);
             console.log(`📦 SCREEN-QUILT: computed margin=${screenStyle.marginTop}, position=${screenStyle.position}`);
           }
           
           // DEBUG BODY/HTML: Check if something else is affecting top spacing
           const bodyStyle = window.getComputedStyle(document.body);
           const htmlStyle = window.getComputedStyle(document.documentElement);
           console.log(`📦 BODY: margin-top=${bodyStyle.marginTop}, padding-top=${bodyStyle.paddingTop}`);
           console.log(`📦 HTML: margin-top=${htmlStyle.marginTop}, padding-top=${htmlStyle.paddingTop}`);
           
           if (bgRect.width < screenWidth * 0.95) {
             console.log(`⚠️ RED BACKGROUND TOO NARROW: Only using ${(bgRect.width/screenWidth*100).toFixed(1)}% of screen width`);
           }
           
           // FIND THE CONSTRAINT: What's limiting the SVG width?
           let currentElement = quiltSVG;
           console.log(`🔍 CONSTRAINT HUNT:`);
           while (currentElement && currentElement !== document.body) {
             const rect = currentElement.getBoundingClientRect();
             const style = window.getComputedStyle(currentElement);
             console.log(`  ${currentElement.tagName}#${currentElement.id || 'no-id'}: ${rect.width}px (max-width: ${style.maxWidth})`);
             if (rect.width < screenWidth * 0.9) {
               console.log(`    🚨 THIS ELEMENT IS CONSTRAINING: ${rect.width}px < ${screenWidth * 0.9}px`);
             }
             currentElement = currentElement.parentElement;
           }
         }, 100);
          
                   // FULL-WIDTH POSITIONING: Spread columns across entire screen width
         const colorFamilies = ['reds', 'oranges', 'yellows', 'greens', 'blues', 'purples', 'magentas', 'neutrals'];
         const columnPositions = new Map();
         
         // CENTER CONTENT: Calculate how to center the 8-column layout in full-width canvas
         const quiltContentWidth = (numberOfColorFamilies * scale) + ((numberOfColorFamilies - 1) * targetSpacing);
         const startX = (svgWidth - quiltContentWidth) / 2; // Center the content horizontally
         
         console.log(`🎯 CENTERING: Content=${quiltContentWidth}px, SVG=${svgWidth}px, startX=${startX.toFixed(1)}px`);
         
         colorFamilies.forEach((family, index) => {
           const x = startX + (index * (scale + targetSpacing));
           columnPositions.set(family, x);
           console.log(`🎯 CENTERED COLUMN: ${family} → x=${x.toFixed(1)}px`);
         });
         
         // FIXED POSITIONING: Top padding and stacking for mobile
         const topPadding = 30; // Fixed top padding for clean mobile layout
         
         console.log(`🎯 FIXED LAYOUT: ${colorFamilies.length} columns @ ${scale}px blocks + ${targetSpacing}px spacing`);
         console.log(`🎯 MOBILE POSITIONING: ${sidePadding}px side padding + ${topPadding}px top padding`);
         console.log(`📱 OPTIMAL: Fixed ${scale}px blocks - perfect for touch interaction`);
          
                   // FIXED POSITIONING: Render colors using predefined column layout
         console.log(`🎨 DEBUG: About to render ${engineState.colors.length} colors with fixed positioning`);
         
         // Group colors by family and stack them in their fixed columns
         const familyStacks = new Map();
         colorFamilies.forEach(family => familyStacks.set(family, []));
         
         // Sort colors into their family stacks
         engineState.colors.forEach(colorObj => {
           const family = colorObj.position.colorFamily || 'neutrals';
           if (familyStacks.has(family)) {
             familyStacks.get(family).push(colorObj);
           } else {
             familyStacks.get('neutrals').push(colorObj); // Fallback to neutrals
           }
         });
         
         // Render each family stack in its fixed column
         familyStacks.forEach((familyColors, family) => {
           if (familyColors.length === 0) return;
           
           const columnX = columnPositions.get(family);
           console.log(`🎨 COLUMN: ${family} (${familyColors.length} colors) → x=${columnX}px`);
           
           // COLUMN-LEVEL COMPRESSION: Calculate if this column needs compression
           const totalBlocksInColumn = familyColors.length;
           const baseOverlap = 0.2; // Start with 20% overlap for all blocks
           const maxCompression = 0.75; // Maximum compression when column hits bottom
           
           // Calculate natural column height with base overlap
           const naturalColumnHeight = (totalBlocksInColumn * scale * (1 - baseOverlap)) + topPadding;
           const availableColumnHeight = canvasHeight - topPadding;
           
           // Determine compression needed for this entire column
           let columnOverlap = baseOverlap;
           if (naturalColumnHeight > availableColumnHeight && totalBlocksInColumn > 1) {
             // Column is too tall - calculate compression needed
             const neededHeight = availableColumnHeight - topPadding;
             const requiredSpacing = neededHeight / totalBlocksInColumn;
             columnOverlap = Math.max(baseOverlap, Math.min(maxCompression, 1 - (requiredSpacing / scale)));
           }
           
           console.log(`📏 COLUMN ${family}: ${totalBlocksInColumn} blocks, overlap=${(columnOverlap*100).toFixed(1)}%`);

           familyColors.forEach((colorObj, stackIndex) => {
             // FIXED COLUMN POSITIONING: Use predefined column X and stack Y
             const baseX = columnX;
             
             // UNIFORM COLUMN OVERLAP: All blocks in this column use same overlap
             const baseY = topPadding + (stackIndex * scale * (1 - columnOverlap));
             
             // ORGANIC JITTER: Add small random offsets for hand-placed feel
             const jitterAmount = 3; // Small jitter for subtle organic effect
             const jitterX = (Math.random() - 0.5) * jitterAmount * 2; // -3 to +3px
             const jitterY = (Math.random() - 0.5) * jitterAmount * 2; // -3 to +3px
             
             // ORGANIC ROTATION: Add subtle random rotation for hand-placed feel
             const rotationAmount = 4; // Max 4 degrees rotation
             const rotation = (Math.random() - 0.5) * rotationAmount * 2; // -4 to +4 degrees
             
             const x = baseX + jitterX;
             const y = baseY + jitterY;
             
             console.log(`🎨 FIXED POS: ${colorObj.color} → column=${family}, stack=${stackIndex}, xy=(${x}, ${y.toFixed(1)})`);
             
             // Create group for stacking effects (collection phase)
             const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
             
             // Apply organic positioning and rotation
             const centerX = x + scale/2; // Center of the block for rotation
             const centerY = y + scale/2;
             group.setAttribute('transform', `translate(${x}, ${y}) rotate(${rotation.toFixed(1)}, ${scale/2}, ${scale/2})`);
             
                        // Collection phase: quilter's workspace stacking
           if (engineState.phase === 'collection' && colorObj.position.isStacked) {
             this.renderStackedBlock(group, colorObj, 0, 0, scale, stackIndex); // Group handles positioning
           } else if (engineState.phase === 'pattern_filling' && engineState.pattern) {
             // Pattern filling phase: use pattern-based positioning
             this.renderPatternBlock(group, colorObj, 0, 0, scale, stackIndex);
           } else {
             // Standard rendering for other phases
             this.renderStandardBlock(group, colorObj, 0, 0, scale, stackIndex); // Group handles positioning
           }
             
             quiltSVG.appendChild(group);
             console.log(`🎨 DEBUG: Added ${engineState.phase} styled block for color ${colorObj.color}`);
           });
         });
           
           console.log('🎨 DEBUG: Finished rendering all colors');
           console.log('🎨 DEBUG: Final SVG children count:', quiltSVG.children.length);
           
           // Show queued colors if in pattern_selection phase
           if (engineState.phase === 'pattern_selection' && engineState.queuedColors.length > 0) {
             const queuedGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
             
             // Background for queued area
             const queueBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
             queueBg.setAttribute('x', '10');
             queueBg.setAttribute('y', '10');
             queueBg.setAttribute('width', '200');
             queueBg.setAttribute('height', '40');
             queueBg.setAttribute('fill', 'rgba(0, 0, 0, 0.1)');
             queueBg.setAttribute('rx', '5');
             queuedGroup.appendChild(queueBg);
             
             // Queue text
             const queueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             queueText.setAttribute('x', '15');
             queueText.setAttribute('y', '25');
             queueText.setAttribute('font-family', 'Arial, sans-serif');
             queueText.setAttribute('font-size', '12');
             queueText.setAttribute('fill', '#000');
             queueText.textContent = `Analyzing ${engineState.queuedColors.length} colors...`;
             queuedGroup.appendChild(queueText);
             
             // Show queued colors as small squares
             engineState.queuedColors.forEach((color, index) => {
               const queueRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
               queueRect.setAttribute('x', 15 + index * 20);
               queueRect.setAttribute('y', '32');
               queueRect.setAttribute('width', '15');
               queueRect.setAttribute('height', '15');
               queueRect.setAttribute('fill', color);
               queueRect.setAttribute('stroke', '#000');
               queueRect.setAttribute('stroke-width', '0.5');
               queuedGroup.appendChild(queueRect);
             });
             
             quiltSVG.appendChild(queuedGroup);
           }
           
           // Show current pattern info
           if (engineState.pattern) {
             const patternText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             patternText.setAttribute('x', '450');
             patternText.setAttribute('y', '25');
             patternText.setAttribute('font-family', 'Arial, sans-serif');
             patternText.setAttribute('font-size', '14');
             patternText.setAttribute('font-weight', 'bold');
             patternText.setAttribute('fill', '#333');
             patternText.textContent = `Pattern: ${engineState.pattern}`;
             quiltSVG.appendChild(patternText);
           }
           
           
           
           
           
           this.logger.log(`Time-based quilt rendered: ${engineState.colors.length} colors, pattern: ${engineState.pattern}`);
           this.logger.log(`🔍 DEBUG: Current phase: ${engineState.phase}, Pattern: ${engineState.pattern}, Pattern filling: ${engineState.phase === 'pattern_filling' && engineState.pattern}`);
         }

         // Helper method: Render stacked blocks for collection phase (quilter's workspace)
         renderStackedBlock(group, colorObj, x, y, scale, index) {
           const stackLevel = colorObj.position.stackLevel || 0;
           const colorFamily = colorObj.position.colorFamily || 'unknown';
           
           // Calculate block dimensions first
           const blockWidth = Math.max(scale - 2, 5);
           const blockHeight = Math.max(scale - 2, 5);
           const wobbleAmount = Math.max(3, scale * 0.15); // Increased wobble for more visible irregularity
           
           // Create drop shadow for depth (more prominent for larger blocks)
           const shadowOffset = Math.max(2, scale * 0.08); // Scale shadow with block size
           const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
           
           // Generate irregular shadow path with subtle wobble
           const shadowPathData = this.createIrregularBlockPath(x + shadowOffset, y + shadowOffset, blockWidth, blockHeight, wobbleAmount);
           shadow.setAttribute('d', shadowPathData);
           shadow.setAttribute('fill', 'rgba(0, 0, 0, 0.2)'); // Slightly more prominent
           group.appendChild(shadow);
           
           // Main color block with irregular wobble
           
           if (window.debugBlockRendering) {
             console.log(`🎨 RENDERING: Block scale=${scale} → size=${blockWidth}×${blockHeight} at (${x}, ${y})`);
           }
           
           // Create irregular block shape with subtle wobble
           const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
           
           // Generate irregular path with subtle wobble
           const pathData = this.createIrregularBlockPath(x, y, blockWidth, blockHeight, wobbleAmount);
           path.setAttribute('d', pathData);
           path.setAttribute('fill', colorObj.color);
           
           // Stacking opacity: lower in stack = more transparent
           const stackOpacity = Math.max(0.6, 1 - (stackLevel * 0.1));
           path.setAttribute('opacity', stackOpacity);
           
           // Soft border that gets lighter for stacked pieces (scale with block size)
           const borderColor = stackLevel > 0 ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.2)';
           const strokeWidth = Math.max(0.5, scale * 0.02); // Scale stroke with block size
           path.setAttribute('stroke', borderColor);
           path.setAttribute('stroke-width', strokeWidth);
           
           // Enhanced settling animation for new blocks (scale with block size)
           const dropDistance = Math.max(10, scale * 0.2); // Scale drop distance
           const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');
           animate.setAttribute('attributeName', 'transform');
           animate.setAttribute('type', 'translate');
           animate.setAttribute('values', `0,-${dropDistance}; 0,0`); // Gentle drop scaled to block size
           animate.setAttribute('dur', '1.2s');
           animate.setAttribute('begin', '0s');
           animate.setAttribute('fill', 'freeze');
           path.appendChild(animate);
           
           // Enhanced opacity fade-in with subtle bounce
           const fadeIn = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           fadeIn.setAttribute('attributeName', 'opacity');
           fadeIn.setAttribute('values', `0; ${stackOpacity * 1.2}; ${stackOpacity}`); // Slight overshoot then settle
           fadeIn.setAttribute('dur', '1.2s');
           fadeIn.setAttribute('begin', '0s');
           fadeIn.setAttribute('fill', 'freeze');
           path.appendChild(fadeIn);
           
           // Add subtle glow effect for new blocks
           const glow = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           glow.setAttribute('attributeName', 'stroke-width');
           glow.setAttribute('values', `${strokeWidth * 3}; ${strokeWidth}`); // Glow then settle
           glow.setAttribute('dur', '1.5s');
           glow.setAttribute('begin', '0s');
           glow.setAttribute('fill', 'freeze');
           path.appendChild(glow);
           
           // Add highlight color animation
           const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           highlight.setAttribute('attributeName', 'stroke');
           highlight.setAttribute('values', `rgba(255, 255, 255, 0.8); ${borderColor}`); // White highlight then normal
           highlight.setAttribute('dur', '1.5s');
           highlight.setAttribute('begin', '0s');
           highlight.setAttribute('fill', 'freeze');
           path.appendChild(highlight);
           
           group.appendChild(path);
           
           // Trigger column highlight animation for new blocks
           if (window.app && window.app.addColumnHighlightAnimation) {
             window.app.addColumnHighlightAnimation(colorFamily, x, y, scale);
           }
           
         }

         // Helper method: Create irregular block path with visible wobble
         createIrregularBlockPath(x, y, width, height, wobbleAmount) {
           // Create more pronounced irregularity with multiple variation points per side
           const topVariations = [
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2
           ];
           const rightVariations = [
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2
           ];
           const bottomVariations = [
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2
           ];
           const leftVariations = [
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2,
             Math.random() * wobbleAmount - wobbleAmount/2
           ];
           
           // Generate path with irregular edges - each side has multiple variation points
           const path = [
             `M ${x + topVariations[0]} ${y + topVariations[0]}`, // Top-left with variation
             `L ${x + width/3 + topVariations[1]} ${y + topVariations[1]}`, // Top middle-left
             `L ${x + width*2/3 + topVariations[2]} ${y + topVariations[2]}`, // Top middle-right
             `L ${x + width + rightVariations[0]} ${y + rightVariations[0]}`, // Top-right
             `L ${x + width + rightVariations[1]} ${y + height/3 + rightVariations[1]}`, // Right middle-top
             `L ${x + width + rightVariations[2]} ${y + height*2/3 + rightVariations[2]}`, // Right middle-bottom
             `L ${x + width + bottomVariations[0]} ${y + height + bottomVariations[0]}`, // Bottom-right
             `L ${x + width*2/3 + bottomVariations[1]} ${y + height + bottomVariations[1]}`, // Bottom middle-right
             `L ${x + width/3 + bottomVariations[2]} ${y + height + bottomVariations[2]}`, // Bottom middle-left
             `L ${x + leftVariations[0]} ${y + height + leftVariations[0]}`, // Bottom-left
             `L ${x + leftVariations[1]} ${y + height*2/3 + leftVariations[1]}`, // Left middle-bottom
             `L ${x + leftVariations[2]} ${y + height/3 + leftVariations[2]}`, // Left middle-top
             'Z' // Close path
           ].join(' ');
           
           return path;
         }
         
         // Helper method: Standard block rendering for non-collection phases
         renderStandardBlock(group, colorObj, x, y, scale, index) {
           // DEBUG: Log standard block size calculation
           const blockWidth = Math.max(scale - 2, 5);
           const blockHeight = Math.max(scale - 2, 5);
           if (window.debugBlockRendering) {
             console.log(`🎨 STANDARD BLOCK: scale=${scale} → size=${blockWidth}×${blockHeight} at (${x}, ${y})`);
           }
           
           // Create irregular block shape with more visible wobble
           const wobbleAmount = Math.max(3, scale * 0.15); // Increased wobble for more visible irregularity
           const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
           
           // Generate irregular path with subtle wobble
           const pathData = this.createIrregularBlockPath(x, y, blockWidth, blockHeight, wobbleAmount);
           path.setAttribute('d', pathData);
           path.setAttribute('fill', colorObj.color);
           path.setAttribute('stroke', '#000');
           path.setAttribute('stroke-width', '0.5');
           path.setAttribute('opacity', '0.9');
           
           // Enhanced scale animation for new pieces with glow
           const animate = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');
           animate.setAttribute('attributeName', 'transform');
           animate.setAttribute('type', 'scale');
           animate.setAttribute('values', '0;1.3;1'); // Slightly more dramatic scale
           animate.setAttribute('dur', '1s');
           animate.setAttribute('begin', '0s');
           animate.setAttribute('fill', 'freeze');
           path.appendChild(animate);
           
           // Add glow effect for new pieces
           const glow = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           glow.setAttribute('attributeName', 'stroke-width');
           glow.setAttribute('values', '2; 0.5'); // Glow then settle
           glow.setAttribute('dur', '1.2s');
           glow.setAttribute('begin', '0s');
           glow.setAttribute('fill', 'freeze');
           path.appendChild(glow);
           
           // Add highlight color animation
           const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
           highlight.setAttribute('attributeName', 'stroke');
           highlight.setAttribute('values', 'rgba(255, 255, 255, 0.9); #000'); // White highlight then normal
           highlight.setAttribute('dur', '1.2s');
           highlight.setAttribute('begin', '0s');
           highlight.setAttribute('fill', 'freeze');
           path.appendChild(highlight);
           
           group.appendChild(path);
           
           // Trigger highlight animation for new standard blocks
           if (window.app && window.app.addColumnHighlightAnimation) {
             window.app.addColumnHighlightAnimation('standard', x, y, scale);
           }
         }
         
         // Helper method: Render pattern-based blocks for pattern filling phase
         renderPatternBlock(group, colorObj, x, y, scale, index) {
           // Use the same irregular block rendering as standard blocks
           this.renderStandardBlock(group, colorObj, x, y, scale, index);
         }

         showPhaseMessage(result) {
           const engineState = this.timeBasedEngine.getState();
           const totalColors = engineState.colors.length + engineState.queuedColors.length;
           let message = '';
           
           switch (result.phase) {
             case 'collection':
               // Check column-specific compression status
               const compressedCols = new Set();
               const uncompressedCols = new Set();
               
               engineState.colors.forEach(colorObj => {
                 const family = colorObj.position.colorFamily;
                 if (colorObj.position.compressionLevel === 'none') {
                   uncompressedCols.add(family);
                 } else if (colorObj.position.compressionLevel !== undefined) {
                   compressedCols.add(family);
                 }
               });
               
               // Check if mobile optimization is active  
               const hasCompressedColumns = engineState.colors.some(colorObj => {
                 return colorObj.position.overlapFactor && colorObj.position.overlapFactor <= 0.45;
               });
               
               if (compressedCols.size > 0) {
                 if (uncompressedCols.size > 0) {
                   message = `Column compressed! ${compressedCols.size} of ${compressedCols.size + uncompressedCols.size} columns optimized... (${totalColors} colors)`;
                 } else {
                   message = `All columns compressed! Mobile-optimized... (${totalColors} colors)`;
                 }
               } else if (hasCompressedColumns) {
                 message = `Color stacked! Mobile-optimized workspace... (${totalColors} colors)`;
               } else {
                 message = `Color added! Collecting in family columns... (${totalColors} colors)`;
               }
               break;
             case 'pattern_selection':
               if (engineState.pattern) {
                 message = `Color queued! Organizing into ${engineState.pattern} pattern... (${totalColors} colors)`;
               } else {
                 message = `Color queued! Analyzing ${engineState.queuedColors.length} colors for pattern... (${totalColors} colors)`;
               }
               break;
             case 'pattern_filling':
               message = `Color placed in ${engineState.pattern} pattern! (${totalColors} colors)`;
               break;
             case 'finalization':
               message = `Perfect finishing touch added to the ${engineState.pattern}! (${totalColors} colors)`;
               break;
             default:
               message = 'Color added to the community quilt!';
           }
           
                     // this.uiService.showToast(message); // Toast removed
        }

        // MOBILE-FIRST: Dynamic compression helper methods for fitting quilt in viewport
        calculateAvailableCanvasHeight() {
          try {
            // Simple, reliable calculation instead of complex DOM measurement
            const viewportHeight = window.innerHeight;
            console.log(`📱 DEBUG: Viewport height = ${viewportHeight}px`);
            
            // MAXIMIZE CANVAS: Only phase text + count text above canvas, all buttons below!
            // Above fold: "Cutting up squares til noon!" + "X squares today and counting!" 
            const estimatedUIHeight = 80; // Minimal text-only UI above canvas
            
            const availableHeight = viewportHeight - estimatedUIHeight;
            console.log(`📱 SIMPLE CALC: viewport ${viewportHeight}px - estimated UI ${estimatedUIHeight}px = ${availableHeight}px available for canvas`);
            
            return Math.max(300, availableHeight); // Minimum 300px canvas for proper testing
          } catch (error) {
            console.warn('Height calculation failed, using fallback:', error);
            const fallback = Math.max(300, window.innerHeight - 170);
            console.log(`📱 FALLBACK HEIGHT: ${fallback}px`);
            return fallback;
          }
        }

        applyDynamicCompression(colors, targetHeight, scale) {
          if (!colors || colors.length === 0) return false;
          
          // Group colors by their columns for individual column analysis
          const columnGroups = new Map();
          colors.forEach(colorObj => {
            const family = colorObj.position.colorFamily || 'unknown';
            if (!columnGroups.has(family)) {
              columnGroups.set(family, []);
            }
            columnGroups.get(family).push(colorObj);
          });
          
          console.log(`📱 COLUMN-SPECIFIC COMPRESSION: Analyzing ${columnGroups.size} columns for individual compression needs`);
          
          let totalRepositioned = 0;
          let columnsCompressed = 0;
          
          // Apply compression column by column based on individual needs
          columnGroups.forEach((columnColors, family) => {
            // Sort by original stack level to maintain order
            columnColors.sort((a, b) => (a.position.stackLevel || 0) - (b.position.stackLevel || 0));
            
            // Calculate this column's natural height
            const columnMaxY = Math.max(...columnColors.map(c => c.position.y));
            const columnMinY = Math.min(...columnColors.map(c => c.position.y));
            const columnHeight = (columnMaxY - columnMinY) * scale;
            const columnHeightRatio = columnHeight / targetHeight;
            
            // Determine if this column needs compression and how much
            let compressionLevel = null;
            
            if (columnHeightRatio <= 0.8) {
              // Column fits comfortably - no compression needed
              console.log(`📱 ${family.toUpperCase()}: ${columnHeight.toFixed(0)}px (${Math.round(columnHeightRatio * 100)}%) - NO COMPRESSION`);
              columnColors.forEach(colorObj => {
                colorObj.position.compressionLevel = 'none';
              });
              return; // Skip this column entirely
            } else if (columnHeightRatio <= 1.2) {
              compressionLevel = 0.85; // 85% overlap - gentle compression
            } else if (columnHeightRatio <= 1.5) {
              compressionLevel = 0.75; // 75% overlap - medium compression
            } else if (columnHeightRatio <= 2.0) {
              compressionLevel = 0.65; // 65% overlap - heavy compression
            } else if (columnHeightRatio <= 3.0) {
              compressionLevel = 0.55; // 55% overlap - extreme compression
            } else {
              compressionLevel = 0.45; // 45% overlap - maximum compression
            }
            
            console.log(`📱 ${family.toUpperCase()}: ${columnHeight.toFixed(0)}px (${Math.round(columnHeightRatio * 100)}%) - COMPRESSING to ${Math.round((1 - compressionLevel) * 100)}% overlap`);
            columnsCompressed++;
            
            // Apply compression to this specific column
            columnColors.forEach((colorObj, index) => {
              const oldY = colorObj.position.y;
              
              if (index === 0) {
                // First block stays at base position
                colorObj.position.compressionLevel = compressionLevel;
                return;
              }
              
              // Calculate compressed position relative to previous block
              const previousBlock = columnColors[index - 1];
              const spacing = 1 - compressionLevel;
              colorObj.position.y = previousBlock.position.y + spacing;
              colorObj.position.compressionLevel = compressionLevel;
              
              console.log(`📱   ${family} Block ${index}: y ${oldY.toFixed(1)} → ${colorObj.position.y.toFixed(1)} (spacing ${spacing.toFixed(2)})`);
              totalRepositioned++;
            });
          });
          
          console.log(`📱 COMPRESSION COMPLETE: ${columnsCompressed}/${columnGroups.size} columns compressed, ${totalRepositioned} blocks repositioned`);
          
          return columnsCompressed > 0; // Compression applied if any columns were compressed
        }

        calculateCompressedQuiltHeight(colors, scale) {
          if (!colors || colors.length === 0) return 0;
          const maxY = Math.max(...colors.map(c => c.position.y));
          const height = maxY * scale;
          console.log(`📱 COMPRESSED HEIGHT: maxY=${maxY.toFixed(1)} × scale=${scale} = ${height.toFixed(1)}px`);
          return height;
         }

         async handleTestAddBlock() {
           try {
             const randomHue = Math.floor(Math.random() * 360);
             
             // 20% chance to generate a neutral color (low saturation)
             let randomSaturation, randomLightness;
             if (Math.random() < 0.2) {
               // Generate neutral color (gray/white/black)
               randomSaturation = Math.floor(Math.random() * 10); // 0-10% saturation
               randomLightness = 20 + Math.floor(Math.random() * 60); // 20-80% lightness
             } else {
               // Generate colorful color
               randomSaturation = CONFIG.COLOR_PICKER.saturation;
               randomLightness = 35 + Math.floor(Math.random() * 56);
             }
             
             const warmHue = (randomHue + 25) % 360;
             const warmSaturation = Math.min(randomSaturation + 5, 100);
             const randomColor = Utils.hslToHex(warmHue, warmSaturation, randomLightness);
             
             // NEW: Use TimeBasedQuiltEngine for testing too
             const result = this.timeBasedEngine.addColor(randomColor);
             
             if (result.success) {
               // Update the legacy state for UI compatibility
               this.syncEngineStateToLegacyState();
             
               await this.saveQuilt();
              this.renderTimeBasedQuilt();
              
              // Update square counter for test blocks too
              const engineState = this.timeBasedEngine.getState();
              const totalSquares = engineState.colors.length + engineState.queuedColors.length;
              console.log(`🧪 TEST BLOCK: Engine has ${engineState.colors.length} placed + ${engineState.queuedColors.length} queued = ${totalSquares} total squares`);
              window.updateUserCounter(totalSquares);
              
              this.updateUI();
              
              // Show test-specific message
              // const message = `🧪 Test color added! Phase: ${result.phase}, Pattern: ${engineState.pattern || 'analyzing'}, Total: ${totalSquares}`;
              // this.uiService.showToast(message); // Toast removed
             }
           } catch (error) {
             this.errorHandler.handleError(error, 'handleTestAddBlock');
             // this.uiService.showToast('Test add failed.'); // Toast removed
           }
         }

         handleShowMyPiece() {
           try {
             this.state.userPiecesHighlighted = !this.state.userPiecesHighlighted;
             
             const userPieces = this.state.pieces.filter(piece => piece.userId === this.state.currentUserId);
             const userPatches = this.state.patches.filter(patch => 
               patch.pieces && patch.pieces.some(piece => piece.userId === this.state.currentUserId)
             );
             const userBlocks = this.state.blocks.filter(block => 
               block.patches && block.patches.some(patch => 
                 patch.pieces && patch.pieces.some(piece => piece.userId === this.state.currentUserId)
               )
             );
             
             const totalUserPieces = userPieces.length + userPatches.length + userBlocks.length;
             
             if (this.state.userPiecesHighlighted) {
               if (totalUserPieces > 0) {
                 this.uiService.showToast(`Found ${totalUserPieces} of your pieces! ✨`);
               } else {
                 this.uiService.showToast("You haven't added any pieces yet. Try adding your first color!");
               }
             } else {
               this.uiService.showToast('Highlighting turned off');
             }
             
            this.renderTimeBasedQuilt();
             
           } catch (error) {
             this.errorHandler.handleError(error, 'handleShowMyPiece');
             this.uiService.showToast('Failed to highlight your pieces. Please try again.');
           }
         }

         handleTestDifferentUser() {
           try {
             const originalUserId = this.state.currentUserId;
             this.state.currentUserId = `test_user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
             
             this.uiService.showToast(`Now simulating user: ${this.state.currentUserId.substring(0, 20)}...`);
             
             const randomColor = Utils.hslToHex(Math.floor(Math.random() * 360), 65, 50);
             const success = this.addPieceToQuilt(randomColor);
             
             this.updateUI();
             
             if (success) {
               this.lastAddedForShare = this.state.lastAddedIndex;
              this.renderTimeBasedQuilt();
               
               // Update user counter to reflect multiple contributors
               const uniqueUsers = new Set(this.state.pieces.map(piece => piece.userId));
     
               
               this.uiService.showToast(`Added piece for different user! Now try "SHOW ME MY PIECE"`);
             }
             
             setTimeout(() => {
               this.state.currentUserId = originalUserId;
               this.uiService.showToast('Switched back to original user');
             }, 5000);
             
           } catch (error) {
             this.errorHandler.handleError(error, 'handleTestDifferentUser');
             this.uiService.showToast('Failed to simulate different user.');
           }
         }

         async handleShare() {
           try {
             const shareBtn = document.getElementById('shareBtnCompleted');
             if (shareBtn) shareBtn.disabled = true;
             
             this.uiService.showToast("Preparing flyer...");
             await this.shareFlow();
             
             if (shareBtn) shareBtn.disabled = false;
           } catch (error) {
             this.errorHandler.handleError(error, 'handleShare');
             this.uiService.showToast('Share failed. Saving instead.');
             
             const shareBtn = document.getElementById('shareBtnCompleted');
             if (shareBtn) shareBtn.disabled = false;
           }
         }

         async shareFlow() {
           try {
             // Track the share
             const shareCount = this.archiveService.trackCurrentQuiltShare();
             
             // Create share image (simplified version)
             const quiltElement = document.getElementById('quilt');
             if (!quiltElement) {
               throw new Error('Quilt element not found');
             }
             
             // Use the Web Share API if available
             if (navigator.share) {
               try {
                 await navigator.share({
                   title: 'Check out today\'s community quilt!',
                   text: 'I contributed to this beautiful quilt made by our community today.',
                   url: window.location.href
                 });
                 
                 this.uiService.showToast(`Shared! (${shareCount} total shares today)`);
                 this.logger.log(`📤 Quilt shared via Web Share API - total: ${shareCount}`);
                 return;
               } catch (shareError) {
                 // User cancelled or share failed
                 if (shareError.name !== 'AbortError') {
                   this.logger.log('Web Share failed, falling back to copy link');
                 }
               }
             }
             
             // Fallback: Copy link to clipboard
             try {
               await navigator.clipboard.writeText(window.location.href);
               this.uiService.showToast(`Link copied! (${shareCount} total shares today)`);
               this.logger.log(`📤 Quilt link copied to clipboard - total: ${shareCount}`);
             } catch (clipboardError) {
               // Final fallback: Just show a message
               this.uiService.showToast(`Share this link: ${window.location.href}`);
               this.logger.log(`📤 Share link displayed - total: ${shareCount}`);
             }
             
           } catch (error) {
             this.logger.error('Share flow failed:', error);
             this.uiService.showToast('Share failed. Please try again.');
           }
         }

         setupColorPicker() {
           const colorWheel = document.getElementById('colorWheelCanvas');
           const indicator = document.getElementById('colorIndicator');
           const valueSlider = document.getElementById('valueSlider');

           if (!colorWheel || !indicator || !valueSlider) return;
           
           const previewElement = document.getElementById('selectedColorPreview');
           if (previewElement) {
             previewElement.remove();
           }

           this.drawColorWheel();
           this.updatePreview();
           
           valueSlider.value = this.selectedLightness;
           
           setTimeout(() => {
             valueSlider.value = this.selectedLightness;
           }, 100);
           
           const rect = colorWheel.getBoundingClientRect();
           const centerX = rect.width / 2;
           const centerY = rect.height / 2;
           const radius = rect.width / 2;
           const angleRad = (this.selectedHue - 90) * Math.PI / 180;
           const x = centerX + radius * Math.cos(angleRad);
           const y = centerY + radius * Math.sin(angleRad);
           
           if (indicator) {
             const container = colorWheel.parentElement;
             const containerRect = container.getBoundingClientRect();
             const relativeX = x + rect.left - containerRect.left;
             const relativeY = y + rect.top - containerRect.top;
             indicator.style.left = `${relativeX}px`;
             indicator.style.top = `${relativeY}px`;
           }

           const debouncedSetHue = Utils.debounce(this.setHueFromCoords.bind(this), 16);
           
           colorWheel.addEventListener('click', e => {
             const rect = colorWheel.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
             const radius = rect.width / 2;
             
             if (distance <= radius) {
               this.setHueFromCoords(x, y);
             }
           });

           colorWheel.addEventListener('mousedown', e => {
             const rect = colorWheel.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
             const radius = rect.width / 2;
             
             if (distance <= radius) {
               this.setHueFromCoords(x, y);
             }
           });

           document.addEventListener('mousemove', e => {
             if (e.buttons === 1) {
               const rect = colorWheel.getBoundingClientRect();
               const x = e.clientX - rect.left;
               const y = e.clientY - rect.top;
               
               const centerX = rect.width / 2;
               const centerY = rect.height / 2;
               const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
               const radius = rect.width / 2;
               
               if (distance <= radius) {
                 debouncedSetHue(x, y);
               }
             }
           });

           valueSlider.addEventListener('input', () => {
             this.selectedLightness = Number(valueSlider.value);
             this.updatePreview();
           });
         }

         drawColorWheel() {
           // CSS-based color wheel doesn't need drawing
         }

         updatePreview() {
           const valueSlider = document.getElementById('valueSlider');
           
           const hslColor = `hsl(${this.selectedHue}, ${this.selectedSaturation}%, ${this.selectedLightness}%)`;
           const hexColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
           
           const colorScreen = document.getElementById('screen-color');
           if (colorScreen && this.colorHasBeenSelected) {
             colorScreen.style.backgroundColor = hexColor;
           }
           
           if (valueSlider) {
             valueSlider.style.background = `linear-gradient(to right,
               hsl(${this.selectedHue}, ${this.selectedSaturation}%, 20%), 
               hsl(${this.selectedHue}, ${this.selectedSaturation}%, 90%))`;
           }
         }

         setHueFromCoords(x, y) {
           const colorWheel = document.getElementById('colorWheelCanvas');
           const indicator = document.getElementById('colorIndicator');
           const rect = colorWheel.getBoundingClientRect();
           const centerX = rect.width / 2;
           const centerY = rect.height / 2;
           
           const dx = x - centerX;
           const dy = y - centerY;
           const distance = Math.sqrt(dx * dx + dy * dy);
           const radius = rect.width / 2;

           // Calculate angle for hue (around circumference)
           let angle = Math.atan2(dy, dx) * 180 / Math.PI;
           if (angle < 0) angle += 360;
           
           // Apply warm cast: +25° hue shift to match the color wheel display
           const rawHue = Math.round((angle + 90) % 360);
           this.selectedHue = (rawHue + 25) % 360;
           
           // Calculate saturation based on distance from center
           // 0% at center, 100% at edge, with +5% saturation boost for warmth
           const baseSaturation = Math.min(100, (distance / radius) * 100);
           this.selectedSaturation = Math.min(Math.round(baseSaturation + 5), 100);

           if (distance > radius) {
             // Clamp to edge of circle
             const clampedDistance = radius;
             const clampedX = centerX + (dx / distance) * clampedDistance;
             const clampedY = centerY + (dy / distance) * clampedDistance;
             this.selectedSaturation = 100; // Edge = full saturation (already includes +5% boost from above)
             
             if (indicator) {
               const container = colorWheel.parentElement;
               const containerRect = container.getBoundingClientRect();
               const relativeX = clampedX + rect.left - containerRect.left;
               const relativeY = clampedY + rect.top - containerRect.top;
               indicator.style.left = `${relativeX}px`;
               indicator.style.top = `${relativeY}px`;
             }
           } else {
             if (indicator) {
               const container = colorWheel.parentElement;
               const containerRect = container.getBoundingClientRect();
               const relativeX = x + rect.left - containerRect.left;
               const relativeY = y + rect.top - containerRect.top;
               indicator.style.left = `${relativeX}px`;
               indicator.style.top = `${relativeY}px`;
             }
           }
           
           this.colorHasBeenSelected = true;
           this.updatePreview();
         }

         handleKeyDown(event) {
           if (event.key === 'Escape') {
             const currentScreen = document.querySelector('.screen.active');
             if (currentScreen) {
               const currentId = currentScreen.id;
               if (currentId === 'screen-quote') {
                 this.uiService.showScreen('screen-portal');
               } else if (currentId === 'screen-color') {
                 this.uiService.showScreen('screen-quote');
               } else if (currentId === 'screen-quilt') {
                 this.uiService.showScreen('screen-color');
               }
             }
           }
         }

         
       }

             // Global function to update square counter in community message
      window.updateUserCounter = function(squareCount) {
        console.log(`🔢 COUNTER UPDATE: Attempting to set squares to ${squareCount}`);
        const userCountSpan = document.getElementById('user-count');
        if (userCountSpan) {
          userCountSpan.textContent = `${squareCount}`;
          console.log(`✅ COUNTER UPDATE: Successfully updated to ${squareCount} squares`);
        } else {
          console.error('❌ COUNTER UPDATE: Could not find user-count element in DOM');
          console.log('🔍 Available elements with IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id));
        }
      }

      // Debug function to test square counter
      window.testSquareCounter = function() {
        console.log('🧪 TESTING SQUARE COUNTER...');
        
        // Check if element exists
        const userCountSpan = document.getElementById('user-count');
        console.log('Element found:', userCountSpan);
        
        if (userCountSpan) {
          console.log('Current text content:', userCountSpan.textContent);
          
          // Test setting a value
          userCountSpan.textContent = '999';
          console.log('Set to 999, now reads:', userCountSpan.textContent);
          
          // Check engine state
          if (window.app && window.app.timeBasedEngine) {
            const engineState = window.app.timeBasedEngine.getState();
            const totalSquares = engineState.colors.length + engineState.queuedColors.length;
            console.log(`Engine state: ${engineState.colors.length} placed + ${engineState.queuedColors.length} queued = ${totalSquares} total`);
            
            // Update with real count
            setTimeout(() => {
              window.updateUserCounter(totalSquares);
            }, 1000);
          }
        } else {
          console.error('❌ user-count element not found!');
          console.log('Available elements:', Array.from(document.querySelectorAll('[id]')).map(el => `${el.tagName}#${el.id}`));
        }
      };

      // Force massive blocks for mobile testing
      window.forceMassiveBlocks = function() {
        console.log('🔧 FORCING MASSIVE BLOCKS FOR MOBILE...');
        
        // Override the scale calculation temporarily
        const originalRender = window.app.renderTimeBasedQuilt;
        window.app.renderTimeBasedQuilt = function() {
          // Temporarily force massive blocks
          const originalCode = originalRender.toString();
          
          console.log('🔧 Overriding block size calculation...');
          console.log(`📱 Screen width: ${window.innerWidth}px`);
          
          // Force huge blocks
          const forceScale = Math.min(200, Math.floor(window.innerWidth / 6)); // Use 6 columns instead of 8
          console.log(`🔧 FORCED SCALE: ${forceScale}px (using 6 columns instead of 8)`);
          
          // Call original but with debugging
          const result = originalRender.call(this);
          
          // Override any blocks that were created
          const blocks = document.querySelectorAll('#quilt rect[data-color]');
          blocks.forEach((block, i) => {
            const currentWidth = block.getAttribute('width');
            const currentHeight = block.getAttribute('height');
            
            block.setAttribute('width', forceScale);
            block.setAttribute('height', forceScale);
            
            console.log(`🔧 Block ${i+1}: ${currentWidth}×${currentHeight} → ${forceScale}×${forceScale}`);
          });
          
          console.log(`🔧 FORCED ${blocks.length} blocks to ${forceScale}×${forceScale}px`);
          
          return result;
        };
        
        // Re-render with massive blocks
        window.app.renderTimeBasedQuilt();
        
        console.log('✅ Massive blocks applied! Refresh page to return to normal.');
      };

      // ===== ADMIN SYSTEM =====
      class AdminController {
        constructor(app) {
          this.app = app;
          this.isVisible = false;
          this.isAddingBlocks = false; // Prevent rapid successive additions
          this.setupEventListeners();
        }

        setupEventListeners() {
          // Toggle admin panel
          document.getElementById('adminToggle').addEventListener('click', () => {
            this.togglePanel();
          });

          // Add sample blocks
          document.getElementById('addSampleBlocks').addEventListener('click', () => {
            const count = parseInt(document.getElementById('blockCount').value) || 10;
            this.addSampleBlocks(count);
          });

          // Phase override control
          document.getElementById('applyPhaseOverride').addEventListener('click', () => {
            const phase = document.getElementById('phaseOverride').value;
            this.app.timeBasedEngine.setPhaseOverride(phase);
          });

          // Pattern control
          document.getElementById('applyPattern').addEventListener('click', () => {
            const pattern = document.getElementById('forcePattern').value;
            this.forcePattern(pattern);
          });

          // System control
          document.getElementById('forceReorganize').addEventListener('click', () => {
            this.forceReorganize();
          });

          document.getElementById('resetQuiltAdmin').addEventListener('click', () => {
            this.resetQuilt();
          });

          document.getElementById('updateThreshold').addEventListener('click', () => {
            const threshold = parseInt(document.getElementById('reorganizeThreshold').value) || 5;
            this.updateReorganizeThreshold(threshold);
          });

          document.getElementById('emergencyResetBtn').addEventListener('click', () => {
            this.emergencyReset();
          });

          // Diagnostics
          document.getElementById('showDiagnostics').addEventListener('click', () => {
            this.showDiagnostics();
          });

          document.getElementById('exportQuilt').addEventListener('click', () => {
            this.exportQuiltData();
          });

          // Hide panel when clicking outside
          document.addEventListener('click', (e) => {
            const panel = document.getElementById('adminPanel');
            const toggle = document.getElementById('adminToggle');
            if (this.isVisible && !panel.contains(e.target) && e.target !== toggle) {
              this.hidePanel();
            }
          });

          // Keyboard shortcut to toggle admin (Cmd+Shift+A on Mac, Ctrl+Shift+A on PC)
          document.addEventListener('keydown', (e) => {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const correctModifier = isMac ? e.metaKey : e.ctrlKey;
            
            // Use e.code for more reliable key detection (KeyA regardless of case/modifiers)
            if (correctModifier && e.shiftKey && e.code === 'KeyA') {
              e.preventDefault();
              this.togglePanel();
              console.log('🛠️ Admin panel toggled via keyboard shortcut');
            }
          });
        }

        togglePanel() {
          if (this.isVisible) {
            this.hidePanel();
             } else {
            this.showPanel();
          }
        }

        showPanel() {
          document.getElementById('adminPanel').classList.add('visible');
          this.isVisible = true;
          console.log('🛠️ Admin panel activated');
        }

        hidePanel() {
          document.getElementById('adminPanel').classList.remove('visible');
          this.isVisible = false;
        }

        // CORE FUNCTION: Sample from existing colors and add N blocks
        async addSampleBlocks(count) {
          if (!this.app.timeBasedEngine) {
            this.app.uiService.showToast('❌ Engine not initialized');
            return;
          }
          
          // Prevent rapid successive additions
          if (this.isAddingBlocks) {
            this.app.uiService.showToast('⏳ Please wait, still adding blocks...');
            return;
          }
          
          this.isAddingBlocks = true;
          
          try {
            console.log(`🎨 Admin: Adding ${count} sample blocks...`);

            // Get all existing colors
            const existingColors = this.getExistingColors();
            
            if (existingColors.length === 0) {
              this.app.uiService.showToast('❌ No existing colors to sample from');
              return;
            }

          console.log(`📊 Found ${existingColors.length} existing colors to sample from`);

          // Generate representative samples
          const samples = this.generateRepresentativeSamples(existingColors, count);

          // Add each sample with a small delay for smooth addition
          let successCount = 0;
          for (let i = 0; i < samples.length; i++) {
            const color = samples[i];
            
            try {
              const result = this.app.timeBasedEngine.addColor(color);
              
              if (result.success) {
                successCount++;
                console.log(`✅ Added sample ${i + 1}/${samples.length}: ${color}`);
           } else {
                console.log(`❌ Failed to add sample ${i + 1}: ${color} (${result.reason || 'unknown'})`);
              }
            } catch (error) {
              console.error(`💥 Error adding sample ${i + 1}: ${color}`, error);
              // Continue with next color even if this one fails
            }

            // Small delay to prevent overwhelming the system
            if (i < samples.length - 1) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }

          // Update UI
          console.log('🔄 Admin: Syncing engine state to legacy state...');
          this.app.syncEngineStateToLegacyState();
          
          console.log('🎨 Admin: Rendering time-based quilt...');
          this.app.renderTimeBasedQuilt();

          // Debug: Check final state
          const finalColors = this.app.timeBasedEngine.gridState.getAllColors();
          console.log(`📊 Admin: Final engine state: ${finalColors.length} colors in grid`);
          console.log(`📊 Admin: Colors:`, finalColors.map(c => c.color));

            this.app.uiService.showToast(`✅ Added ${successCount}/${count} sample blocks`);
            console.log(`🎨 Admin: Successfully added ${successCount}/${count} sample blocks`);
          } finally {
            // Always reset the flag, even if there was an error
            this.isAddingBlocks = false;
          }
        }

        getExistingColors() {
          // Get colors from the time-based engine
          const allColorObjects = this.app.timeBasedEngine.gridState.getAllColors();
          const queuedColors = this.app.timeBasedEngine.gridState.getQueuedColors();
          
          // Extract just the color values
          const colors = [
            ...allColorObjects.map(obj => obj.color),
            ...queuedColors
          ];

          // Remove duplicates
          return [...new Set(colors)];
        }

        generateRepresentativeSamples(existingColors, count) {
          if (existingColors.length === 0) return [];

          const samples = [];
          const usedColors = new Set(); // Prevent duplicates
          
          // If we have fewer existing colors than requested, repeat them intelligently
          if (existingColors.length <= count) {
            // Create a weighted distribution - more frequent colors appear more often
            const colorFrequency = this.analyzeColorFrequency(existingColors);
            
            for (let i = 0; i < count; i++) {
              let attempts = 0;
              let randomColor;
              
              // Try to find a color we haven't used yet
              do {
                randomColor = this.weightedRandomSelection(colorFrequency);
                attempts++;
              } while (usedColors.has(randomColor) && attempts < 50 && usedColors.size < existingColors.length);
              
              // If we've used all unique colors, start over (allows duplicates when necessary)
              if (usedColors.size >= existingColors.length) {
                usedColors.clear();
              }
              
              samples.push(randomColor);
              usedColors.add(randomColor);
            }
        } else {
            // We have more colors than needed - create a representative sample
            const diverseSample = this.createDiverseSample(existingColors, count);
            samples.push(...diverseSample);
          }

          // Final duplicate check and removal
          const uniqueSamples = [...new Set(samples)];
          
          // If we removed duplicates and now have fewer than requested, fill up to count
          while (uniqueSamples.length < count && uniqueSamples.length < existingColors.length) {
            const remaining = existingColors.filter(color => !uniqueSamples.includes(color));
            if (remaining.length > 0) {
              uniqueSamples.push(remaining[Math.floor(Math.random() * remaining.length)]);
            } else {
              break;
            }
          }
          
          // If we still don't have enough (fewer unique colors than requested), cycle through existing colors
          if (uniqueSamples.length < count && existingColors.length > 0) {
            const needed = count - uniqueSamples.length;
            for (let i = 0; i < needed; i++) {
              const randomColor = existingColors[i % existingColors.length];
              uniqueSamples.push(randomColor);
            }
          }

          console.log(`🎯 Generated ${uniqueSamples.length} representative samples (removed ${samples.length - uniqueSamples.length} duplicates)`);
          return uniqueSamples;
        }

        analyzeColorFrequency(colors) {
          const frequency = {};
          colors.forEach(color => {
            frequency[color] = (frequency[color] || 0) + 1;
          });
          return frequency;
        }

        weightedRandomSelection(colorFrequency) {
          const colors = Object.keys(colorFrequency);
          const weights = Object.values(colorFrequency);
          const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
          
          let random = Math.random() * totalWeight;
          for (let i = 0; i < colors.length; i++) {
            random -= weights[i];
            if (random <= 0) {
              return colors[i];
            }
          }
          
          // Fallback
          return colors[Math.floor(Math.random() * colors.length)];
        }

        createDiverseSample(colors, count) {
          // Convert colors to HSL for better diversity analysis
          const colorsWithHSL = colors.map(color => ({
            color,
            hsl: this.hexToHsl(color)
          }));

          // Sort by hue for diverse selection
          colorsWithHSL.sort((a, b) => a.hsl.h - b.hsl.h);

          const samples = [];
          const step = Math.floor(colorsWithHSL.length / count);

          for (let i = 0; i < count; i++) {
            const index = (i * step) % colorsWithHSL.length;
            samples.push(colorsWithHSL[index].color);
          }

          return samples;
        }

        hexToHsl(hex) {
          // Simple hex to HSL conversion (matches the one in ColorAnalyzer)
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }

          return { h: h * 360, s: s * 100, l: l * 100 };
        }

        forcePattern(patternName) {
          if (!patternName) {
            console.log('🎯 Admin: Resetting to auto-pattern selection');
            this.app.uiService.showToast('🎯 Pattern selection reset to auto');
            return;
          }

          console.log(`🎯 Admin: Forcing pattern to ${patternName}`);
          this.app.timeBasedEngine.patternGenerator.currentPattern = patternName;
          
          // Trigger reorganization to apply the new pattern
          this.app.timeBasedEngine.reorganizeQuilt();
          this.app.syncEngineStateToLegacyState();
          this.app.renderTimeBasedQuilt();

          this.app.uiService.showToast(`🎯 Forced pattern: ${patternName}`);
        }

        forceReorganize() {
          console.log('🔄 Admin: Forcing reorganization...');
          this.app.timeBasedEngine.reorganizeQuilt();
          this.app.syncEngineStateToLegacyState();
          this.app.renderTimeBasedQuilt();
          this.app.uiService.showToast('🔄 Quilt reorganized');
        }

        resetQuilt() {
          if (confirm('⚠️ This will delete all colors and reset the quilt. Are you sure?')) {
            console.log('🗑️ Admin: Resetting quilt...');
            this.app.timeBasedEngine.gridState.clearAll();
            this.app.timeBasedEngine.colorsSinceReorganization = 0;
            this.app.syncEngineStateToLegacyState();
            this.app.renderTimeBasedQuilt();
            this.app.uiService.showToast('🗑️ Quilt reset');
          }
        }

        emergencyReset() {
          if (confirm('🚨 EMERGENCY RESET: This will clear ALL data and reset system state. Continue?')) {
            console.log('🚨 Admin: Emergency reset...');
            this.app.timeBasedEngine.gridState.clearAll();
            this.app.timeBasedEngine.colorsSinceReorganization = 0;
            this.app.timeBasedEngine.isReorganizing = false; // Force release lock
            this.app.syncEngineStateToLegacyState();
            this.app.renderTimeBasedQuilt();
            this.app.uiService.showToast('🚨 Emergency reset complete');
            this.hidePanel(); // Close admin panel after reset
          }
        }

        updateReorganizeThreshold(threshold) {
          this.app.timeBasedEngine.reorganizationThreshold = threshold;
          console.log(`⚙️ Admin: Updated reorganization threshold to ${threshold}`);
          this.app.uiService.showToast(`⚙️ Threshold updated: ${threshold}`);
        }

        showDiagnostics() {
          const engine = this.app.timeBasedEngine;
          const colors = engine.gridState.getAllColors();
          const queued = engine.gridState.getQueuedColors();
          const analysis = engine.colorAnalyzer.getAnalysis();

          const stats = {
            'Total Colors': colors.length,
            'Queued Colors': queued.length,
            'Current Pattern': engine.patternGenerator.getCurrentPattern() || 'None',
            'Current Phase': engine.getCurrentPhase(),
            'Colors Since Reorganization': engine.colorsSinceReorganization,
            'Reorganization Threshold': engine.reorganizationThreshold,
            'Dominant Theme': analysis.dominantTheme || 'None',
            'Has Contrasts': analysis.hasContrasts || false
          };

          console.log('📊 ADMIN DIAGNOSTICS:', stats);
          
          let message = '📊 SYSTEM STATS:\\n';
          Object.entries(stats).forEach(([key, value]) => {
            message += `${key}: ${value}\\n`;
          });

          alert(message);
        }

        exportQuiltData() {
          const data = {
            timestamp: new Date().toISOString(),
            colors: this.app.timeBasedEngine.gridState.getAllColors(),
            queued: this.app.timeBasedEngine.gridState.getQueuedColors(),
            pattern: this.app.timeBasedEngine.patternGenerator.getCurrentPattern(),
            phase: this.app.timeBasedEngine.getCurrentPhase(),
            analysis: this.app.timeBasedEngine.colorAnalyzer.getAnalysis()
          };

          const jsonString = JSON.stringify(data, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = `quilt-export-${new Date().toISOString().slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          this.app.uiService.showToast('📁 Quilt data exported');
          console.log('📁 Admin: Quilt data exported');
        }
      }

      // Initialize the application
      document.addEventListener('DOMContentLoaded', async () => {
        const app = new OurDailyApp();
        await app.initialize();
        
        // Initialize admin controller
        const adminController = new AdminController(app);
        
        // Expose app and admin globally for testing
        window.app = app;
        window.admin = adminController;
        
        // Global admin convenience functions
        window.addBlocks = (count = 10) => adminController.addSampleBlocks(count);
        
        // Global archive testing functions
        window.forceArchiveSnapshot = () => app.forceArchiveSnapshot();
        window.clearArchives = () => {
          app.archiveService.archives.clear();
          app.archiveService.currentPage = 0;
          console.log('✅ Archives cleared');
        };
        window.forcePattern = (pattern) => adminController.forcePattern(pattern);
        window.showStats = () => adminController.showDiagnostics();
        window.toggleAdmin = () => adminController.togglePanel();
        
        // Debug function to check state and force render
        window.debugRender = () => {
          console.log('🔍 DEBUG: Checking system state...');
          
          const engine = app.timeBasedEngine;
          const colors = engine.gridState.getAllColors();
          const queued = engine.gridState.getQueuedColors();
          
          console.log(`📊 Engine colors: ${colors.length}`);
          console.log(`📊 Queued colors: ${queued.length}`);
          console.log(`📊 Current pattern: ${engine.patternGenerator.getCurrentPattern()}`);
          console.log(`📊 Current phase: ${engine.getCurrentPhase()}`);
          console.log(`📊 Colors in detail:`, colors);
          
          console.log('🔄 Forcing UI sync and render...');
          app.syncEngineStateToLegacyState();
          app.renderTimeBasedQuilt();
          
          console.log('✅ Debug render complete');
        };
        
        // Test function to add sample blocks from console
        window.testAddSamples = (count = 5) => adminController.addSampleBlocks(count);
        
        // Emergency reset function for when things go wrong
        window.emergencyReset = () => {
          console.log('🚨 EMERGENCY RESET: Clearing all data...');
          app.timeBasedEngine.gridState.clearAll();
          app.timeBasedEngine.colorsSinceReorganization = 0;
          app.timeBasedEngine.isReorganizing = false; // Force release lock
          app.syncEngineStateToLegacyState();
          app.renderTimeBasedQuilt();
          console.log('🆕 System reset complete - ready for fresh start');
        };
        
        // Force visual update function
        window.forceRender = () => {
          console.log('🔄 FORCE RENDER: Updating visual quilt...');
          app.syncEngineStateToLegacyState();
          app.renderTimeBasedQuilt();
          const colors = app.timeBasedEngine.gridState.getAllColors();
          console.log(`✅ Rendered ${colors.length} colors to screen`);
        };

        // BLOCK SIZE DEBUGGING - Let's see what's actually happening!
        window.debugBlockSizes = function() {
          console.log('\n🔍 === BLOCK SIZE DEBUG ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log(`📐 SVG Dimensions: ${svg.getAttribute('width')} × ${svg.getAttribute('height')}`);
          console.log(`📐 SVG ViewBox: ${svg.getAttribute('viewBox')}`);
          console.log(`🏷️ Data attribute: data-time-based-active="${svg.getAttribute('data-time-based-active')}"`);
          
          const blocks = svg.querySelectorAll('rect');
          console.log(`🎨 Total blocks found: ${blocks.length}`);
          
          if (blocks.length > 0) {
            const firstBlock = blocks[0];
            console.log(`📦 First block: width=${firstBlock.getAttribute('width')} height=${firstBlock.getAttribute('height')}`);
            console.log(`📍 First block position: x=${firstBlock.getAttribute('x')} y=${firstBlock.getAttribute('y')}`);
            
            // Check a few more blocks
            for (let i = 0; i < Math.min(5, blocks.length); i++) {
              const block = blocks[i];
              console.log(`Block ${i}: ${block.getAttribute('width')}×${block.getAttribute('height')} at (${block.getAttribute('x')}, ${block.getAttribute('y')})`);
            }
          }
          
          // Check CSS that might be affecting size
          const computedStyle = window.getComputedStyle(svg);
          console.log(`💄 SVG CSS: width=${computedStyle.width}, height=${computedStyle.height}`);
          console.log(`💄 Max dimensions: max-width=${computedStyle.maxWidth}, max-height=${computedStyle.maxHeight}`);
          console.log(`💄 Min dimensions: min-width=${computedStyle.minWidth}, min-height=${computedStyle.minHeight}`);
          
          return { svg, blocks: Array.from(blocks) };
        };

        window.debugRenderProcess = function() {
          console.log('\n🎨 === RENDER PROCESS DEBUG ===');
          console.log('Screen width:', window.innerWidth);
          console.log('Screen height:', window.innerHeight);
          
          if (window.app && window.app.timeBasedEngine) {
            const engine = window.app.timeBasedEngine;
            const state = engine.getState();
            console.log('Phase:', state.phase);
            console.log('Colors count:', state.colors.length);
            console.log('Grid bounds:', {
              minX: Math.min(...state.colors.map(c => c.position.x)),
              maxX: Math.max(...state.colors.map(c => c.position.x)),
              minY: Math.min(...state.colors.map(c => c.position.y)),
              maxY: Math.max(...state.colors.map(c => c.position.y))
            });
          }
        };

        // Toggle detailed block rendering debug
        window.toggleBlockDebug = function() {
          window.debugBlockRendering = !window.debugBlockRendering;
          console.log(`🔧 Block rendering debug: ${window.debugBlockRendering ? 'ON' : 'OFF'}`);
          if (window.debugBlockRendering) {
            console.log('Next blocks rendered will show size details...');
          }
        };

        // Quick debug combo - run all debug functions
        window.debugAll = function() {
          console.log('\n🚀 === FULL DEBUG COMBO ===');
          window.debugRenderProcess();
          window.debugBlockSizes();
          window.debugStatus();
        };

        // Test ultra-big blocks manually
        window.testUltraBigBlocks = function() {
          console.log('🚀 TESTING ULTRA-BIG BLOCKS');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Clear and create one massive test block
          svg.innerHTML = '';
          svg.setAttribute('width', '412');
          svg.setAttribute('height', '765');
          svg.setAttribute('viewBox', '0 0 412 765');
          svg.setAttribute('data-time-based-active', 'true');
          
          // AGGRESSIVE HEIGHT FORCING
          svg.style.setProperty('height', '765px', 'important');
          svg.style.setProperty('width', '412px', 'important');
          svg.style.setProperty('max-height', 'none', 'important');
          svg.style.setProperty('min-height', 'auto', 'important');
          
          // Create background
          const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          bg.setAttribute('width', '100%');
          bg.setAttribute('height', '100%');
          bg.setAttribute('fill', '#f8f9fa');
          svg.appendChild(bg);
          
          // Create one massive test block to see maximum size
          const testBlock = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          testBlock.setAttribute('x', '50');
          testBlock.setAttribute('y', '100');
          testBlock.setAttribute('width', '100'); // Much bigger test block
          testBlock.setAttribute('height', '100');
          testBlock.setAttribute('fill', '#ff6b6b');
          testBlock.setAttribute('stroke', '#000');
          testBlock.setAttribute('stroke-width', '2');
          svg.appendChild(testBlock);
          
          console.log('✅ Ultra-big test block created (100×100px) with aggressive height forcing!');
          setTimeout(() => window.debugBlockSizes(), 200);
        };

        // Force SVG to use proper dimensions during normal rendering
        window.aggressivelyFixSVGHeight = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) return false;
          
          const currentWidth = svg.getAttribute('width') || '412';
          const currentHeight = svg.getAttribute('height') || '765';
          
          console.log(`🔧 AGGRESSIVE FIX: Setting SVG to ${currentWidth}×${currentHeight}`);
          
          // Multiple ways to force the height
          svg.style.setProperty('width', currentWidth + 'px', 'important');
          svg.style.setProperty('height', currentHeight + 'px', 'important');
          svg.style.setProperty('max-width', 'none', 'important');
          svg.style.setProperty('max-height', 'none', 'important');
          svg.style.setProperty('min-width', 'auto', 'important');
          svg.style.setProperty('min-height', 'auto', 'important');
          
          return true;
        };

        // Height monitoring system to catch when something overrides our styles
        window.startHeightMonitor = function() {
          if (window.heightMonitorInterval) {
            clearInterval(window.heightMonitorInterval);
          }
          
          console.log('🔍 Starting SVG height monitor...');
          
          window.heightMonitorInterval = setInterval(() => {
            const svg = document.querySelector('#quilt');
            if (!svg) return;
            
            const attributeHeight = svg.getAttribute('height');
            const computedStyle = window.getComputedStyle(svg);
            const cssHeight = computedStyle.height;
            
            // Only log when there's a mismatch
            if (attributeHeight && cssHeight !== attributeHeight + 'px') {
              console.log(`🚨 HEIGHT OVERRIDE DETECTED!`);
              console.log(`   Attribute: ${attributeHeight}px`);
              console.log(`   CSS: ${cssHeight}`);
              
              // Get detailed CSS information
              const computedStyle = window.getComputedStyle(svg);
              console.log(`   Max-height: ${computedStyle.maxHeight}`);
              console.log(`   Min-height: ${computedStyle.minHeight}`);
              console.log(`   Box-sizing: ${computedStyle.boxSizing}`);
              console.log(`   Display: ${computedStyle.display}`);
              console.log(`   Position: ${computedStyle.position}`);
              
              // Check for aspect ratio constraints
              if (computedStyle.aspectRatio && computedStyle.aspectRatio !== 'auto') {
                console.log(`   🎯 ASPECT RATIO CONSTRAINT: ${computedStyle.aspectRatio}`);
              }
              
              // Check parent container constraints
              const parent = svg.parentElement;
              if (parent) {
                const parentStyle = window.getComputedStyle(parent);
                console.log(`   Parent height: ${parentStyle.height}`);
                console.log(`   Parent max-height: ${parentStyle.maxHeight}`);
                console.log(`   Parent overflow: ${parentStyle.overflow}`);
              }
              
              console.log(`   Forcing back to ${attributeHeight}px with nuclear option...`);
              
              // NUCLEAR OPTION: Multiple aggressive overrides
              svg.style.cssText += `
                width: ${svg.getAttribute('width')}px !important;
                height: ${attributeHeight}px !important;
                max-width: none !important;
                max-height: none !important;
                min-width: auto !important;
                min-height: auto !important;
                aspect-ratio: auto !important;
                flex: none !important;
                flex-shrink: 0 !important;
                flex-grow: 0 !important;
              `;
            }
          }, 100); // Check every 100ms
        };

        window.stopHeightMonitor = function() {
          if (window.heightMonitorInterval) {
            clearInterval(window.heightMonitorInterval);
            window.heightMonitorInterval = null;
            console.log('🔍 Height monitor stopped');
          }
        };

        // Deep dive into what's constraining the SVG
        window.debugSVGConstraints = function() {
          console.log('\n🔬 === SVG CONSTRAINT ANALYSIS ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          const computedStyle = window.getComputedStyle(svg);
          
          console.log('📏 SVG Attributes:');
          console.log(`   width="${svg.getAttribute('width')}" height="${svg.getAttribute('height')}"`);
          console.log(`   viewBox="${svg.getAttribute('viewBox')}"`);
          
          console.log('🎨 Computed CSS:');
          console.log(`   width: ${computedStyle.width}`);
          console.log(`   height: ${computedStyle.height}`);
          console.log(`   max-width: ${computedStyle.maxWidth}`);
          console.log(`   max-height: ${computedStyle.maxHeight}`);
          console.log(`   min-width: ${computedStyle.minWidth}`);
          console.log(`   min-height: ${computedStyle.minHeight}`);
          console.log(`   aspect-ratio: ${computedStyle.aspectRatio}`);
          console.log(`   box-sizing: ${computedStyle.boxSizing}`);
          console.log(`   display: ${computedStyle.display}`);
          console.log(`   position: ${computedStyle.position}`);
          console.log(`   flex: ${computedStyle.flex}`);
          console.log(`   flex-shrink: ${computedStyle.flexShrink}`);
          console.log(`   flex-grow: ${computedStyle.flexGrow}`);
          
          // Check parent constraints
          let parent = svg.parentElement;
          let level = 1;
          while (parent && level <= 3) {
            const parentStyle = window.getComputedStyle(parent);
            console.log(`🏠 Parent ${level} (${parent.tagName}#${parent.id || 'no-id'}.${parent.className || 'no-class'}):`);
            console.log(`   height: ${parentStyle.height}`);
            console.log(`   max-height: ${parentStyle.maxHeight}`);
            console.log(`   overflow: ${parentStyle.overflow}`);
            console.log(`   display: ${parentStyle.display}`);
            console.log(`   position: ${parentStyle.position}`);
            
            parent = parent.parentElement;
            level++;
          }
          
          // Check specific CSS rules targeting #quilt
          const rules = Array.from(document.styleSheets).flatMap(sheet => {
            try {
              return Array.from(sheet.cssRules || []);
            } catch (e) {
              return [];
            }
          });
          
          console.log('📋 CSS Rules affecting #quilt:');
          rules.forEach((rule, index) => {
            if (rule.selectorText && rule.selectorText.includes('#quilt')) {
              console.log(`   Rule ${index}: ${rule.selectorText}`);
              console.log(`      ${rule.cssText}`);
            }
          });
        };

        // Debug current scale calculation
        window.debugScaleCalculation = function() {
          console.log('\n🔢 === SCALE CALCULATION DEBUG ===');
          
          const screenWidth = window.innerWidth;
          const numberOfColorFamilies = 8;
          const smallPadding = 8;
          const columnSpacing = 4;
          
          const availableWidthForBlocks = screenWidth - smallPadding - (columnSpacing * (numberOfColorFamilies - 1));
          const optimalBlockSize = Math.floor(availableWidthForBlocks / numberOfColorFamilies);
          
          const minBlockSize = 40;
          const maxBlockSize = 80;
          const scale = Math.min(maxBlockSize, Math.max(minBlockSize, optimalBlockSize));
          
          console.log(`📱 Screen width: ${screenWidth}px`);
          console.log(`📏 Small padding: ${smallPadding}px`);
          console.log(`📏 Column spacing: ${columnSpacing}px × 7 gaps = ${columnSpacing * 7}px`);
          console.log(`📦 Available for blocks: ${availableWidthForBlocks}px`);
          console.log(`🔢 Optimal block size: ${optimalBlockSize}px`);
          console.log(`🎯 Final scale (min=${minBlockSize}, max=${maxBlockSize}): ${scale}px`);
          console.log(`📐 Rendered block size: ${scale - 2}px × ${scale - 2}px (scale - 2px padding)`);
          
          return scale;
        };

        // Emergency visual scaling debug
        window.debugVisualScaling = function() {
          console.log('\n🔍 === VISUAL SCALING DEBUG ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Get actual visual measurements
          const svgRect = svg.getBoundingClientRect();
          const svgStyle = window.getComputedStyle(svg);
          
          console.log('📏 VISUAL MEASUREMENTS:');
          console.log(`   getBoundingClientRect: ${svgRect.width.toFixed(1)}×${svgRect.height.toFixed(1)}`);
          console.log(`   CSS width/height: ${svgStyle.width} / ${svgStyle.height}`);
          console.log(`   SVG attributes: ${svg.getAttribute('width')}×${svg.getAttribute('height')}`);
          
          // Check viewport scaling
          console.log('📱 VIEWPORT SCALING:');
          console.log(`   window.devicePixelRatio: ${window.devicePixelRatio}`);
          console.log(`   window.innerWidth: ${window.innerWidth}`);
          console.log(`   screen.width: ${screen.width}`);
          console.log(`   document.documentElement.clientWidth: ${document.documentElement.clientWidth}`);
          
          // Check for zoom/transform
          const transform = svgStyle.transform;
          const zoom = svgStyle.zoom;
          console.log(`   CSS transform: ${transform}`);
          console.log(`   CSS zoom: ${zoom}`);
          
          // Check viewport meta tag
          const viewportMeta = document.querySelector('meta[name="viewport"]');
          console.log(`   Viewport meta: ${viewportMeta ? viewportMeta.content : 'MISSING!'}`);
          
          // Check actual block measurements
          const blocks = svg.querySelectorAll('rect:not([width="100%"])');
          if (blocks.length > 0) {
            const firstBlock = blocks[0];
            const blockRect = firstBlock.getBoundingClientRect();
            console.log('🎨 FIRST BLOCK:');
            console.log(`   SVG attributes: ${firstBlock.getAttribute('width')}×${firstBlock.getAttribute('height')}`);
            console.log(`   Visual size: ${blockRect.width.toFixed(1)}×${blockRect.height.toFixed(1)}`);
            console.log(`   Visual/Attribute ratio: ${(blockRect.width / parseFloat(firstBlock.getAttribute('width'))).toFixed(2)}x`);
            
            // Calculate what size they SHOULD be for good mobile visibility
            const screenWidth = window.innerWidth;
            const idealBlockSize = Math.floor(screenWidth / 8); // 8 color families
            console.log(`🎯 IDEAL MOBILE SIZE: ${idealBlockSize}px (screen ${screenWidth}px ÷ 8 families)`);
            console.log(`🔍 SIZE COMPARISON: Current ${firstBlock.getAttribute('width')}px vs Ideal ${idealBlockSize}px`);
          }
        };

        // Fix visual scaling by making blocks actually bigger
        window.makeMobileFriendlyBlocks = function() {
          console.log('🔧 MAKING BLOCKS MOBILE-FRIENDLY...');
          
          const screenWidth = window.innerWidth;
          const optimalSize = Math.floor(screenWidth / 6); // 6 instead of 8 for bigger blocks
          const biggerSize = Math.max(60, optimalSize); // Minimum 60px
          
          console.log(`📱 Screen: ${screenWidth}px → Making blocks ${biggerSize}px (vs current 47px)`);
          
          // Force bigger scale in the engine
          if (window.app && window.app.timeBasedEngine) {
            console.log('🎯 Forcing bigger scale in time-based engine...');
            
            // Override the scale calculation temporarily
            const originalRender = window.app.renderTimeBasedQuilt;
            window.app.renderTimeBasedQuilt = function() {
              console.log(`🔧 OVERRIDE: Using ${biggerSize}px blocks instead of calculated size`);
              
              // Temporarily override scale calculation
              const originalCalc = window.innerWidth;
              window.innerWidth = biggerSize * 8 + 50; // Fake screen width to get bigger blocks
              
              const result = originalRender.call(this);
              
              // Restore original
              window.innerWidth = originalCalc;
              
              return result;
            };
            
            // Re-render with bigger blocks
            window.app.renderTimeBasedQuilt();
          }
        };

        // Manual CSS fix test
        window.fixSVGSize = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log('🔧 MANUAL CSS FIX: Applying inline styles to override all constraints');
          svg.style.setProperty('width', '100vw', 'important');
          svg.style.setProperty('height', 'auto', 'important');
          svg.style.setProperty('max-width', 'none', 'important');
          svg.style.setProperty('max-height', 'none', 'important');
          svg.style.setProperty('min-width', 'unset', 'important');
          svg.style.setProperty('min-height', 'unset', 'important');
          svg.style.setProperty('margin', '0', 'important');
          svg.style.setProperty('padding', '0', 'important');
          
          console.log('✅ Inline styles applied - check visual result');
          setTimeout(() => window.debugBlockSizes(), 100);
        };

        // Check parent container constraints
        window.debugParents = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log('\n🏗️ === PARENT CONTAINER DEBUG ===');
          let element = svg;
          let level = 0;
          
          while (element && level < 5) {
            const styles = window.getComputedStyle(element);
            console.log(`Level ${level}: <${element.tagName.toLowerCase()}${element.id ? ' id="' + element.id + '"' : ''}${element.className ? ' class="' + element.className + '"' : ''}>`);
            console.log(`  width: ${styles.width}, height: ${styles.height}`);
            console.log(`  max-width: ${styles.maxWidth}, max-height: ${styles.maxHeight}`);
            console.log(`  overflow: ${styles.overflow}, position: ${styles.position}`);
            
            element = element.parentElement;
            level++;
          }
        };

        // Force parent containers to not constrain
        window.fixParents = function() {
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          console.log('🔧 FIXING PARENT CONTAINERS');
          let element = svg.parentElement;
          let level = 1;
          
          while (element && level < 4) {
            console.log(`Fixing parent level ${level}: ${element.tagName}`);
            element.style.setProperty('height', 'auto', 'important');
            element.style.setProperty('max-height', 'none', 'important');
            element.style.setProperty('min-height', 'unset', 'important');
            element.style.setProperty('overflow', 'visible', 'important');
            
            element = element.parentElement;
            level++;
          }
          
          console.log('✅ Parent fixes applied');
          setTimeout(() => window.debugBlockSizes(), 100);
        };

        // Force time-based engine to activate
        window.forceTimeBasedEngine = function() {
          console.log('🚀 FORCING TIME-BASED ENGINE ACTIVATION');
          
          if (!window.app || !window.app.timeBasedEngine) {
            console.log('❌ No time-based engine found');
            return;
          }
          
          const svg = document.querySelector('#quilt');
          if (svg) {
            console.log('🧹 Clearing old legacy content...');
            svg.innerHTML = '';
            // REMOVED: Don't clear attributes - this causes white rectangle flash!
            // svg.removeAttribute('width');
            // svg.removeAttribute('height'); 
            // svg.removeAttribute('viewBox');
          }
          
          console.log('🔄 Triggering renderTimeBasedQuilt...');
          window.app.renderTimeBasedQuilt();
          
          setTimeout(() => {
            console.log('✅ Time-based engine should now be active');
            window.debugBlockSizes();
          }, 200);
        };

        // Clear everything and start fresh
        window.resetToTimeBasedEngine = function() {
          console.log('🔄 COMPLETE RESET TO TIME-BASED ENGINE');
          
          const svg = document.querySelector('#quilt');
          if (svg) {
            console.log('🧹 Completely clearing SVG...');
            svg.innerHTML = '';
            // REMOVED: Don't clear attributes - this causes white rectangle flash!
            // svg.removeAttribute('width');
            // svg.removeAttribute('height'); 
            // svg.removeAttribute('viewBox');
            svg.setAttribute('data-time-based-active', 'true');
          }
          
          if (window.app && window.app.timeBasedEngine) {
            console.log('🎨 Forcing fresh render with current colors...');
            const state = window.app.timeBasedEngine.getState();
            console.log(`Colors in engine: ${state.colors.length}`);
            
            // Force a complete re-render
            window.app.renderTimeBasedQuilt();
          }
          
          setTimeout(() => {
            console.log('✅ Fresh time-based render complete');
            window.debugBlockSizes();
          }, 300);
        };

        // Diagnose why blocks become small again
        window.diagnoseSmallBlocks = function() {
          console.log('🔍 DIAGNOSING SMALL BLOCKS ISSUE...');
          
          const svg = document.getElementById('quilt');
          if (!svg) {
            console.error('❌ SVG element not found');
            return;
          }
          
          // Check if time-based engine is active
          const isTimeBasedActive = svg.getAttribute('data-time-based-active');
          console.log(`🔍 Time-based engine active: ${isTimeBasedActive}`);
          
          // Check SVG dimensions vs computed style
          const svgAttribs = {
            width: svg.getAttribute('width'),
            height: svg.getAttribute('height'),
            viewBox: svg.getAttribute('viewBox')
          };
          console.log('🔍 SVG Attributes:', svgAttribs);
          
          const computedStyle = window.getComputedStyle(svg);
          const computedDims = {
            width: computedStyle.width,
            height: computedStyle.height,
            maxHeight: computedStyle.maxHeight,
            minHeight: computedStyle.minHeight
          };
          console.log('🔍 Computed SVG Style:', computedDims);
          
          // Check inline styles
          console.log('🔍 SVG Inline Style:', svg.style.cssText);
          
          // Check blocks
          const blocks = svg.querySelectorAll('rect[data-color]');
          console.log(`🔍 Total blocks found: ${blocks.length}`);
          
          if (blocks.length > 0) {
            const firstBlock = blocks[0];
            const blockAttribs = {
              width: firstBlock.getAttribute('width'),
              height: firstBlock.getAttribute('height'),
              x: firstBlock.getAttribute('x'),
              y: firstBlock.getAttribute('y')
            };
            console.log('🔍 First block attributes:', blockAttribs);
          }
          
          // Check engine state
          if (window.app && window.app.timeBasedEngine) {
            const engineState = window.app.timeBasedEngine.getState();
            console.log('🔍 Engine state:', {
              phase: engineState.phase,
              colorCount: engineState.colors.length,
              isReorganizing: engineState.isReorganizing
            });
          }
          
          // Check if legacy system took over
          const legacyBlocks = svg.querySelectorAll('rect:not([data-color])');
          if (legacyBlocks.length > 0) {
            console.warn(`🚨 LEGACY BLOCKS DETECTED: ${legacyBlocks.length} blocks without data-color attribute`);
            console.warn('🚨 This suggests the legacy rendering system has taken over');
          }
          
          console.log('🔍 Diagnosis complete. Run resetToTimeBasedEngine() if legacy system detected.');
        };

        // Check engine state and add a test block if needed
        window.testWithBlock = function() {
          console.log('🧪 TESTING WITH BLOCK ADDITION');
          
          if (!window.app || !window.app.timeBasedEngine) {
            console.log('❌ No time-based engine found');
            return;
          }
          
          const state = window.app.timeBasedEngine.getState();
          console.log(`Current colors in engine: ${state.colors.length}`);
          console.log(`Phase: ${state.phase}`);
          
          if (state.colors.length === 0) {
            console.log('🎨 No colors found, adding a test color...');
            window.app.timeBasedEngine.addColor('#ff6b6b');
          } else {
            console.log('🔄 Colors exist, forcing re-render...');
            window.app.renderTimeBasedQuilt();
          }
          
          setTimeout(() => {
            console.log('✅ Test complete');
            window.debugBlockSizes();
          }, 500);
        };

        // Check for viewport scaling issues
        window.checkViewportScaling = function() {
          console.log('\n🔍 === VIEWPORT SCALING DEBUG ===');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Get actual visual dimensions
          const rect = svg.getBoundingClientRect();
          console.log(`🖼️ Visual SVG size: ${rect.width.toFixed(1)} × ${rect.height.toFixed(1)}`);
          
          // Compare to computed style
          const computed = window.getComputedStyle(svg);
          console.log(`💄 Computed style: ${computed.width} × ${computed.height}`);
          
          // Check for scaling
          const scaleX = rect.width / parseFloat(computed.width);
          const scaleY = rect.height / parseFloat(computed.height);
          console.log(`📏 Scale factors: X=${scaleX.toFixed(3)}, Y=${scaleY.toFixed(3)}`);
          
          // Check viewport meta tag
          const viewport = document.querySelector('meta[name="viewport"]');
          console.log(`📱 Viewport meta: ${viewport ? viewport.content : 'MISSING!'}`);
          
          // Check zoom level
          console.log(`🔍 Browser zoom: ${(window.devicePixelRatio || 1)}x`);
          console.log(`📺 Screen: ${screen.width}×${screen.height}, Window: ${window.innerWidth}×${window.innerHeight}`);
          
          return { rect, computed, scaleX, scaleY };
        };

        // Force proper viewport and remove all scaling
        window.fixViewportScaling = function() {
          console.log('🔧 FIXING VIEWPORT SCALING');
          
          // Fix viewport meta tag
          let viewport = document.querySelector('meta[name="viewport"]');
          if (!viewport) {
            viewport = document.createElement('meta');
            viewport.name = 'viewport';
            document.head.appendChild(viewport);
          }
          viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
          console.log('✅ Viewport meta tag fixed');
          
          // Remove any transforms on the SVG and parents
          const svg = document.querySelector('#quilt');
          if (svg) {
            let element = svg;
            let level = 0;
            while (element && level < 5) {
              element.style.setProperty('transform', 'none', 'important');
              element.style.setProperty('zoom', '1', 'important');
              element.style.setProperty('scale', '1', 'important');
              element = element.parentElement;
              level++;
            }
            console.log('✅ Removed scaling transforms');
          }
          
          setTimeout(() => {
            console.log('📊 Post-fix scaling check:');
            window.checkViewportScaling();
          }, 200);
        };

        // Nuclear option - completely disable old system and force time-based
        window.forceTimeBasedOnly = function() {
          console.log('💥 NUCLEAR OPTION: Completely disabling old system');
          
          // Disable old rendering functions
          if (window.app && window.app.renderBlocks) {
            window.app.renderBlocks = function() {
              console.log('🚫 Old renderBlocks() disabled - using time-based engine instead');
              return window.app.renderTimeBasedQuilt();
            };
          }
          
          if (window.app && window.app.renderQuilt) {
            window.app.renderQuilt = function() {
              console.log('🚫 Old renderQuilt() disabled - using time-based engine instead');
              return window.app.renderTimeBasedQuilt();
            };
          }
          
          // Clear and setup SVG
          const svg = document.querySelector('#quilt');
          if (svg) {
            console.log('🧹 Clearing and setting up SVG...');
            svg.innerHTML = '';
            // REMOVED: Don't clear attributes - this causes white rectangle flash!
            // svg.removeAttribute('width');
            // svg.removeAttribute('height'); 
            // svg.removeAttribute('viewBox');
            svg.setAttribute('data-time-based-active', 'true');
            
            // Apply CSS overrides directly
            svg.style.setProperty('width', '100vw', 'important');
            svg.style.setProperty('height', 'auto', 'important');
            svg.style.setProperty('max-width', 'none', 'important');
            svg.style.setProperty('max-height', 'none', 'important');
            svg.style.setProperty('min-width', 'unset', 'important');
            svg.style.setProperty('min-height', 'unset', 'important');
          }
          
          // Force time-based engine render
          if (window.app && window.app.timeBasedEngine) {
            console.log('🚀 Forcing time-based engine render...');
            const state = window.app.timeBasedEngine.getState();
            
            if (state.colors.length === 0) {
              console.log('Adding test colors...');
              window.app.timeBasedEngine.addColor('#ff6b6b');
              window.app.timeBasedEngine.addColor('#4ecdc4');
              window.app.timeBasedEngine.addColor('#45b7d1');
            }
            
            window.app.renderTimeBasedQuilt();
          }
          
          setTimeout(() => {
            console.log('✅ Nuclear option complete - check results');
            window.debugBlockSizes();
          }, 800);
        };

        // Test ultra-big blocks to see maximum possible size
        window.testUltraBigBlocks = function() {
          console.log('🚀 TESTING ULTRA-BIG BLOCKS');
          
          const svg = document.querySelector('#quilt');
          if (!svg) {
            console.log('❌ No SVG found');
            return;
          }
          
          // Clear and create one massive test block
          svg.innerHTML = '';
          svg.setAttribute('width', '412');
          svg.setAttribute('height', '765');
          svg.setAttribute('viewBox', '0 0 412 765');
          svg.setAttribute('data-time-based-active', 'true');
          
          // Create background
          const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          bg.setAttribute('width', '100%');
          bg.setAttribute('height', '100%');
          bg.setAttribute('fill', '#f8f9fa');
          svg.appendChild(bg);
          
          // Create one massive test block to see maximum size
          const testBlock = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          testBlock.setAttribute('x', '50');
          testBlock.setAttribute('y', '100');
          testBlock.setAttribute('width', '100'); // Much bigger test block
          testBlock.setAttribute('height', '100');
          testBlock.setAttribute('fill', '#ff6b6b');
          testBlock.setAttribute('stroke', '#000');
          testBlock.setAttribute('stroke-width', '2');
          svg.appendChild(testBlock);
          
          console.log('✅ Ultra-big test block created (100×100px)');
          setTimeout(() => window.debugBlockSizes(), 200);
        };

        // DEBUG STATUS - comprehensive status check
        window.debugStatus = () => {
          console.log('🔍 === DEBUG STATUS ===');
          const state = app.timeBasedEngine.getState();
          console.log('Engine State:', state);
          console.log('Total Colors (including duplicates):', state.colors?.length || 0);
          console.log('Queued Colors:', state.queuedColors?.length || 0);
          console.log('Current Phase:', state.phase);
          console.log('Colors Since Reorganization:', app.timeBasedEngine.colorsSinceReorganization);
          console.log('Is Reorganizing:', app.timeBasedEngine.isReorganizing);
          
          // Show duplicate analysis
          if (state.colors?.length > 0) {
            const colorCounts = {};
            state.colors.forEach(colorObj => {
              colorCounts[colorObj.color] = (colorCounts[colorObj.color] || 0) + 1;
            });
            const uniqueColors = Object.keys(colorCounts).length;
            const duplicates = Object.entries(colorCounts).filter(([color, count]) => count > 1);
            console.log(`Unique Colors: ${uniqueColors}`);
            console.log(`Duplicate Colors: ${duplicates.length > 0 ? duplicates.map(([color, count]) => `${color}(${count}x)`).join(', ') : 'None'}`);
            
            // Show coordinate bounds
            const positions = state.colors.map(c => c.position);
            const minX = Math.min(...positions.map(p => p.x));
            const maxX = Math.max(...positions.map(p => p.x));
            const minY = Math.min(...positions.map(p => p.y));
            const maxY = Math.max(...positions.map(p => p.y));
            console.log(`Grid Bounds: X(${minX} to ${maxX}), Y(${minY} to ${maxY})`);
            console.log(`Grid Size: ${maxX - minX + 1} x ${maxY - minY + 1}`);
            
            // Collection phase: show color family columns
            if (state.phase === 'collection') {
              const columnInfo = Array.from(app.timeBasedEngine.gridState.colorColumns.entries())
                .map(([family, column]) => `${family}(${column.colors.length})`);
              console.log(`🧵 Color Family Columns: ${columnInfo.join(', ')}`);
              console.log(`🧵 Tight column spacing (1.2) - no reorganization in collection phase!`);
              
              // Show column positions for tight spacing analysis
              const columnPositions = Array.from(app.timeBasedEngine.gridState.colorColumns.entries())
                .map(([family, column]) => `${family}@x${column.x.toFixed(1)}`);
              console.log(`🧵 Column positions: ${columnPositions.join(' | ')}`);
              
              // Mobile optimization analysis
              const columnHeights = Array.from(app.timeBasedEngine.gridState.colorColumns.entries())
                .map(([family, column]) => {
                  const height = column.colors.length;
                  let overlap;
                  if (height <= 3) overlap = '0.8';
                  else if (height <= 6) overlap = '0.6';
                  else if (height <= 10) overlap = '0.45';
                  else overlap = '0.35';
                  return `${family}(${height}@${overlap})`;
                });
              console.log(`📱 Mobile columns: ${columnHeights.join(' | ')}`);
            }
            
            // Check for negative coordinates
            const negativeCoords = positions.filter(p => p.x < 0 || p.y < 0);
            if (negativeCoords.length > 0) {
              console.warn(`⚠️ ${negativeCoords.length} blocks have negative coordinates:`, negativeCoords);
            }
          }
          
          const svg = document.getElementById('quilt');
          console.log('SVG Element Found:', !!svg);
          console.log('SVG Children Count:', svg?.children?.length || 0);
          console.log('Time-based Active:', svg?.getAttribute('data-time-based-active'));
          
          if (svg?.children?.length > 0) {
            console.log('SVG First Few Children:');
            for (let i = 0; i < Math.min(5, svg.children.length); i++) {
              const child = svg.children[i];
              console.log(`  ${i}: ${child.tagName} fill="${child.getAttribute('fill')}" x="${child.getAttribute('x')}" y="${child.getAttribute('y')}"`);
            }
          } else {
            console.log('❌ No children found in SVG element');
          }
          
          return {
            totalColors: state.colors?.length || 0,
            queuedColors: state.queuedColors?.length || 0,
            svgChildren: svg?.children?.length || 0,
            timeBasedActive: svg?.getAttribute('data-time-based-active'),
            isReorganizing: app.timeBasedEngine.isReorganizing
          };
        };
        
        // GRID BOUNDS DEBUG - quick check for positioning issues
        window.checkGridBounds = () => {
          const state = app.timeBasedEngine.getState();
          if (state.colors?.length === 0) {
            console.log('No colors to check');
            return;
          }
          
          const positions = state.colors.map(c => c.position);
          const bounds = {
            minX: Math.min(...positions.map(p => p.x)),
            maxX: Math.max(...positions.map(p => p.x)),
            minY: Math.min(...positions.map(p => p.y)),
            maxY: Math.max(...positions.map(p => p.y))
          };
          
          console.log('🗂️ Grid Analysis:');
          console.log(`   Bounds: (${bounds.minX},${bounds.minY}) to (${bounds.maxX},${bounds.maxY})`);
          console.log(`   Size: ${bounds.maxX - bounds.minX + 1} x ${bounds.maxY - bounds.minY + 1}`);
          
          // Calculate what the rendering scale would be (phase-aware)
          const gridWidth = bounds.maxX - bounds.minX + 1;
          const gridHeight = bounds.maxY - bounds.minY + 1;
          
          let availableWidth, availableHeight, maxScale;
          if (state.phase === 'collection') {
            availableWidth = 500;
            availableHeight = 450;
            maxScale = 50;
          } else {
            availableWidth = 400;
            availableHeight = 400;
            maxScale = 30;
          }
          
          const scaleX = availableWidth / gridWidth;
          const scaleY = availableHeight / gridHeight;
          const scale = Math.min(scaleX, scaleY, maxScale);
          
          console.log(`   Render scale: ${scale.toFixed(1)}px per block (${state.phase} phase)`);
          console.log(`   Block size: ${Math.max(scale - 2, 5)}px`);
          
          if (state.phase === 'collection') {
            console.log(`   🧵 Large blocks for quilter's workspace!`);
          }
          
          // Check for problematic coordinates
          const negativeCoords = positions.filter(p => p.x < 0 || p.y < 0);
          const largeCoords = positions.filter(p => p.x > 100 || p.y > 100);
          
          if (negativeCoords.length > 0) console.warn(`⚠️ ${negativeCoords.length} negative coordinates`);
          if (largeCoords.length > 0) console.warn(`⚠️ ${largeCoords.length} very large coordinates (>100)`);
          
          return bounds;
        };
        
        // Set initial user counter (will be updated as users are added)
        
        
        // Check for admin access via localStorage
        const adminValue = localStorage.getItem('isAdmin');
        console.log('🔍 Debug: localStorage.getItem("isAdmin") =', adminValue);
        console.log('🔍 Debug: typeof adminValue =', typeof adminValue);
        console.log('🔍 Debug: adminValue === "true" =', adminValue === 'true');
        
        if (adminValue === 'true') {
          const adminButton = document.getElementById('adminToggle');
          console.log('🔍 Debug: adminButton element =', adminButton);
          if (adminButton) {
            adminButton.style.display = 'block';
            console.log('🛠️ Admin access granted. Use Ctrl+Shift+A or click ADMIN button to access.');
          } else {
            console.log('❌ Admin button element not found!');
          }
          
          // Show admin sections in archive screen
          setTimeout(() => {
            if (window.app && window.app.showAdminAnalytics) {
              window.app.showAdminAnalytics();
            }
          }, 100);
        } else {
          console.log('🔒 Admin access: Run localStorage.setItem("isAdmin", "true") to enable admin mode.');
          console.log('🔍 Current localStorage isAdmin value:', adminValue);
        }
        
        // Admin analytics visibility functions
        window.app.showAdminAnalytics = function() {
          console.log('🔧 Showing admin analytics');
          
          // Show trend summary
          const trendSummary = document.getElementById('adminTrendSummary');
          if (trendSummary) {
            trendSummary.style.display = 'block';
          }
          
          // Show admin sections in archive posts
          const adminSections = document.querySelectorAll('.archive-post-admin');
          adminSections.forEach(section => {
            section.style.display = 'block';
          });
          
          // Update trend data
          window.app.updateTrendSummary();
        };
        
        window.app.hideAdminAnalytics = function() {
          console.log('🔧 Hiding admin analytics');
          
          // Hide trend summary
          const trendSummary = document.getElementById('adminTrendSummary');
          if (trendSummary) {
            trendSummary.style.display = 'none';
          }
          
          // Hide admin sections in archive posts
          const adminSections = document.querySelectorAll('.archive-post-admin');
          adminSections.forEach(section => {
            section.style.display = 'none';
          });
        };
        
        window.app.updateTrendSummary = function() {
          // Mock trend data for now
          const trends = {
            noonSquares: '15▲',
            users: '12▼', 
            peakTime: '2-4pm',
            colors: 'W:65%',
            mobile: '78%',
            shares: '3.2▲'
          };
          
          // Update trend values
          document.getElementById('trendNoonSquares').textContent = trends.noonSquares;
          document.getElementById('trendUsers').textContent = trends.users;
          document.getElementById('trendPeakTime').textContent = trends.peakTime;
          document.getElementById('trendColors').textContent = trends.colors;
          document.getElementById('trendMobile').textContent = trends.mobile;
          document.getElementById('trendShares').textContent = trends.shares;
          
          // Update change indicators
          document.getElementById('trendNoonChange').textContent = 'Trending ▲';
          document.getElementById('trendUsersChange').textContent = 'Steady';
          document.getElementById('trendPeakChange').textContent = 'Stable';
          document.getElementById('trendColorsChange').textContent = 'Warm trend';
          document.getElementById('trendMobileChange').textContent = 'High mobile';
          document.getElementById('trendSharesChange').textContent = 'Growing ▲';
        };
        
        // Add timeframe selector event listener
        document.getElementById('trendTimeframe').addEventListener('change', function(e) {
          console.log('📊 Timeframe changed to:', e.target.value);
          window.app.updateTrendSummary();
        });
        
        // Global admin analytics functions
        window.showAdminAnalytics = () => window.app.showAdminAnalytics();
        window.hideAdminAnalytics = () => window.app.hideAdminAnalytics();
      });
     </script>
   </body>
   </html> 