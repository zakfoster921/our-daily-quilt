<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our Daily Quilt - Beta</title>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      text-align: center;
      height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow: hidden;
    }

    /* ===== FULL VIEWPORT QUILT ===== */
    .quilt-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: block;
      background-color: #f6f4f1;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }

    .quilt-container svg {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      margin: 0;
      padding: 0;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }



    /* ===== SCREENS ===== */
    .screen {
      display: none;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out;
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 0;
      align-items: stretch;
      justify-content: flex-start;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      display: flex !important;
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header h1 {
      font-weight: 500;
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      margin-bottom: 0.0em;
      letter-spacing:.02em;
    }
    
    .portal-header .quilt-text {
      font-weight: 900;
      font-size: clamp(2.5rem, 6vw, 6rem);
      margin-top: -.5rem;
      margin-bottom: 0.5rem;
      letter-spacing: 0.05em;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.4rem, 3.5vw, 2rem);
      margin-top: 0.1rem;
    }
    
    .portal-question {
      font-size: clamp(1.5rem, 3.5vw, 2.2rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.2rem;
      margin: 1.5rem auto 1.5rem;
      background: #f6f4f1;
      width: 90%;
      max-width: 500px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 120px;
      max-height: 40vh;
    }
    
    .quote-line { 
      font-size: clamp(1rem, 2.8vw, 1.4rem); 
      font-style: italic; 
      font-weight: 300; 
      line-height: 1.4;
    }
    
    .quote-author { 
      font-size: clamp(0.9rem, 2.2vw, 1.1rem); 
      font-weight: 200; 
      margin-top: 0.5rem;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 1rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 1rem auto;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: fit-content;
      gap: 1.5rem;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      position: relative;
      background: conic-gradient(
        hsl(25, 100%, 50%),
        hsl(40, 100%, 50%),
        hsl(55, 100%, 50%),
        hsl(70, 100%, 50%),
        hsl(85, 100%, 50%),
        hsl(100, 100%, 50%),
        hsl(115, 100%, 50%),
        hsl(130, 100%, 50%),
        hsl(145, 100%, 50%),
        hsl(160, 100%, 50%),
        hsl(175, 100%, 50%),
        hsl(190, 100%, 50%),
        hsl(205, 100%, 50%),
        hsl(220, 100%, 50%),
        hsl(235, 100%, 50%),
        hsl(250, 100%, 50%),
        hsl(265, 100%, 50%),
        hsl(280, 100%, 50%),
        hsl(295, 100%, 50%),
        hsl(310, 100%, 50%),
        hsl(325, 100%, 50%),
        hsl(340, 100%, 50%),
        hsl(355, 100%, 50%),
        hsl(10, 100%, 50%),
        hsl(25, 100%, 50%)
      );
    }
    
    .css-color-wheel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, white 0%, transparent 70%);
      pointer-events: none;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
    
    .css-color-wheel:hover {
      transform: scale(1.02);
    }
    
    .css-color-wheel:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; 
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 300px;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      background-color: #f6f4f1;
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
      justify-content: center;
    }
    
    #screen-quote {
      justify-content: center;
    }
    
    @media (max-width: 768px) {
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
        justify-content: center;
      }
      
      .css-color-wheel {
        width: 224px !important;
        height: 224px !important;
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */
    #quilt {
      width: 100vw !important;
      height: 100%;
      max-width: 100vw !important;
      max-height: 100%;
      background: transparent;
      position: relative;
      display: block;
      margin: 0;
      padding: 0;
    }
    


    /* ===== ENHANCED FEATURES ===== */
    .color-family-indicator {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    .phase-transition {
      animation: phasePulse 2s ease-in-out;
    }
    
    @keyframes phasePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    


    /* ===== SQUARE COUNTER ===== */
    .square-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #000;
      border-radius: 8px;
      font-family: inherit;
    }
    
    .counter-number {
      font-size: 1.5rem;
      font-weight: 700;
      color: #000;
    }
    
    .counter-label {
      font-size: 1rem;
      font-weight: 400;
      color: #333;
      text-transform: lowercase;
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000 !important;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #000 !important; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
    .new-block {
      transform-origin: center;
      animation: scaleUpSpring 2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes scaleUpSpring {
      0% { transform: scale(0); opacity: 0; }
      40% { transform: scale(0.8); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      80% { transform: scale(0.98); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      html, body {
        overflow: hidden !important;
        position: fixed !important;
        width: 100% !important;
        height: 100% !important;
        -webkit-overflow-scrolling: touch;
      }
      
      #app {
        overflow: hidden !important;
        height: 100% !important;
        width: 100% !important;
      }
      
      .screen { 
        padding: 0; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 95%; padding: 1rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      .quilt-container {
        width: 100% !important;
        max-width: 100vw !important;
        height: 100vh !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        z-index: 1;
        display: flex !important;
        align-items: stretch !important;
        justify-content: stretch !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      
      #screen-quilt .square-counter {
        background: #fff !important;
        border: 2px solid #000 !important;
        margin: 1rem 0.5rem 0.5rem 0.5rem !important;
        padding: 0.5rem !important;
        border-radius: 6px !important;
      }
      
      #screen-quilt .counter-number {
        font-size: 1.3rem !important;
        font-weight: 700 !important;
      }
      
      #screen-quilt .counter-label {
        font-size: 0.9rem !important;
      }
      
      #screen-quilt .btn {
        background: #fff !important;
        border: 2px solid #000 !important;
        color: #000 !important;
        font-size: 0.9rem !important;
        padding: 8px 16px !important;
        margin: 0.5rem !important;
        display: block !important;
        width: 100% !important;
        max-width: none !important;
      }
      
      #screen-portal .btn,
      #screen-welcome .btn,
      #screen-quote .btn,
      #screen-color .btn,
      #screen-archive .btn,
      #screen-about .btn {
        background: transparent !important;
        border: 1px solid #000 !important;
        font-size: 1rem !important;
        padding: 12px 30px !important;
        margin: 0.5rem !important;
        display: inline-block !important;
        width: auto !important;
        max-width: none !important;
      }
      
      #screen-quilt {
        padding: 0 !important;
        margin: 0 !important;
        justify-content: flex-start !important;
        align-items: stretch !important;
        min-height: 100vh !important;
        height: 100vh !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;
      }
      
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 1rem !important;
        justify-content: center !important;
        align-items: center !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
      

      
      #screen-archive {
        padding: 3rem 0 10px 0 !important;
        justify-content: flex-start !important;
        align-items: center !important;
        min-height: 100vh !important;
        height: auto !important;
        max-height: none !important;
        overflow-y: auto !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
      }
      
      #screen-about {
        padding: 3rem 0 10px 0 !important;
        justify-content: center !important;
        align-items: center !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        overflow: hidden !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
      }
      
      #screen-quilt .button-container {
        position: relative !important;
        background: #f6f4f1 !important;
        padding: 1rem !important;
        border-top: 2px solid #000 !important;
        margin-top: 100vh !important;
      }
      
      #screen-portal .button-container,
      #screen-welcome .button-container,
      #screen-quote .button-container,
      #screen-color .button-container,
      #screen-archive .button-container,
      #screen-about .button-container {
        position: static !important;
        background: transparent !important;
        padding: 0 !important;
        border-top: none !important;
        margin-top: 0 !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      html, body {
        overflow: hidden !important;
        position: fixed !important;
        width: 100vw !important;
        height: 100vh !important;
        -webkit-overflow-scrolling: touch;
      }
      
      #app {
        overflow: hidden !important;
        height: 100vh !important;
        width: 100vw !important;
      }
      
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      
      #screen-quilt .thank-you-message {
        font-size: 1rem;
        margin-bottom: 0.3rem;
      }
      
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 0.5rem !important;
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
    }

    /* ===== FLOATING ADMIN BUTTON ===== */
    .floating-admin-btn {
      position: fixed !important;
      bottom: 20px !important;
      right: 20px !important;
      width: 50px !important;
      height: 50px !important;
      border-radius: 50% !important;
      background: #f6f4f1 !important;
      color: #000 !important;
      border: none !important;
      font-size: 20px !important;
      cursor: pointer !important;
      z-index: 1000 !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2) !important;
      transition: all 0.3s ease !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }

    .floating-admin-btn:hover {
      transform: scale(1.1) !important;
      box-shadow: 0 6px 12px rgba(0,0,0,0.4) !important;
    }

    .floating-admin-btn:active {
      transform: scale(0.95) !important;
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .new-block { animation: none; }
    }
    
    /* ===== MOBILE SCROLL PREVENTION ===== */
    @media (max-width: 768px) {
      * {
        -webkit-overflow-scrolling: touch;
      }
      
      .screen {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
      }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }

    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-feed {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .archive-load-more {
      margin: 2rem auto;
      display: block;
      background: #666;
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 24px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .archive-load-more:hover {
      background: #333;
    }
    
    .archive-load-more:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .archive-loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }

    /* ===== ARCHIVE POSTS ===== */
    .archive-post {
      background: #fff;
      border: 2px solid #000;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .archive-post:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .archive-post-image {
      width: 100%;
      height: 200px;
      object-fit: cover;
      display: block;
    }

    .archive-post-caption {
      padding: 1rem;
    }

    .archive-post-quote-author {
      font-size: 1.1rem;
      font-style: italic;
      margin-bottom: 0.5rem;
      line-height: 1.4;
    }

    .archive-post-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      color: #666;
    }

    .archive-share-btn {
      background: transparent;
      border: 1px solid #000;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: background 0.2s ease;
    }

    .archive-share-btn:hover {
      background: #000;
      color: #fff;
    }

    /* ===== ARCHIVE MODAL ===== */
    .archive-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .archive-modal-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
    }

    .archive-modal-content {
      position: relative;
      background: #fff;
      border-radius: 12px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      z-index: 1001;
    }

    .archive-modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 20px;
      cursor: pointer;
      z-index: 1002;
    }

    .archive-modal-image {
      width: 100%;
      max-height: 70vh;
      object-fit: contain;
    }

    .archive-modal-info {
      padding: 1.5rem;
    }

    .archive-modal-quote {
      font-size: 1.2rem;
      font-style: italic;
      margin-bottom: 0.5rem;
      line-height: 1.4;
    }

    .archive-modal-meta {
      font-size: 0.9rem;
      color: #666;
    }

    /* ===== ABOUT SCREEN ===== */
    .about-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .about-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .about-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .about-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .about-description {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .about-info h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .about-info h3:first-child {
      margin-top: 0;
    }
    
    .about-info p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>

  
  <main id="app">

    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <h1>OUR DAILY</h1>
        <h1 class="quilt-text">QUILT</h1>
        <p class="date" id="date-text" aria-live="polite"></p>
      </div>
      <p class="portal-question">What if today started with just one good thought?</p>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
        <h1>WELCOME TO OUR DAILY</h1>
        <p class="welcome-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3>Here's how it works:</h3>
          <p>1. Read a quote<br>
          2. Choose a color<br>
          3. Help build a growing community quilt</p>
          
          <p><strong>New quote and quilt everyday!</strong></p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quote" aria-label="Get started">Get Started</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-card">
        <div class="quote-inner">
          <p class="quote-line" aria-live="polite"></p>
          <p class="quote-author" aria-live="polite"></p>
        </div>
      </div>
      <p class="quote-prompt">What color comes to mind when you read this?</p>
      <div class="arrow-down">‚Üì</div>
      <button class="btn" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="25" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">

      
      <!-- Quilt container - full viewport -->
      <div class="quilt-container">
        <svg id="quilt" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      </div>
      
      <!-- Button container - overlay on top -->
      <div class="button-container" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; background: rgba(246, 244, 241, 0.9); padding: 10px; border-radius: 8px; border: 2px solid #000;">
        <!-- Square counter -->
        <div class="square-counter">
          <span class="counter-number" id="squareCounter">1</span>
          <span class="counter-label">squares</span>
        </div>
        
        <div class="button-group">
          <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white;">SHOW ME MY PIECE</button>
        </div>
        
        <div class="button-group">
          <!-- <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button> -->
          <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
          <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
        </div>
      </div>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>QUILT ARCHIVE</h1>
        <p class="archive-subtitle">Past community quilts</p>
      </div>
      
      <!-- Archive Feed -->
      <div class="archive-feed" id="archiveFeed">
        <!-- Archive posts will be dynamically inserted here -->
      </div>
      
      <!-- Load More Button -->
      <button class="btn archive-load-more" id="archiveLoadMore" style="display: none;">Load More</button>
      
      <!-- Loading Indicator -->
      <div class="archive-loading" id="archiveLoading" style="display: none;">
        <p>Loading quilts...</p>
      </div>
      
      <!-- Back Button -->
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-header">
        <h1>ABOUT OUR DAILY</h1>
        <p class="about-subtitle">A collaborative community quilt</p>
      </div>
      
      <div class="about-content">
        <p class="about-description">This is a daily collaborative art project where people from around the world contribute colors to create a community quilt.</p>
        
        <div class="about-info">
          <h3>How it works</h3>
          <p>Each day, participants read an inspiring quote and choose a color that speaks to them. These colors become blocks in our community quilt.</p>
          
          <h3>Community</h3>
          <p>Every color represents a person, a moment, a feeling. Together we create something beautiful that grows with each contribution.</p>
          
          <h3>Share</h3>
          <p>Download your quilt block or the entire community quilt to share with others and inspire them to join in.</p>
        </div>
      </div>
      
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

      <!-- Toast notifications -->
    <div id="toast" class="toast" role="alert" aria-live="polite"></div>

    <!-- Archive Modal -->
    <div id="archiveModal" class="archive-modal" style="display: none;">
      <div id="archiveModalBackdrop" class="archive-modal-backdrop"></div>
      <div class="archive-modal-content">
        <button id="archiveModalClose" class="archive-modal-close" aria-label="Close modal">√ó</button>
        <img id="archiveModalImage" class="archive-modal-image" alt="Quilt" />
        <div class="archive-modal-info">
          <p id="archiveModalQuote" class="archive-modal-quote"></p>
          <p id="archiveModalMeta" class="archive-modal-meta"></p>
        </div>
      </div>
    </div>

    <!-- Floating Admin Button -->
    <button id="floatingAdminBtn" class="floating-admin-btn" aria-label="Admin controls" style="display: none;">
      ‚öôÔ∏è
    </button>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script type="module">
    // ===== CONFIGURATION =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '3.0.0-beta',
        defaultColor: '#f7b733',
        quiltSize: 1000,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        gridCols: 8,
        gridRows: 8,
        blockSpacing: 4,
        blockPadding: 2
      },
      QUILT_V2: {
        FREEZE_THRESHOLD: 20,
        MIN_SHAPE_SIZE: 40,
        COLOR_SIMILARITY_THRESHOLD: 35,
        LAB_COLOR_CACHE_SIZE: 1000
      }
    };

    // ===== COLOR UTILITIES (LAB Color Space) =====
    class ColorUtilsV2 {
      static colorCache = new Map();
      
      static hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      
      static rgbToXyz(r, g, b) {
        let r1 = r / 255, g1 = g / 255, b1 = b / 255;
        
        r1 = r1 > 0.04045 ? Math.pow((r1 + 0.055) / 1.055, 2.4) : r1 / 12.92;
        g1 = g1 > 0.04045 ? Math.pow((g1 + 0.055) / 1.055, 2.4) : g1 / 12.92;
        b1 = b1 > 0.04045 ? Math.pow((b1 + 0.055) / 1.055, 2.4) : b1 / 12.92;
        
        const x = r1 * 0.4124 + g1 * 0.3576 + b1 * 0.1805;
        const y = r1 * 0.2126 + g1 * 0.7152 + b1 * 0.0722;
        const z = r1 * 0.0193 + g1 * 0.1192 + b1 * 0.9505;
        
        return { x, y, z };
      }
      
      static xyzToLab(x, y, z) {
        const xn = 0.95047, yn = 1.00000, zn = 1.08883;
        
        const x1 = x / xn, y1 = y / yn, z1 = z / zn;
        
        const fx = x1 > 0.008856 ? Math.pow(x1, 1/3) : (7.787 * x1) + (16 / 116);
        const fy = y1 > 0.008856 ? Math.pow(y1, 1/3) : (7.787 * y1) + (16 / 116);
        const fz = z1 > 0.008856 ? Math.pow(z1, 1/3) : (7.787 * z1) + (16 / 116);
        
        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b = 200 * (fy - fz);
        
        return { L, a, b };
      }
      
      static hexToLab(hex) {
        if (this.colorCache.has(hex)) {
          return this.colorCache.get(hex);
        }
        
        const rgb = this.hexToRgb(hex);
        if (!rgb) return null;
        
        const xyz = this.rgbToXyz(rgb.r, rgb.g, rgb.b);
        const lab = this.xyzToLab(xyz.x, xyz.y, xyz.z);
        
        if (this.colorCache.size < CONFIG.QUILT_V2.LAB_COLOR_CACHE_SIZE) {
          this.colorCache.set(hex, lab);
        }
        
        return lab;
      }
      
      static getColorDistance(color1, color2) {
        const lab1 = this.hexToLab(color1);
        const lab2 = this.hexToLab(color2);
        
        if (!lab1 || !lab2) return Infinity;
        
        const dL = lab1.L - lab2.L;
        const da = lab1.a - lab2.a;
        const db = lab1.b - lab2.b;
        
        return Math.sqrt(dL * dL + da * da + db * db);
      }
      
      static isColorSimilar(color1, color2) {
        const distance = this.getColorDistance(color1, color2);
        return distance <= CONFIG.QUILT_V2.COLOR_SIMILARITY_THRESHOLD;
      }
      
      static getColorFamilyName(hexColor) {
        const rgb = this.hexToRgb(hexColor);
        if (!rgb) return 'unknown';
        
        const { r, g, b } = rgb;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;
        
        if (delta === 0) return 'gray';
        
        let hue;
        if (max === r) {
          hue = ((g - b) / delta) % 6;
        } else if (max === g) {
          hue = (b - r) / delta + 2;
        } else {
          hue = (r - g) / delta + 4;
        }
        
        hue = Math.round(hue * 60);
        if (hue < 0) hue += 360;
        
        if (hue >= 0 && hue < 30) return 'red';
        if (hue >= 30 && hue < 60) return 'orange';
        if (hue >= 60 && hue < 90) return 'yellow';
        if (hue >= 90 && hue < 150) return 'green';
        if (hue >= 150 && hue < 210) return 'cyan';
        if (hue >= 210 && hue < 270) return 'blue';
        if (hue >= 270 && hue < 330) return 'purple';
        return 'pink';
      }
    }

    // ===== ENHANCED SHAPE CLASS =====
    class QuiltShapeV2 {
      constructor(options = {}) {
        this.id = options.id || this.generateId();
        this.type = options.type || 'KEY_SHAPE';
        this.color = options.color || CONFIG.APP.defaultColor;
        this.position = options.position || { x: 0, y: 0, width: 1000, height: 1000 };
        this.parentId = options.parentId || null;
        this.contributorId = options.contributorId || null;
        this.submissionIndex = options.submissionIndex || 0;
        this.colorFamily = options.colorFamily || null;
        this.descendants = [];
      }
      
      generateId() {
        return 'shape_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }
      
      canSplit(direction) {
        if (direction === 'horizontal') {
          return this.position.height >= CONFIG.QUILT_V2.MIN_SHAPE_SIZE * 2;
        } else {
          return this.position.width >= CONFIG.QUILT_V2.MIN_SHAPE_SIZE * 2;
        }
      }
      
      getValidSplitDirections() {
        const directions = [];
        if (this.canSplit('horizontal')) directions.push('horizontal');
        if (this.canSplit('vertical')) directions.push('vertical');
        return directions;
      }
      
      split(newColor, direction, contributorId, submissionIndex) {
        if (!this.canSplit(direction)) {
          throw new Error(`Cannot split shape ${this.id} in ${direction} direction`);
        }

        const splitRatio = 0.3 + Math.random() * 0.4;
        let shape1, shape2;

        if (direction === 'horizontal') {
          const splitHeight = this.position.height * splitRatio;
          
          shape1 = new QuiltShapeV2({
            type: this.type,
            color: this.color,
            position: {
              x: this.position.x,
              y: this.position.y,
              width: this.position.width,
              height: splitHeight
            },
            parentId: this.id,
            contributorId: this.contributorId,
            submissionIndex: this.submissionIndex,
            colorFamily: this.colorFamily
          });

          shape2 = new QuiltShapeV2({
            type: this.type,
            color: newColor,
            position: {
              x: this.position.x,
              y: this.position.y + splitHeight,
              width: this.position.width,
              height: this.position.height - splitHeight
            },
            parentId: this.id,
            contributorId: contributorId,
            submissionIndex: submissionIndex,
            colorFamily: this.colorFamily
          });
        } else {
          const splitWidth = this.position.width * splitRatio;
          
          shape1 = new QuiltShapeV2({
            type: this.type,
            color: this.color,
            position: {
              x: this.position.x,
              y: this.position.y,
              width: splitWidth,
              height: this.position.height
            },
            parentId: this.id,
            contributorId: this.contributorId,
            submissionIndex: this.submissionIndex,
            colorFamily: this.colorFamily
          });

          shape2 = new QuiltShapeV2({
            type: this.type,
            color: newColor,
            position: {
              x: this.position.x + splitWidth,
              y: this.position.y,
              width: this.position.width - splitWidth,
              height: this.position.height
            },
            parentId: this.id,
            contributorId: contributorId,
            submissionIndex: submissionIndex,
            colorFamily: this.colorFamily
          });
        }

        this.descendants.push(shape2.id);
        
        return [shape1, shape2];
      }
      
      getAllDescendants(allShapes) {
        const descendants = [...this.descendants];
        this.descendants.forEach(descId => {
          const desc = allShapes.find(s => s.id === descId);
          if (desc) {
            descendants.push(...desc.getAllDescendants(allShapes));
          }
        });
        return descendants;
      }
    }

    // ===== SIMPLIFIED QUILT ENGINE (BETA) =====
    class SimpleQuiltEngine {
      constructor() {
        this.blocks = [];
        this.submissionCount = 0;
        this.deviceId = this.getOrCreateDeviceId();
      }
      
      getOrCreateDeviceId() {
        let deviceId = localStorage.getItem('quiltDeviceId');
        if (!deviceId) {
          deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('quiltDeviceId', deviceId);
        }
        return deviceId;
      }
      
      initialize() {
        // Start with a single block covering the viewport
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        this.blocks = [{
          id: 'initial',
          x: 0,
          y: 0,
          width: viewportWidth,
          height: viewportHeight,
          color: CONFIG.APP.defaultColor,
          contributorId: this.deviceId,
          submissionIndex: 0
        }];
        
        this.submissionCount = 0;
        console.log('üßµ Simple Quilt Engine initialized');
      }
      
      addSubmission() {
        this.submissionCount++;
        return this.submissionCount;
      }
      
      addColor(newColor) {
        this.submissionCount++;
        
        // Find a random block to split
        const splittableBlocks = this.blocks.filter(block => 
          block.width > 60 && block.height > 60
        );
        
        if (splittableBlocks.length === 0) {
          // If no blocks can be split, create a new block at the edge
          return this.addBlockAtEdge(newColor);
        }
        
        const randomBlock = splittableBlocks[Math.floor(Math.random() * splittableBlocks.length)];
        const splitResult = this.splitBlock(randomBlock, newColor);
        
        // Replace the original block with the split result
        const blockIndex = this.blocks.findIndex(b => b.id === randomBlock.id);
        this.blocks.splice(blockIndex, 1, ...splitResult);
        
        this.recordUserContribution(splitResult[1].id, newColor, this.submissionCount);
        
        return {
          originalBlock: randomBlock,
          newBlocks: splitResult,
          submissionIndex: this.submissionCount
        };
      }
      
      splitBlock(block, newColor) {
        const isWider = block.width > block.height;
        const splitDirection = isWider ? 'vertical' : 'horizontal';
        
        if (splitDirection === 'horizontal') {
          const splitHeight = block.height * (0.3 + Math.random() * 0.4);
          
          const block1 = {
            ...block,
            id: block.id + '_1',
            height: splitHeight
          };
          
          const block2 = {
            ...block,
            id: block.id + '_2',
            y: block.y + splitHeight,
            height: block.height - splitHeight,
            color: newColor,
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount
          };
          
          return [block1, block2];
        } else {
          const splitWidth = block.width * (0.3 + Math.random() * 0.4);
          
          const block1 = {
            ...block,
            id: block.id + '_1',
            width: splitWidth
          };
          
          const block2 = {
            ...block,
            id: block.id + '_2',
            x: block.x + splitWidth,
            width: block.width - splitWidth,
            color: newColor,
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount
          };
          
          return [block1, block2];
        }
      }
      
      addBlockAtEdge(newColor) {
        // Find the current bounds
        const minX = Math.min(...this.blocks.map(b => b.x));
        const minY = Math.min(...this.blocks.map(b => b.y));
        const maxX = Math.max(...this.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.blocks.map(b => b.y + b.height));
        
        const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
        const blockSize = 80;
        
        let newBlock;
        switch (edge) {
          case 0: // top
            newBlock = {
              id: 'edge_' + Date.now(),
              x: minX + Math.random() * (maxX - minX - blockSize),
              y: minY - blockSize,
              width: blockSize,
              height: blockSize,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
          case 1: // right
            newBlock = {
              id: 'edge_' + Date.now(),
              x: maxX,
              y: minY + Math.random() * (maxY - minY - blockSize),
              width: blockSize,
              height: blockSize,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
          case 2: // bottom
            newBlock = {
              id: 'edge_' + Date.now(),
              x: minX + Math.random() * (maxX - minX - blockSize),
              y: maxY,
              width: blockSize,
              height: blockSize,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
          case 3: // left
            newBlock = {
              id: 'edge_' + Date.now(),
              x: minX - blockSize,
              y: minY + Math.random() * (maxY - minY - blockSize),
              width: blockSize,
              height: blockSize,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
        }
        
        this.blocks.push(newBlock);
        this.recordUserContribution(newBlock.id, newColor, this.submissionCount);
        
        return {
          originalBlock: null,
          newBlocks: [newBlock],
          submissionIndex: this.submissionCount
        };
      }
      

      
      recordUserContribution(blockId, color, submissionIndex) {
        const contribution = {
          submissionIndex,
          blockId,
          color,
          timestamp: new Date().toISOString()
        };
        
        const stored = JSON.parse(localStorage.getItem('quiltContributions') || '{"submissions": []}');
        stored.submissions.push(contribution);
        localStorage.setItem('quiltContributions', JSON.stringify(stored));
      }
      
      findUserPieces() {
        const contributions = this.getUserContributions();
        const userBlockIds = new Set();
        
        contributions.submissions.forEach(contrib => {
          userBlockIds.add(contrib.blockId);
        });
        
        return this.blocks.filter(block => userBlockIds.has(block.id));
      }
      
      getUserContributions() {
        const stored = localStorage.getItem('quiltContributions');
        return stored ? JSON.parse(stored) : { submissions: [] };
      }
      
      getState() {
        return {
          submissionCount: this.submissionCount,
          blocks: this.blocks,
          userPieces: this.findUserPieces()
        };
      }
    }

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static getQuiltDimensions() {
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        
        let screenWidth, screenHeight;
        
        if (hasVisualViewport) {
          screenWidth = window.visualViewport.width;
          screenHeight = window.visualViewport.height;
        } else {
          const body = document.body;
          const html = document.documentElement;
          
          const bodyRect = body.getBoundingClientRect();
          const htmlRect = html.getBoundingClientRect();
          
          const measuredWidth = Math.min(bodyRect.width, htmlRect.width);
          const measuredHeight = Math.min(bodyRect.height, htmlRect.height);
          
          if (measuredWidth > 0 && measuredHeight > 0) {
            screenWidth = measuredWidth;
            screenHeight = measuredHeight;
          } else {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            
            const browserUIMargin = Math.min(screenHeight * 0.15, 120);
            screenHeight = screenHeight - browserUIMargin;
          }
        }
        
        const isMobile = screenWidth <= 768;
        
        if (isMobile) {
          return {
            width: screenWidth,
            height: screenHeight,
            viewBoxWidth: screenWidth,
            viewBoxHeight: screenHeight
          };
        } else {
          const maxSize = Math.min(screenWidth * 0.8, screenHeight * 0.8);
          return {
            width: maxSize,
            height: maxSize,
            viewBoxWidth: maxSize,
            viewBoxHeight: maxSize
          };
        }
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    }

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = 'üßµ';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} ‚ö†Ô∏è ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} ‚ùå ${message}`, error || '');
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        try {
          document.querySelectorAll(".screen").forEach(s => {
            s.classList.remove("active");
            s.style.display = 'none';
          });
          
          const target = document.getElementById(screenId);
          if (target) {
            target.style.display = 'flex';
            target.classList.add("active");
            
            target.offsetHeight;
            
            if (screenId === 'screen-color') {
              const colorScreen = document.getElementById('screen-color');
              if (colorScreen) {
                colorScreen.style.backgroundColor = '#f6f4f1';
              }
            }
            
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            const app = document.getElementById('app');
            if (app) {
              app.scrollTop = 0;
            }
            
            // Dispatch custom event for screen change
            document.dispatchEvent(new CustomEvent('screenChange', {
              detail: { screenId: screenId }
            }));
            
          } else {
            this.logger.error(`‚ùå Screen not found: ${screenId}`);
            this.showScreen('screen-portal');
          }
        } catch (error) {
          this.logger.error(`‚ùå Error switching to screen ${screenId}:`, error);
          const portalScreen = document.getElementById('screen-portal');
          if (portalScreen) {
            document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
            portalScreen.classList.add("active");
            portalScreen.style.display = 'flex';
          }
        }
      }
    }

    // ===== ERROR HANDLING SERVICE =====
    class ErrorHandler {
      constructor(uiService, logger) {
        this.uiService = uiService;
        this.logger = logger;
      }

      handleError(error, context = 'Unknown') {
        this.logger.error(`Error in ${context}:`, error);
        
        const errorMessages = {
          'loadQuilt': 'Failed to load quilt data. Starting fresh.',
          'saveQuilt': 'Failed to save your color. Please try again.',
          'shareFlow': 'Failed to create share image. Saving instead.',
          'colorPicker': 'Color picker error. Please try again.',
          'App initialization': 'Failed to initialize app. Please refresh.',
          'renderQuilt': 'Failed to render quilt. Please try again.',
          'addColorToQuilt': 'Failed to add color. Please try again.'
        };
        
        const message = errorMessages[context] || 'Something went wrong. Please try again.';
        this.uiService.showToast(message);
      }

      validateColor(color) {
        if (!Utils.validateHexColor(color)) {
          throw new Error(`Invalid color format: ${color}`);
        }
        return true;
      }
    }

    // ===== ARCHIVE SERVICE =====
    class ArchiveService {
      constructor(logger, dataService) {
        this.logger = logger;
        this.dataService = dataService;
        this.archives = new Map(); // Date string -> archive data (cached)
        this.isLoading = false;
        this.currentPage = 0;
        this.postsPerPage = 10;
      }

      // Archive data structure for each day
      createArchiveEntry(date, quilt, quote, userCount) {
        return {
          date: date, // "2024-01-15"
          quilt: quilt, // SVG data/state
          quote: quote, // { text: "...", author: "..." }
          userCount: userCount, // Number of users who contributed
          shareCount: 0, // Number of times this quilt has been shared
          thumbnail: null, // Will be generated
          isComplete: true // Whether the day finished properly
        };
      }

      // Get archives for feed (with pagination)
      getArchives(page = 0, limit = this.postsPerPage) {
        const allArchives = Array.from(this.archives.values())
          .sort((a, b) => new Date(b.date) - new Date(a.date)); // Newest first
        
        const start = page * limit;
        const end = start + limit;
        const pageArchives = allArchives.slice(start, end);
        
        return {
          archives: pageArchives,
          hasMore: end < allArchives.length,
          totalCount: allArchives.length
        };
      }

      // Add new archive entry
      async addArchive(archiveEntry) {
        // Add to local cache
        this.archives.set(archiveEntry.date, archiveEntry);
        this.logger.log(`üìù Archive cached locally: ${archiveEntry.date}`);
      }

      // Generate thumbnail from SVG
      async generateThumbnail(svgElement) {
        try {
          if (!svgElement) {
            svgElement = document.getElementById('quilt');
          }
          
          if (!svgElement) {
            this.logger.warn('No SVG element found for thumbnail generation');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+Tm8gUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // Clone SVG to avoid modifying original
          const svgClone = svgElement.cloneNode(true);
          
          // Get SVG dimensions
          const svgRect = svgElement.getBoundingClientRect();
          const width = Math.max(400, svgRect.width);
          const height = Math.max(400, svgRect.height);
          
          // Ensure SVG has proper attributes
          svgClone.setAttribute('width', width);
          svgClone.setAttribute('height', height);
          svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          
          // Convert SVG to string
          const svgData = new XMLSerializer().serializeToString(svgClone);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          
          // Create canvas for conversion
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = width;
          canvas.height = height;
          
          // Create image from SVG
          const img = new Image();
          const url = URL.createObjectURL(svgBlob);
          
          return new Promise((resolve) => {
            img.onload = () => {
              // Draw to canvas
              ctx.fillStyle = '#f6f4f1'; // Background color
              ctx.fillRect(0, 0, width, height);
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert to data URL
              const dataURL = canvas.toDataURL('image/png', 0.8);
              URL.revokeObjectURL(url);
              
              this.logger.log(`‚úÖ Generated thumbnail: ${width}x${height}`);
              resolve(dataURL);
            };
            
            img.onerror = () => {
              URL.revokeObjectURL(url);
              this.logger.error('Failed to generate thumbnail');
              resolve('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==');
            };
            
            img.src = url;
          });
          
        } catch (error) {
          this.logger.error('Thumbnail generation failed:', error);
          return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==';
        }
      }

      // Load more archives (for "Load More" button)
      async loadMore() {
        if (this.isLoading) return null;
        
        this.isLoading = true;
        this.currentPage++;
        
        try {
          const result = this.getArchives(this.currentPage);
          this.isLoading = false;
          return result;
        } catch (error) {
          this.isLoading = false;
          this.logger.error('Failed to load more archives:', error);
          return null;
        }
      }

      // Create HTML for a single archive post
      createArchivePostHTML(archiveEntry) {
        const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });

        return `
          <div class="archive-post" data-date="${archiveEntry.date}">
            <img class="archive-post-image" 
                 src="${archiveEntry.thumbnail || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+TG9hZGluZy4uLjwvdGV4dD4KPHN2Zz4='}" 
                 alt="Quilt from ${formattedDate}"
                 loading="lazy" />
            <div class="archive-post-caption">
              <div class="archive-post-content">
                <div class="archive-post-public">
                  <div class="archive-post-quote-author">"${archiveEntry.quote.text}" ${archiveEntry.quote.author}</div>
                  <div class="archive-post-meta">
                    <span class="archive-post-date">${formattedDate}</span>
                    <span class="archive-post-contributors">${archiveEntry.userCount} contributors</span>
                    <button class="archive-share-btn" data-date="${archiveEntry.date}" title="Share this quilt">
                      üì§ Share
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      // Render archive feed
      renderArchiveFeed(containerId = 'archiveFeed') {
        const container = document.getElementById(containerId);
        if (!container) {
          this.logger.error('Archive feed container not found');
          return;
        }

        // Get first page of archives
        const result = this.getArchives(0);
        
        if (result.archives.length === 0) {
          container.innerHTML = '<p class="archive-loading">No quilts archived yet. Check back soon!</p>';
          return;
        }

        // Render posts
        container.innerHTML = result.archives
          .map(archive => this.createArchivePostHTML(archive))
          .join('');

        // Setup click handlers for images
        this.setupImageClickHandlers(container);

        // Show/hide Load More button
        this.updateLoadMoreButton(result.hasMore);

        this.logger.log(`Rendered ${result.archives.length} archive posts`);
      }

      // Setup click handlers for archive post images and share buttons
      setupImageClickHandlers(container) {
        // Archive image click handlers
        const images = container.querySelectorAll('.archive-post-image');
        images.forEach(img => {
          img.addEventListener('click', (e) => {
            const postElement = e.target.closest('.archive-post');
            const date = postElement.dataset.date;
            const archiveEntry = this.archives.get(date);
            if (archiveEntry) {
              this.openArchiveModal(archiveEntry);
            }
          });
        });
        
        // Archive share button click handlers
        const shareButtons = container.querySelectorAll('.archive-share-btn');
        shareButtons.forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent triggering image click
            const date = btn.getAttribute('data-date');
            await this.shareArchiveQuilt(date);
          });
        });
      }

      // Open archive modal with enlarged view
      openArchiveModal(archiveEntry) {
        const modal = document.getElementById('archiveModal');
        const modalImage = document.getElementById('archiveModalImage');
        const modalQuote = document.getElementById('archiveModalQuote');
        const modalMeta = document.getElementById('archiveModalMeta');

        if (!modal) return;

        // Set modal content
        modalImage.src = archiveEntry.thumbnail || '';
        modalImage.alt = `Quilt from ${archiveEntry.date}`;
        modalQuote.textContent = `"${archiveEntry.quote.text}" ${archiveEntry.quote.author}`;
        
        const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        modalMeta.innerHTML = `${formattedDate} ‚Ä¢ ${archiveEntry.userCount} contributors`;

        // Show modal
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden'; // Prevent background scroll
      }

      // Close archive modal
      closeArchiveModal() {
        const modal = document.getElementById('archiveModal');
        if (modal) {
          modal.style.display = 'none';
          document.body.style.overflow = ''; // Restore scroll
        }
      }

      // Update Load More button visibility
      updateLoadMoreButton(hasMore) {
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        if (loadMoreBtn) {
          loadMoreBtn.style.display = hasMore ? 'block' : 'none';
        }
      }

      // Share an archived quilt
      async shareArchiveQuilt(date) {
        try {
          const archiveEntry = this.archives.get(date);
          if (!archiveEntry) {
            throw new Error('Archive entry not found');
          }
          
          const formattedDate = new Date(date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Use the Web Share API if available
          if (navigator.share) {
            try {
              await navigator.share({
                title: `Community Quilt - ${formattedDate}`,
                text: `"${archiveEntry.quote.text}" ${archiveEntry.quote.author} - Made by ${archiveEntry.userCount} contributors`,
                url: `${window.location.href}?date=${date}`
              });
              
              this.logger.log(`üì§ Archive quilt shared: ${date}`);
              return;
            } catch (shareError) {
              // User cancelled or share failed
              if (shareError.name !== 'AbortError') {
                this.logger.log('Web Share failed, falling back to copy link');
              }
            }
          }
          
          // Fallback: Copy link to clipboard
          try {
            const shareUrl = `${window.location.href}?date=${date}`;
            await navigator.clipboard.writeText(shareUrl);
            this.logger.log(`üì§ Archive link copied: ${date}`);
          } catch (clipboardError) {
            // Final fallback: Just show a message
            const shareUrl = `${window.location.href}?date=${date}`;
            this.logger.log(`üì§ Archive share link: ${shareUrl}`);
          }
          
        } catch (error) {
          this.logger.error('Archive share failed:', error);
        }
      }
    }

    // ===== DATA LAYER =====
    class QuiltDataService {
      constructor(logger, errorHandler) {
        this.logger = logger;
        this.errorHandler = errorHandler;
        this.db = null;
        this.quiltDoc = null;
      }

      async initialize() {
        this.db = null;
        this.quiltDoc = null;
      }

      async loadQuilt() {
        try {
          const savedData = localStorage.getItem('ourDailyQuilt');
          if (savedData) {
            const data = JSON.parse(savedData);
            return { 
              blocks: data.blocks || [], 
              contributorCount: data.contributorCount || 1 
            };
          }
        } catch (error) {
          // Fall through to default
        }
        
        const dimensions = Utils.getQuiltDimensions();
        return { 
          blocks: [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }], 
          contributorCount: 1 
        };
      }

      async saveQuilt(blocks, contributorCount) {
        try {
          localStorage.setItem('ourDailyQuilt', JSON.stringify({
            blocks: blocks,
            contributorCount: contributorCount,
            lastUpdated: new Date().toISOString(),
            date: new Date().toISOString().split('T')[0]
          }));
          return true;
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          return false;
        }
      }
    }



    // ===== QUOTE SERVICE =====
    class QuoteService {
      constructor() {
        this.quotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "‚Äî Pablo Picasso" },
          { text: "Creativity takes courage.", author: "‚Äî Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "‚Äî Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "‚Äî Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "‚Äî Vincent Van Gogh" },
          { text: "You can't use up creativity. The more you use, the more you have.", author: "‚Äî Maya Angelou" }
        ];
        this.shuffledIndexes = [2, 4, 0, 5, 3, 1];
      }

      getTodayQuote() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayString = `${year}-${month}-${day}`;
        const dayIndex = Math.floor(new Date(todayString).getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        return this.quotes[quoteIndex];
      }

      displayQuote() {
        try {
          const { text, author } = this.getTodayQuote();
          const quoteLine = document.querySelector('.quote-line');
          const quoteAuthor = document.querySelector('.quote-author');
          
          if (quoteLine) quoteLine.textContent = text;
          if (quoteAuthor) quoteAuthor.textContent = author;
        } catch (error) {
          console.error('Error displaying quote:', error);
        }
      }
    }

    // ===== ENHANCED RENDERER =====
    class QuiltRendererV2 {
      constructor(logger) {
        this.logger = logger;
        this.quiltSVG = null;
        this.lastAddedIndex = null;
        this.userPieces = new Set();
      }

      initialize() {
        this.quiltSVG = document.getElementById('quilt');
        if (!this.quiltSVG) {
          throw new Error('Quilt SVG element not found');
        }
        
        // Set initial viewBox to viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        this.quiltSVG.setAttribute('viewBox', `0 0 ${viewportWidth} ${viewportHeight}`);
        this.quiltSVG.setAttribute('width', viewportWidth);
        this.quiltSVG.setAttribute('height', viewportHeight);
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      }

      renderBlocks(blocks, userPieces = []) {
        if (!this.quiltSVG) {
          this.logger.warn('Quilt SVG not found');
          return;
        }

        this.quiltSVG.innerHTML = '';
        this.userPieces = new Set(userPieces.map(b => b.id));

        if (blocks.length === 0) {
          return;
        }

        const minX = Math.min(...blocks.map(b => b.x));
        const minY = Math.min(...blocks.map(b => b.y));
        const maxX = Math.max(...blocks.map(b => b.x + b.width));
        const maxY = Math.max(...blocks.map(b => b.y + b.height));
        
        const quiltWidth = maxX - minX;
        const quiltHeight = maxY - minY;
        
        const scale = window.app?.quiltScale || 1;
        const scaledWidth = quiltWidth * scale;
        const scaledHeight = quiltHeight * scale;
        
        this.quiltSVG.setAttribute('viewBox', `${minX} ${minY} ${quiltWidth} ${quiltHeight}`);
        this.quiltSVG.setAttribute('width', scaledWidth);
        this.quiltSVG.setAttribute('height', scaledHeight);
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMinYMin meet');
        
        this.quiltSVG.style.width = `${scaledWidth}px`;
        this.quiltSVG.style.height = `${scaledHeight}px`;
        this.quiltSVG.style.maxWidth = '100%';
        this.quiltSVG.style.maxHeight = '100%';

        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
          <filter id="dropShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="rgba(0,0,0,0.15)"/>
          </filter>
        `;
        this.quiltSVG.appendChild(defs);

        blocks.forEach((block, i) => {
          const jitterX = (Math.random() - 0.5) * 6;
          const jitterY = (Math.random() - 0.5) * 6;
          const jitterRotation = (Math.random() - 0.5) * 3;
          
          const jitteredBlock = {
            x: block.x + jitterX,
            y: block.y + jitterY,
            width: block.width,
            height: block.height,
            color: block.color,
            rotation: jitterRotation
          };
          
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', jitteredBlock.x);
          rect.setAttribute('y', jitteredBlock.y);
          rect.setAttribute('width', jitteredBlock.width);
          rect.setAttribute('height', jitteredBlock.height);
          rect.setAttribute('fill', jitteredBlock.color);
          
          const centerX = jitteredBlock.x + jitteredBlock.width / 2;
          const centerY = jitteredBlock.y + jitteredBlock.height / 2;
          rect.setAttribute('transform', `rotate(${jitterRotation} ${centerX} ${centerY})`);
          
          // Add user piece highlighting
          if (this.userPieces.has(block.id)) {
            rect.classList.add('user-piece-highlight');
          }
          
          // Add new block animation
          if (i === this.lastAddedIndex) {
            rect.setAttribute('opacity', '0');
            rect.classList.add('new-block');
            rect.addEventListener('animationend', () => {
              rect.classList.remove('new-block');
              rect.removeAttribute('opacity');
            }, { once: true });
          }
          
          this.quiltSVG.appendChild(rect);
        });

        this.lastAddedIndex = null;
      }

      setLastAddedIndex(index) {
        this.lastAddedIndex = index;
      }
    }

    // ===== MAIN APPLICATION =====
    class SimplifiedQuiltAppV2 {
      constructor() {
        // Initialize services
        this.logger = new Logger(CONFIG.APP.debugMode);
        this.uiService = new UIService(this.logger);
        this.errorHandler = new ErrorHandler(this.uiService, this.logger);
        this.dataService = new QuiltDataService(this.logger, this.errorHandler);
        this.quoteService = new QuoteService();
        this.renderer = new QuiltRendererV2(this.logger);
        this.archiveService = new ArchiveService(this.logger, this.dataService);
        
        // Initialize simplified engine
        this.quiltEngine = new SimpleQuiltEngine();
        
        // App state
        this.currentUserId = Utils.getOrCreateUserId();
        this.quiltScale = 1;
        
        // Color picker state
        this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
        this.selectedSaturation = CONFIG.COLOR_PICKER.saturation;
        this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
        this.colorHasBeenSelected = false;
      }

      async initialize() {
        try {
          this.uiService.showScreen('screen-portal');
          
          await this.dataService.initialize();
          this.setupEventListeners();
          this.initializeUI();
          
          // Initialize new engine
          this.quiltEngine.initialize();
          await this.loadQuilt();
          
          this.renderer.initialize();
          this.renderQuilt();
          this.updateSquareCounter();
          
          this.setupAutoTransition();
          this.setupDailyReset();
          
        } catch (error) {
          this.errorHandler.handleError(error, 'App initialization');
          this.uiService.showScreen('screen-portal');
        }
      }

      setupEventListeners() {
        // Navigation
        document.querySelectorAll(".btn[data-next]").forEach(btn => {
          btn.addEventListener("click", e => {
            e.preventDefault();
            const targetId = btn.getAttribute("data-next");
            if (targetId) this.uiService.showScreen(targetId);
          });
        });

        // Add color button
        const addColorBtn = document.getElementById('addColorBtn');
        if (addColorBtn) {
          addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
        }

        // Share button
        const shareBtnCompleted = document.getElementById('shareBtnCompleted');
        if (shareBtnCompleted) {
          shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
        }

        // Test buttons
        const showMyPieceBtn = document.getElementById('showMyPieceBtn');
        if (showMyPieceBtn) {
          showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
        }



        // Color picker
        this.setupColorPicker();

        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        
        // Window resize handler
        window.addEventListener('resize', this.handleWindowResize.bind(this));
        
        // Visual viewport resize handler
        if (window.visualViewport) {
          window.visualViewport.addEventListener('resize', this.handleWindowResize.bind(this));
        }
        
        // Floating admin button
        this.setupFloatingAdminButton();
        
        // Archive event handlers
        this.setupArchiveEventHandlers();
      }

      setupColorPicker() {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const valueSlider = document.getElementById('valueSlider');

        if (colorWheel) {
          colorWheel.addEventListener('mousedown', this.handleColorWheelMouseDown.bind(this));
          colorWheel.addEventListener('mousemove', this.handleColorWheelMouseMove.bind(this));
          colorWheel.addEventListener('mouseup', this.handleColorWheelMouseUp.bind(this));
          
          colorWheel.addEventListener('touchstart', this.handleColorWheelTouchStart.bind(this));
          colorWheel.addEventListener('touchmove', this.handleColorWheelTouchMove.bind(this));
          colorWheel.addEventListener('touchend', this.handleColorWheelTouchEnd.bind(this));
          
          colorWheel.addEventListener('keydown', this.handleColorWheelKeyDown.bind(this));
          colorWheel.addEventListener('click', this.handleColorWheelClick.bind(this));
        }

        if (valueSlider) {
          valueSlider.addEventListener('input', this.handleValueSliderChange.bind(this));
        }

        this.updateColorWheel();
      }

      handleColorWheelMouseDown(e) {
        e.preventDefault();
        this.isDragging = true;
        this.setHueFromCoords(e.clientX, e.clientY);
      }

      handleColorWheelMouseMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          this.setHueFromCoords(e.clientX, e.clientY);
        }
      }

      handleColorWheelMouseUp(e) {
        this.isDragging = false;
      }

      handleColorWheelClick(e) {
        e.preventDefault();
        this.setHueFromCoords(e.clientX, e.clientY);
        this.updateColorWheel();
      }

      handleColorWheelTouchStart(e) {
        e.preventDefault();
        this.isDragging = true;
        const touch = e.touches[0];
        this.setHueFromCoords(touch.clientX, touch.clientY);
      }

      handleColorWheelTouchMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          const touch = e.touches[0];
          this.setHueFromCoords(touch.clientX, touch.clientY);
        }
      }

      handleColorWheelTouchEnd(e) {
        this.isDragging = false;
      }

      handleColorWheelKeyDown(e) {
        const step = 15;
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            this.selectedHue = (this.selectedHue - step + 360) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.selectedHue = (this.selectedHue + step) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.selectedLightness = Math.min(90, this.selectedLightness + 5);
            this.updateColorWheel();
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.selectedLightness = Math.max(25, this.selectedLightness - 5);
            this.updateColorWheel();
            break;
        }
      }

      handleValueSliderChange(e) {
        this.selectedLightness = parseInt(e.target.value);
        this.updateColorWheel();
      }

      updateColorWheel() {
        const valueSlider = document.getElementById('valueSlider');
        
        const hslColor = `hsl(${this.selectedHue}, ${this.selectedSaturation}%, ${this.selectedLightness}%)`;
        const hexColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
        
        const colorScreen = document.getElementById('screen-color');
        if (colorScreen && this.colorHasBeenSelected) {
          colorScreen.style.backgroundColor = hexColor;
        }
        
        if (valueSlider) {
          valueSlider.style.background = `linear-gradient(to right,
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 20%), 
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 90%))`;
        }
      }

      setHueFromCoords(x, y) {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = rect.width / 2;

        let angle = Math.atan2(dy, dx) * 180 / Math.PI;
        if (angle < 0) angle += 360;
        
        const rawHue = Math.round((angle + 90) % 360);
        this.selectedHue = (rawHue + 25) % 360;
        
        const baseSaturation = Math.min(100, (distance / radius) * 100);
        this.selectedSaturation = Math.min(Math.round(baseSaturation + 5), 100);

        if (distance > radius) {
          const clampedDistance = radius;
          const clampedX = centerX + (dx / distance) * clampedDistance;
          const clampedY = centerY + (dy / distance) * clampedDistance;
          this.selectedSaturation = 100;
          
          if (indicator) {
            const relativeX = clampedX - rect.left;
            const relativeY = clampedY - rect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        } else {
          if (indicator) {
            const relativeX = x - rect.left;
            const relativeY = y - rect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        }
        
        this.colorHasBeenSelected = true;
        this.updateColorWheel();
      }

      handleKeyDown(event) {
        if (event.key === 'Escape') {
          const currentScreen = document.querySelector('.screen.active');
          if (currentScreen) {
            const currentId = currentScreen.id;
            if (currentId === 'screen-quote') {
              this.uiService.showScreen('screen-portal');
            } else if (currentId === 'screen-color') {
              this.uiService.showScreen('screen-quote');
            } else if (currentId === 'screen-quilt') {
              this.uiService.showScreen('screen-color');
            }
          }
        }
      }

      handleWindowResize() {
        if (this.quiltEngine.blocks && this.quiltEngine.blocks.length > 0) {
          this.renderQuilt();
        }
      }

      setupFloatingAdminButton() {
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          const isAdmin = this.isCurrentUserAdmin();
          
          if (isAdmin) {
            adminBtn.style.display = 'flex';
            if (!adminBtn.hasAttribute('data-admin-initialized')) {
              adminBtn.addEventListener('click', () => {
                this.showAdminMenu();
              });
              adminBtn.setAttribute('data-admin-initialized', 'true');
            }
          } else {
            adminBtn.style.display = 'none';
          }
        }
      }

      setupArchiveEventHandlers() {
        // Archive Load More button
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        if (loadMoreBtn) {
          loadMoreBtn.addEventListener('click', () => {
            this.handleArchiveLoadMore();
          });
        }

        // Archive modal close handlers
        const modalClose = document.getElementById('archiveModalClose');
        const modalBackdrop = document.getElementById('archiveModalBackdrop');
        
        if (modalClose) {
          modalClose.addEventListener('click', () => {
            this.archiveService.closeArchiveModal();
          });
        }
        
        if (modalBackdrop) {
          modalBackdrop.addEventListener('click', () => {
            this.archiveService.closeArchiveModal();
          });
        }

        // Archive screen initialization
        document.addEventListener('screenChange', (e) => {
          if (e.detail.screenId === 'screen-archive') {
            this.initializeArchiveScreen();
          }
        });
      }

      async handleArchiveLoadMore() {
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        const loadingDiv = document.getElementById('archiveLoading');
        
        if (loadMoreBtn) loadMoreBtn.disabled = true;
        if (loadingDiv) loadingDiv.style.display = 'block';

        try {
          const result = await this.archiveService.loadMore();
          if (result && result.archives.length > 0) {
            // Append new posts to existing feed
            const container = document.getElementById('archiveFeed');
            if (container) {
              const newPostsHTML = result.archives
                .map(archive => this.archiveService.createArchivePostHTML(archive))
                .join('');
              
              container.insertAdjacentHTML('beforeend', newPostsHTML);
              this.archiveService.setupImageClickHandlers(container);
              this.archiveService.updateLoadMoreButton(result.hasMore);
            }
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'Load more archives');
        } finally {
          if (loadMoreBtn) loadMoreBtn.disabled = false;
          if (loadingDiv) loadingDiv.style.display = 'none';
        }
      }

      initializeArchiveScreen() {
        // Render the archive feed
        this.archiveService.renderArchiveFeed();
      }

      // Create archive snapshot from current quilt
      async createArchiveSnapshot() {
        const today = new Date().toISOString().split('T')[0];
        const currentQuote = this.quoteService.getTodayQuote();
        const blockCount = this.quiltEngine.blocks.length;
        
        this.logger.log(`üñºÔ∏è Generating thumbnail for ${blockCount} blocks...`);
        
        // Generate thumbnail from current SVG
        const thumbnail = await this.archiveService.generateThumbnail();
        
        // Create archive entry
        const archiveEntry = this.archiveService.createArchiveEntry(
          today,
          { blocks: this.quiltEngine.blocks }, // Current quilt state
          currentQuote,
          Math.max(blockCount, 12) // Use actual block count or minimum 12
        );
        
        // Set the generated thumbnail
        archiveEntry.thumbnail = thumbnail;
        
        // Add to archive
        await this.archiveService.addArchive(archiveEntry);
        
        // Re-render if on archive screen
        const archiveScreen = document.getElementById('screen-archive');
        if (archiveScreen && archiveScreen.classList.contains('active')) {
          this.archiveService.renderArchiveFeed();
        }
        
        this.logger.log(`‚úÖ Created archive snapshot for ${today} with ${blockCount} blocks and thumbnail`);
        return archiveEntry;
      }

      // Create test archive posts
      async createTestArchivePosts() {
        const testQuotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "‚Äî Pablo Picasso" },
          { text: "Creativity takes courage.", author: "‚Äî Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "‚Äî Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "‚Äî Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "‚Äî Vincent Van Gogh" }
        ];

        const testDates = [
          '2024-01-15',
          '2024-01-14', 
          '2024-01-13',
          '2024-01-12',
          '2024-01-11'
        ];

        for (let i = 0; i < 5; i++) {
          const archiveEntry = this.archiveService.createArchiveEntry(
            testDates[i],
            { blocks: [] }, // Empty quilt state for test
            testQuotes[i],
            15 + Math.floor(Math.random() * 20) // Random contributor count
          );

          // Create a simple test thumbnail with a colored background
          const canvas = document.createElement('canvas');
          canvas.width = 400;
          canvas.height = 400;
          const ctx = canvas.getContext('2d');
          
          // Create a gradient background
          const gradient = ctx.createLinearGradient(0, 0, 400, 400);
          const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
          gradient.addColorStop(0, colors[i % colors.length]);
          gradient.addColorStop(1, colors[(i + 1) % colors.length]);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 400, 400);
          
          // Add some random rectangles to simulate quilt blocks
          for (let j = 0; j < 8; j++) {
            ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
            ctx.fillRect(
              Math.random() * 350,
              Math.random() * 350,
              30 + Math.random() * 50,
              30 + Math.random() * 50
            );
          }
          
          // Add date text
          ctx.fillStyle = '#000';
          ctx.font = '24px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(testDates[i], 200, 200);
          
          archiveEntry.thumbnail = canvas.toDataURL('image/png', 0.8);
          
          await this.archiveService.addArchive(archiveEntry);
        }

        this.logger.log('‚úÖ Created 5 test archive posts');
        
        // Re-render if on archive screen
        const archiveScreen = document.getElementById('screen-archive');
        if (archiveScreen && archiveScreen.classList.contains('active')) {
          this.archiveService.renderArchiveFeed();
        }
      }

      isCurrentUserAdmin() {
        const currentUserId = this.currentUserId;
        const adminUserIds = [];
        const isAdminFlag = localStorage.getItem('ourDailyIsAdmin') === 'true';
        const adminEmails = [];
        
        return isAdminFlag || adminUserIds.includes(currentUserId);
      }

      enableAdminMode() {
        localStorage.setItem('ourDailyIsAdmin', 'true');
        this.uiService.showToast('Admin mode enabled');
        this.setupFloatingAdminButton();
      }

      disableAdminMode() {
        if (!confirm('Are you sure you want to disable admin mode? You can re-enable it with enableAdmin().')) {
          return;
        }
        
        localStorage.removeItem('ourDailyIsAdmin');
        this.uiService.showToast('Admin mode disabled');
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          adminBtn.style.display = 'none';
        }
      }

      showAdminMenu() {
        const menu = document.createElement('div');
        menu.className = 'admin-menu';
        menu.innerHTML = `
          <div class="admin-menu-content">
            <h3>Admin Controls</h3>
            <button onclick="app.handleTestAddBlock()">Add Random Block</button>
            <button onclick="app.handleShowMyPiece()">Show My Piece</button>
            <button onclick="app.handleTestDifferentUser()">Simulate Different User</button>
            <button onclick="app.handleResetQuilt()">Reset Quilt</button>
            <button onclick="app.handleCreateTestArchives()">Create Test Archives</button>
            <button onclick="app.handleTestDailyReset()">Test Daily Reset</button>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        menu.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          z-index: 1001;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          min-width: 250px;
        `;
        
        const content = menu.querySelector('.admin-menu-content');
        content.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 10px;
        `;
        
        const buttons = menu.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
          `;
        });
        
        menu.addEventListener('click', (e) => {
          if (e.target === menu) {
            menu.remove();
          }
        });
        
        document.body.appendChild(menu);
      }

      initializeUI() {
        const dateText = document.getElementById("date-text");
        if (dateText) {
          dateText.textContent = Utils.formatDate();
        }
        this.quoteService.displayQuote();
        this.uiService.showScreen('screen-portal');
      }

      setupAutoTransition() {
        // Always set up the auto-transition regardless of current screen
        const delay = window.innerWidth <= 768 ? 3000 : 2000;
        
        console.log('üîÑ Setting up auto-transition with delay:', delay);
        
        setTimeout(() => {
          const currentScreen = document.querySelector('.screen.active');
          console.log('üîÑ Auto-transition check - current screen:', currentScreen?.id);
          
          if (currentScreen && currentScreen.id === 'screen-portal') {
            console.log('üîÑ Auto-transitioning from portal...');
            this.autoTransitionFromPortal();
          } else {
            console.log('üîÑ No auto-transition - portal not active');
          }
        }, delay);
      }

      async autoTransitionFromPortal() {
        try {
          console.log('üîÑ Starting auto-transition from portal...');
          
          const hasVisitedBefore = localStorage.getItem('ourDailyHasVisited');
          const lastVisitDate = localStorage.getItem('ourDailyLastVisitDate');
          
          const now = new Date();
          const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          const currentDate = chicagoTime.toDateString();
          const isNewDay = lastVisitDate !== currentDate;
          
          console.log('üîÑ Visit check:', { hasVisitedBefore, lastVisitDate, currentDate, isNewDay });
          
          if (!hasVisitedBefore || isNewDay) {
            console.log('üîÑ First visit or new day - showing welcome screen');
            localStorage.setItem('ourDailyHasVisited', 'true');
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            
            if (isNewDay) {
              console.log('üîÑ New day detected - resetting quilt');
              await this.resetQuiltForNewDay();
            }
            
            this.uiService.showScreen('screen-welcome');
            
            const quoteDelay = window.innerWidth <= 768 ? 2500 : 1500;
            console.log('üîÑ Will show quote screen in:', quoteDelay);
            setTimeout(() => {
              this.uiService.showScreen('screen-quote');
            }, quoteDelay);
          } else {
            console.log('üîÑ Returning user - showing quote screen directly');
            this.uiService.showScreen('screen-quote');
          }
        } catch (error) {
          this.logger.error('‚ùå Auto transition failed:', error);
          this.uiService.showScreen('screen-quote');
        }
      }
      
      async resetQuiltForNewDay() {
        this.quiltEngine.initialize();
        
        try {
          await this.dataService.saveQuilt([], 1);
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Failed to clear data for new day:', error);
        }
        
        this.renderQuilt();
        this.updateSquareCounter();
      }

      setupDailyReset() {
        this.logger.log('üåô Setting up automatic daily archive and reset...');
        
        const scheduleDailyCycle = () => {
          const now = new Date();
          
          // Convert to Chicago time (Central Time)
          const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          
          // Calculate next 11:59 PM Chicago time
          const nextArchive = new Date(chicagoTime);
          nextArchive.setHours(23, 59, 0, 0); // 11:59:00 PM
          
          // If it's already past 11:59 PM today, schedule for tomorrow
          if (chicagoTime >= nextArchive) {
            nextArchive.setDate(nextArchive.getDate() + 1);
          }
          
          // Calculate next 12:00 AM Chicago time (next day)
          const nextReset = new Date(chicagoTime);
          nextReset.setDate(nextReset.getDate() + 1);
          nextReset.setHours(0, 0, 0, 0); // 12:00:00 AM
          
          // Convert back to local time for setTimeout
          const localNextArchive = new Date(nextArchive.toLocaleString("en-US", {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone}));
          const localNextReset = new Date(nextReset.toLocaleString("en-US", {timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone}));
          
          const timeUntilArchive = localNextArchive.getTime() - now.getTime();
          const timeUntilReset = localNextReset.getTime() - now.getTime();
          
          this.logger.log(`üì¶ Next archive scheduled for: ${nextArchive.toLocaleString("en-US", {timeZone: "America/Chicago"})} Chicago time`);
          this.logger.log(`üîÑ Next reset scheduled for: ${nextReset.toLocaleString("en-US", {timeZone: "America/Chicago"})} Chicago time`);
          
          // Schedule archive at 11:59 PM
          if (timeUntilArchive > 0) {
            setTimeout(async () => {
              this.logger.log('üì¶ 11:59 PM reached - archiving current quilt');
              const archiveSuccess = await this.performDailyArchive();
              
              // Store archive status for reset check (using Chicago timezone)
              const chicagoNow = new Date(new Date().toLocaleString("en-US", {timeZone: "America/Chicago"}));
              const todayKey = chicagoNow.toDateString();
              localStorage.setItem(`archiveStatus_${todayKey}`, archiveSuccess ? 'success' : 'failed');
            }, timeUntilArchive);
          }
          
          // Schedule reset at 12:00 AM
          if (timeUntilReset > 0) {
            setTimeout(async () => {
              this.logger.log('üîÑ Midnight reached - checking archive status before reset');
              await this.performDailyReset();
              scheduleDailyCycle(); // Schedule next day's cycle
            }, timeUntilReset);
          }
        };
        
        // Schedule the first cycle
        scheduleDailyCycle();
      }

      async performDailyArchive() {
        try {
          this.logger.log('üì¶ Performing daily archive...');
          
          // Create archive of current quilt
          if (this.quiltEngine.blocks.length > 1) { // Only archive if there are blocks beyond the initial one
            await this.createArchiveSnapshot();
            this.logger.log('üì¶ Archived current quilt successfully');
            return true;
          } else {
            this.logger.log('üì¶ No quilt to archive (only initial block)');
            return true; // Consider this a success since there's nothing to archive
          }
          
        } catch (error) {
          this.logger.error('‚ùå Daily archive failed:', error);
          return false;
        }
      }

      async performDailyReset() {
        try {
          this.logger.log('üîÑ Performing daily reset...');
          
          // Check if archive was successful before resetting (using Chicago timezone)
          const chicagoNow = new Date(new Date().toLocaleString("en-US", {timeZone: "America/Chicago"}));
          const yesterday = new Date(chicagoNow);
          yesterday.setDate(yesterday.getDate() - 1);
          const yesterdayKey = yesterday.toDateString();
          const archiveStatus = localStorage.getItem(`archiveStatus_${yesterdayKey}`);
          
          if (archiveStatus === 'failed') {
            this.logger.error('‚ùå Archive failed yesterday - skipping reset to preserve data');
            this.logger.error('‚ùå Manual intervention required to resolve archive issue');
            return false;
          }
          
          if (archiveStatus === 'success' || archiveStatus === null) {
            // Archive was successful or no archive was needed (first day)
            this.logger.log('‚úÖ Archive check passed - proceeding with reset');
            
            // Reset the quilt
            await this.resetQuiltForNewDay();
            
            // Update visit tracking (using Chicago timezone)
            const chicagoNow = new Date(new Date().toLocaleString("en-US", {timeZone: "America/Chicago"}));
            const currentDate = chicagoNow.toDateString();
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            
            this.logger.log('‚úÖ Daily reset completed successfully');
            return true;
          }
          
        } catch (error) {
          this.logger.error('‚ùå Daily reset failed:', error);
          return false;
        }
      }

      async loadQuilt() {
        try {
          const data = await this.dataService.loadQuilt();
          
          if (data.blocks && data.blocks.length > 0) {
            this.quiltEngine.blocks = data.blocks.map(block => ({
              id: block.id || 'loaded_' + Math.random().toString(36).substr(2, 9),
              x: block.x,
              y: block.y,
              width: block.width,
              height: block.height,
              color: block.color,
              contributorId: this.currentUserId,
              submissionIndex: 0
            }));
            this.quiltEngine.submissionCount = data.contributorCount || 1;
          } else {
            this.quiltEngine.initialize();
          }
          
        } catch (error) {
          this.logger.error('‚ùå Failed to load quilt:', error);
          this.quiltEngine.initialize();
        }
      }

      async saveQuilt() {
        try {
          const blocks = this.quiltEngine.blocks.map(block => ({
            id: block.id,
            x: block.x,
            y: block.y,
            width: block.width,
            height: block.height,
            color: block.color
          }));
          
          await this.dataService.saveQuilt(blocks, this.quiltEngine.submissionCount);
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          throw error;
        }
      }

      renderQuilt() {
        this.ensureQuiltFits();
        
        const state = this.quiltEngine.getState();
        this.renderer.renderBlocks(state.blocks, state.userPieces);
        this.updateSquareCounter();
      }

      ensureQuiltFits() {
        if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length === 0) return;
        
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        const availableWidth = hasVisualViewport ? window.visualViewport.width : window.innerWidth;
        const availableHeight = hasVisualViewport ? window.visualViewport.height : window.innerHeight;
        
        const minX = Math.min(...this.quiltEngine.blocks.map(b => b.x));
        const minY = Math.min(...this.quiltEngine.blocks.map(b => b.y));
        const maxX = Math.max(...this.quiltEngine.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.quiltEngine.blocks.map(b => b.y + b.height));
        
        const currentWidth = maxX - minX;
        const currentHeight = maxY - minY;
        
        const scaleX = availableWidth / currentWidth;
        const scaleY = availableHeight / currentHeight;
        const optimalScale = Math.min(scaleX, scaleY, 1);
        
        this.quiltScale = optimalScale;
      }

      updateSquareCounter() {
        const counterElement = document.getElementById('squareCounter');
        if (counterElement) {
          counterElement.textContent = this.quiltEngine.blocks.length;
        }
      }

      async handleAddColor() {
        try {
          const selectedColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
          
          if (!selectedColor || !Utils.validateHexColor(selectedColor)) {
            this.logger.warn('Invalid color selected');
            return;
          }

          const result = this.quiltEngine.addColor(selectedColor);
          
          if (result) {
            await this.saveQuilt();
            this.renderQuilt();
            
            this.uiService.showToast('Color added to the quilt!');
            this.uiService.showScreen('screen-quilt');
          }
          
        } catch (error) {
          this.errorHandler.handleError(error, 'handleAddColor');
        }
      }

      async handleShare() {
        try {
          const quiltSVG = document.getElementById('quilt');
          if (!quiltSVG) {
            throw new Error('Quilt SVG not found');
          }

          const canvas = await html2canvas(quiltSVG, {
            backgroundColor: '#f6f4f1',
            scale: 2,
            useCORS: true,
            allowTaint: true
          });

          canvas.toBlob(async (blob) => {
            try {
              const shareData = {
                title: 'Our Daily Quilt',
                text: `Check out today's community quilt with ${this.quiltEngine.submissionCount} contributors!`,
                files: [new File([blob], 'quilt.png', { type: 'image/png' })]
              };

              if (navigator.share && navigator.canShare(shareData)) {
                await navigator.share(shareData);
                this.uiService.showToast('Shared successfully!');
              } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quilt-${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.uiService.showToast('Quilt downloaded!');
              }
            } catch (error) {
              this.logger.error('Share failed:', error);
              this.uiService.showToast('Share failed. Please try again.');
            }
          }, 'image/png', 0.9);

        } catch (error) {
          this.errorHandler.handleError(error, 'shareFlow');
        }
      }

      async handleTestAddBlock() {
        const testColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
        const randomColor = testColors[Math.floor(Math.random() * testColors.length)];
        
        try {
          const result = this.quiltEngine.addColor(randomColor);
          
          if (result) {
            this.renderQuilt();
            await this.saveQuilt();
            
            this.uiService.showToast(`Added test block: ${randomColor}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testAddBlock');
        }
      }

      handleShowMyPiece() {
        const userPieces = this.quiltEngine.findUserPieces();
        if (userPieces.length > 0) {
          this.uiService.showToast(`Found ${userPieces.length} of your pieces!`);
          this.renderQuilt();
        } else {
          this.uiService.showToast('No pieces found for current user');
        }
      }

      handleTestDifferentUser() {
        this.currentUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('ourDailyUserId', this.currentUserId);
        
        this.uiService.showToast('Switched to different user');
      }

      async handleResetQuilt() {
        // Show confirmation dialog
        const confirmed = confirm('Are you sure you want to reset the quilt? This will clear all blocks and start fresh. This action cannot be undone.');
        
        if (confirmed) {
          try {
            // Reset the quilt engine
            this.quiltEngine.initialize();
            
            // Clear saved data
            await this.dataService.saveQuilt([], 1);
            
            // Clear user contributions for this session
            localStorage.removeItem('quiltContributions');
            
            // Re-render the quilt
            this.renderQuilt();
            this.updateSquareCounter();
            
            this.uiService.showToast('Quilt reset successfully! Starting fresh.');
            
            // Log the reset
            this.logger.log('üßµ Quilt reset by user');
            
          } catch (error) {
            this.errorHandler.handleError(error, 'resetQuilt');
            this.uiService.showToast('Failed to reset quilt. Please try again.');
          }
        }
      }

      async handleCreateArchive() {
        try {
          const archiveEntry = await this.createArchiveSnapshot();
          this.uiService.showToast(`Archive created for today with ${archiveEntry.userCount} contributors!`);
        } catch (error) {
          this.errorHandler.handleError(error, 'createArchive');
        }
      }

      async handleCreateTestArchives() {
        try {
          await this.createTestArchivePosts();
          this.uiService.showToast('Created 5 test archive posts!');
        } catch (error) {
          this.errorHandler.handleError(error, 'createTestArchives');
        }
      }

      async handleTestDailyReset() {
        try {
          await this.performDailyReset();
          this.uiService.showToast('Test daily reset completed!');
        } catch (error) {
          this.errorHandler.handleError(error, 'testDailyReset');
        }
      }
    }

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', async () => {
      const app = new SimplifiedQuiltAppV2();
      await app.initialize();
      
      window.app = app;
      
      // Global test functions
      window.addTestBlock = () => app.handleTestAddBlock();
      window.showMyPiece = () => app.handleShowMyPiece();
      window.switchUser = () => app.handleTestDifferentUser();
      window.shareQuilt = () => app.handleShare();
      window.resetQuilt = () => app.handleResetQuilt();
      window.createArchive = () => app.handleCreateArchive();
      window.createTestArchives = () => app.handleCreateTestArchives();
      
      // Admin console commands
      window.enableAdmin = () => app.enableAdminMode();
      window.disableAdmin = () => app.disableAdminMode();
    });

    console.log('üßµ Our Daily Quilt Beta - Loading...');
  </script>
</body>
</html>
