<!DOCTYPE html>
<html lang="en">
<script>
// Squarespace Editor Error Prevention
try {
  // Prevent common errors that break Squarespace editor
  if (typeof window !== 'undefined') {
    // Override console.error to prevent editor crashes
    const originalError = console.error;
    console.error = function(...args) {
      // Only log errors, don't throw them
      originalError.apply(console, args);
    };
    
    // Prevent unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
      console.warn('Prevented unhandled promise rejection:', event.reason);
      event.preventDefault();
    });
    
    // Prevent other global errors
    window.addEventListener('error', function(event) {
      console.warn('Prevented global error:', event.error);
      event.preventDefault();
    });
  }
} catch (e) {
  // If error handling itself fails, just continue
  console.warn('Error handling setup failed:', e);
}
</script>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our Daily Quilt - Beta</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      text-align: center;
      height: 100vh;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
      overflow-y: auto;
    }

    /* ===== FULL VIEWPORT QUILT ===== */
          .quilt-container {
        width: 70%;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f6f4f1;
        overflow: hidden;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        clip-path: inset(0);
        border: 3px solid red;
      }
    
    /* Base SVG styling - will be overridden by media queries */
    .quilt-container svg {
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      margin: 0;
      padding: 0;
      display: block;
      position: relative;
      flex-shrink: 0;
              border: none;
    }







    /* ===== SCREENS ===== */
    .screen {
      display: none;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out;
      position: absolute;
      top: 0; left: 0;
      min-height: 100vh;
      padding: 0;
      align-items: stretch;
      justify-content: flex-start;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      display: flex !important;
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header .title-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 81%;
      max-width: 450px;
      margin: 0 auto;
      text-align: center;
    }
    
    .portal-header {
      text-align: center;
      width: 100%;
    }
    
    .portal-header .title-line {
      font-weight: 500;
      font-size: clamp(2.5rem, 5vw, 3.5rem);
      margin-bottom: 0.0em;
      letter-spacing:.02em;
      text-align: center;
      width: 100%;
    }
    
    .portal-header .title-line:last-child {
      font-weight: 900;
      font-size: clamp(4.5rem, 8vw, 8rem);
      margin-top: -0.5rem;
      margin-bottom: 1.5rem;
      letter-spacing: 0.05em;
      width: 100%;
      white-space: nowrap;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.4rem, 3.5vw, 2rem);
      margin-top: 0.5rem;
    }
    
    .portal-question {
      font-size: clamp(1.125rem, 2.625vw, 1.65rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.2rem;
      margin: 0.0rem auto 1.5rem;
      background: #f6f4f1;
      width: 81%;
      max-width: 450px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 120px;
      max-height: 40vh;
      overflow: visible;
      position: relative;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 500; 
      line-height: 1.4;
      text-align: center;
    }
    
    .quote-author { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-weight: 300; 
      font-style: italic;
      margin-top: 1rem;
      text-align: center;
    }

    /* Left-justify long quotes (more than 2 lines) */
    .quote-line.long-quote {
      text-align: left;
    }
    
    .quote-author.long-quote {
      text-align: center;
    }

    /* Stylized quotation marks using pseudo-elements */
    /*
    .quote-card::before,
    .quote-card::after {
      content: '';
      position: absolute;
      font-size: 8rem;
      font-weight: 700;
      font-family: 'Crimson Pro', Georgia, serif;
      color: #000;
      line-height: 1;
      z-index: 1;
    }

    .quote-card::before {
      content: '\201C';
      top: -25px;
      left: -30px;
    }

    .quote-card::after {
      content: '\201D';
      bottom: -25px;
      right: -30px;
    }
    */

    /* Ensure quote-inner has proper positioning */
    .quote-inner {
      position: relative;
      padding: 20px 30px;
      z-index: 2;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 0rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 0rem auto 0.5rem auto;
    }

    /* Quote screen fade-in elements */
    .quote-screen-fade-in {
      opacity: 0 !important;
      transition: opacity 0.8s ease-in-out !important;
    }

    .quote-screen-fade-in.visible {
      opacity: 1 !important;
    }
    
    /* Ensure button fade-in works properly */
    .quote-screen-fade-in.btn {
      opacity: 0 !important;
      transition: opacity 0.8s ease-in-out !important;
    }

    .quote-screen-fade-in.btn.visible {
      opacity: 1 !important;
    }

    /* Welcome screen fade-in elements */
    .welcome-screen-fade-in {
      opacity: 0 !important;
      transition: opacity 0.8s ease-in-out !important;
    }

    .welcome-screen-fade-in.visible {
      opacity: 1 !important;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: fit-content;
      gap: 1.5rem;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      position: relative;
      background: conic-gradient(
        hsl(25, 100%, 50%),
        hsl(40, 100%, 50%),
        hsl(55, 100%, 50%),
        hsl(70, 100%, 50%),
        hsl(85, 100%, 50%),
        hsl(100, 100%, 50%),
        hsl(115, 100%, 50%),
        hsl(130, 100%, 50%),
        hsl(145, 100%, 50%),
        hsl(160, 100%, 50%),
        hsl(175, 100%, 50%),
        hsl(190, 100%, 50%),
        hsl(205, 100%, 50%),
        hsl(220, 100%, 50%),
        hsl(235, 100%, 50%),
        hsl(250, 100%, 50%),
        hsl(265, 100%, 50%),
        hsl(280, 100%, 50%),
        hsl(295, 100%, 50%),
        hsl(310, 100%, 50%),
        hsl(325, 100%, 50%),
        hsl(340, 100%, 50%),
        hsl(355, 100%, 50%),
        hsl(10, 100%, 50%),
        hsl(25, 100%, 50%)
      );
    }
    
    .css-color-wheel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, white 0%, transparent 70%);
      pointer-events: none;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
    
    .css-color-wheel:hover {
      transform: scale(1.02);
    }
    
    .css-color-wheel:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; 
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 300px;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
      justify-content: center;
    }
    
    #screen-quote {
      justify-content: center;
      padding-top: env(safe-area-inset-top, 0);
      padding-bottom: env(safe-area-inset-bottom, 0);
      /* Assume URL bar is always present for consistent centering */
      min-height: calc(100vh - 120px);
      height: calc(100vh - 120px);
    }
    
    .quote-content-wrapper {
      /* This wrapper gets centered as one unit */
    }
    
    @media (max-width: 768px) {
      /* Lock orientation to portrait */
      @media screen and (orientation: landscape) {
        body {
          transform: rotate(-90deg);
          transform-origin: left top;
          width: 100vh;
          height: 100vw;
          overflow-x: hidden;
          position: absolute;
          top: 100%;
          left: 0;
        }
      }
      
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
        justify-content: center;
      }
      

      
      .css-color-wheel {
        width: 224px !important;
        height: 224px !important;
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */
    #quilt {
      width: 100% !important;
      height: 100% !important;
      max-width: 100% !important;
      max-height: 100% !important;
      background: transparent;
      position: relative;
      display: block;
      margin: 0;
      padding: 0;
    }
    


    /* ===== ENHANCED FEATURES ===== */
    .color-family-indicator {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    .phase-transition {
      animation: phasePulse 2s ease-in-out;
    }
    
    @keyframes phasePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    


    /* ===== SQUARE COUNTER ===== */
    .square-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #000;
      border-radius: 8px;
      font-family: inherit;
    }
    
    .counter-label {
      font-size: 1.2rem;
      font-weight: 400;
      color: #333;
      text-transform: none;
    }



    /* ===== QUILT QUOTE DISPLAY ===== */
    .quilt-quote-display {
      text-align: center;
      margin-bottom: 15px;
      padding: 10px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .quilt-quote-display.has-content {
      opacity: 1;
    }
    
    .quilt-quote-text {
      font-size: 1.4rem;
      font-style: italic;
      font-weight: 300;
      margin: 0 0 8px 0;
      line-height: 1.4;
      color: #000;
      text-align: left;
    }
    
    .quilt-quote-author {
      font-size: 1.2rem;
      font-weight: 300;
      font-style: italic;
      margin: 0;
      color: #333;
      text-align: left;
    }
    
    @media (max-width: 768px) {
      .quilt-quote-display {
        margin-bottom: 12px;
        padding: 8px 20px;
      }
      
      .quilt-quote-text {
        font-size: 1.25rem !important;
      }
      
      .quilt-quote-author {
        font-size: 1.25rem !important;
      }
      
      /* Mobile quote marks */
      /*
      .quote-card::before,
      .quote-card::after {
        font-size: 6rem;
      }
      
      .quote-card::before {
        top: -15px;
        left: -20px;
      }
      
      .quote-card::after {
        bottom: -15px;
        right: -20px;
      }
      */
      
      .quote-inner {
        padding: 15px 25px;
      }
    }
    
    @media (max-width: 480px) {
      .quilt-quote-display {
        margin-bottom: 10px;
        padding: 6px 25px;
      }
      
      .quilt-quote-text {
        font-size: 2.2rem;
      }
      
      .quilt-quote-author {
        font-size: 1.8rem;
      }
      
      /* Small mobile quote marks */
      /*
      .quote-card::before,
      .quote-card::after {
        font-size: 5rem;
      }
      
      .quote-card::before {
        top: -3px;
        left: -8px;
      }
      
      .quote-card::after {
        bottom: -3px;
        right: -8px;
      }
      */
      
      .quote-inner {
        padding: 12px 20px;
      }
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000 !important;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff !important; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
      .new-block {
    transform-origin: center;
    animation: scaleUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }
  
  @keyframes scaleUp {
    0% { 
      transform: scale(0.9) rotate(-2deg); 
      opacity: 0.8; 
    }
    80% { 
      transform: scale(1.05) rotate(1deg); 
      opacity: 1; 
    }
    100% { 
      transform: scale(1) rotate(0deg); 
      opacity: 1; 
    }
  }
    
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* ===== FLIP ANIMATIONS ===== */
    @keyframes quiltFlip {
      0% { transform: scale(1, 1); }
      50% { transform: scale(0.95, 0.95); }
      100% { transform: scale(1, 1); }
    }
    
    .quilt-flipping {
      animation: quiltFlip 0.6s ease-in-out;
    }
    
    /* Smooth transitions for flip transformations */
    #quilt rect {
      transition: transform 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
      transform-origin: center;
    }
    
    /* Simple block flip effect using CSS */
    #quilt rect.block-flipped {
      fill: #000000; /* Black for obvious flip side - removed !important */
      opacity: 0.8;
      stroke: #ffffff;
      stroke-width: 2;
    }
    
    /* Playing card flip animation */
    @keyframes cardFlip {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(180deg); }
    }
    
    .block-flipping {
      animation: cardFlip 0.6s ease-in-out;
    }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 12px 24px;
      border-radius: 24px;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .toast.show { opacity: 1; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      html, body {
        overflow: auto !important;
        position: static !important;
        width: 100% !important;
        height: auto !important;
        -webkit-overflow-scrolling: touch;
      }
      
      #app {
        overflow: visible !important;
        height: auto !important;
        width: 100% !important;
      }
      
      .screen { 
        padding: 0; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 85%; padding: 1.5rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      .quilt-container {
        width: calc(100% - 40px) !important;
        max-width: calc(100vw - 40px) !important;
        height: calc((100vw - 40px) * 1.25) !important;
        max-height: 90vh !important;
        position: relative !important;
        flex-shrink: 0 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        overflow: visible !important;
        margin: 0 20px !important;
        padding: 0 !important;
        border: 3px solid blue !important;
        box-sizing: border-box !important;
      }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      

      
      #screen-quilt .square-counter {
        background: #fff !important;
        border: 2px solid #000 !important;
        margin: 1rem 0.5rem 0.5rem 0.5rem !important;
        padding: 0.5rem !important;
        border-radius: 6px !important;
        width: 100% !important;
        box-sizing: border-box !important;
      }
      

      
      #screen-quilt .counter-label {
        font-size: 1rem !important;
      }
      
      #screen-quilt .btn {
        background: #fff !important;
        border: 2px solid #000 !important;
        color: #000 !important;
        font-size: 0.9rem !important;
        padding: 8px 16px !important;
        margin: 0.5rem !important;
        display: block !important;
        width: 100% !important;
        max-width: none !important;
      }
      
      #screen-portal .btn,
      #screen-welcome .btn,
      #screen-quote .btn,
      #screen-color .btn,
      #screen-archive .btn,
      #screen-about .btn {
        background: transparent !important;
        border: 1px solid #000 !important;
        font-size: 1rem !important;
        padding: 12px 30px !important;
        margin: 0.5rem !important;
        display: inline-block !important;
        width: auto !important;
        max-width: none !important;
      }
      
      #screen-quilt {
        padding: 0 !important;
        margin: 0 !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: flex-start !important;
        align-items: stretch !important;
        min-height: 100vh !important;
        height: auto !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        position: relative !important;
        top: auto !important;
        left: auto !important;
        right: auto !important;
        bottom: auto !important;
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;
        border: 3px solid green !important;
      }
      
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 1rem !important;
        justify-content: center !important;
        align-items: center !important;
        height: 100dvh !important;
        min-height: 100dvh !important;
        max-height: 100dvh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
        /* Fallback for browsers that don't support dvh */
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
      }
      

      
      #screen-archive {
        padding: 0 !important;
        display: block !important;
        min-height: 100vh !important;
        height: auto !important;
        max-height: none !important;
        overflow-y: scroll !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: auto !important;
        border: none !important;
      }
      
      #screen-archive.active {
        display: block !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: auto !important;
      }
      

      
      #screen-quilt .button-container {
        position: relative !important;
        background: #f6f4f1 !important;
        padding: 1rem !important;
        margin-top: 0 !important;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25) !important;
        width: 100% !important;
        z-index: 10 !important;
        height: auto !important;
        border: none !important;
        min-height: 200px !important;
        top: auto !important;
        right: auto !important;
      }
      

      
      #screen-portal .button-container,
      #screen-welcome .button-container,
      #screen-quote .button-container,
      #screen-color .button-container,
      #screen-about .button-container {
        position: static !important;
        background: transparent !important;
        padding: 0 !important;
        border-top: none !important;
        margin-top: 0 !important;
      }
      
      #screen-archive .button-container {
        position: static !important;
        background: transparent !important;
        padding: 0 !important;
        border-top: none !important;
        margin-top: 0 !important;
        border: none !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      html, body {
        overflow: hidden !important;
        position: fixed !important;
        width: 100vw !important;
        height: 100vh !important;
        height: 100dvh !important;
        -webkit-overflow-scrolling: touch;
        /* Safe area support for mobile devices */
        padding-top: env(safe-area-inset-top) !important;
        padding-bottom: env(safe-area-inset-bottom) !important;
        padding-left: env(safe-area-inset-left) !important;
        padding-right: env(safe-area-inset-right) !important;
      }
      
      #app {
        overflow: hidden !important;
        height: 100vh !important;
        width: 100vw !important;
      }
      
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      
      #screen-quilt .thank-you-message {
        font-size: 1rem;
        margin-bottom: 0.3rem;
      }
      
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 0.5rem !important;
        padding-top: calc(0rem + env(safe-area-inset-top, 0)) !important;
        padding-bottom: calc(0.5rem + env(safe-area-inset-bottom, 0)) !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
      
      /* Screens that need precise centering */
      #screen-portal,
      #screen-welcome,
      #screen-quote {
        height: calc(100vh - 120px) !important;
        min-height: calc(100vh - 120px) !important;
        max-height: calc(100vh - 120px) !important;
      }
      
      /* Screens that need full viewport */
      #screen-color {
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
      }
      

      
      #screen-archive {
        overflow-y: scroll !important;
        height: auto !important;
        min-height: auto !important;
        max-height: none !important;
        position: absolute !important;
        padding-bottom: 2rem !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
      }
      

    }

    /* ===== FLOATING ADMIN BUTTON ===== */
    .floating-admin-btn {
      position: fixed !important;
      bottom: 20px !important;
      right: 20px !important;
      width: 50px !important;
      height: 50px !important;
      border-radius: 50% !important;
      background: #f6f4f1 !important;
      color: #000 !important;
      border: none !important;
      font-size: 20px !important;
      cursor: pointer !important;
      z-index: 1000 !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2) !important;
      transition: all 0.3s ease !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }

    .floating-admin-btn:hover {
      transform: scale(1.1) !important;
      box-shadow: 0 6px 12px rgba(0,0,0,0.4) !important;
    }

    .floating-admin-btn:active {
      transform: scale(0.95) !important;
    }

    /* Mobile-specific admin button improvements */
    @media (max-width: 768px) {
      .floating-admin-btn {
        width: 60px !important;
        height: 60px !important;
        font-size: 24px !important;
        bottom: 30px !important;
        right: 30px !important;
        -webkit-tap-highlight-color: transparent !important;
        touch-action: manipulation !important;
        user-select: none !important;
      }
      
      .floating-admin-btn:active {
        transform: scale(0.9) !important;
        background: #e8e4e0 !important;
      }
    }

    /* ===== USER PIECE HIGHLIGHTING ===== */
    .user-piece-highlight {
      /* Animation only applied when class is added via JavaScript */
    }
    
    .user-piece-highlight.wiggle {
      animation: userWobble 1.2s ease-in-out infinite;
    }
    
    @keyframes userWobble {
      0%, 100% { 
        transform: rotate(0deg); 
      }
      25% { 
        transform: rotate(-0.5deg); 
      }
      75% { 
        transform: rotate(0.5deg); 
      }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }

    }
    
    /* ===== MOBILE-ONLY STYLES (PROTECTED) ===== */
    /* WARNING: Changes here affect mobile layout */
    /* For desktop development, use the desktop-only section above */
    @media (max-width: 768px) {
      * {
        -webkit-overflow-scrolling: touch;
      }
      
      .screen {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
      }
      
      html, body {
        overflow-x: hidden !important;
        overflow-y: auto !important;
        position: relative !important;
        height: auto !important;
        min-height: 150vh !important;
      }
      
      #app {
        overflow-x: hidden !important;
        overflow-y: auto !important;
        height: auto !important;
        min-height: 150vh !important;
      }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }

    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
              margin-top: 0;
        margin-bottom: 1rem;
        border: none !important;
        width: 100%;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-feed {
      width: 100%;
              margin: 0 auto;
        padding: 0;
        border: none !important;
        min-height: auto !important;
        height: auto !important;
    }


    
    .archive-load-more {
      margin: 2rem auto;
      display: block;
      background: #666;
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 24px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .archive-load-more:hover {
      background: #333;
    }
    
    .archive-load-more:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .archive-loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }

    /* ===== ARCHIVE POSTS ===== */
    .archive-post {
      background: #f6f4f1;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      overflow: visible;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .archive-post:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .archive-post-image {
      width: 100%;
      height: auto;
      max-width: 100%;
      display: block;
      cursor: pointer;
      border-radius: 8px;
      transition: transform 0.2s ease;
    }

    .archive-post-image:hover {
      transform: scale(1.02);
    }

    .archive-post-caption {
      padding: 0.25rem;
      width: 75%;
      margin: 0 auto;
    }
    
    @media (max-width: 768px) {
      .archive-post-caption {
        width: 100%;
        margin: 0;
        padding-left: 5rem;
        padding-right: 5rem;
      }
    }
    
    @media (min-width: 769px) {
      .archive-post-quote-author {
        font-size: 2rem;
      }
    }

    .archive-post-quote-author {
      font-size: 1.1rem;
      font-style: italic;
      margin-bottom: 2rem;
      line-height: 1.2;
      text-align: left;
    }

    .archive-post-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      color: #666;
      margin-top: 1rem;
      margin-bottom: 1rem;
    }

    .archive-share-btn {
      background: transparent;
      border: 1px solid #000;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: background 0.2s ease;
    }

    .archive-share-btn:hover {
      background: #000;
      color: #fff;
    }

    /* ===== ARCHIVE MODAL ===== */
    .archive-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .archive-modal-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
    }

    .archive-modal-content {
      position: relative;
      background: #fff;
      border-radius: 12px;
      width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      z-index: 1001;
      display: flex;
      flex-direction: column;
    }

    .archive-modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 20px;
      cursor: pointer;
      z-index: 1002;
    }

    .archive-modal-delete {
      position: absolute;
      top: 10px;
      right: 50px;
      background: rgba(220, 53, 69, 0.9);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 16px;
      cursor: pointer;
      z-index: 1002;
      transition: background 0.2s ease;
    }

    .archive-modal-delete:hover {
      background: rgba(220, 53, 69, 1);
    }

    .archive-modal-image {
      width: 100%;
      flex: 1;
      object-fit: contain;
    }

    .archive-modal-info {
      padding: 1.5rem;
    }

    .archive-modal-quote {
      font-size: 1.2rem;
      font-style: italic;
      margin-bottom: 0.5rem;
      line-height: 1.4;
      text-align: left;
    }

    .archive-modal-meta {
      font-size: 0.9rem;
      color: #666;
    }

    /* ===== ABOUT SCREEN ===== */
    #screen-about {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 2rem 1rem;
      min-height: 100vh;
      background-color: #f6f4f1;
    }
    
    .about-container {
      max-width: 600px;
      width: 100%;
      text-align: center;
    }
    
    .about-title {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 2rem;
      color: #000;
      line-height: 1.2;
    }
    
    .about-description {
      font-size: 1.2rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 3rem;
      text-align: left;
    }
    
    .about-section {
      margin-bottom: 2rem;
      text-align: left;
    }
    
    .about-section h3 {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #000;
    }
    
    .about-section p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }
    
    .about-section ul {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }
    
    .about-section li {
      margin-bottom: 0.5rem;
    }
    
    @media (max-width: 768px) {
      .about-title {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>

  
  <main id="app">

    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <div class="title-container">
          <h1 class="title-line">OUR DAILY</h1>
          <h1 class="title-line">QUILT</h1>
        </div>
        <p class="date" id="date-text" aria-live="polite">Tuesday, August 19, 2025</p>
      </div>
      
      <div style="margin-top: 2rem;"></div>
      
      <p class="portal-question">First we gather<br>then we build</p>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3 style="text-align: center;">How It Works</h3>
          
          <div style="margin-top: 2rem;"></div>
          
          <p class="welcome-screen-fade-in step-1" style="text-align: center;">Read a quote</p>
          <p class="welcome-screen-fade-in step-arrow-1" style="text-align: center; margin: 0.5rem 0;">‚Üì</p>
          <p class="welcome-screen-fade-in step-2" style="text-align: center;">Add your color</p>
          <p class="welcome-screen-fade-in step-arrow-2" style="text-align: center; margin: 0.5rem 0;">‚Üì</p>
          <p class="welcome-screen-fade-in step-4" style="text-align: center; line-height: 1.2;">Discover what we can do together</p>
        </div>
      </div>
      
      <div style="margin-top: 2rem;"></div>
      
      <button class="btn welcome-screen-fade-in" data-next="screen-quote" aria-label="Read today's quote">READ TODAY'S QUOTE</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-content-wrapper">
        <div class="quote-card">
          <div class="quote-inner">
            <p class="quote-line" aria-live="polite"></p>
            <p class="quote-author" aria-live="polite"></p>
          </div>
        </div>
        <p class="quote-prompt quote-screen-fade-in">What color comes to mind<br>when you read this?</p>
        <div class="arrow-down quote-screen-fade-in">‚Üì</div>
        <button class="btn quote-screen-fade-in" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
      </div>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="25" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">

      
      <!-- Quilt container - full viewport -->
      <div class="quilt-container">
        <svg id="quilt" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      </div>
      
                     <!-- Button container - side panel on desktop -->
                               <div class="button-container" style="position: relative; background: rgba(246, 244, 241, 0.95); padding: 20px; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15); overflow-y: auto; box-sizing: border-box; border: 3px solid orange;">
                 
        <!-- Quote display at top of button container -->
        <div class="quilt-quote-display" style="margin-bottom: 20px;">
          <p class="quilt-quote-text"></p>
          <p class="quilt-quote-author"></p>
        </div>
        <!-- People counter -->
        <div class="square-counter">
          <span class="counter-label">Building today's quilt together: <span class="counter-number" id="squareCounter">1</span></span>
        </div>
        
        <div class="button-group">
          <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white;">SHOW ME MY PIECE</button>
        </div>
        
        <div class="button-group">
          <!-- <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button> -->
          <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
          <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
        </div>
        

      </div>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>ARCHIVE</h1>
      </div>
      
      <!-- Archive Feed -->
      <div class="archive-feed" id="archiveFeed">
        <!-- Archive posts will be dynamically inserted here -->
      </div>
      
      <!-- Load More Button -->
      <button class="btn archive-load-more" id="archiveLoadMore" style="display: none;">Load More</button>
      
      <!-- Loading Indicator -->
      <div class="archive-loading" id="archiveLoading" style="display: none;">
        <p>Loading quilts...</p>
      </div>
      
      <!-- Back Button -->
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-container">
        <h1 class="about-title">ABOUT</h1>
        
        <p class="about-description" style="text-align: center;">OUR DAILY QUILT explores how gathering creates beauty we can't achieve alone.</p>
        

        
        <div class="about-section">
          <h3>What we're exploring</h3>
          <ul>
            <li>What can we accomplish when we each contribute to a common cause?</li>
            <li>How much variety can a system absorb while maintaining coherence?</li>
            <li>How do we balance individual expression with group harmony?</li>
          </ul>
        </div>
        
        <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
      </div>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

      <!-- Toast notifications -->
    <div id="toast" class="toast" role="alert" aria-live="polite"></div>

    <!-- Archive Modal -->
    <div id="archiveModal" class="archive-modal" style="display: none;">
      <div id="archiveModalBackdrop" class="archive-modal-backdrop"></div>
      <div class="archive-modal-content">
        <button id="archiveModalClose" class="archive-modal-close" aria-label="Close modal">√ó</button>
        <button id="archiveModalDelete" class="archive-modal-delete" aria-label="Delete archive" style="display: none;">üóëÔ∏è</button>
        <img id="archiveModalImage" class="archive-modal-image" alt="Quilt" />
        <div class="archive-modal-info">
          <p id="archiveModalQuote" class="archive-modal-quote"></p>
          <p id="archiveModalMeta" class="archive-modal-meta"></p>
        </div>
      </div>
    </div>

    <!-- Floating Admin Button -->
    <button id="floatingAdminBtn" class="floating-admin-btn" aria-label="Admin controls" style="display: none;">
      ‚öôÔ∏è
    </button>
    


  <!-- External dependencies -->
  <scrip st src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  
  <!-- Firebase SDK will be initialized after CONFIG is defined -->
  <!-- FIREBASE DISABLED FOR LOCAL TESTING -->
  <script type="module">
    // ===== CONFIGURATION =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '3.0.0-beta',
        defaultColor: '#f7b733',
        quiltSize: 1000,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        // ENABLED FOR IMAGE REVEAL FUNCTIONALITY
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        gridCols: 8,
        gridRows: 8,
        blockSpacing: 4,
        blockPadding: 2
      },
      QUILT_V2: {
        FREEZE_THRESHOLD: 20,
        MIN_SHAPE_SIZE: 40,
        COLOR_SIMILARITY_THRESHOLD: 35,
        LAB_COLOR_CACHE_SIZE: 1000
      }
    };

    // ===== COLOR UTILITIES (LAB Color Space) =====
    class ColorUtilsV2 {
      static colorCache = new Map();
      
      static hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      
      static rgbToXyz(r, g, b) {
        let r1 = r / 255, g1 = g / 255, b1 = b / 255;
        
        r1 = r1 > 0.04045 ? Math.pow((r1 + 0.055) / 1.055, 2.4) : r1 / 12.92;
        g1 = g1 > 0.04045 ? Math.pow((g1 + 0.055) / 1.055, 2.4) : g1 / 12.92;
        b1 = b1 > 0.04045 ? Math.pow((b1 + 0.055) / 1.055, 2.4) : b1 / 12.92;
        
        const x = r1 * 0.4124 + g1 * 0.3576 + b1 * 0.1805;
        const y = r1 * 0.2126 + g1 * 0.7152 + b1 * 0.0722;
        const z = r1 * 0.0193 + g1 * 0.1192 + b1 * 0.9505;
        
        return { x, y, z };
      }
      
      static xyzToLab(x, y, z) {
        const xn = 0.95047, yn = 1.00000, zn = 1.08883;
        
        const x1 = x / xn, y1 = y / yn, z1 = z / zn;
        
        const fx = x1 > 0.008856 ? Math.pow(x1, 1/3) : (7.787 * x1) + (16 / 116);
        const fy = y1 > 0.008856 ? Math.pow(y1, 1/3) : (7.787 * y1) + (16 / 116);
        const fz = z1 > 0.008856 ? Math.pow(z1, 1/3) : (7.787 * z1) + (16 / 116);
        
        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b = 200 * (fy - fz);
        
        return { L, a, b };
      }
      
      static hexToLab(hex) {
        if (this.colorCache.has(hex)) {
          return this.colorCache.get(hex);
        }
        
        const rgb = this.hexToRgb(hex);
        if (!rgb) return null;
        
        const xyz = this.rgbToXyz(rgb.r, rgb.g, rgb.b);
        const lab = this.xyzToLab(xyz.x, xyz.y, xyz.z);
        
        if (this.colorCache.size < CONFIG.QUILT_V2.LAB_COLOR_CACHE_SIZE) {
          this.colorCache.set(hex, lab);
        }
        
        return lab;
      }
      
      static getColorDistance(color1, color2) {
        const lab1 = this.hexToLab(color1);
        const lab2 = this.hexToLab(color2);
        
        if (!lab1 || !lab2) return Infinity;
        
        const dL = lab1.L - lab2.L;
        const da = lab1.a - lab2.a;
        const db = lab1.b - lab2.b;
        
        return Math.sqrt(dL * dL + da * da + db * db);
      }
      
      static isColorSimilar(color1, color2) {
        const distance = this.getColorDistance(color1, color2);
        return distance <= CONFIG.QUILT_V2.COLOR_SIMILARITY_THRESHOLD;
      }
      
      static getColorFamilyName(hexColor) {
        const rgb = this.hexToRgb(hexColor);
        if (!rgb) return 'unknown';
        
        const { r, g, b } = rgb;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;
        
        if (delta === 0) return 'gray';
        
        let hue;
        if (max === r) {
          hue = ((g - b) / delta) % 6;
        } else if (max === g) {
          hue = (b - r) / delta + 2;
        } else {
          hue = (r - g) / delta + 4;
        }
        
        hue = Math.round(hue * 60);
        if (hue < 0) hue += 360;
        
        if (hue >= 0 && hue < 30) return 'red';
        if (hue >= 30 && hue < 60) return 'orange';
        if (hue >= 60 && hue < 90) return 'yellow';
        if (hue >= 90 && hue < 150) return 'green';
        if (hue >= 150 && hue < 210) return 'cyan';
        if (hue >= 210 && hue < 270) return 'blue';
        if (hue >= 270 && hue < 330) return 'purple';
        return 'pink';
      }
    }

    // ===== ENHANCED SHAPE CLASS =====
    class QuiltShapeV2 {
      constructor(options = {}) {
        this.id = options.id || this.generateId();
        this.type = options.type || 'KEY_SHAPE';
        this.color = options.color || CONFIG.APP.defaultColor;
        this.position = options.position || { x: 0, y: 0, width: 1000, height: 1000 };
        this.parentId = options.parentId || null;
        this.contributorId = options.contributorId || null;
        this.submissionIndex = options.submissionIndex || 0;
        this.colorFamily = options.colorFamily || null;
        this.descendants = [];
      }
      
      generateId() {
        return 'shape_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }
      
      canSplit(direction) {
        if (direction === 'horizontal') {
          return this.position.height >= CONFIG.QUILT_V2.MIN_SHAPE_SIZE * 2;
        } else {
          return this.position.width >= CONFIG.QUILT_V2.MIN_SHAPE_SIZE * 2;
        }
      }
      
      getValidSplitDirections() {
        const directions = [];
        if (this.canSplit('horizontal')) directions.push('horizontal');
        if (this.canSplit('vertical')) directions.push('vertical');
        return directions;
      }
      
      split(newColor, direction, contributorId, submissionIndex) {
        if (!this.canSplit(direction)) {
          throw new Error(`Cannot split shape ${this.id} in ${direction} direction`);
        }

        const splitRatio = 0.3 + Math.random() * 0.4;
        let shape1, shape2;

        if (direction === 'horizontal') {
          const splitHeight = this.position.height * splitRatio;
          
          shape1 = new QuiltShapeV2({
            type: this.type,
            color: this.color,
            position: {
              x: this.position.x,
              y: this.position.y,
              width: this.position.width,
              height: splitHeight
            },
            parentId: this.id,
            contributorId: this.contributorId,
            submissionIndex: this.submissionIndex,
            colorFamily: this.colorFamily
          });

          shape2 = new QuiltShapeV2({
            type: this.type,
            color: newColor,
            position: {
              x: this.position.x,
              y: this.position.y + splitHeight,
              width: this.position.width,
              height: this.position.height - splitHeight
            },
            parentId: this.id,
            contributorId: contributorId,
            submissionIndex: submissionIndex,
            colorFamily: this.colorFamily
          });
        } else {
          const splitWidth = this.position.width * splitRatio;
          
          shape1 = new QuiltShapeV2({
            type: this.type,
            color: this.color,
            position: {
              x: this.position.x,
              y: this.position.y,
              width: splitWidth,
              height: this.position.height
            },
            parentId: this.id,
            contributorId: this.contributorId,
            submissionIndex: this.submissionIndex,
            colorFamily: this.colorFamily
          });

          shape2 = new QuiltShapeV2({
            type: this.type,
            color: newColor,
            position: {
              x: this.position.x + splitWidth,
              y: this.position.y,
              width: this.position.width - splitWidth,
              height: this.position.height
            },
            parentId: this.id,
            contributorId: contributorId,
            submissionIndex: submissionIndex,
            colorFamily: this.colorFamily
          });
        }

        this.descendants.push(shape2.id);
        
        return [shape1, shape2];
      }
      
      getAllDescendants(allShapes) {
        const descendants = [...this.descendants];
        this.descendants.forEach(descId => {
          const desc = allShapes.find(s => s.id === descId);
          if (desc) {
            descendants.push(...desc.getAllDescendants(allShapes));
          }
        });
        return descendants;
      }
    }

    // ===== SIMPLIFIED QUILT ENGINE (BETA) =====
    class SimpleQuiltEngine {
      constructor(userId = null) {
        this.blocks = [];
        this.submissionCount = 0;
        this.deviceId = userId || this.getOrCreateDeviceId();
      }
      
      getOrCreateDeviceId() {
        let deviceId = localStorage.getItem('quiltDeviceId');
        if (!deviceId) {
          deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('quiltDeviceId', deviceId);
        }
        return deviceId;
      }
      
      initialize() {
        // Use 4:5 dimensions from getQuiltDimensions
        const dimensions = Utils.getQuiltDimensions();
        const initialWidth = dimensions.width;
        const initialHeight = dimensions.height;
        
        this.blocks = [{
          id: 'initial',
          x: 0,
          y: 0,
          width: initialWidth,
          height: initialHeight,
          color: CONFIG.APP.defaultColor,
          contributorId: this.deviceId,
          submissionIndex: 0
        }];
        
        this.submissionCount = 0;
        // console.log('üßµ Simple Quilt Engine initialized');
      }
      
      addSubmission() {
        this.submissionCount++;
        return this.submissionCount;
      }
      
      addColor(newColor) {
        this.submissionCount++;
        
        // Find a random block to split
        const splittableBlocks = this.blocks.filter(block => 
          block.width > 60 && block.height > 60
        );
        
        if (splittableBlocks.length === 0) {
          // If no blocks can be split, create a new block at the edge
          return this.addBlockAtEdge(newColor);
        }
        
        const randomBlock = splittableBlocks[Math.floor(Math.random() * splittableBlocks.length)];
        const splitResult = this.splitBlock(randomBlock, newColor);
        
        // Replace the original block with the split result
        const blockIndex = this.blocks.findIndex(b => b.id === randomBlock.id);
        this.blocks.splice(blockIndex, 1, ...splitResult);
        
        this.recordUserContribution(splitResult[1].id, newColor, this.submissionCount);
        
        return {
          originalBlock: randomBlock,
          newBlocks: splitResult,
          submissionIndex: this.submissionCount
        };
      }
      
      splitBlock(block, newColor) {
        const isWider = block.width > block.height;
        const splitDirection = isWider ? 'vertical' : 'horizontal';
        
        if (splitDirection === 'horizontal') {
          const splitHeight = block.height * (0.3 + Math.random() * 0.4);
          
          const block1 = {
            ...block,
            id: block.id + '_1',
            height: splitHeight
          };
          
          const block2 = {
            ...block,
            id: block.id + '_2',
            y: block.y + splitHeight,
            height: block.height - splitHeight,
            color: newColor,
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount
          };
          
          return [block1, block2];
        } else {
          const splitWidth = block.width * (0.3 + Math.random() * 0.4);
          
          const block1 = {
            ...block,
            id: block.id + '_1',
            width: splitWidth
          };
          
          const block2 = {
            ...block,
            id: block.id + '_2',
            x: block.x + splitWidth,
            width: block.width - splitWidth,
            color: newColor,
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount
          };
          
          return [block1, block2];
        }
      }
      
      addBlockAtEdge(newColor) {
        // Find the current bounds
        const minX = Math.min(...this.blocks.map(b => b.x));
        const minY = Math.min(...this.blocks.map(b => b.y));
        const maxX = Math.max(...this.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.blocks.map(b => b.y + b.height));
        
        const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
        // Mobile-first: Use tall rectangles instead of squares
        const blockWidth = 80;
        const blockHeight = 160; // 1:2 ratio for mobile-friendly blocks with breathing room
        
        let newBlock;
        switch (edge) {
          case 0: // top
            newBlock = {
              id: 'edge_' + Date.now(),
              x: minX + Math.random() * (maxX - minX - blockWidth),
              y: minY - blockHeight,
              width: blockWidth,
              height: blockHeight,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
          case 1: // right
            newBlock = {
              id: 'edge_' + Date.now(),
              x: maxX,
              y: minY + Math.random() * (maxY - minY - blockHeight),
              width: blockWidth,
              height: blockHeight,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
          case 2: // bottom
            newBlock = {
              id: 'edge_' + Date.now(),
              x: minX + Math.random() * (maxX - minX - blockWidth),
              y: maxY,
              width: blockWidth,
              height: blockHeight,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
          case 3: // left
            newBlock = {
              id: 'edge_' + Date.now(),
              x: minX - blockWidth,
              y: minY + Math.random() * (maxY - minY - blockHeight),
              width: blockWidth,
              height: blockHeight,
              color: newColor,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount
            };
            break;
        }
        
        this.blocks.push(newBlock);
        this.recordUserContribution(newBlock.id, newColor, this.submissionCount);
        
        return {
          originalBlock: null,
          newBlocks: [newBlock],
          submissionIndex: this.submissionCount
        };
      }
      

      
      recordUserContribution(blockId, color, submissionIndex) {
        const contribution = {
          submissionIndex,
          blockId,
          color,
          userId: this.deviceId, // Add user ID to track who contributed
          timestamp: new Date().toISOString()
        };
        
        const stored = JSON.parse(localStorage.getItem('quiltContributions') || '{"submissions": []}');
        stored.submissions.push(contribution);
        localStorage.setItem('quiltContributions', JSON.stringify(stored));
      }
      
      findUserPieces() {
        const contributions = this.getUserContributions();
        const userBlockIds = new Set();
        
        // Filter contributions by current user ID
        contributions.submissions.forEach(contrib => {
          if (contrib.userId === this.deviceId) {
            userBlockIds.add(contrib.blockId);
          }
        });
        
        return this.blocks.filter(block => userBlockIds.has(block.id));
      }
      
      getUserContributions() {
        const stored = localStorage.getItem('quiltContributions');
        return stored ? JSON.parse(stored) : { submissions: [] };
      }
      
      getState() {
        return {
          submissionCount: this.submissionCount,
          blocks: this.blocks,
          userPieces: this.findUserPieces()
        };
      }
      
      // Individual block flip state is now handled by the renderer
      
      // ===== RESPONSIVE QUILT DIMENSIONS =====
      recalculateDimensionsForCurrentViewport() {
        if (this.blocks.length === 0) return;
        
        // Get current viewport dimensions
        const currentViewportWidth = window.innerWidth;
        const currentViewportHeight = window.innerHeight;
        
        // Calculate current quilt bounds (don't modify the blocks!)
        const minX = Math.min(...this.blocks.map(b => b.x));
        const minY = Math.min(...this.blocks.map(b => b.y));
        const maxX = Math.max(...this.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.blocks.map(b => b.y + b.height));
        
        const currentQuiltWidth = maxX - minX;
        const currentQuiltHeight = maxY - minY;
        
        // Store the original quilt bounds for viewBox calculation
        this.quiltBounds = {
          minX: minX,
          minY: minY,
          width: currentQuiltWidth,
          height: currentQuiltHeight
        };
        
        // Determine target dimensions based on current viewport
        let targetWidth, targetHeight;
        
        // Instagram-friendly: Use 4:5 aspect ratio for consistent experience
        const targetAspectRatio = 4/5; // 4:5 ratio for Instagram portrait format
        
        if (window.innerWidth >= 768) {
          // Desktop: Use mobile aspect ratio, account for button container
          const availableWidth = currentViewportWidth * 0.7; // 70% for quilt container
          const availableHeight = currentViewportHeight;
          
          if (availableWidth / availableHeight > targetAspectRatio) {
            // Viewport is wider than target ratio
            targetHeight = availableHeight;
            targetWidth = availableHeight * targetAspectRatio;
          } else {
            // Viewport is taller than target ratio
            targetWidth = availableWidth;
            targetHeight = availableWidth / targetAspectRatio;
          }
        } else {
          // Mobile: Use 4:5 aspect ratio with breathing room
          const breathingRoom = 0.95; // 95% of viewport for quilt, 5% for breathing room
          const availableWidth = currentViewportWidth * breathingRoom;
          const availableHeight = currentViewportHeight * breathingRoom;
          
          if (availableWidth / availableHeight > targetAspectRatio) {
            // Viewport is wider than target ratio
            targetHeight = availableHeight;
            targetWidth = availableHeight * targetAspectRatio;
          } else {
            // Viewport is taller than target ratio
            targetWidth = availableWidth;
            targetHeight = availableWidth / targetAspectRatio;
          }
        }
        
        // Store target dimensions for rendering
        this.targetDimensions = {
          width: targetWidth,
          height: targetHeight,
          viewport: { width: currentViewportWidth, height: currentViewportHeight }
        };
        
        // console.log('üßµ Quilt viewBox recalculated for current viewport');
      }
    }

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static getQuiltDimensions() {
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        
        let screenWidth, screenHeight;
        
        if (hasVisualViewport) {
          screenWidth = window.visualViewport.width;
          screenHeight = window.visualViewport.height;
        } else {
          const body = document.body;
          const html = document.documentElement;
          
          const bodyRect = body.getBoundingClientRect();
          const htmlRect = html.getBoundingClientRect();
          
          const measuredWidth = Math.min(bodyRect.width, htmlRect.width);
          const measuredHeight = Math.min(bodyRect.height, htmlRect.height);
          
          if (measuredWidth > 0 && measuredHeight > 0) {
            screenWidth = measuredWidth;
            screenHeight = measuredHeight;
          } else {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            
            const browserUIMargin = Math.min(screenHeight * 0.15, 120);
            screenHeight = screenHeight - browserUIMargin;
          }
        }
        
        const isMobile = screenWidth <= 768;
        
        if (isMobile) {
          // Mobile: Use fixed 4:5 dimensions for Instagram-friendly experience
          const width = 1070;  // 1080 - 10px padding
          const height = 1340; // 1350 - 10px padding
          return {
            width: width,
            height: height,
            viewBoxWidth: width,
            viewBoxHeight: height
          };
        } else {
          // Desktop: Use fixed 4:5 dimensions for Instagram-friendly experience
          const width = 1070;  // 1080 - 10px padding
          const height = 1340; // 1350 - 10px padding
          return {
            width: width,
            height: height,
            viewBoxWidth: width,
            viewBoxHeight: height
          };
        }
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    }

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = 'üßµ';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} ‚ö†Ô∏è ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} ‚ùå ${message}`, error || '');
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        try {
          document.querySelectorAll(".screen").forEach(s => {
            s.classList.remove("active");
            s.style.display = 'none';
          });
          
          const target = document.getElementById(screenId);
          if (target) {
            target.style.display = 'flex';
            target.classList.add("active");
            
            target.offsetHeight;
            
            // Set date immediately when portal screen is shown
            if (screenId === 'screen-portal') {
              const dateText = document.getElementById("date-text");
              if (dateText) {
                const formattedDate = Utils.formatDate();
                dateText.textContent = formattedDate;
                console.log('üìÖ Date set immediately for portal:', formattedDate);
              }
            }
            

            
            // Populate quote display when quilt screen is shown
            if (screenId === 'screen-quilt') {
              const quoteService = window.app?.quoteService;
              if (quoteService) {
                const { text, author } = quoteService.getTodayQuote();
                const quiltQuoteText = document.querySelector('.quilt-quote-text');
                const quiltQuoteAuthor = document.querySelector('.quilt-quote-author');
                const quiltQuoteDisplay = document.querySelector('.quilt-quote-display');
                
                if (quiltQuoteText) quiltQuoteText.textContent = text;
                if (quiltQuoteAuthor) quiltQuoteAuthor.textContent = author;
                
                // Show the quote display when content is populated
                if (quiltQuoteDisplay && text && author) {
                  quiltQuoteDisplay.classList.add('has-content');
                }
              }
              
              // Set up flip handlers when showing quilt screen
              setTimeout(() => {
                if (window.app && window.app.setupQuiltFlipHandlers) {
                  window.app.setupQuiltFlipHandlers();
                }
              }, 100);
            } else {
              // Remove flip handlers when leaving quilt screen
              if (window.app && window.app.removeQuiltFlipHandlers) {
                window.app.removeQuiltFlipHandlers();
              }
            }
            
            // Handle quote screen fade-in elements
            if (screenId === 'screen-quote') {
              // Reset fade-in elements to hidden state
              const fadeElements = document.querySelectorAll('.quote-screen-fade-in');
              fadeElements.forEach(el => el.classList.remove('visible'));
              
              // Trigger fade-in immediately (removed 3-second delay for testing)
              fadeElements.forEach(el => el.classList.add('visible'));
            }
            
            // Handle welcome screen fade-in elements
            if (screenId === 'screen-welcome') {
              // Reset fade-in elements to hidden state
              const fadeElements = document.querySelectorAll('.welcome-screen-fade-in');
              fadeElements.forEach(el => el.classList.remove('visible'));
              
              // Trigger smooth top-to-bottom fade-in with overlapping transitions
              fadeElements.forEach((el, index) => {
                const staggerDelay = index * 200; // 200ms between each element
                setTimeout(() => {
                  el.classList.add('visible');
                }, staggerDelay);
              });
            }
            
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            const app = document.getElementById('app');
            if (app) {
              app.scrollTop = 0;
            }
            
            // Dispatch custom event for screen change
            document.dispatchEvent(new CustomEvent('screenChange', {
              detail: { screenId: screenId }
            }));
            
          } else {
            this.logger.error(`‚ùå Screen not found: ${screenId}`);
            this.showScreen('screen-portal');
          }
        } catch (error) {
          this.logger.error(`‚ùå Error switching to screen ${screenId}:`, error);
          const portalScreen = document.getElementById('screen-portal');
          if (portalScreen) {
            document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
            portalScreen.classList.add("active");
            portalScreen.style.display = 'flex';
          }
        }
      }
    }

    // ===== ERROR HANDLING SERVICE =====
    class ErrorHandler {
      constructor(uiService, logger) {
        this.uiService = uiService;
        this.logger = logger;
      }

      handleError(error, context = 'Unknown') {
        this.logger.error(`Error in ${context}:`, error);
        
        const errorMessages = {
          'loadQuilt': 'Failed to load quilt data. Starting fresh.',
          'saveQuilt': 'Failed to save your color. Please try again.',
          'shareFlow': 'Failed to create share image. Saving instead.',
          'colorPicker': 'Color picker error. Please try again.',
          'App initialization': 'Failed to initialize app. Please refresh.',
          'renderQuilt': 'Failed to render quilt. Please try again.',
          'addColorToQuilt': 'Failed to add color. Please try again.'
        };
        
        const message = errorMessages[context] || 'Something went wrong. Please try again.';
        this.uiService.showToast(message);
      }

      validateColor(color) {
        if (!Utils.validateHexColor(color)) {
          throw new Error(`Invalid color format: ${color}`);
        }
        return true;
      }
    }

    // ===== ARCHIVE SERVICE =====
    class ArchiveService {
      constructor(logger, dataService) {
        this.logger = logger;
        this.dataService = dataService;
        this.archives = new Map(); // Date string -> archive data (cached)
        this.isLoading = false;
        this.currentPage = 0;
        this.postsPerPage = 10;
      }

      // Archive data structure for each day
      createArchiveEntry(date, quilt, quote, userCount) {
        return {
          date: date, // "2024-01-15"
          quilt: quilt, // SVG data/state
          quote: quote, // { text: "...", author: "..." }
          userCount: userCount, // Number of users who contributed
          shareCount: 0, // Number of times this quilt has been shared
          thumbnail: null, // Will be generated
          isComplete: true // Whether the day finished properly
        };
      }

      // Get archives for feed (with pagination)
      async getArchives(page = 0, limit = this.postsPerPage) {
        try {
                  // Try to load from Firestore if we don't have archives cached
        // if (this.archives.size === 0 && window.db && window.firestore) {
        //   await this.loadArchivesFromFirestore();
        // }
          
          const allArchives = Array.from(this.archives.values())
            .sort((a, b) => new Date(b.date) - new Date(a.date)); // Newest first
          
          const start = page * limit;
          const end = start + limit;
          const pageArchives = allArchives.slice(start, end);
          
          return {
            archives: pageArchives,
            hasMore: end < allArchives.length,
            totalCount: allArchives.length
          };
        } catch (error) {
          this.logger.error('Failed to get archives:', error);
          return {
            archives: [],
            hasMore: false,
            totalCount: 0
          };
        }
      }

      // Load archives from Firestore
      async loadArchivesFromFirestore() {
        try {
          if (!window.db || !window.firestore) {
            this.logger.warn('Firestore not available for loading archives');
            return;
          }

          const archivesRef = window.firestore.collection(window.db, 'archives');
          const q = window.firestore.query(archivesRef, window.firestore.orderBy('date', 'desc'), window.firestore.limit(50));
          const querySnapshot = await window.firestore.getDocs(q);
          
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            this.archives.set(data.date, data);
          });
          
          this.logger.log(`üìñ Loaded ${this.archives.size} archives from Firestore`);
        } catch (error) {
          this.logger.error('Failed to load archives from Firestore:', error);
        }
      }

      // Add new archive entry
      async addArchive(archiveEntry) {
        try {
          // Add to Firestore if available
          // if (window.db && window.firestore) {
          //   const archiveRef = window.firestore.doc(window.db, 'archives', archiveEntry.date);
          //   await window.firestore.setDoc(archiveRef, {
          //     ...archiveEntry,
          //     createdAt: new Date().toISOString()
          //   });
          //   this.logger.log(`üìù Archive saved to Firestore: ${archiveEntry.date}`);
          // }
          
          // Add to local cache
          this.archives.set(archiveEntry.date, archiveEntry);
          this.logger.log(`üìù Archive cached locally: ${archiveEntry.date}`);
        } catch (error) {
          this.logger.error('Failed to save archive to Firestore:', error);
          // Still cache locally as fallback
          this.archives.set(archiveEntry.date, archiveEntry);
        }
      }

      // Generate Instagram-ready image (4:5 portrait ratio)
      async generateInstagramImage(blocks, quote = null) {
        try {
          if (!blocks || blocks.length === 0) {
            this.logger.warn('No blocks provided for Instagram image generation');
            return null;
          }

          // Instagram optimal size: 1080x1350 (4:5 ratio)
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = 1080;
          canvas.height = 1350;
          
          // Fill background with true white to match Instagram
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Debug: Check what getQuiltDimensions returns
          const dimensions = Utils.getQuiltDimensions();
          console.log('üîç INSTAGRAM DEBUG - getQuiltDimensions returns:', dimensions);
          
          // Use fixed 4:5 dimensions (1070 x 1340) - same as main app
          const targetWidth = 1070;  // 1080 - 10px padding
          const targetHeight = 1340; // 1350 - 10px padding
          
          // Center the quilt in the Instagram canvas (5px padding all around)
          const offsetX = 5;  // 5px from left
          const offsetY = 5;  // 5px from top
          
          // Debug: Log block dimensions and coordinate bounds
          const minX = Math.min(...blocks.map(b => b.x));
          const minY = Math.min(...blocks.map(b => b.y));
          const maxX = Math.max(...blocks.map(b => b.x + b.width));
          const maxY = Math.max(...blocks.map(b => b.y + b.height));
          console.log('üîç INSTAGRAM DEBUG - Block dimensions:', blocks.map(b => `${b.width}x${b.height} at (${b.x},${b.y})`));
          console.log('üîç INSTAGRAM DEBUG - Coordinate bounds:', `X: ${minX} to ${maxX} (${maxX-minX}), Y: ${minY} to ${maxY} (${maxY-minY})`);
          
          // Draw each block
          blocks.forEach(block => {
            // Add jitter effects (same as current quilt)
            const jitterX = (Math.random() - 0.5) * 8;
            const jitterY = (Math.random() - 0.5) * 8;
            const jitterRotation = (Math.random() - 0.5) * 4;
            
            const jitteredX = block.x + jitterX;
            const jitteredY = block.y + jitterY;
            
            // Transform to canvas coordinates (handle negative coordinates)
            const canvasX = offsetX + (jitteredX - minX);
            const canvasY = offsetY + (jitteredY - minY);
            const canvasWidth = block.width;
            const canvasHeight = block.height;
            
            // Save context for rotation
            ctx.save();
            
            // Move to center of block for rotation
            const centerX = canvasX + canvasWidth / 2;
            const centerY = canvasY + canvasHeight / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(jitterRotation * Math.PI / 180);
            
            // Draw block (no shadow for clean Instagram look)
            ctx.fillStyle = block.color;
            ctx.fillRect(-canvasWidth / 2, -canvasHeight / 2, canvasWidth, canvasHeight);
            
            // Restore context
            ctx.restore();
          });
          
          // Convert to data URL
          const dataURL = canvas.toDataURL('image/png', 0.95);
          
          this.logger.log(`‚úÖ Generated Instagram image: 1080x1350 (4:5 ratio) - Quilt only`);
          return dataURL;
          
        } catch (error) {
          this.logger.error('Instagram image generation failed:', error);
          return null;
        }
      }

      // Delete archive entry
      async deleteArchive(date) {
        try {
          // Delete from Firestore if available
          // if (window.db && window.firestore) {
          //   const archiveRef = window.firestore.doc(window.db, 'archives', date);
          //   await window.firestore.deleteDoc(archiveRef);
          //   this.logger.log(`üóëÔ∏è Archive deleted from Firestore: ${date}`);
          // }
          
          // Remove from local cache
          this.archives.delete(date);
          this.logger.log(`üóëÔ∏è Archive removed from local cache: ${date}`);
          
          // Refresh the archive feed
          await this.renderArchiveFeed();
          
        } catch (error) {
          this.logger.error('Failed to delete archive:', error);
          throw error;
        }
      }

      // Generate thumbnail from SVG
      async generateThumbnail(svgElement) {
        try {
          if (!svgElement) {
            svgElement = document.getElementById('quilt');
          }
          
          if (!svgElement) {
            this.logger.warn('No SVG element found for thumbnail generation');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+Tm8gUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // SAFEGUARD: Check if SVG has content
          if (!svgElement.children || svgElement.children.length === 0) {
            this.logger.warn('SVG element has no children - using fallback thumbnail');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RW1wdHkgUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // Clone SVG to avoid modifying original
          const svgClone = svgElement.cloneNode(true);
          
          // Get SVG dimensions
          const svgRect = svgElement.getBoundingClientRect();
          const width = Math.max(400, svgRect.width);
          const height = Math.max(400, svgRect.height);
          
          // Ensure SVG has proper attributes
          svgClone.setAttribute('width', width);
          svgClone.setAttribute('height', height);
          svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          
          // Convert SVG to string
          const svgData = new XMLSerializer().serializeToString(svgClone);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          
          // Create canvas for conversion
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = width;
          canvas.height = height;
          
          // Create image from SVG
          const img = new Image();
          const url = URL.createObjectURL(svgBlob);
          
          return new Promise((resolve) => {
            img.onload = () => {
              // Draw to canvas
              ctx.fillStyle = '#f6f4f1'; // Background color
              ctx.fillRect(0, 0, width, height);
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert to data URL
              const dataURL = canvas.toDataURL('image/png', 0.8);
              URL.revokeObjectURL(url);
              
              this.logger.log(`‚úÖ Generated thumbnail: ${width}x${height}`);
              resolve(dataURL);
            };
            
            img.onerror = () => {
              URL.revokeObjectURL(url);
              this.logger.error('Failed to generate thumbnail');
              resolve('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==');
            };
            
            img.src = url;
          });
          
        } catch (error) {
          this.logger.error('Thumbnail generation failed:', error);
          return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==';
        }
      }

      // Generate full quilt image from blocks data
      async generateFullQuiltImage(blocks) {
        try {
          if (!blocks || blocks.length === 0) {
            this.logger.warn('No blocks provided for full quilt image generation');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgdmlld0JveD0iMCAwIDgwMCA2MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI4MDAiIGhlaWdodD0iNjAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjQwMCIgeT0iMzAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIyNCI+Tm8gUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // Calculate quilt bounds
          const minX = Math.min(...blocks.map(b => b.x));
          const minY = Math.min(...blocks.map(b => b.y));
          const maxX = Math.max(...blocks.map(b => b.x + b.width));
          const maxY = Math.max(...blocks.map(b => b.y + b.height));
          
          const quiltWidth = maxX - minX;
          const quiltHeight = maxY - minY;
          
          // Create canvas for full quilt image
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size (tall and narrow like the quilt)
          canvas.width = 800;
          canvas.height = 1200;
          
          // Fill background
          ctx.fillStyle = '#f6f4f1';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Calculate scale to fit quilt in canvas
          const scaleX = canvas.width / quiltWidth;
          const scaleY = canvas.height / quiltHeight;
          const scale = Math.min(scaleX, scaleY, 1) * 1.2; // 20% larger to reduce white space
          
          // Center the quilt
          const offsetX = (canvas.width - quiltWidth * scale) / 2;
          const offsetY = (canvas.height - quiltHeight * scale) / 2;
          
          // Draw each block
          blocks.forEach(block => {
            // Add jitter effects (same as current quilt)
            const jitterX = (Math.random() - 0.5) * 6;
            const jitterY = (Math.random() - 0.5) * 6;
            const jitterRotation = (Math.random() - 0.5) * 3;
            
            const jitteredX = block.x + jitterX;
            const jitteredY = block.y + jitterY;
            
            // Transform to canvas coordinates
            const canvasX = offsetX + (jitteredX - minX) * scale;
            const canvasY = offsetY + (jitteredY - minY) * scale;
            const canvasWidth = block.width * scale;
            const canvasHeight = block.height * scale;
            
            // Save context for rotation
            ctx.save();
            
            // Move to center of block for rotation
            const centerX = canvasX + canvasWidth / 2;
            const centerY = canvasY + canvasHeight / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(jitterRotation * Math.PI / 180);
            
            // Draw block with shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 4;
            
            ctx.fillStyle = block.color;
            ctx.fillRect(-canvasWidth / 2, -canvasHeight / 2, canvasWidth, canvasHeight);
            
            // Restore context
            ctx.restore();
          });
          
          // Convert to data URL
          const dataURL = canvas.toDataURL('image/png', 0.9);
          
          this.logger.log(`‚úÖ Generated full quilt image: 800x1200`);
          return dataURL;
          
        } catch (error) {
          this.logger.error('Full quilt image generation failed:', error);
          return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgdmlld0JveD0iMCAwIDgwMCA2MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI4MDAiIGhlaWdodD0iNjAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjQwMCIgeT0iMzAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIyNCI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==';
        }
      }

      // Load more archives (for "Load More" button)
      async loadMore() {
        if (this.isLoading) return null;
        
        this.isLoading = true;
        this.currentPage++;
        
        try {
          const result = await this.getArchives(this.currentPage);
          this.isLoading = false;
          return result;
        } catch (error) {
          this.isLoading = false;
          this.logger.error('Failed to load more archives:', error);
          return null;
        }
      }

      // Create HTML for a single archive post
      createArchivePostHTML(archiveEntry) {
        const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });

        // Debug: Log image source info
        console.log('Archive image debug:', {
          date: archiveEntry.date,
          hasFullQuiltImage: !!archiveEntry.fullQuiltImage,
          hasThumbnail: !!archiveEntry.thumbnail,
          imageSource: archiveEntry.fullQuiltImage ? 'fullQuiltImage' : (archiveEntry.thumbnail ? 'thumbnail' : 'fallback')
        });

        return `
          <div class="archive-post" data-date="${archiveEntry.date}">
            <img class="archive-post-image" 
                 src="${archiveEntry.fullQuiltImage || archiveEntry.thumbnail || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+TG9hZGluZy4uLjwvdGV4dD4KPHN2Zz4='}" 
                 alt="Quilt from ${formattedDate}"
                 loading="lazy"
                 onload="console.log('Image loaded:', this.naturalWidth + 'x' + this.naturalHeight, 'Displayed:', this.offsetWidth + 'x' + this.offsetHeight, 'Container:', this.parentElement.offsetWidth + 'x' + this.parentElement.offsetHeight, 'Date:', '${formattedDate}')" />
            <div class="archive-post-caption">
              <div class="archive-post-content">
                <div class="archive-post-public">
                  <div class="archive-post-quote-author">${archiveEntry.quote.text} ‚Äî ${archiveEntry.quote.author}</div>
                  <div class="archive-post-meta">
                    <span class="archive-post-date">${formattedDate}</span>
                    <span class="archive-post-contributors">${archiveEntry.userCount} contributors</span>
                    <button class="archive-share-btn" data-date="${archiveEntry.date}" title="Share this quilt">
                      üì§ Share
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      // Render archive feed
      async renderArchiveFeed(containerId = 'archiveFeed') {
        const container = document.getElementById(containerId);
        if (!container) {
          this.logger.error('Archive feed container not found');
          return;
        }

        // Show loading state
        container.innerHTML = '<p class="archive-loading">Loading archives...</p>';

        try {
          // Get first page of archives
          const result = await this.getArchives(0);
          
          if (result.archives.length === 0) {
            container.innerHTML = '<p class="archive-loading">No quilts archived yet. Check back soon!</p>';
            return;
          }

          // Render posts
          container.innerHTML = result.archives
            .map(archive => this.createArchivePostHTML(archive))
            .join('');

          // Setup click handlers for images
          this.setupImageClickHandlers(container);

          // Show/hide Load More button
          this.updateLoadMoreButton(result.hasMore);



          this.logger.log(`Rendered ${result.archives.length} archive posts`);
        } catch (error) {
          this.logger.error('Failed to render archive feed:', error);
          container.innerHTML = '<p class="archive-loading">Failed to load archives. Please try again.</p>';
        }
      }

      // Setup click handlers for archive post images and share buttons
      setupImageClickHandlers(container) {
        // Archive image click handlers
        const images = container.querySelectorAll('.archive-post-image');
        images.forEach(img => {
          img.addEventListener('click', (e) => {
            const postElement = e.target.closest('.archive-post');
            const date = postElement.dataset.date;
            const archiveEntry = this.archives.get(date);
            if (archiveEntry) {
              this.openArchiveModal(archiveEntry);
            }
          });
        });
        
        // Archive share button click handlers
        const shareButtons = container.querySelectorAll('.archive-share-btn');
        shareButtons.forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent triggering image click
            const date = btn.getAttribute('data-date');
            await this.shareArchiveQuilt(date);
          });
        });
      }

      // Open archive modal with enlarged view
      openArchiveModal(archiveEntry) {
        const modal = document.getElementById('archiveModal');
        const modalImage = document.getElementById('archiveModalImage');
        const modalQuote = document.getElementById('archiveModalQuote');
        const modalMeta = document.getElementById('archiveModalMeta');
        const modalDelete = document.getElementById('archiveModalDelete');

        if (!modal) return;

        // Set modal content
        modalImage.src = archiveEntry.fullQuiltImage || archiveEntry.thumbnail || '';
        modalImage.alt = `Quilt from ${archiveEntry.date}`;
        modalQuote.textContent = `${archiveEntry.quote.text} ‚Äî ${archiveEntry.quote.author}`;
        
        const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        modalMeta.innerHTML = `${formattedDate} ‚Ä¢ ${archiveEntry.userCount} contributors`;

        // Show/hide delete button based on admin status
        if (modalDelete) {
          const isAdmin = window.app?.authService?.isAdmin() || false;
          modalDelete.style.display = isAdmin ? 'block' : 'none';
          
          // Set up delete functionality
          modalDelete.onclick = async () => {
            if (confirm(`Are you sure you want to delete the archive from ${formattedDate}?`)) {
              try {
                await this.deleteArchive(archiveEntry.date);
                this.closeArchiveModal();
                this.logger.log(`üóëÔ∏è Archive deleted: ${archiveEntry.date}`);
              } catch (error) {
                this.logger.error('Failed to delete archive:', error);
              }
            }
          };
        }

        // Show modal
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden'; // Prevent background scroll
      }

      // Close archive modal
      closeArchiveModal() {
        const modal = document.getElementById('archiveModal');
        if (modal) {
          modal.style.display = 'none';
          document.body.style.overflow = ''; // Restore scroll
        }
      }

      // Update Load More button visibility
      updateLoadMoreButton(hasMore) {
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        if (loadMoreBtn) {
          loadMoreBtn.style.display = hasMore ? 'block' : 'none';
        }
      }

      // Share an archived quilt
      async shareArchiveQuilt(date) {
        try {
          const archiveEntry = this.archives.get(date);
          if (!archiveEntry) {
            throw new Error('Archive entry not found');
          }
          
          const formattedDate = new Date(date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Use the Web Share API if available
          if (navigator.share) {
            try {
              await navigator.share({
                title: `Community Quilt - ${formattedDate}`,
                text: `${archiveEntry.quote.text} ‚Äî ${archiveEntry.quote.author} - Made by ${archiveEntry.userCount} contributors`,
                url: `${window.location.href}?date=${date}`
              });
              
              this.logger.log(`üì§ Archive quilt shared: ${date}`);
              return;
            } catch (shareError) {
              // User cancelled or share failed
              if (shareError.name !== 'AbortError') {
                this.logger.log('Web Share failed, falling back to copy link');
              }
            }
          }
          
          // Fallback: Copy link to clipboard
          try {
            const shareUrl = `${window.location.href}?date=${date}`;
            await navigator.clipboard.writeText(shareUrl);
            this.logger.log(`üì§ Archive link copied: ${date}`);
          } catch (clipboardError) {
            // Final fallback: Just show a message
            const shareUrl = `${window.location.href}?date=${date}`;
            this.logger.log(`üì§ Archive share link: ${shareUrl}`);
          }
          
        } catch (error) {
          this.logger.error('Archive share failed:', error);
        }
      }
    }

    // ===== DATA LAYER =====
    class QuiltDataService {
      constructor(logger, errorHandler) {
        this.logger = logger;
        this.errorHandler = errorHandler;
        this.db = null;
        this.quiltDoc = null;
      }

      async initialize() {
        try {
          // Wait for Firebase to be available
          // let attempts = 0;
          // while (!window.db && attempts < 50) {
          //   await new Promise(resolve => setTimeout(resolve, 100));
          //   attempts++;
          // }
          
          // if (window.db) {
          //   this.db = window.db;
          //   this.logger.log('‚úÖ Firestore initialized successfully');
          // } else {
          //   this.logger.warn('‚ö†Ô∏è Firestore not available, falling back to localStorage');
          //   this.db = null;
          // }
          this.logger.log('‚úÖ Using local storage only - Firebase disabled');
          this.db = null;
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Firestore initialization failed, falling back to localStorage:', error);
          this.db = null;
        }
      }

      async loadQuilt() {
        try {
          // if (this.db) {
          //   // Try Firestore first
          //   const today = Utils.getTodayKey();
          //   this.logger.log('üîç Looking for quilt in Firestore with date key:', today);
          //   
          //   // Also check what other dates exist in Firestore
          //   try {
          //     const quiltsRef = window.firestore.collection(this.db, 'quilts');
          //     const querySnapshot = await window.firestore.getDocs(quiltsRef);
          //     const availableDates = [];
          //     querySnapshot.forEach(doc => {
          //       constData = doc.data();
          //     availableDates.push({
          //       date: doc.id,
          //       blocks: data.blocks?.length || 0,
          //       contributorCount: data.contributorCount || 1
          //     });
          //   });
          //   this.logger.log('üìä Available Firestore dates:', JSON.stringify(availableDates, null, 2));
          // } catch (listError) {
          //   this.logger.warn('‚ö†Ô∏è Could not list Firestore documents:', listError);
          // }
          //   
          //   const quiltRef = window.firestore.doc(this.db, 'quilts', today);
          //   const quiltSnap = await window.firestore.getDoc(quiltRef);
          //   
          //   if (quiltSnap.exists()) {
          //     const data = quiltSnap.data();
          //     this.logger.log('üìñ Loaded quilt from Firestore with', data.blocks?.length || 0, 'blocks');
          //     return { 
          //       blocks: data.blocks || [], 
          //       contributorCount: data.contributorCount || 1 
          //     };
          //   } else {
          //     this.logger.warn('‚ö†Ô∏è No Firestore document found for date:', today);
          //   }
          // }
          
          // Fallback to localStorage
          const savedData = localStorage.getItem('ourDailyQuilt');
          if (savedData) {
            const data = JSON.parse(savedData);
            this.logger.log('üìñ Loaded quilt from localStorage with', data.blocks?.length || 0, 'blocks, date:', data.date);
            return { 
              blocks: data.blocks || [], 
              contributorCount: data.contributorCount || 1 
            };
          } else {
            this.logger.warn('‚ö†Ô∏è No localStorage data found');
          }
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Error loading quilt, using default:', error);
        }
        
        // Default quilt
        const dimensions = Utils.getQuiltDimensions();
        this.logger.log('üìñ Using default quilt');
        return { 
          blocks: [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }], 
          contributorCount: 1 
        };
      }

      async saveQuilt(blocks, contributorCount) {
        try {
          const quiltData = {
            blocks: blocks,
            contributorCount: contributorCount,
            lastUpdated: new Date().toISOString(),
            date: Utils.getTodayKey()
          };
          
          // Check Firestore availability
          if (!window.db || !window.firestore) {
            console.warn('‚ö†Ô∏è Firestore not available for saving');
          }
          
          if (window.db && window.firestore) {
            // Save to Firestore
            const today = Utils.getTodayKey();
            const quiltRef = window.firestore.doc(window.db, 'quilts', today);
            await window.firestore.setDoc(quiltRef, quiltData);
            this.logger.log('üíæ Saved quilt to Firestore');
            
            // Also save today's quote to Firestore
            try {
              const todayQuote = window.app?.quoteService?.getTodayQuote();
              if (todayQuote) {
                const quoteData = {
                  text: todayQuote.text,
                  author: todayQuote.author,
                  date: today,
                  lastUpdated: new Date().toISOString()
                };
                const quoteRef = window.firestore.doc(window.db, 'quotes', today);
                await window.firestore.setDoc(quoteRef, quoteData);
                this.logger.log('üíæ Saved today\'s quote to Firestore');
              }
            } catch (quoteError) {
              console.warn('‚ö†Ô∏è Could not save quote to Firestore:', quoteError);
            }
            
            // Also save the generated Instagram image to Firestore
            try {
              const instagramImage = await window.app.archiveService.generateInstagramImage(quiltData.blocks);
              if (instagramImage) {
                const imageData = {
                  imageData: instagramImage,
                  date: today,
                  lastUpdated: new Date().toISOString()
                };
                const imageRef = window.firestore.doc(window.db, 'instagram-images', today);
                await window.firestore.setDoc(imageRef, imageData);
                this.logger.log('üíæ Saved Instagram image to Firestore');
              }
            } catch (imageError) {
              console.warn('‚ö†Ô∏è Could not save Instagram image to Firestore:', imageError);
            }
          }
          
          // Also save to localStorage as backup with safety check
          if (quiltData.blocks && quiltData.blocks.length > 0) {
            localStorage.setItem('ourDailyQuilt', JSON.stringify(quiltData));
            console.log('üíæ Safely saved quilt with', quiltData.blocks.length, 'blocks');
          } else {
            console.warn('‚ö†Ô∏è Attempted to save empty quilt data - skipping to prevent data loss');
          }
          
          return true;
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          
          // Fallback to localStorage only
          try {
            localStorage.setItem('ourDailyQuilt', JSON.stringify({
              blocks: blocks,
              contributorCount: contributorCount,
              lastUpdated: new Date().toISOString(),
              date: Utils.getTodayKey()
            }));
            this.logger.log('üíæ Saved quilt to localStorage (fallback)');
            return true;
          } catch (localError) {
            this.errorHandler.handleError(localError, 'saveQuilt localStorage fallback');
            return false;
          }
        }
      }
    }



    // ===== QUOTE SERVICE =====
    class QuoteService {
      constructor(firebaseInstance = null) {
        this.firebase = firebaseInstance;
        console.log('üìö QuoteService constructor - Firebase instance:', !!firebaseInstance);
        // Initialize with default quotes (will be replaced if Firestore load succeeds)
        this.quotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "‚Äî Pablo Picasso" },
          { text: "Creativity takes courage.", author: "‚Äî Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "‚Äî Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "‚Äî Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "‚Äî Vincent Van Gogh" },
          { text: "You can't use up creativity. The more you use, the more you have.", author: "Maya Angelou" },
          { text: "Every time I have had a problem, I have confronted it with the ax of art.", author: "Yayoi Kusama" },
          { text: "I found I could say things with color and shapes that I couldn't say any other way ‚Äì things I had no words for.", author: "Georgia O'Keeffe" },
          { text: "I love creation more than life, and I must express myself before disappearing.", author: "Sonia Delaunay" },
          { text: "The job of the artist is always to deepen the mystery.", author: "Francis Bacon" },
          { text: "The most important relationship in your life is the relationship you have with yourself.", author: "Diane von Furstenberg" },
          { text: "There is a vitality, a life force, an energy, a quickening that is translated through you into action, and because there is only one of you in all time, this expression is unique.", author: "Martha Graham" },
          { text: "If there is a book that you want to read, but it hasn't been written yet, you must be the one to write it.", author: "Toni Morrison" },
          { text: "Creativity doesn't wait for that perfect moment. It fashions its own perfect moments out of ordinary ones.", author: "Elizabeth Gilbert" },
          { text: "I think, at a child's birth, if a mother could ask a fairy godmother to endow it with the most useful gift, that gift would be curiosity.", author: "Eleanor Roosevelt" },
          { text: "Imagination is more important than knowledge. Knowledge is limited. Imagination encircles the world.", author: "Albert Einstein" },
          { text: "The beauty of a living thing is not the atoms that go into it, but the way those atoms are put together.", author: "Carl Sagan" },
          { text: "Let your curiosity be greater than your fear.", author: "Pema Ch√∂dr√∂n" },
          { text: "Study hard what interests you the most in the most undisciplined, irreverent and original manner possible.", author: "Richard Feynman" },
          { text: "Research is formalized curiosity. It is poking and prying with a purpose.", author: "Zora Neale Hurston" },
          { text: "It is always with excitement that I wake up in the morning wondering what my intuition will toss up to me, like gifts from the sea.", author: "Jonas Salk" },
          { text: "The only thing that makes life possible is permanent, intolerable uncertainty; not knowing what comes next.", author: "Ursula K. Le Guin" },
          { text: "Curiosity is the engine of achievement.", author: "Sir Ken Robinson" },
          { text: "Let the beauty of what you love be what you do. There are a thousand ways to kneel and kiss the earth.", author: "Rumi" },

          { text: "I'm very interested in, 'What does it mean for us to cultivate together?' Community that allows for risk, the risk of knowing someone outside your own boundaries, the risk that is love.", author: "bell hooks" },
          { text: "A nation's culture resides in the hearts and in the soul of its people.", author: "Mahatma Gandhi" },
          { text: "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.", author: "Antoine de Saint-Exup√©ry" },
          { text: "The butterfly counts not months but moments, and has time enough.", author: "Rabindranath Tagore" },
          { text: "To fly, we have to have resistance.", author: "Maya Lin" },
          { text: "Not everything that is faced can be changed, but nothing can be changed until it is faced.", author: "James Baldwin" },
          { text: "There's nothing new under the sun, but there are new suns.", author: "Octavia Butler" },
          { text: "Never doubt that a small group of thoughtful, committed citizens can change the world; indeed, it's the only thing that ever has.", author: "Margaret Mead" },
          { text: "There is no such thing as a single-issue struggle because we do not live single-issue lives.", author: "Audre Lorde" },
          { text: "Every moment is an organizing opportunity, every person a potential activist, every minute a chance to change the world.", author: "Dolores Huerta" },
          { text: "We don't have to engage in grand, heroic actions to participate in the process of change. Small acts, when multiplied by millions of people, can transform the world.", author: "Howard Zinn" },
          { text: "When the whole world is silent, even one voice becomes powerful.", author: "Malala Yousafzai" },
          { text: "Activism is my rent for living on the planet.", author: "Alice Walker" },
          { text: "We are the leaders we've been waiting for.", author: "Grace Lee Boggs" },
          { text: "Do your little bit of good where you are; it's those little bits of good put together that overwhelm the world.", author: "Desmond Tutu" },
          { text: "What you do makes a difference, and you have to decide what kind of difference you want to make.", author: "Jane Goodall" },
          { text: "You never change things by fighting the existing reality. To change something, build a new model that makes the existing model obsolete.", author: "Buckminster Fuller" },
          { text: "Like what you do, and then you will do your best.", author: "Katherine Johnson" },
          { text: "The present is theirs; the future, for which I really worked, is mine.", author: "Nikola Tesla" },
          { text: "Cities have the capability of providing something for everybody, only because, and only when, they are created by everybody.", author: "Jane Jacobs" },
          { text: "In every outthrust headland, in every curving beach, in every grain of sand there is the story of the earth.", author: "Rachel Carson" },
          { text: "What the people want is very simple - they want an America as good as its promise.", author: "Barbara Jordan" },
          { text: "In nature's economy the currency is not money, it is life.", author: "Vandana Shiva" },
          { text: "When we plant trees, we plant the seeds of peace and seeds of hope.", author: "Wangari Maathai" },
          { text: "No one is born fully-formed: it is through self-experience in the world that we become what we are.", author: "Paulo Freire" },
          { text: "Turn your wounds into wisdom.", author: "Oprah Winfrey" },
          { text: "Courage doesn't always roar. Sometimes courage is the quiet voice at the end of the day saying 'I will try again tomorrow.'", author: "Mary Anne Radmacher" },
          { text: "I fight pain, anxiety, and fear every day, and the only method I have found that relieves my illness is to keep creating art.", author: "Yayoi Kusama" },
          { text: "To heal is to touch with love that which we previously touched with fear.", author: "Stephen Levine" },
          { text: "I am better off healed than I ever was unbroken.", author: "Beth Moore" },
          { text: "Everything can be taken from a man but one thing: the last of the human freedoms‚Äîto choose one's attitude in any given set of circumstances.", author: "Viktor Frankl" },
          { text: "The purpose of life is not to be happy. It is to be useful, to be honorable, to be compassionate, to have it make some difference that you have lived and lived well.", author: "Ralph Waldo Emerson" },
          { text: "Let yourself be silently drawn by the strange pull of what you really love. It will not lead you astray.", author: "Rumi" },
          { text: "Follow your bliss and the universe will open doors where there were only walls.", author: "Joseph Campbell" },
          { text: "A musician must make music, an artist must paint, a poet must write, if he is to be ultimately happy. What a man can be, he must be.", author: "Abraham Maslow" },
          { text: "At every moment you choose yourself. But do you choose your self? Body and soul contain a thousand possibilities out of which you can build many I's.", author: "Dag Hammarskj√∂ld" },
          { text: "We are the myths we tell ourselves about ourselves.", author: "Jean Houston" },
          { text: "A vocation is not a career that you choose for yourself. A vocation is a calling that you discover by listening to the voice of vocation within you.", author: "Parker Palmer" },
          { text: "Attention is the rarest and purest form of generosity.", author: "Simone Weil" },
          { text: "Waking up this morning, I smile. Twenty-four brand new hours are before me. I vow to live fully in each moment.", author: "Th√≠ch Nh·∫•t H·∫°nh" },
          { text: "The privilege of a lifetime is to become who you truly are.", author: "Carl Jung" },
          { text: "I define connection as the energy that exists between people when they feel seen, heard, and valued; when they can give and receive without judgment.", author: "Bren√© Brown" },
          { text: "Perhaps the secret of living well is not in having all the answers but in pursuing unanswerable questions in good company.", author: "Rachel Naomi Remen" },
          { text: "All real living is meeting.", author: "Martin Buber" },
          { text: "We humans are social beings. We come into the world as the result of others' actions. We survive here in dependence on others.", author: "The Dalai Lama" },
          { text: "Sometimes people try to destroy you, precisely because they recognize your power.", author: "bell hooks" },
          { text: "When you understand that being connected to others is one of life's greatest joys, you realize that life's best comes when you initiate and invest in solid relationships.", author: "John C. Maxwell" },
          { text: "Healing yourself is connected with healing others.", author: "Yoko Ono" },
          { text: "Relationships are all there is. Everything in the universe only exists because it is in relationship to everything else.", author: "Margaret J. Wheatley" },
          { text: "When you take one step to reach out to people, when you meet with others and share their thoughts and sufferings, infinite compassion and wisdom well up within your heart.", author: "Daisaku Ikeda" },
          { text: "We now accept the fact that learning is a lifelong process of keeping abreast of change. And the most pressing task is to teach people how to learn.", author: "Peter Drucker" },
          { text: "The illiterate of the 21st century will not be those who cannot read and write, but those who cannot learn, unlearn, and relearn.", author: "Alvin Toffler" },
          { text: "Those people who develop the ability to continuously acquire new and better forms of knowledge that they can apply to their work and to their lives will be the movers and shakers in our society for the indefinite future.", author: "Brian Tracy" },
          { text: "The purpose of learning is growth, and our minds, unlike our bodies, can continue growing as we continue to live.", author: "Mortimer Adler" },
          { text: "The good thing about science is that it's true whether or not you believe in it. But the great thing about learning is that it makes you more capable of reducing the suffering of others.", author: "Neil deGrasse Tyson" },
          { text: "I have learned that each and every piece of cloth embodies the spirit, skill, and personal history of an individual weaver‚Ä¶ It ties together with an endless thread the emotional life of my people.", author: "Nilda Calla√±aupa Alvarez" },
          { text: "I wanted to tell my story through fabric because it was a medium that was accessible to me as a woman and as an African American.", author: "Faith Ringgold" },
          { text: "Come stitch next to me, and I'll tell you a story.", author: "Sonya Clark" },
          { text: "Fabric is a material that forgives. You can always mend, patch, darn, and transform it into something new.", author: "Louise Bourgeois" },
          { text: "We must learn inner solitude wherever or with whomsoever we may be. We must learn to penetrate things and find God in them.", author: "Anni Albers" },
          { text: "Thread has the potential to unite, to heal, to provide a soft structure in a hard world.", author: "Sheila Hicks" },
          { text: "The loom is the universe in miniature‚Äîwarp and weft, the essential crossing that creates all structure, all meaning.", author: "Lenore Tawney" },
          { text: "Western art tradition values fine art practices such as painting, mostly done by men and on canvas. Bringing these techniques into the gallery space allows me to question the hierarchy in the Western art world.", author: "Hale Ekinci" },
          { text: "The true measure of our commitment to justice, the character of our society, our commitment to the rule of law, fairness, and equality cannot be measured by how we treat the rich, the powerful, the privileged, and the respected among us.", author: "Bryan Stevenson" },
          { text: "We cannot seek achievement for ourselves and forget about the progress and prosperity for our community.", author: "Dolores Huerta" },
          { text: "If you see something that is not right, not fair, not just, you have a moral obligation to do something about it.", author: "John Lewis" },
          { text: "Trauma happens in relationship, so does healing.", author: "Tarana Burke" },
          { text: "Real change requires real relationships. And real relationships require that we tell the truth about our experiences.", author: "Alicia Garza" },
          { text: "Care is the strategy. Care is what we need more of in this world. Care is revolutionary.", author: "Ai-jen Poo" },
          { text: "We accomplish nothing if we say nothing. We accomplish nothing if we do nothing. And we accomplish nothing if we know nothing.", author: "Stacey Abrams" }
        ];
        this.shuffledIndexes = [2, 4, 0, 5, 3, 1, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99];
      }

      getTodayQuote() {
        // Use UTC time for day calculation - quote changes at 7:00 AM UTC
        const now = new Date();
        
        // Adjust for 7 AM UTC day boundary instead of midnight UTC
        // If it's before 7 AM UTC, use yesterday's quote
        const utcHours = now.getUTCHours();
        const adjustedDate = new Date(now);
        
        if (utcHours < 7) {
          // Before 7 AM UTC, use yesterday's date
          adjustedDate.setUTCDate(adjustedDate.getUTCDate() - 1);
        }
        
        const dayIndex = Math.floor(adjustedDate.getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        
        console.log(`üîç getTodayQuote: ${now.toDateString()} (UTC) ‚Üí adjusted: ${adjustedDate.toDateString()} ‚Üí dayIndex: ${dayIndex} ‚Üí quoteIndex: ${quoteIndex} ‚Üí quote: "${this.quotes[quoteIndex].text.substring(0, 50)}..."`);
        
        return this.quotes[quoteIndex];
      }

      getQuoteForDate(dateString) {
        // dateString format: "2025-08-18" - assumes UTC date
        const date = new Date(dateString);
        const dayIndex = Math.floor(date.getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        
        console.log(`üîç getQuoteForDate: ${dateString} (UTC) ‚Üí dayIndex: ${dayIndex} ‚Üí quoteIndex: ${quoteIndex} ‚Üí quote: "${this.quotes[quoteIndex].text.substring(0, 50)}..."`);
        
        return this.quotes[quoteIndex];
      }

      displayQuote() {
        try {
          const { text, author } = this.getTodayQuote();
          const quoteLine = document.querySelector('.quote-line');
          const quoteAuthor = document.querySelector('.quote-author');
          
          // Reset fade-in elements to hidden state when quote is displayed
          const fadeElements = document.querySelectorAll('.quote-screen-fade-in');
          fadeElements.forEach(el => el.classList.remove('visible'));
          
          if (quoteLine) {
            quoteLine.textContent = text;
            
            // IMMEDIATE check: If text is longer than ~100 characters, apply long-quote class immediately
            if (text.length > 100) {
              quoteLine.classList.add('long-quote');
              console.log('Applied long-quote class immediately based on text length:', text.length);
            } else {
              // For shorter text, check height-based measurement
              this.checkQuoteLength(quoteLine);
            }
          }
          if (quoteAuthor) {
            quoteAuthor.textContent = author;
            // Apply same long-quote class to author if quote is long
            if (quoteLine && quoteLine.classList.contains('long-quote')) {
              quoteAuthor.classList.add('long-quote');
            } else {
              quoteAuthor.classList.remove('long-quote');
            }
          }
          
          // Also populate the quote display on the quilt screen
          const quiltQuoteText = document.querySelector('.quilt-quote-text');
          const quiltQuoteAuthor = document.querySelector('.quilt-quote-author');
          const quiltQuoteDisplay = document.querySelector('.quilt-quote-display');
          
          if (quiltQuoteText) quiltQuoteText.textContent = text;
          if (quiltQuoteAuthor) quiltQuoteAuthor.textContent = author;
          
          // Show the quote display when content is populated
          if (quiltQuoteDisplay && text && author) {
            quiltQuoteDisplay.classList.add('has-content');
          }

        } catch (error) {
          console.error('Error displaying quote:', error);
        }
      }

      // Check if quote is longer than 2 lines and apply appropriate styling
      checkQuoteLength(quoteElement) {
        // Prevent multiple calls on the same element
        if (quoteElement.dataset.lengthChecked === 'true') {
          return;
        }
        
        // Mark as checked to prevent re-runs
        quoteElement.dataset.lengthChecked = 'true';
        
        // Use setTimeout to ensure the text is fully rendered before measuring
        setTimeout(() => {
          // Check if element is visible
          if (quoteElement.offsetHeight === 0) {
            console.log('Quote element not visible yet, retrying...');
            // Reset the flag and retry after a longer delay
            delete quoteElement.dataset.lengthChecked;
            setTimeout(() => this.checkQuoteLength(quoteElement), 500);
            return;
          }
          
          // Get the computed line height
          const computedStyle = window.getComputedStyle(quoteElement);
          const lineHeight = parseFloat(computedStyle.lineHeight);
          const elementHeight = quoteElement.offsetHeight;
          
          console.log('Quote height:', elementHeight, 'Line height:', lineHeight, 'Ratio:', elementHeight / lineHeight);
          
          // If the element height is more than 2.2 times the line height, consider it long (lowered threshold)
          if (elementHeight > lineHeight * 2.2) {
            quoteElement.classList.add('long-quote');
            console.log('Applied long-quote class');
          }
        }, 200);
      }

      // Load quotes from Firestore
      async loadQuotesFromFirestore() {
        try {
          console.log('üìö Loading quotes from Firestore...');
          
          // Check if global Firestore is available
          // if (!window.db || !window.firestore) {
          //   console.log('üìö Global Firestore not available, using default quotes');
          //   return false;
          // }
          
          // Use the global Firestore functions
          // const docRef = window.firestore.doc(window.db, 'quotes', 'daily');
          // const docSnap = await window.firestore.getDoc(docRef);
          
          // if (docSnap.exists() && docSnap.data().quotes) {
          //   this.quotes = docSnap.data().quotes;
          //   if (docSnap.data().shuffledIndexes) {
          //     this.shuffledIndexes = docSnap.data().shuffledIndexes;
          //     console.log('‚úÖ Loaded shuffled indexes from Firestore:', this.shuffledIndexes.length, 'indexes');
          //   }
          //   console.log('‚úÖ Loaded quotes from Firestore:', this.quotes.length, 'quotes');
          //   
          //   Update the display if we're on the quote screen
          //   if (document.querySelector('.quote-line')) {
          //     this.displayQuote();
          //   }
          //   
          //   return true;
          // } else {
          //   console.log('üìö No quotes found in Firestore, using defaults');
          //   return false;
          // }
          
          console.log('üìö Using default quotes - Firestore disabled');
          return false;
          
        } catch (error) {
          console.error('‚ùå Error loading quotes from Firestore:', error);
          
          // Fallback to localStorage if available
          try {
            const savedQuotes = localStorage.getItem('ourDailyQuotes');
            if (savedQuotes) {
              this.quotes = JSON.parse(savedQuotes);
              console.log('üìö Loaded quotes from localStorage fallback:', this.quotes.length, 'quotes');
              return true;
            }
          } catch (localError) {
            console.error('Error loading from localStorage:', localError);
          }
          
          return false;
        }
      }
    }

    // ===== ENHANCED RENDERER =====
    class QuiltRendererV2 {
      constructor(logger) {
        this.logger = logger;
        this.quiltSVG = null;
        this.lastAddedIndex = null;
        this.userPieces = new Set();
      }

      initialize() {
        this.quiltSVG = document.getElementById('quilt');
        if (!this.quiltSVG) {
          throw new Error('Quilt SVG element not found');
        }
        
        // Set initial viewBox to viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        this.quiltSVG.setAttribute('viewBox', `0 0 ${viewportWidth} ${viewportHeight}`);
        this.quiltSVG.setAttribute('width', viewportWidth);
        this.quiltSVG.setAttribute('height', viewportHeight);
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      }

      renderBlocks(blocks, userPieces = []) {
        if (!this.quiltSVG) {
          this.logger.warn('Quilt SVG not found');
          return;
        }

        this.quiltSVG.innerHTML = '';
        this.userPieces = new Set(userPieces.map(b => b.id));

        if (blocks.length === 0) {
          return;
        }

        // Calculate actual quilt bounds from blocks
        const minX = Math.min(...blocks.map(b => b.x));
        const minY = Math.min(...blocks.map(b => b.y));
        const maxX = Math.max(...blocks.map(b => b.x + b.width));
        const maxY = Math.max(...blocks.map(b => b.y + b.height));
        
        const actualQuiltWidth = maxX - minX;
        const actualQuiltHeight = maxY - minY;
        
        // Add some padding around the quilt content
        const padding = 20;
        const viewBoxWidth = actualQuiltWidth + (padding * 2);
        const viewBoxHeight = actualQuiltHeight + (padding * 2);
        
        // Set viewBox to actual quilt content with padding
        this.quiltSVG.setAttribute('viewBox', `${minX - padding} ${minY - padding} ${viewBoxWidth} ${viewBoxHeight}`);
        
        // Set SVG dimensions to fill container
        this.quiltSVG.setAttribute('width', '100%');
        this.quiltSVG.setAttribute('height', '100%');
        
        console.log('üîß USING ACTUAL QUILT DIMENSIONS:', actualQuiltWidth, 'x', actualQuiltHeight);
        
        // Mobile: Center the quilt content and fit fully inside container
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        
        // Make SVG fill the entire container with !important
        this.quiltSVG.style.setProperty('width', '100%', 'important');
        this.quiltSVG.style.setProperty('height', '100%', 'important');
        this.quiltSVG.style.setProperty('max-width', '100%', 'important');
        this.quiltSVG.style.setProperty('max-height', '100%', 'important');
        
        // Debug: Log SVG dimensions
        console.log('üîß SVG dimensions set to:', {
          width: this.quiltSVG.style.width,
          height: this.quiltSVG.style.height,
          viewBox: this.quiltSVG.getAttribute('viewBox'),
          preserveAspectRatio: this.quiltSVG.getAttribute('preserveAspectRatio')
        });
        
        // No global flip - individual blocks will be flipped when touched

        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
          <filter id="dropShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="rgba(0,0,0,0.15)"/>
          </filter>
        `;
        this.quiltSVG.appendChild(defs);

        blocks.forEach((block, i) => {
          const jitterX = (Math.random() - 0.5) * 6;
          const jitterY = (Math.random() - 0.5) * 6;
          const jitterRotation = (Math.random() - 0.5) * 3;
          
          const jitteredBlock = {
            x: block.x + jitterX,
            y: block.y + jitterY,
            width: block.width,
            height: block.height,
            color: block.color,
            rotation: jitterRotation
          };
          
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', jitteredBlock.x);
          rect.setAttribute('y', jitteredBlock.y);
          rect.setAttribute('width', jitteredBlock.width);
          rect.setAttribute('height', jitteredBlock.height);
          rect.setAttribute('fill', jitteredBlock.color);
          
          const centerX = jitteredBlock.x + jitteredBlock.width / 2;
          const centerY = jitteredBlock.y + jitteredBlock.height / 2;
          
          // Apply basic rotation transformation
          rect.setAttribute('transform', `rotate(${jitterRotation} ${centerX} ${centerY})`);
          
          // Add flip state as CSS class for simpler handling
          const blockFlipState = this.getBlockFlipState(block.id);
          if (blockFlipState) {
            rect.classList.add('block-flipped');
            console.log(`üîÑ Applied block-flipped class to block ${block.id}`); // TEMPORARILY RE-ENABLED FOR DEBUGGING
            
            // Apply reveal image if one is selected (access through global app instance)
            if (window.app && window.app.currentRevealImage) {
              const color = window.app.currentRevealImage === 'image1' ? '#ff6b6b' : '#4ecdc4';
              rect.setAttribute('fill', color);
              rect.style.setProperty('fill', color, 'important');
            }
          }
          rect.setAttribute('data-block-id', block.id);
          
          // Add user piece highlighting
          if (this.userPieces.has(block.id)) {
            rect.classList.add('user-piece-highlight');
          }
          
          // Add new block animation
          if (i === this.lastAddedIndex) {
            rect.setAttribute('opacity', '0');
            rect.classList.add('new-block');
            rect.addEventListener('animationend', () => {
              rect.classList.remove('new-block');
              rect.removeAttribute('opacity');
            }, { once: true });
          }
          
          this.quiltSVG.appendChild(rect);
        });

        this.lastAddedIndex = null;
      }

      setLastAddedIndex(index) {
        this.lastAddedIndex = index;
      }
      
      // Individual block flip state management
      clearAllFlipStates() {
        const todayKey = Utils.getTodayKey();
        localStorage.removeItem(`blockFlips_${todayKey}`);
        console.log('üîÑ Cleared all flip states - quilt loads right side up');
      }
      
      getBlockFlipState(blockId) {
        const todayKey = Utils.getTodayKey();
        const flippedBlocks = JSON.parse(localStorage.getItem(`blockFlips_${todayKey}`) || '[]');
        return flippedBlocks.includes(blockId);
      }
      
      toggleBlockFlip(blockId) {
        const todayKey = Utils.getTodayKey();
        const flippedBlocks = JSON.parse(localStorage.getItem(`blockFlips_${todayKey}`) || '[]');
        
        if (flippedBlocks.includes(blockId)) {
          // Remove from flipped blocks
          const index = flippedBlocks.indexOf(blockId);
          flippedBlocks.splice(index, 1);
        } else {
          // Add to flipped blocks
          flippedBlocks.push(blockId);
        }
        
        localStorage.setItem(`blockFlips_${todayKey}`, JSON.stringify(flippedBlocks));
        return flippedBlocks.includes(blockId);
      }

      getFlippedBlocks() {
        const todayKey = Utils.getTodayKey();
        return JSON.parse(localStorage.getItem(`blockFlips_${todayKey}`) || '[]');
      }
    }

    // ===== MAIN APPLICATION =====
    class SimplifiedQuiltAppV2 {
      constructor() {
        // Check if user is on desktop and show redirect if needed
        const redirected = this.checkDeviceAndRedirect();
        if (redirected) {
          // Create a minimal app object for desktop redirect
          this.isDesktopRedirect = true;
          this.initialize = () => Promise.resolve(); // No-op initialize
          return;
        }
        
        // Initialize services
        this.logger = new Logger(CONFIG.APP.debugMode);
        this.uiService = new UIService(this.logger);
        this.errorHandler = new ErrorHandler(this.uiService, this.logger);
        this.dataService = new QuiltDataService(this.logger, this.errorHandler);
        // console.log('üßµ App constructor - window.firebaseApp available:', !!window.firebaseApp);
        // this.quoteService = new QuoteService(window.firebaseApp);
        this.quoteService = new QuoteService(null); // Use null for local storage only
        this.renderer = new QuiltRendererV2(this.logger);
        this.archiveService = new ArchiveService(this.logger, this.dataService);
        
        // Initialize simplified engine
        this.quiltEngine = new SimpleQuiltEngine(this.currentUserId);
        
        // App state
        this.currentUserId = Utils.getOrCreateUserId();
        this.quiltScale = 1;
        
        // Check for secret admin URL parameter
        this.checkSecretAdminAccess();
        
        // Color picker state
        this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
        this.selectedSaturation = CONFIG.COLOR_PICKER.saturation;
        this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
        this.colorHasBeenSelected = false;
        this.isDragging = false;
      }
      
      checkDeviceAndRedirect() {
        const isDesktop = window.innerWidth >= 768;
        if (isDesktop) {
          this.showDesktopRedirect();
          return true; // Indicate that redirect happened
        }
        return false; // No redirect, continue with normal initialization
      }
      
      showDesktopRedirect() {
        // Hide all existing content
        document.body.innerHTML = '';
        
        // Create redirect screen styled like ABOUT screen
        const redirectHTML = `
          <div style="
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f6f4f1;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 2rem;
            text-align: center;
          ">
                  <h1 style="
        font-size: 2.5rem;
        font-weight: 400;
        margin-bottom: -1.5rem;
        color: #333;
      ">Welcome to</h1>
      
      <h1 style="
        font-size: 2.5rem;
        font-weight: 600;
        margin-bottom: 2rem;
        color: #333;
      ">OUR DAILY QUILT</h1>
      
      <p style="
        font-size: 1.3rem;
        line-height: 1.6;
        margin-bottom: 0.5rem;
        color: #333;
        max-width: 400px;
      ">Please switch to your phone<br>to add your block</p>
      
      <p style="
        font-size: 1.5rem;
        margin-bottom: 1.5rem;
        color: #666;
      ">‚Üì</p>
            
            <div id="qr-code" style="
              display: flex;
              justify-content: center;
              margin-bottom: 1rem;
            "></div>

            

          </div>
        `;
        
        document.body.innerHTML = redirectHTML;
        
        // Generate QR code
        this.generateQRCode();
      }
      
      generateQRCode() {
        const qrContainer = document.getElementById('qr-code');
        console.log('QR Container found:', qrContainer);
        
        if (qrContainer) {
          // Create QR code using live website URL
          const currentURL = 'https://www.zakfoster.com/odq';
          console.log('QR Code URL:', currentURL);
          
          // Clear container first
          qrContainer.innerHTML = '';
          
          if (typeof qrcode !== 'undefined') {
            try {
              // Generate real QR code using qrcode-generator library
              const qr = qrcode(0, 'M');
              qr.addData(currentURL);
              qr.make();
              
              // Create QR code as SVG with transparent background
              const svg = qr.createSvgTag({
                cellSize: 8,
                margin: 4,
                scalable: true,
                color: '#000000',
                background: 'transparent'
              });
              
              // Create container for the SVG
              const qrCodeContainer = document.createElement('div');
              qrCodeContainer.style.cssText = `
                width: 200px;
                height: 200px;
                background: #f6f4f1;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 10px;
              `;
              
              qrCodeContainer.innerHTML = svg;
              qrContainer.appendChild(qrCodeContainer);
              console.log('Real QR Code generated successfully');
            } catch (error) {
              console.error('QR Code generation failed:', error);
              this.createFallbackQRCode(qrContainer, currentURL);
            }
          } else {
            console.log('QR code library not available, using fallback');
            this.createFallbackQRCode(qrContainer, currentURL);
          }
        } else {
          console.error('QR container not found');
        }
      }
      
      createFallbackQRCode(container, url) {
        // Fallback to simple text display
        container.innerHTML = `
          <div style="
            width: 200px;
            height: 200px;
            background: #f6f4f1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            padding: 1rem;
          ">QR Code<br>${url}</div>
        `;
      }

      async initialize() {
        try {
          this.uiService.showScreen('screen-portal');
          
          await this.dataService.initialize();
          this.setupEventListeners();
          
          // Initialize new engine
          this.quiltEngine.initialize();
          
          // Clear all flip states to ensure quilt loads right side up
          this.renderer.clearAllFlipStates();
          
          console.log('üîç DEBUGGING: About to load quilt...');
          await this.loadQuilt();
          console.log('üîç DEBUGGING: Quilt loaded, blocks count:', this.quiltEngine.blocks.length);
          
          this.renderer.initialize();
          await this.renderQuilt();
          this.updateSquareCounter();
          
          // Initialize UI after portal is shown
          this.initializeUI();
          
          // Load quotes from Firestore
          // console.log('üîÑ About to load quotes from Firestore...');
          // console.log('üîÑ Firebase available:', !!window.firebaseApp);
          // console.log('üîÑ Firestore available:', !!window.firestore);
          // console.log('üîÑ DB available:', !!window.db);
          
          // Wait a bit for Firebase to be fully initialized
          // if (!window.db || !window.firestore) {
          //   console.log('üîÑ Waiting for Firebase to initialize...');
          //   await new Promise(resolve => setTimeout(resolve, 1000));
          // }
          
          // await this.quoteService.loadQuotesFromFirestore();
          console.log('üîÑ Using local storage only - Firebase disabled');
          
          this.setupAutoTransition();
          // this.setupDailyReset(); // DISABLED FOR LOCAL TESTING - prevents automatic resets
          
          // Don't set up flip handlers here - they'll be set up when quilt screen is shown
          
        } catch (error) {
          this.errorHandler.handleError(error, 'App initialization');
          this.uiService.showScreen('screen-portal');
        }
      }

      setupEventListeners() {
        // Navigation
        document.querySelectorAll(".btn[data-next]").forEach(btn => {
          btn.addEventListener("click", e => {
            e.preventDefault();
            const targetId = btn.getAttribute("data-next");
            if (targetId) this.uiService.showScreen(targetId);
          });
        });

        // Add color button
        const addColorBtn = document.getElementById('addColorBtn');
        if (addColorBtn) {
          addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
        }

        // Share button
        const shareBtnCompleted = document.getElementById('shareBtnCompleted');
        if (shareBtnCompleted) {
          shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
        }

        // Test buttons
        const showMyPieceBtn = document.getElementById('showMyPieceBtn');
        if (showMyPieceBtn) {
          showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
        }



        // Color picker
        this.setupColorPicker();

        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        
        // Window resize handler
        window.addEventListener('resize', this.handleWindowResize.bind(this));
        
        // Visual viewport resize handler
        if (window.visualViewport) {
          window.visualViewport.addEventListener('resize', this.handleWindowResize.bind(this));
        }
        
        // Floating admin button
        this.setupFloatingAdminButton();
        

        
        // Archive event handlers
        this.setupArchiveEventHandlers();
      }

      setupColorPicker() {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const valueSlider = document.getElementById('valueSlider');

        if (colorWheel) {
          colorWheel.addEventListener('mousedown', this.handleColorWheelMouseDown.bind(this));
          colorWheel.addEventListener('mousemove', this.handleColorWheelMouseMove.bind(this));
          colorWheel.addEventListener('mouseup', this.handleColorWheelMouseUp.bind(this));
          
          colorWheel.addEventListener('touchstart', this.handleColorWheelTouchStart.bind(this));
          colorWheel.addEventListener('touchmove', this.handleColorWheelTouchMove.bind(this));
          colorWheel.addEventListener('touchend', this.handleColorWheelTouchEnd.bind(this));
          
          colorWheel.addEventListener('keydown', this.handleColorWheelKeyDown.bind(this));
          colorWheel.addEventListener('click', this.handleColorWheelClick.bind(this));
        }

        if (valueSlider) {
          valueSlider.addEventListener('input', this.handleValueSliderChange.bind(this));
        }

        this.updateColorWheel();
      }

      handleColorWheelMouseDown(e) {
        e.preventDefault();
        this.isDragging = true;
        this.setHueFromCoords(e.clientX, e.clientY);
      }

      handleColorWheelMouseMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          this.setHueFromCoords(e.clientX, e.clientY);
        }
      }

      handleColorWheelMouseUp(e) {
        this.isDragging = false;
      }

      handleColorWheelClick(e) {
        e.preventDefault();
        this.setHueFromCoords(e.clientX, e.clientY);
        this.updateColorWheel();
      }

      handleColorWheelTouchStart(e) {
        e.preventDefault();
        this.isDragging = true;
        const touch = e.touches[0];
        this.setHueFromCoords(touch.clientX, touch.clientY);
      }

      handleColorWheelTouchMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          const touch = e.touches[0];
          this.setHueFromCoords(touch.clientX, touch.clientY);
        }
      }

      handleColorWheelTouchEnd(e) {
        this.isDragging = false;
      }

      handleColorWheelKeyDown(e) {
        const step = 15;
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            this.selectedHue = (this.selectedHue - step + 360) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.selectedHue = (this.selectedHue + step) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.selectedLightness = Math.min(90, this.selectedLightness + 5);
            this.updateColorWheel();
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.selectedLightness = Math.max(25, this.selectedLightness - 5);
            this.updateColorWheel();
            break;
        }
      }

      handleValueSliderChange(e) {
        this.selectedLightness = parseInt(e.target.value);
        this.updateColorWheel();
      }

      updateColorWheel() {
        const valueSlider = document.getElementById('valueSlider');
        
        const hslColor = `hsl(${this.selectedHue}, ${this.selectedSaturation}%, ${this.selectedLightness}%)`;
        const hexColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
        
        const colorScreen = document.getElementById('screen-color');
        if (colorScreen) {
          colorScreen.style.backgroundColor = hexColor;
        }
        
        if (valueSlider) {
          valueSlider.style.background = `linear-gradient(to right,
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 20%), 
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 90%))`;
        }
      }

      setHueFromCoords(x, y) {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = rect.width / 2;

        let angle = Math.atan2(dy, dx) * 180 / Math.PI;
        if (angle < 0) angle += 360;
        
        const rawHue = Math.round((angle + 90) % 360);
        this.selectedHue = (rawHue + 25) % 360;
        
        const baseSaturation = Math.min(100, (distance / radius) * 100);
        this.selectedSaturation = Math.min(Math.round(baseSaturation + 5), 100);

        if (distance > radius) {
          const clampedDistance = radius;
          const clampedX = centerX + (dx / distance) * clampedDistance;
          const clampedY = centerY + (dy / distance) * clampedDistance;
          this.selectedSaturation = 100;
          
          if (indicator) {
            const relativeX = clampedX - rect.left;
            const relativeY = clampedY - rect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        } else {
          if (indicator) {
            const relativeX = x - rect.left;
            const relativeY = y - rect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        }
        
        this.colorHasBeenSelected = true;
        this.updateColorWheel();
      }

      handleKeyDown(event) {
        if (event.key === 'Escape') {
          const currentScreen = document.querySelector('.screen.active');
          if (currentScreen) {
            const currentId = currentScreen.id;
            if (currentId === 'screen-quote') {
              this.uiService.showScreen('screen-portal');
            } else if (currentId === 'screen-color') {
              this.uiService.showScreen('screen-quote');
            } else if (currentId === 'screen-quilt') {
              this.uiService.showScreen('screen-color');
            }
          }
        }
      }

      handleWindowResize() {
        if (this.quiltEngine.blocks && this.quiltEngine.blocks.length > 0) {
          // Recalculate dimensions for new viewport size
          this.quiltEngine.recalculateDimensionsForCurrentViewport();
          this.renderQuilt();
        }
      }

      setupFloatingAdminButton() {
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          const isAdmin = this.isCurrentUserAdmin();
          console.log('üîß Admin check:', { userId: this.currentUserId, isAdmin });
          
          if (isAdmin) {
            adminBtn.style.display = 'flex';
            console.log('üîß Admin button shown');
            
            // Remove any existing listeners to prevent duplicates
            adminBtn.removeEventListener('click', this.handleAdminButtonClick);
            adminBtn.removeEventListener('touchstart', this.handleAdminButtonClick);
            
            // Add both click and touchstart for better mobile support
            this.handleAdminButtonClick = () => {
              console.log('üîß Admin button clicked/touched');
              this.showAdminMenu();
            };
            
            adminBtn.addEventListener('click', this.handleAdminButtonClick);
            adminBtn.addEventListener('touchstart', this.handleAdminButtonClick);
            
            // Ensure the button is clickable
            adminBtn.style.pointerEvents = 'auto';
            adminBtn.style.cursor = 'pointer';
            
          } else {
            adminBtn.style.display = 'none';
            console.log('üîß Admin button hidden');
          }
        } else {
          console.log('üîß Admin button element not found');
        }
      }



      setupArchiveEventHandlers() {
        // Archive Load More button
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        if (loadMoreBtn) {
          loadMoreBtn.addEventListener('click', () => {
            this.handleArchiveLoadMore();
          });
        }

        // Archive modal close handlers
        const modalClose = document.getElementById('archiveModalClose');
        const modalBackdrop = document.getElementById('archiveModalBackdrop');
        
        if (modalClose) {
          modalClose.addEventListener('click', () => {
            this.archiveService.closeArchiveModal();
          });
        }
        
        if (modalBackdrop) {
          modalBackdrop.addEventListener('click', () => {
            this.archiveService.closeArchiveModal();
          });
        }

        // Archive screen initialization
        document.addEventListener('screenChange', (e) => {
          if (e.detail.screenId === 'screen-archive') {
            this.initializeArchiveScreen();
          }
        });
      }

      async handleArchiveLoadMore() {
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        const loadingDiv = document.getElementById('archiveLoading');
        
        if (loadMoreBtn) loadMoreBtn.disabled = true;
        if (loadingDiv) loadingDiv.style.display = 'block';

        try {
          const result = await this.archiveService.loadMore();
          if (result && result.archives.length > 0) {
            // Append new posts to existing feed
            const container = document.getElementById('archiveFeed');
            if (container) {
              const newPostsHTML = result.archives
                .map(archive => this.archiveService.createArchivePostHTML(archive))
                .join('');
              
              container.insertAdjacentHTML('beforeend', newPostsHTML);
              this.archiveService.setupImageClickHandlers(container);
              this.archiveService.updateLoadMoreButton(result.hasMore);
            }
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'Load more archives');
        } finally {
          if (loadMoreBtn) loadMoreBtn.disabled = false;
          if (loadingDiv) loadingDiv.style.display = 'none';
        }
      }

      initializeArchiveScreen() {
        // Render the archive feed
        this.archiveService.renderArchiveFeed();
      }

      // Create archive snapshot from current quilt
      async createArchiveSnapshot() {
        // Use UTC to determine the date for this quilt
        const utcNow = new Date();
        const quiltDate = utcNow.toISOString().split('T')[0];
        const currentQuote = this.quoteService.getQuoteForDate(quiltDate);
        const blockCount = this.quiltEngine.blocks.length;
        
        this.logger.log(`üñºÔ∏è Generating thumbnail for ${blockCount} blocks...`);
        
        // Generate thumbnail and full quilt image
        const thumbnail = await this.archiveService.generateThumbnail();
        const fullQuiltImage = await this.archiveService.generateFullQuiltImage(this.quiltEngine.blocks);
        
        // Create archive entry
        const archiveEntry = this.archiveService.createArchiveEntry(
          quiltDate,
          { blocks: this.quiltEngine.blocks }, // Current quilt state
          currentQuote,
          Math.max(blockCount, 12) // Use actual block count or minimum 12
        );
        
        // Set the generated images
        archiveEntry.thumbnail = thumbnail;
        archiveEntry.fullQuiltImage = fullQuiltImage;
        
        // Add to archive
        await this.archiveService.addArchive(archiveEntry);
        
        // Note: Archive feed will be re-rendered when switching to archive screen
        
        this.logger.log(`‚úÖ Created archive snapshot for ${quiltDate} with ${blockCount} blocks and thumbnail`);
        return archiveEntry;
      }

      // Archive current quilt (renamed from createTestArchivePosts)
      async createTestArchivePosts() {
        this.logger.log('üì¶ Archiving current quilt as test...');
        
        try {
          // Check if there's a current quilt to archive
          if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length <= 1) {
            this.logger.warn('üì¶ No quilt to archive (only initial block or no blocks)');
            this.uiService.showToast('No quilt to archive - add some blocks first!');
            return;
          }
          
          // Create archive of current quilt
          const archiveEntry = await this.createArchiveSnapshot();
          
          this.logger.log(`‚úÖ Archived current quilt with ${this.quiltEngine.blocks.length} blocks`);
          this.uiService.showToast(`Current quilt archived with ${this.quiltEngine.blocks.length} blocks!`);
          
          // Show the archived quilt immediately
          this.uiService.showToast(`Current quilt archived with ${this.quiltEngine.blocks.length} blocks! Now showing archive...`);
          
          // Force refresh the archive cache to include the new archive
          await this.archiveService.loadArchivesFromFirestore();
          
          // Switch to archive screen (renderArchiveFeed will be called by initializeArchiveScreen)
          await this.uiService.showScreen('screen-archive');
          
          // Scroll to the top to show the newest archive
          const archiveContainer = document.querySelector('.archive-feed');
          if (archiveContainer) {
            archiveContainer.scrollTop = 0;
          }
          
        } catch (error) {
          this.logger.error('‚ùå Failed to archive current quilt:', error);
          this.uiService.showToast('Failed to archive current quilt');
        }
      }

      // Manual archive trigger for testing
      async triggerManualArchive() {
        this.logger.log('üîß Manual archive triggered for testing...');
        try {
          const result = await this.performDailyArchive();
          this.logger.log(`üîß Manual archive result: ${result ? 'SUCCESS' : 'FAILED'}`);
          return result;
        } catch (error) {
          this.logger.error('üîß Manual archive error:', error);
          return false;
        }
      }

      isCurrentUserAdmin() {
        const currentUserId = this.currentUserId;
        const isAdminFlag = localStorage.getItem('ourDailyIsAdmin') === 'true';
        
        // Check if admin flag is set (you can enable this via console)
        if (isAdminFlag) {
          return true;
        }
        
        // For development/testing, enable admin mode by default
        return true;
      }

      enableAdminMode() {
        localStorage.setItem('ourDailyIsAdmin', 'true');
        this.uiService.showToast('Admin mode enabled');
        this.setupFloatingAdminButton();
      }

      disableAdminMode() {
        if (!confirm('Are you sure you want to disable admin mode? You can re-enable it with enableAdmin().')) {
          return;
        }
        
        localStorage.removeItem('ourDailyIsAdmin');
        this.uiService.showToast('Admin mode disabled');
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          adminBtn.style.display = 'none';
        }
      }

      // Secret function to enable admin mode - call from console: app.enableAdminSecret()
      enableAdminSecret() {
        localStorage.setItem('ourDailyIsAdmin', 'true');
        this.uiService.showToast('üîß Admin mode enabled!');
        this.setupFloatingAdminButton();
        console.log('üîß Admin mode enabled. You can now access admin controls.');
      }

      // Reveal image management functions
      async loadRevealImageOptions() {
        try {
          // Enable Firebase for image storage
          await this.initializeFirebaseForImages();
          
          const optionsContainer = document.getElementById('revealImageOptions');
          if (!optionsContainer) return;
          
          // Check if Firebase is available
          if (!window.firebaseApp || !window.firebaseStorage) {
            optionsContainer.innerHTML = '<p>Firebase not available. Please try again.</p>';
            return;
          }
          
          // Load images from Firebase Storage
          const { ref, listAll, getDownloadURL } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const storage = window.firebaseStorage;
          
          // Try to get images from quilt-reveals folder
          const revealsRef = ref(storage, 'quilt-reveals');
          const result = await listAll(revealsRef);
          
          if (result.items.length === 0) {
            optionsContainer.innerHTML = '<p>No reveal images found. Upload one to get started!</p>';
            return;
          }
          
          // Build HTML for image options
          let optionsHTML = '';
          
          for (let i = 0; i < result.items.length; i++) {
            const item = result.items[i];
            const downloadURL = await getDownloadURL(item);
            const imageId = `revealImage${i}`;
            
            optionsHTML += `
              <div class="image-option" style="margin: 10px 0; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                <input type="radio" name="revealImage" value="${downloadURL}" id="${imageId}">
                <label for="${imageId}" style="display: flex; align-items: center; gap: 10px;">
                  <img src="${downloadURL}" alt="Reveal Image ${i + 1}" style="width: 60px; height: 60px; object-fit: cover; border-radius: 4px;">
                  <span>${item.name}</span>
                </label>
              </div>
            `;
          }
          
          optionsHTML += '<button onclick="app.handleSelectRevealImage()" style="margin-top: 10px;">Apply Selected Image</button>';
          
          optionsContainer.innerHTML = optionsHTML;
          
        } catch (error) {
          console.error('Error loading reveal image options:', error);
          const optionsContainer = document.getElementById('revealImageOptions');
          if (optionsContainer) {
            optionsContainer.innerHTML = '<p>Error loading images. Please try again.</p>';
          }
        }
      }

      async initializeFirebaseForImages() {
        // Only initialize Firebase if not already done
        if (window.firebaseApp && window.firebaseStorage && window.firebaseAuth) {
          console.log('üî• Firebase already initialized');
          return window.firebaseApp;
        }
        
        try {
          console.log('üî• Initializing Firebase for images...');
          console.log('üî• CONFIG.FIREBASE exists:', !!CONFIG.FIREBASE);
          console.log('üî• CONFIG.FIREBASE keys:', Object.keys(CONFIG.FIREBASE || {}));
          
          const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
          const { getStorage } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const { getAuth, signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
          
          console.log('üî• Firebase config:', CONFIG.FIREBASE);
          const firebaseApp = initializeApp(CONFIG.FIREBASE);
          const storage = getStorage(firebaseApp);
          const auth = getAuth(firebaseApp);
          
          // Sign in anonymously to enable uploads
          try {
            const authResult = await signInAnonymously(auth);
            console.log('üî• Anonymous authentication successful:', authResult.user.uid);
            console.log('üî• User is authenticated:', auth.currentUser !== null);
            
            // Wait a moment for auth to fully propagate
            await new Promise(resolve => setTimeout(resolve, 1000));
            
          } catch (authError) {
            console.log('üî• Anonymous auth failed:', authError);
            // Try to continue anyway
          }
          
          window.firebaseApp = firebaseApp;
          window.firebaseStorage = storage;
          window.firebaseAuth = auth;
          
          console.log('üî• Firebase initialized successfully');
          console.log('üî• window.firebaseApp set:', !!window.firebaseApp);
          console.log('üî• window.firebaseStorage set:', !!window.firebaseStorage);
          console.log('üî• window.firebaseAuth set:', !!window.firebaseAuth);
          console.log('üî• Storage instance:', storage);
          return firebaseApp;
        } catch (error) {
          console.error('Failed to initialize Firebase for images:', error);
          throw error;
        }
      }

      async handleUploadRevealImage() {
        const fileInput = document.getElementById('revealImageUpload');
        const file = fileInput?.files[0];
        
        if (!file) {
          alert('Please select an image file first.');
          return;
        }
        
        try {
          await this.initializeFirebaseForImages();
          
          // Show loading message
          const uploadButton = document.querySelector('button[onclick="app.handleUploadRevealImage()"]');
          const originalText = uploadButton.textContent;
          uploadButton.textContent = 'Resizing & Uploading...';
          uploadButton.disabled = true;
          
          // Resize image to quilt dimensions (412 x 800)
          const resizedImageBlob = await this.resizeImageToQuiltDimensions(file);
          
          // Check authentication status before upload
          if (!window.firebaseAuth) {
            console.log('üî• Firebase Auth not initialized, trying to initialize...');
            await this.initializeFirebaseForImages();
          }
          
          const auth = window.firebaseAuth;
          console.log('üî• Auth status before upload:', {
            currentUser: auth?.currentUser,
            isAuthenticated: auth?.currentUser !== null,
            uid: auth?.currentUser?.uid
          });
          
          // Upload to Firebase Storage
          const { ref, uploadBytes, getDownloadURL } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const storage = window.firebaseStorage;
          
          // Create unique filename with timestamp
          const timestamp = Date.now();
          const filename = `quilt-reveal-${timestamp}.png`;
          const imageRef = ref(storage, `quilt-reveals/${filename}`);
          
          // Upload the resized image
          let downloadURL;
          try {
            await uploadBytes(imageRef, resizedImageBlob);
            downloadURL = await getDownloadURL(imageRef);
          } catch (uploadError) {
            console.error('Upload failed:', uploadError);
            
            // If upload fails due to permissions, show helpful message
            if (uploadError.code === 'storage/unauthorized') {
              console.log('üî• Upload failed - checking auth status...');
              console.log('üî• Auth object:', window.firebaseAuth);
              console.log('üî• Current user:', window.firebaseAuth?.currentUser);
              
              this.uiService.showToast('‚ùå Upload failed: Authentication issue. Please check Firebase Console settings.');
              throw new Error('Firebase authentication issue. Please enable Anonymous Authentication in Firebase Console.');
            }
            
            throw uploadError;
          }
          
          // Store image info
          const imageInfo = {
            name: filename,
            url: downloadURL,
            uploadedAt: timestamp
          };
          
          // Add to available images
          if (!this.availableRevealImages) {
            this.availableRevealImages = [];
          }
          this.availableRevealImages.push(imageInfo);
          
          // Refresh the image options display
          this.loadRevealImageOptions();
          
          // Clear the file input
          fileInput.value = '';
          
          // Reset button
          uploadButton.textContent = originalText;
          uploadButton.disabled = false;
          
          this.uiService.showToast('‚úÖ Image uploaded and resized successfully!');
          console.log('Image uploaded:', imageInfo);
          
        } catch (error) {
          console.error('Error uploading image:', error);
          this.uiService.showToast('‚ùå Error uploading image. Please try again.');
          
          // Reset button on error
          const uploadButton = document.querySelector('button[onclick="app.handleUploadRevealImage()"]');
          if (uploadButton) {
            uploadButton.textContent = 'Upload Image';
            uploadButton.disabled = false;
          }
        }
      }

      async resizeImageToQuiltDimensions(file) {
        return new Promise((resolve, reject) => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();
          
          // Set target dimensions (quilt size)
          const targetWidth = 412;
          const targetHeight = 800;
          
          img.onload = () => {
            try {
              // Set canvas size to target dimensions
              canvas.width = targetWidth;
              canvas.height = targetHeight;
              
              // Calculate scaling to fill the entire target area (crop approach)
              const imageAspect = img.width / img.height;
              const targetAspect = targetWidth / targetHeight;
              
              let sourceX, sourceY, sourceWidth, sourceHeight;
              
              if (imageAspect > targetAspect) {
                // Image is wider than target - scale to height and crop width
                const scaledWidth = img.height * targetAspect;
                sourceWidth = scaledWidth;
                sourceHeight = img.height;
                sourceX = (img.width - scaledWidth) / 2; // Center crop
                sourceY = 0;
              } else {
                // Image is taller than target - scale to width and crop height
                const scaledHeight = img.width / targetAspect;
                sourceWidth = img.width;
                sourceHeight = scaledHeight;
                sourceX = 0;
                sourceY = (img.height - scaledHeight) / 2; // Center crop
              }
              
              // Draw the cropped portion of the image to fill the entire canvas
              ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
              
              // Convert to blob
              canvas.toBlob((blob) => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error('Failed to create image blob'));
                }
              }, 'image/png', 0.9);
              
            } catch (error) {
              reject(error);
            }
          };
          
          img.onerror = () => {
            reject(new Error('Failed to load image for resizing'));
          };
          
          // Load image from file
          const reader = new FileReader();
          reader.onload = (e) => {
            img.src = e.target.result;
          };
          reader.onerror = () => {
            reject(new Error('Failed to read image file'));
          };
          reader.readAsDataURL(file);
        });
      }

      async handleSelectRevealImage() {
        const selectedImageURL = document.querySelector('input[name="revealImage"]:checked')?.value;
        
        if (!selectedImageURL) {
          alert('Please select an image first.');
          return;
        }
        
        try {
          // Create image info object
          const imageInfo = {
            name: 'Selected Reveal Image',
            url: selectedImageURL
          };
          
          // Store the selected image preference
          localStorage.setItem('selectedRevealImage', selectedImageURL);
          
          // Apply the image to the quilt
          await this.applyImageToQuilt(imageInfo);
          
          this.uiService.showToast('‚úÖ Reveal image applied successfully!');
          
        } catch (error) {
          console.error('Error applying reveal image:', error);
          this.uiService.showToast('‚ùå Error applying image. Please try again.');
        }
      }

      async applyRevealImageToQuilt(imageName) {
        console.log('Applying reveal image:', imageName);
        
        // Store the selection
        this.currentRevealImage = imageName;
        
        // Apply image to flipped blocks
        await this.applyImageToQuilt(this.currentRevealImage);
      }

      async loadRandomRevealImage() {
        try {
          // Always try to initialize Firebase first
          console.log('üî• Attempting to initialize Firebase...');
          await this.initializeFirebaseForImages();
          
          // Check if Firebase is available after initialization
          if (!window.firebaseApp || !window.firebaseStorage) {
            console.log('Firebase still not available after initialization, using fallback images');
            return this.loadFallbackImages();
          }
          
          await this.initializeFirebaseForImages();
          
          // Get list of images from Firebase Storage
          const { ref, listAll, getDownloadURL, getBlob } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const storage = window.firebaseStorage;
          
          // Try different possible folder names
          const possibleFolders = ['quilt-reveals', 'quilt reveals', 'quiltreveals', 'reveals', 'images'];
          let result = null;
          let folderName = null;
          
          for (const folder of possibleFolders) {
            try {
              console.log(`üñºÔ∏è Trying Firebase folder: "${folder}"`);
              const revealsRef = ref(storage, folder);
              result = await listAll(revealsRef);
              if (result.items.length > 0) {
                folderName = folder;
                console.log(`‚úÖ Found ${result.items.length} images in Firebase folder: "${folder}"`);
                break;
              } else {
                console.log(`üìÅ Folder "${folder}" exists but is empty`);
              }
            } catch (error) {
              console.log(`‚ùå Folder "${folder}" not found:`, error.message);
            }
          }
          
          if (!result || result.items.length === 0) {
            console.log('No images found in Firebase, using fallback images');
            return this.loadFallbackImages();
          }
          
          // Randomly select an image
          const randomIndex = Math.floor(Math.random() * result.items.length);
          const selectedImageRef = result.items[randomIndex];
          
          // Try to get the image URL (may fail due to CORS when running locally)
          console.log('üñºÔ∏è Getting Firebase image URL...');
          let imageUrl;
          let blob = null;
          
          try {
            // Try blob first (better for CORS)
            blob = await getBlob(selectedImageRef);
            imageUrl = URL.createObjectURL(blob);
            console.log('üé≤ Randomly selected Firebase image:', selectedImageRef.name, 'blob URL created');
          } catch (blobError) {
            console.log('üîÑ Blob failed, trying direct URL:', blobError.message);
            try {
              // Fallback to direct URL
              imageUrl = await getDownloadURL(selectedImageRef);
              console.log('üé≤ Randomly selected Firebase image:', selectedImageRef.name, 'direct URL created');
            } catch (urlError) {
              console.log('‚ùå Both blob and direct URL failed:', urlError.message);
              if (urlError.message.includes('CORS') || urlError.message.includes('Access-Control-Allow-Origin')) {
                console.log('üîÑ CORS issue detected - this is normal when running locally');
                console.log('üí° Firebase images will work when deployed to a proper server');
                throw new Error('CORS blocked Firebase image (normal when running locally)');
              } else {
                throw new Error('Could not load Firebase image: ' + urlError.message);
              }
            }
          }
          
          // Store the selected image info
          this.currentRevealImage = {
            name: selectedImageRef.name,
            url: imageUrl,
            blob: blob // Keep reference to clean up later
          };
          
          console.log('üñºÔ∏è Stored currentRevealImage:', this.currentRevealImage);
          
          // Apply the image to the quilt
          await this.applyImageToQuilt(this.currentRevealImage);
          
          return this.currentRevealImage;
          
        } catch (error) {
          console.error('Error loading Firebase image:', error);
          console.log('Firebase image loading failed - no fallback');
          throw error; // Don't fall back, let the error propagate
        }
      }

      async loadFallbackImages() {
        // Use CORS-friendly test images as fallback
        const testImages = [
          {
            name: 'sunset-gradient',
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0ic3Vuc2V0IiBjeD0iNDAwIiBjeT0iMzAwIiByPSI0MDAiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojZmY2YjZiO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjUwJSIgc3R5bGU9InN0b3AtY29sb3I6I2ZmYzc0O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmZmViM2I7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI3N1bnNldCkiIC8+CiAgPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkRhaWx5IFN1bnNldDwvdGV4dD4KPC9zdmc+Cg=='
          },
          {
            name: 'ocean-waves', 
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0ib2NlYW4iIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojNGVjZGM0O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjUwJSIgc3R5bGU9InN0b3AtY29sb3I6IzAwNzNhYTtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMDA0ZGRkO3N0b3Atb3BhY2l0eToxIiAvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICA8L2RlZnM+CiAgPHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNvY2VhbikiIC8+CiAgPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPk9jZWFuIFdhdmVzPC90ZXh0Pgo8L3N2Zz4K'
          },
          {
            name: 'forest-greens',
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZm9yZXN0IiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzJkNzQzNDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSI1MCUiIHN0eWxlPSJzdG9wLWNvbG9yOjM4YTg1MzN0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOjQyYjY4MmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2ZvcmVzdCkiIC8+CiAgPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkZvcmVzdCBHcmVlbnM8L3RleHQ+Cjwvc3ZnPgo='
          }
        ];
        
        // Randomly select a test image
        const randomIndex = Math.floor(Math.random() * testImages.length);
        const selectedImage = testImages[randomIndex];
        
        console.log('üé≤ Randomly selected fallback image:', selectedImage.name);
        
        // Store the selected image info
        this.currentRevealImage = selectedImage;
        
        // Apply the image to the quilt
        await this.applyImageToQuilt(this.currentRevealImage);
        
        return this.currentRevealImage;
      }

      async forceLoadFirebaseImage() {
        console.log('üî• Force loading Firebase image...');
        try {
          const result = await this.loadRandomRevealImage();
          if (result) {
            this.uiService.showToast('‚úÖ Firebase image loaded successfully!');
          } else {
            this.uiService.showToast('‚ùå Failed to load Firebase image');
          }
        } catch (error) {
          console.error('Error force loading Firebase image:', error);
          this.uiService.showToast('‚ùå Error loading Firebase image');
        }
      }

      async applyImageToQuilt(imageInfo) {
        // console.log('üñºÔ∏è applyImageToQuilt called with:', imageInfo);
        
        if (!imageInfo) {
          console.log('‚ùå No imageInfo provided');
          return;
        }
        
        if (!imageInfo.url) {
          console.log('‚ùå No imageInfo.url provided');
          return;
        }
        
        // console.log('üñºÔ∏è Image URL type:', typeof imageInfo.url);
        // console.log('üñºÔ∏è Image URL value:', imageInfo.url);
        
        console.log('Applying image to quilt:', imageInfo.name);
        
        // Create image pattern for the quilt
        await this.createImagePattern(imageInfo);
        
        // Apply to flipped blocks
        this.applyImageToFlippedBlocks(imageInfo);
      }

      async createImagePattern(imageInfo) {
        // console.log('üñºÔ∏è Creating image pattern for:', imageInfo.name);
        
        // Create a canvas to load and process the image
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        return new Promise((resolve, reject) => {
          img.onload = () => {
            console.log('üñºÔ∏è Image loaded, dimensions:', img.width, 'x', img.height);
            
            // Get quilt dimensions
            const blocks = this.quiltEngine.blocks;
            if (blocks.length === 0) {
              reject('No blocks in quilt');
              return;
            }
            
            const minX = Math.min(...blocks.map(b => b.x));
            const minY = Math.min(...blocks.map(b => b.y));
            const maxX = Math.max(...blocks.map(b => b.x + b.width));
            const maxY = Math.max(...blocks.map(b => b.y + b.height));
            const quiltWidth = maxX - minX;
            const quiltHeight = maxY - minY;
            
            console.log('üñºÔ∏è Quilt dimensions:', quiltWidth, 'x', quiltHeight);
            
            // Scale the image to fit the quilt while maintaining aspect ratio
            const imageAspect = img.width / img.height;
            const quiltAspect = quiltWidth / quiltHeight;
            
            let scaledWidth, scaledHeight, offsetX, offsetY;
            
            if (imageAspect > quiltAspect) {
              // Image is wider than quilt - fit to width
              scaledWidth = quiltWidth;
              scaledHeight = quiltWidth / imageAspect;
              offsetX = 0;
              offsetY = (quiltHeight - scaledHeight) / 2;
            } else {
              // Image is taller than quilt - fit to height
              scaledWidth = quiltHeight * imageAspect;
              scaledHeight = quiltHeight;
              offsetX = (quiltWidth - scaledWidth) / 2;
              offsetY = 0;
            }
            
            // Set canvas size to match quilt dimensions
            canvas.width = quiltWidth;
            canvas.height = quiltHeight;
            
            // Draw the scaled image centered in the quilt area
            ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // Convert to data URL for SVG pattern
            const imageDataUrl = canvas.toDataURL('image/png');
            
            // Store the processed image data
            this.processedImageData = {
              dataUrl: imageDataUrl,
              quiltWidth: quiltWidth,
              quiltHeight: quiltHeight,
              minX: minX,
              minY: minY,
              imageWidth: scaledWidth,  // Use actual scaled image dimensions
              imageHeight: scaledHeight, // Use actual scaled image dimensions
              offsetX: offsetX,         // Store offset for positioning
              offsetY: offsetY          // Store offset for positioning
            };
            
            console.log('‚úÖ Image pattern created for quilt, data URL length:', imageDataUrl.length);
            resolve();
          };
          
          img.onerror = (error) => {
            console.error('üñºÔ∏è Failed to load image:', error);
            reject('Failed to load image');
          };
          
          // Ensure we have a valid URL
          if (!imageInfo.url || typeof imageInfo.url !== 'string') {
            console.error('Invalid image URL:', imageInfo.url);
            reject('Invalid image URL');
            return;
          }
          
          // Handle CORS for Firebase images
          if (imageInfo.url.includes('firebasestorage.googleapis.com')) {
            // console.log('üñºÔ∏è Loading Firebase image with CORS handling');
            img.crossOrigin = 'anonymous';
            
            // Try to load with credentials
            img.crossOrigin = 'use-credentials';
            
            // Add error handler for CORS issues
            img.onerror = (error) => {
                      // console.log('üñºÔ∏è CORS error loading Firebase image, trying alternative method');
        // console.log('üñºÔ∏è Error details:', error);
              
              // Try without crossOrigin as fallback
              img.crossOrigin = null;
              img.src = imageInfo.url;
            };
          } else {
            // console.log('üñºÔ∏è Loading local/SVG image');
          }
          
          // console.log('üñºÔ∏è Loading image from URL:', imageInfo.url);
          
          // Add timeout for Firebase images to handle CORS issues
          if (imageInfo.url.includes('firebasestorage.googleapis.com')) {
            const timeout = setTimeout(() => {
              // console.log('üñºÔ∏è Timeout loading Firebase image, likely CORS issue');
              img.onerror = null; // Remove error handler to prevent double handling
              reject(new Error('Timeout loading Firebase image (CORS issue)'));
            }, 5000); // 5 second timeout
            
            img.onload = () => {
              clearTimeout(timeout);
              resolve();
            };
            
            img.onerror = (error) => {
              clearTimeout(timeout);
              console.log('üñºÔ∏è CORS error loading Firebase image, falling back to test image');
              console.log('üñºÔ∏è Error details:', error);
              reject(new Error('CORS blocked Firebase image'));
            };
          }
          
          img.src = imageInfo.url;
        });
      }

      applyImageToFlippedBlocks(imageInfo) {
        if (!this.processedImageData) {
          // console.log('No processed image data available');
          return;
        }
        
        const flippedBlocks = this.renderer.getFlippedBlocks();
        
        if (flippedBlocks.length === 0) {
          // console.log('No flipped blocks to apply image to');
          return;
        }
        
        // console.log(`Applying image pieces to ${flippedBlocks.length} flipped blocks`);
        
        // Apply individual image pieces to each flipped block
        flippedBlocks.forEach(blockId => {
          const block = this.quiltEngine.blocks.find(b => b.id === blockId);
          if (block && this.processedImageData) {
            // Calculate the portion of the image that should be shown for this block
            // Normalize block coordinates from quilt space to image space, accounting for image offset
            const minX = this.quiltBounds ? this.quiltBounds.minX : 0;
            const minY = this.quiltBounds ? this.quiltBounds.minY : 0;
            
            // Calculate block position relative to the scaled image (accounting for centering offset)
            const blockRelativeX = block.x - minX - (this.processedImageData.offsetX || 0);
            const blockRelativeY = block.y - minY - (this.processedImageData.offsetY || 0);
            
            // Convert to image coordinates
            const imageX = (blockRelativeX / this.processedImageData.quiltWidth) * this.processedImageData.imageWidth;
            const imageY = (blockRelativeY / this.processedImageData.quiltHeight) * this.processedImageData.imageHeight;
            const imageWidth = (block.width / this.processedImageData.quiltWidth) * this.processedImageData.imageWidth;
            const imageHeight = (block.height / this.processedImageData.quiltHeight) * this.processedImageData.imageHeight;
            
            const patternId = `pattern-${blockId}`;
            this.createBlockImagePattern(patternId, this.processedImageData.dataUrl, imageX, imageY, imageWidth, imageHeight);
            
            const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
            if (blockElement) {
              blockElement.setAttribute('fill', `url(#${patternId})`);
              blockElement.style.setProperty('fill', `url(#${patternId})`, 'important');
              blockElement.style.setProperty('stroke', 'none', 'important');
              blockElement.style.setProperty('opacity', '1', 'important');
              console.log(`Applied image piece to block ${blockId} at ${imageX},${imageY} size ${imageWidth}x${imageHeight}`);
            } else {
              console.log(`‚ùå Block element not found for ${blockId}`);
            }
          }
        });
      }

      createQuiltImagePattern(patternId, imageDataUrl) {
        console.log('üñºÔ∏è Creating quilt image pattern:', patternId);
        
        // Remove existing pattern if it exists
        const existingPattern = document.getElementById(patternId);
        if (existingPattern) {
          existingPattern.remove();
        }
        
        // Create new pattern
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', patternId);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('x', -this.processedImageData.minX);
        pattern.setAttribute('y', -this.processedImageData.minY);
        pattern.setAttribute('width', this.processedImageData.quiltWidth);
        pattern.setAttribute('height', this.processedImageData.quiltHeight);
        
        // Add image to pattern
        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        image.setAttribute('href', imageDataUrl);
        image.setAttribute('width', this.processedImageData.quiltWidth);
        image.setAttribute('height', this.processedImageData.quiltHeight);
        image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
        
        pattern.appendChild(image);
        
        // Add to SVG defs - ensure defs exists
        let defs = document.querySelector('#quilt defs');
        if (!defs) {
          defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          const quilt = document.querySelector('#quilt');
          quilt.insertBefore(defs, quilt.firstChild);
        }
        defs.appendChild(pattern);
        
        console.log('‚úÖ Quilt image pattern created and added to defs:', patternId);
      }

      createBlockImagePattern(patternId, imageDataUrl, x, y, width, height) {
                    console.log('üñºÔ∏è Creating pattern:', patternId, 'for block at', x, y, 'size', width, height);
        
        // Remove existing pattern if it exists
        const existingPattern = document.getElementById(patternId);
        if (existingPattern) {
          existingPattern.remove();
        }
        
        // Create new pattern
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', patternId);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('x', 0);
        pattern.setAttribute('y', 0);
        pattern.setAttribute('width', width);
        pattern.setAttribute('height', height);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('patternContentUnits', 'userSpaceOnUse');
        
        // Add image to pattern - positioned to show only the relevant portion
        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        image.setAttribute('href', imageDataUrl);
        image.setAttribute('width', this.processedImageData.imageWidth);
        image.setAttribute('height', this.processedImageData.imageHeight);
        image.setAttribute('x', -x);
        image.setAttribute('y', -y);
        image.setAttribute('preserveAspectRatio', 'none');
        image.setAttribute('style', 'shape-rendering: crispEdges; image-rendering: pixelated;');
        
        pattern.appendChild(image);
        
        // Add to SVG defs - ensure defs exists
        let defs = document.querySelector('#quilt defs');
        if (!defs) {
          defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          const quilt = document.querySelector('#quilt');
          quilt.insertBefore(defs, quilt.firstChild);
        }
        defs.appendChild(pattern);
        
        console.log('‚úÖ Pattern created and added to defs:', patternId);
      }

      applyColorToFlippedBlocks(imageName) {
        // Get all blocks that are currently flipped
        const flippedBlocks = this.renderer.getFlippedBlocks();
        
        if (flippedBlocks.length === 0) {
          console.log('No flipped blocks to apply color to');
          return;
        }
        
        const color = imageName === 'image1' ? '#ff6b6b' : '#4ecdc4'; // Red or teal
        console.log(`Applying color ${color} to ${flippedBlocks.length} flipped blocks`);
        
        // Apply the color directly to all flipped blocks
        flippedBlocks.forEach(blockId => {
          const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
          if (blockElement) {
            blockElement.setAttribute('fill', color);
            blockElement.style.setProperty('fill', color, 'important');
            console.log(`Applied color ${color} to block ${blockId}`);
          }
        });
      }

      applyPatternToFlippedBlocks(patternId) {
        // Get all blocks that are currently flipped
        const flippedBlocks = this.renderer.getFlippedBlocks();
        
        if (flippedBlocks.length === 0) {
          console.log('No flipped blocks to apply pattern to');
          return;
        }
        
        console.log(`Applying pattern to ${flippedBlocks.length} flipped blocks`);
        
        // Apply the SVG pattern to all flipped blocks
        flippedBlocks.forEach(blockId => {
          const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
          if (blockElement) {
            const patternUrl = `url(#pattern-${patternId})`;
            blockElement.setAttribute('fill', patternUrl);
            blockElement.style.setProperty('fill', patternUrl, 'important');
            console.log(`Applied pattern to block ${blockId}`);
          }
        });
      }

      createColorPattern(patternId) {
        const quiltSVG = document.getElementById('quilt');
        if (!quiltSVG) {
          console.error('Quilt SVG not found');
          return;
        }
        
        console.log('Creating color pattern for:', patternId);
        
        // Remove existing pattern if it exists
        const existingPattern = quiltSVG.querySelector(`#pattern-${patternId}`);
        if (existingPattern) {
          existingPattern.remove();
          console.log('Removed existing pattern');
        }
        
        // Create defs if it doesn't exist
        let defs = quiltSVG.querySelector('defs');
        if (!defs) {
          defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          quiltSVG.insertBefore(defs, quiltSVG.firstChild);
          console.log('Created defs element');
        }
        
        // Create pattern with a solid color
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', `pattern-${patternId}`);
        pattern.setAttribute('patternUnits', 'objectBoundingBox');
        pattern.setAttribute('width', '1');
        pattern.setAttribute('height', '1');
        
        // Create a rect with the color
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('width', '100%');
        rect.setAttribute('height', '100%');
        rect.setAttribute('fill', patternId === 'image1' ? '#ff6b6b' : '#4ecdc4'); // Red or teal
        
        pattern.appendChild(rect);
        defs.appendChild(pattern);
        
        console.log(`Created color pattern: pattern-${patternId}`);
        console.log('Pattern element:', pattern);
      }

      // OLD createImagePattern function removed - using new async version instead

      // OLD applyImageToFlippedBlocks function removed - using new version instead

      // Debug function to test admin button - call from console: app.debugAdminButton()
      debugAdminButton() {
        const adminBtn = document.getElementById('floatingAdminBtn');
        console.log('üîß Admin button debug:', {
          element: adminBtn,
          display: adminBtn ? adminBtn.style.display : 'not found',
          isAdmin: this.isCurrentUserAdmin(),
          hasClickListeners: adminBtn ? adminBtn.onclick : 'no element',
          pointerEvents: adminBtn ? adminBtn.style.pointerEvents : 'no element'
        });
        
        if (adminBtn) {
          // Force re-setup
          this.setupFloatingAdminButton();
          console.log('üîß Admin button re-setup complete');
        }
      }

      // Check for secret admin access via URL parameter
      checkSecretAdminAccess() {
        const urlParams = new URLSearchParams(window.location.search);
        const secretAdmin = urlParams.get('admin');
        
        if (secretAdmin === 'zak2024') {
          localStorage.setItem('ourDailyIsAdmin', 'true');
          this.uiService.showToast('üîß Admin mode enabled via URL!');
          console.log('üîß Admin mode enabled via secret URL parameter');
          
          // Remove the parameter from URL without reloading
          const newUrl = window.location.pathname;
          window.history.replaceState({}, document.title, newUrl);
        }
      }

      // Quote Management Functions
      showQuoteManager() {
        // Check if a quote manager modal is already open
        const existingModal = document.querySelector('.quote-manager-modal');
        if (existingModal) {
          console.log('‚ö†Ô∏è Quote manager modal already open, removing existing one');
          existingModal.remove();
        }
        
        // Get next 7 days of quotes
        const next7Days = this.getNext7DaysQuotes();
        let quotesHTML = '';
        
        next7Days.forEach((dayData, index) => {
          const { date, quote, dayName } = dayData;
          quotesHTML += `
            <div class="quote-day-item" data-index="${dayData.originalIndex}">
              <div class="day-header">
                <span class="day-name">${dayName}</span>
                <span class="day-date">${date}</span>
              </div>
              <div class="quote-content">
                <div class="quote-text">"${quote.text}"</div>
                <div class="quote-author">‚Äî ${quote.author}</div>
              </div>
              <div class="quote-actions">
                <button onclick="app.editQuoteForDay(${index})" class="edit-btn">Edit</button>
                <button onclick="app.deleteQuoteForDay(${index})" class="delete-btn">Delete</button>
                <button onclick="app.swapWithPrevious(${index})" class="swap-btn" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                <button onclick="app.swapWithNext(${index})" class="swap-btn" ${index === 6 ? 'disabled' : ''}>‚Üì</button>
              </div>
            </div>
          `;
        });
        
        const modal = document.createElement('div');
        modal.className = 'quote-manager-modal';
        modal.innerHTML = `
          <div class="quote-manager-content">
            <h3>Next 7 Days Quotes</h3>
            <div class="quote-list">
              ${quotesHTML}
            </div>
            <div class="quote-manager-actions">
              <button onclick="app.saveQuotesToFirestore()" class="save-btn">Save Changes</button>
              <button onclick="this.parentElement.parentElement.parentElement.remove()" class="close-btn">Close</button>
            </div>
          </div>
        `;
        
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          z-index: 1002;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 20px;
        `;
        
        const content = modal.querySelector('.quote-manager-content');
        content.style.cssText = `
          background: white;
          border-radius: 8px;
          padding: 20px;
          max-width: 600px;
          max-height: 80vh;
          overflow-y: auto;
          width: 100%;
        `;
        
        document.body.appendChild(modal);
        
        // Add CSS for quote items
        const style = document.createElement('style');
        style.textContent = `
          .quote-day-item {
            border: 1px solid #ddd;
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            background: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          }
          .day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
          }
          .day-name {
            font-weight: bold;
            color: #333;
            font-size: 16px;
          }
          .day-date {
            color: #666;
            font-size: 14px;
            background: #e0e0e0;
            padding: 2px 8px;
            border-radius: 12px;
          }
          .quote-content {
            margin-bottom: 10px;
          }
          .quote-text {
            font-style: italic;
            margin-bottom: 5px;
            font-size: 14px;
            line-height: 1.4;
          }
          .quote-author {
            font-weight: bold;
            color: #666;
            font-size: 12px;
          }
          .quote-actions {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
          }
          .quote-actions button {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #ccc;
            background: white;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
          }
          .quote-actions button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
          }
          .quote-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
          }
          .edit-btn { color: #0066cc; }
          .delete-btn { color: #cc0000; }
          .swap-btn { color: #666; }
          .save-btn { background: #2196F3; color: white; padding: 8px 16px; }
          .close-btn { background: #666; color: white; padding: 8px 16px; }
          .quote-manager-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
          }
          .subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
          }
        `;
        document.head.appendChild(style);
      }

      editQuote(index) {
        const quote = this.quoteService.quotes[index];
        const newText = prompt('Edit quote text:', quote.text);
        if (newText !== null) {
          const newAuthor = prompt('Edit author:', quote.author.replace('‚Äî ', ''));
          if (newAuthor !== null) {
            this.quoteService.quotes[index] = {
              text: newText,
              author: newAuthor.startsWith('‚Äî ') ? newAuthor : `‚Äî ${newAuthor}`
            };
            this.uiService.showToast(`Quote updated`);
            this.showQuoteManager(); // Refresh the manager
          }
        }
      }

      // Edit quote for a specific day (used by the 7-day manager)
      editQuoteForDay(dayIndex) {
        const next7Days = this.getNext7DaysQuotes();
        const dayData = next7Days[dayIndex];
        const quote = dayData.quote;
        
        const newText = prompt('Edit quote text:', quote.text);
        if (newText !== null) {
          const newAuthor = prompt('Edit author:', quote.author.replace('‚Äî ', ''));
          if (newAuthor !== null) {
            // Update the quote in the quotes array using the original index
            this.quoteService.quotes[dayData.originalIndex] = {
              text: newText,
              author: newAuthor.startsWith('‚Äî ') ? newAuthor : `‚Äî ${newAuthor}`
            };
            
            this.uiService.showToast(`Quote for ${dayData.dayName} updated`);
            // Don't refresh immediately - let user save first
          }
        }
      }

      removeQuote(index) {
        if (confirm(`Are you sure you want to remove this quote?\n\n"${this.quoteService.quotes[index].text}"\n‚Äî ${this.quoteService.quotes[index].author}`)) {
          this.quoteService.quotes.splice(index, 1);
          this.uiService.showToast(`Quote ${index + 1} removed`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      moveQuoteUp(index) {
        if (index > 0) {
          const temp = this.quoteService.quotes[index];
          this.quoteService.quotes[index] = this.quoteService.quotes[index - 1];
          this.quoteService.quotes[index - 1] = temp;
          this.uiService.showToast(`Quote moved up`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      moveQuoteDown(index) {
        if (index < this.quoteService.quotes.length - 1) {
          const temp = this.quoteService.quotes[index];
          this.quoteService.quotes[index] = this.quoteService.quotes[index + 1];
          this.quoteService.quotes[index + 1] = temp;
          this.uiService.showToast(`Quote moved down`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      replaceQuote(index) {
        const currentQuote = this.quoteService.quotes[index];
        const newText = prompt('Enter new quote text:', currentQuote.text);
        if (newText !== null) {
          const newAuthor = prompt('Enter new author:', currentQuote.author.replace('‚Äî ', ''));
          if (newAuthor !== null) {
            this.quoteService.quotes[index] = {
              text: newText,
              author: newAuthor.startsWith('‚Äî ') ? newAuthor : `‚Äî ${newAuthor}`
            };
            this.uiService.showToast(`Quote replaced`);
            this.showQuoteManager(); // Refresh the manager
          }
        }
      }

      // Delete quote for a specific day (used by the 7-day manager)
      deleteQuoteForDay(dayIndex) {
        const next7Days = this.getNext7DaysQuotes();
        const dayData = next7Days[dayIndex];
        const quote = dayData.quote;
        
        if (confirm(`Are you sure you want to delete this quote?\n\n"${quote.text}"\n${quote.author}\n\nThis will remove it from the rotation and another quote will automatically appear for ${dayData.dayName}.`)) {
          // Remove the quote from the quotes array
          this.quoteService.quotes.splice(dayData.originalIndex, 1);
          
          // Update the shuffled indexes to account for the removed quote
          this.quoteService.shuffledIndexes = this.quoteService.shuffledIndexes.map(index => {
            if (index > dayData.originalIndex) {
              return index - 1; // Shift down indexes after the deleted quote
            }
            return index;
          });
          
          this.uiService.showToast(`Quote deleted. New quote will appear for ${dayData.dayName}.`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      swapWithPrevious(dayIndex) {
        if (dayIndex <= 0) return; // Can't swap the first day
        
        const next7Days = this.getNext7DaysQuotes();
        const currentDay = next7Days[dayIndex];
        const previousDay = next7Days[dayIndex - 1];
        
        // Calculate the actual day indices for the shuffled array
        const today = new Date();
        const currentDate = new Date(today);
        currentDate.setDate(today.getDate() + currentDay.dayIndex);
        const previousDate = new Date(today);
        previousDate.setDate(today.getDate() + previousDay.dayIndex);
        
        const currentDayIndex = Math.floor(currentDate.getTime() / (1000 * 60 * 60 * 24));
        const previousDayIndex = Math.floor(previousDate.getTime() / (1000 * 60 * 60 * 24));
        
        // Swap the quotes in the shuffled indexes
        const tempIndex = this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length] = 
          this.quoteService.shuffledIndexes[previousDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[previousDayIndex % this.quoteService.shuffledIndexes.length] = tempIndex;
        
        this.uiService.showToast(`Swapped quotes for ${previousDay.dayName} and ${currentDay.dayName}`);
        this.showQuoteManager(); // Refresh the manager
      }

      swapWithNext(dayIndex) {
        if (dayIndex >= 6) return; // Can't swap the last day
        
        const next7Days = this.getNext7DaysQuotes();
        const currentDay = next7Days[dayIndex];
        const nextDay = next7Days[dayIndex + 1];
        
        // Calculate the actual day indices for the shuffled array
        const today = new Date();
        const currentDate = new Date(today);
        currentDate.setDate(today.getDate() + currentDay.dayIndex);
        const nextDate = new Date(today);
        nextDate.setDate(today.getDate() + nextDay.dayIndex);
        
        const currentDayIndex = Math.floor(currentDate.getTime() / (1000 * 60 * 60 * 24));
        const nextDayIndex = Math.floor(nextDate.getTime() / (1000 * 60 * 60 * 24));
        
        // Swap the quotes in the shuffled indexes
        const tempIndex = this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length] = 
          this.quoteService.shuffledIndexes[nextDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[nextDayIndex % this.quoteService.shuffledIndexes.length] = tempIndex;
        
        this.uiService.showToast(`Swapped quotes for ${currentDay.dayName} and ${nextDay.dayName}`);
        this.showQuoteManager(); // Refresh the manager
      }

      addNewQuote() {
        const text = prompt('Enter new quote text:');
        if (text) {
          const author = prompt('Enter author:');
          if (author) {
            this.quoteService.quotes.push({
              text: text,
              author: author.startsWith('‚Äî ') ? author : `‚Äî ${author}`
            });
            this.uiService.showToast('New quote added');
            this.showQuoteManager(); // Refresh the manager
          }
        }
      }

      async saveQuotesToFirestore() {
        try {
          console.log('üíæ Starting save to Firestore...');
          console.log('üíæ QuoteService Firebase available:', !!this.quoteService.firebase);
          console.log('üíæ Global Firebase available:', !!window.firebaseApp);
          console.log('üíæ Quotes to save:', this.quoteService.quotes.length);
          
          // Show loading state
          this.uiService.showToast('Saving quotes to database...');
          
          // Use QuoteService Firebase or fallback to global Firebase
          const firebaseInstance = this.quoteService.firebase || window.firebaseApp;
          if (!firebaseInstance) {
            throw new Error('No Firebase instance available');
          }
          
          // Use the global Firestore functions
          if (!window.db) {
            throw new Error('Firestore database not available');
          }
          
          // Save to Firestore using the global functions
          await window.firestore.setDoc(window.firestore.doc(window.db, 'quotes', 'daily'), {
            quotes: this.quoteService.quotes,
            shuffledIndexes: this.quoteService.shuffledIndexes,
            updatedAt: new Date(),
            updatedBy: this.currentUserId
          });
          
          this.uiService.showToast('‚úÖ Quotes saved to database! All users will see changes.');
          console.log('üíæ Quotes saved to Firestore:', this.quoteService.quotes.length, 'quotes');
          
          // Close the quote admin panel by removing all modals
          const modals = document.querySelectorAll('.quote-manager-modal');
          modals.forEach(modal => modal.remove());
          console.log(`üóëÔ∏è Removed ${modals.length} quote manager modals`);
          
        } catch (error) {
          console.error('‚ùå Error saving quotes to Firestore:', error);
          this.uiService.showToast('‚ùå Error saving quotes to database');
          
          // Fallback to localStorage
          try {
            localStorage.setItem('ourDailyQuotes', JSON.stringify(this.quoteService.quotes));
            this.uiService.showToast('‚ö†Ô∏è Saved to localStorage as fallback');
            console.log('üíæ Saved to localStorage as fallback');
          } catch (localError) {
            console.error('Error saving to localStorage:', localError);
          }
        }
      }

      showTodayQuote() {
        const todayQuote = this.quoteService.getTodayQuote();
        alert(`Today's Quote:\n\n"${todayQuote.text}"\n${todayQuote.author}`);
      }

      // Get next 7 days of quotes with dates
      getNext7DaysQuotes() {
        const next7Days = [];
        const today = new Date();
        
        console.log(`üîç getNext7DaysQuotes - Today: ${today.toDateString()}`);
        console.log(`üîç Current quotes array length: ${this.quoteService.quotes.length}`);
        
        for (let i = 1; i <= 7; i++) { // Start from tomorrow (i=1) instead of today (i=0)
          const futureDate = new Date(today);
          futureDate.setDate(today.getDate() + i);
          
          const year = futureDate.getFullYear();
          const month = String(futureDate.getMonth() + 1).padStart(2, '0');
          const day = String(futureDate.getDate()).padStart(2, '0');
          const dateString = `${year}-${month}-${day}`;
          
          console.log(`üîç Day ${i}: ${futureDate.toDateString()} ‚Üí ${dateString}`);
          
          // Get the quote directly from the quotes array using shuffled indexes
          const dayIndex = Math.floor(futureDate.getTime() / (1000 * 60 * 60 * 24));
          const quoteIndex = this.quoteService.shuffledIndexes[dayIndex % this.quoteService.shuffledIndexes.length];
          const quote = this.quoteService.quotes[quoteIndex];
          
          console.log(`üîç Day ${i}: dayIndex=${dayIndex}, quoteIndex=${quoteIndex}, quote=`, quote);
          
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          const dayName = dayNames[futureDate.getDay()];
          
          next7Days.push({
            date: `${month}/${day}`,
            dayName: dayName,
            quote: quote,
            originalIndex: quoteIndex,
            dayIndex: i // Use the loop index (1-7) instead of the absolute day index
          });
        }
        
        return next7Days;
      }

      // Reset quotes to defaults
      async resetQuotesToDefaults() {
        if (confirm('Are you sure you want to reset all quotes to the original defaults? This will remove all custom quotes.')) {
          // Reset to original quotes array
          this.quoteService.quotes = [
            { text: "Art washes away from the soul the dust of everyday life.", author: "‚Äî Pablo Picasso" },
            { text: "Creativity takes courage.", author: "‚Äî Henri Matisse" },
            { text: "Every artist was first an amateur.", author: "‚Äî Ralph Waldo Emerson" },
            { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "‚Äî Wassily Kandinsky" },
            { text: "Great things are done by a series of small things brought together.", author: "‚Äî Vincent Van Gogh" },
            { text: "You can't use up creativity. The more you use, the more you have.", author: "Maya Angelou" },
            { text: "Every time I have had a problem, I have confronted it with the ax of art.", author: "Yayoi Kusama" },
            { text: "I found I could say things with color and shapes that I couldn't say any other way ‚Äì things I had no words for.", author: "Georgia O'Keeffe" },
            { text: "I love creation more than life, and I must express myself before disappearing.", author: "Sonia Delaunay" },
            { text: "The job of the artist is always to deepen the mystery.", author: "Francis Bacon" },
            { text: "The most important relationship in your life is the relationship you have with yourself.", author: "Diane von Furstenberg" },
            { text: "There is a vitality, a life force, an energy, a quickening that is translated through you into action, and because there is only one of you in all time, this expression is unique.", author: "Martha Graham" },
            { text: "If there is a book that you want to read, but it hasn't been written yet, you must be the one to write it.", author: "Toni Morrison" },
            { text: "Creativity doesn't wait for that perfect moment. It fashions its own perfect moments out of ordinary ones.", author: "Elizabeth Gilbert" },
            { text: "I think, at a child's birth, if a mother could ask a fairy godmother to endow it with the most useful gift, that gift would be curiosity.", author: "Eleanor Roosevelt" },
            { text: "Imagination is more important than knowledge. Knowledge is limited. Imagination encircles the world.", author: "Albert Einstein" },
            { text: "The beauty of a living thing is not the atoms that go into it, but the way those atoms are put together.", author: "Carl Sagan" },
            { text: "Let your curiosity be greater than your fear.", author: "Pema Ch√∂dr√∂n" },
            { text: "Study hard what interests you the most in the most undisciplined, irreverent and original manner possible.", author: "Richard Feynman" },
            { text: "Research is formalized curiosity. It is poking and prying with a purpose.", author: "Zora Neale Hurston" },
            { text: "It is always with excitement that I wake up in the morning wondering what my intuition will toss up to me, like gifts from the sea.", author: "Jonas Salk" },
            { text: "The only thing that makes life possible is permanent, intolerable uncertainty; not knowing what comes next.", author: "Ursula K. Le Guin" },
            { text: "Curiosity is the engine of achievement.", author: "Sir Ken Robinson" },
            { text: "Let the beauty of what you love be what you do. There are a thousand ways to kneel and kiss the earth.", author: "Rumi" },
            { text: "I'm very interested in, 'What does it mean for us to cultivate together?' Community that allows for risk, the risk of knowing someone outside your own boundaries, the risk that is love.", author: "bell hooks" },
            { text: "A nation's culture resides in the hearts and in the soul of its people.", author: "Mahatma Gandhi" },
            { text: "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.", author: "Antoine de Saint-Exup√©ry" },
            { text: "The butterfly counts not months but moments, and has time enough.", author: "Rabindranath Tagore" },
            { text: "To fly, we have to have resistance.", author: "Maya Lin" },
            { text: "Not everything that is faced can be changed, but nothing can be changed until it is faced.", author: "James Baldwin" },
            { text: "There's nothing new under the sun, but there are new suns.", author: "Octavia Butler" },
            { text: "Never doubt that a small group of thoughtful, committed citizens can change the world; indeed, it's the only thing that ever has.", author: "Margaret Mead" },
            { text: "There is no such thing as a single-issue struggle because we do not live single-issue lives.", author: "Audre Lorde" },
            { text: "Every moment is an organizing opportunity, every person a potential activist, every minute a chance to change the world.", author: "Dolores Huerta" },
            { text: "We don't have to engage in grand, heroic actions to participate in the process of change. Small acts, when multiplied by millions of people, can transform the world.", author: "Howard Zinn" },
            { text: "When the whole world is silent, even one voice becomes powerful.", author: "Malala Yousafzai" },
            { text: "Activism is my rent for living on the planet.", author: "Alice Walker" },
            { text: "We are the leaders we've been waiting for.", author: "Grace Lee Boggs" },
            { text: "Do your little bit of good where you are; it's those little bits of good put together that overwhelm the world.", author: "Desmond Tutu" },
            { text: "What you do makes a difference, and you have to decide what kind of difference you want to make.", author: "Jane Goodall" },
            { text: "You never change things by fighting the existing reality. To change something, build a new model that makes the existing model obsolete.", author: "Buckminster Fuller" },
            { text: "Like what you do, and then you will do your best.", author: "Katherine Johnson" },
            { text: "The present is theirs; the future, for which I really worked, is mine.", author: "Nikola Tesla" },
            { text: "Cities have the capability of providing something for everybody, only because, and only when, they are created by everybody.", author: "Jane Jacobs" },
            { text: "In every outthrust headland, in every curving beach, in every grain of sand there is the story of the earth.", author: "Rachel Carson" },
            { text: "What the people want is very simple - they want an America as good as its promise.", author: "Barbara Jordan" },
            { text: "In nature's economy the currency is not money, it is life.", author: "Vandana Shiva" },
            { text: "When we plant trees, we plant the seeds of peace and seeds of hope.", author: "Wangari Maathai" },
            { text: "No one is born fully-formed: it is through self-experience in the world that we become what we are.", author: "Paulo Freire" },
            { text: "Turn your wounds into wisdom.", author: "Oprah Winfrey" },
            { text: "Courage doesn't always roar. Sometimes courage is the quiet voice at the end of the day saying 'I will try again tomorrow.'", author: "Mary Anne Radmacher" },
            { text: "I fight pain, anxiety, and fear every day, and the only method I have found that relieves my illness is to keep creating art.", author: "Yayoi Kusama" },
            { text: "To heal is to touch with love that which we previously touched with fear.", author: "Stephen Levine" },
            { text: "I am better off healed than I ever was unbroken.", author: "Beth Moore" },
            { text: "Everything can be taken from a man but one thing: the last of the human freedoms‚Äîto choose one's attitude in any given set of circumstances.", author: "Viktor Frankl" },
            { text: "The purpose of life is not to be happy. It is to be useful, to be honorable, to be compassionate, to have it make some difference that you have lived and lived well.", author: "Ralph Waldo Emerson" },
            { text: "Let yourself be silently drawn by the strange pull of what you really love. It will not lead you astray.", author: "Rumi" },
            { text: "Follow your bliss and the universe will open doors where there were only walls.", author: "Joseph Campbell" },
            { text: "A musician must make music, an artist must paint, a poet must write, if he is to be ultimately happy. What a man can be, he must be.", author: "Abraham Maslow" },
            { text: "At every moment you choose yourself. But do you choose your self? Body and soul contain a thousand possibilities out of which you can build many I's.", author: "Dag Hammarskj√∂ld" },
            { text: "We are the myths we tell ourselves about ourselves.", author: "Jean Houston" },
            { text: "A vocation is not a career that you choose for yourself. A vocation is a calling that you discover by listening to the voice of vocation within you.", author: "Parker Palmer" },
            { text: "Attention is the rarest and purest form of generosity.", author: "Simone Weil" },
            { text: "Waking up this morning, I smile. Twenty-four brand new hours are before me. I vow to live fully in each moment.", author: "Th√≠ch Nh·∫•t H·∫°nh" },
            { text: "The privilege of a lifetime is to become who you truly are.", author: "Carl Jung" },
            { text: "I define connection as the energy that exists between people when they feel seen, heard, and valued; when they can give and receive without judgment.", author: "Bren√© Brown" },
            { text: "Perhaps the secret of living well is not in having all the answers but in pursuing unanswerable questions in good company.", author: "Rachel Naomi Remen" },
            { text: "All real living is meeting.", author: "Martin Buber" },
            { text: "We humans are social beings. We come into the world as the result of others' actions. We survive here in dependence on others.", author: "The Dalai Lama" },
            { text: "Sometimes people try to destroy you, precisely because they recognize your power.", author: "bell hooks" },
            { text: "When you understand that being connected to others is one of life's greatest joys, you realize that life's best comes when you initiate and invest in solid relationships.", author: "John C. Maxwell" },
            { text: "Healing yourself is connected with healing others.", author: "Yoko Ono" },
            { text: "Relationships are all there is. Everything in the universe only exists because it is in relationship to everything else.", author: "Margaret J. Wheatley" },
            { text: "When you take one step to reach out to people, when you meet with others and share their thoughts and sufferings, infinite compassion and wisdom well up within your heart.", author: "Daisaku Ikeda" },
            { text: "We now accept the fact that learning is a lifelong process of keeping abreast of change. And the most pressing task is to teach people how to learn.", author: "Peter Drucker" },
            { text: "The illiterate of the 21st century will not be those who cannot read and write, but those who cannot learn, unlearn, and relearn.", author: "Alvin Toffler" },
            { text: "Those people who develop the ability to continuously acquire new and better forms of knowledge that they can apply to their work and to their lives will be the movers and shakers in our society for the indefinite future.", author: "Brian Tracy" },
            { text: "The purpose of learning is growth, and our minds, unlike our bodies, can continue growing as we continue to live.", author: "Mortimer Adler" },
            { text: "The good thing about science is that it's true whether or not you believe in it. But the great thing about learning is that it makes you more capable of reducing the suffering of others.", author: "Neil deGrasse Tyson" },
            { text: "I have learned that each and every piece of cloth embodies the spirit, skill, and personal history of an individual weaver‚Ä¶ It ties together with an endless thread the emotional life of my people.", author: "Nilda Calla√±aupa Alvarez" },
            { text: "I wanted to tell my story through fabric because it was a medium that was accessible to me as a woman and as an African American.", author: "Faith Ringgold" },
            { text: "Come stitch next to me, and I'll tell you a story.", author: "Sonya Clark" },
            { text: "Fabric is a material that forgives. You can always mend, patch, darn, and transform it into something new.", author: "Louise Bourgeois" },
            { text: "We must learn inner solitude wherever or with whomsoever we may be. We must learn to penetrate things and find God in them.", author: "Anni Albers" },
            { text: "Thread has the potential to unite, to heal, to provide a soft structure in a hard world.", author: "Sheila Hicks" },
            { text: "The loom is the universe in miniature‚Äîwarp and weft, the essential crossing that creates all structure, all meaning.", author: "Lenore Tawney" },
            { text: "Western art tradition values fine art practices such as painting, mostly done by men and on canvas. Bringing these techniques into the gallery space allows me to question the hierarchy in the Western art world.", author: "Hale Ekinci" },
            { text: "The true measure of our commitment to justice, the character of our society, our commitment to the rule of law, fairness, and equality cannot be measured by how we treat the rich, the powerful, the privileged, and the respected among us.", author: "Bryan Stevenson" },
            { text: "We cannot seek achievement for ourselves and forget about the progress and prosperity for our community.", author: "Dolores Huerta" },
            { text: "If you see something that is not right, not fair, not just, you have a moral obligation to do something about it.", author: "John Lewis" },
            { text: "Trauma happens in relationship, so does healing.", author: "Tarana Burke" },
            { text: "Real change requires real relationships. And real relationships require that we tell the truth about our experiences.", author: "Alicia Garza" },
            { text: "Care is the strategy. Care is what we need more of in this world. Care is revolutionary.", author: "Ai-jen Poo" },
            { text: "We accomplish nothing if we say nothing. We accomplish nothing if we do nothing. And we accomplish nothing if we know nothing.", author: "Stacey Abrams" }
          ];
          
          // Save to Firestore
          await this.saveQuotesToFirestore();
          this.uiService.showToast('‚úÖ Quotes reset to defaults and saved to database');
        }
      }



      showRevealImageManager() {
        const menu = document.createElement('div');
        menu.className = 'reveal-image-manager';
        menu.innerHTML = `
          <div class="reveal-image-manager-content">
            <h3>Quilt Reveal Image Manager</h3>
            <div class="image-upload-section">
              <h4>Upload New Reveal Image</h4>
              <p style="font-size: 12px; color: #666; margin: 5px 0;">Images will be automatically resized to 412 x 800 pixels</p>
              <input type="file" id="revealImageUpload" accept="image/*" style="margin: 10px 0;">
              <button onclick="app.handleUploadRevealImage()">Upload Image</button>
            </div>
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
            <div class="image-selection-section">
              <h4>Select Active Reveal Image</h4>
              <div id="revealImageOptions">
                <p>Loading available images...</p>
              </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        menu.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          z-index: 1001;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          min-width: 300px;
          max-height: 80vh;
          overflow-y: auto;
        `;
        
        const content = menu.querySelector('.reveal-image-manager-content');
        content.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 10px;
        `;
        
        const buttons = menu.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
          `;
        });
        
        menu.addEventListener('click', (e) => {
          if (e.target === menu) {
            menu.remove();
          }
        });
        
        document.body.appendChild(menu);
        
        // Load available images
        this.loadRevealImageOptions();
      }

      showAdminMenu() {
        const menu = document.createElement('div');
        menu.className = 'admin-menu';
        menu.innerHTML = `
          <div class="admin-menu-content">
            <button onclick="app.handleTestAddBlock()">Add Random Block</button>
            <button onclick="app.handleAddColorFamilyBlocks()">Add 10 Color Family Blocks</button>
            <button onclick="app.handleResetQuilt()">Reset Quilt</button>
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
            <button onclick="app.handleTestInstagramImage()">üì∏ Generate Instagram Image</button>
            <button onclick="app.handleTestZapierWebhook()">üîó Test Zapier Webhook</button>
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
            <button onclick="app.showQuoteManager()">Manage Quotes</button>
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
            <button onclick="app.showRevealImageManager()">Manage Reveal Images</button>
        <button onclick="app.forceLoadFirebaseImage()">üî• Load Firebase Image</button>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        menu.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          z-index: 1001;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          min-width: 250px;
        `;
        
        const content = menu.querySelector('.admin-menu-content');
        content.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 10px;
        `;
        
        const buttons = menu.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
          `;
        });
        
        menu.addEventListener('click', (e) => {
          if (e.target === menu) {
            menu.remove();
          }
        });
        
        document.body.appendChild(menu);
      }

      initializeUI() {
        this.quoteService.displayQuote();
        this.uiService.showScreen('screen-portal');
      }

      setupAutoTransition() {
        // Always set up the auto-transition regardless of current screen
        const delay = 1500; // Fixed 1.5 seconds for all devices
        
        console.log('üîÑ Setting up auto-transition with delay:', delay);
        
        setTimeout(() => {
          const currentScreen = document.querySelector('.screen.active');
          console.log('üîÑ Auto-transition check - current screen:', currentScreen?.id);
          
          if (currentScreen && currentScreen.id === 'screen-portal') {
            console.log('üîÑ Auto-transitioning from portal...');
            this.autoTransitionFromPortal();
          } else {
            console.log('üîÑ No auto-transition - portal not active');
          }
        }, delay);
      }

      async autoTransitionFromPortal() {
        try {
          console.log('üîÑ Starting auto-transition from portal...');
          
          const hasVisitedBefore = localStorage.getItem('ourDailyHasVisited');
          const lastVisitDate = localStorage.getItem('ourDailyLastVisitDate');
          
          const now = new Date();
          const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          const currentDate = chicagoTime.toDateString();
          const isNewDay = lastVisitDate !== currentDate;
          
          console.log('üîÑ Visit check:', { hasVisitedBefore, lastVisitDate, currentDate, isNewDay });
          
          if (!hasVisitedBefore) {
            console.log('üîÑ First visit ever - showing welcome screen');
            localStorage.setItem('ourDailyHasVisited', 'true');
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            this.uiService.showScreen('screen-welcome');
          } else if (isNewDay) {
            console.log('üîÑ Returning user on new day - showing quote screen');
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            this.uiService.showScreen('screen-quote');
          } else {
            console.log('üîÑ Returning user on same day - showing quote screen directly');
            this.uiService.showScreen('screen-quote');
          }
        } catch (error) {
          this.logger.error('‚ùå Auto transition failed:', error);
          this.uiService.showScreen('screen-quote');
        }
      }
      
      async resetQuiltForNewDay() {
        this.quiltEngine.initialize();
        
        try {
          await this.dataService.saveQuilt([], 1);
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Failed to clear data for new day:', error);
        }
        
        this.renderQuilt();
        this.updateSquareCounter();
      }

      setupDailyReset() {
        this.logger.log('üåô Setting up automatic daily archive and reset...');
        
        const scheduleDailyCycle = () => {
          const now = new Date();
          
          // Calculate next 6:30 AM UTC (archive)
          const nextArchive = new Date(now);
          nextArchive.setUTCHours(6, 30, 0, 0); // 6:30:00 AM UTC
          
          // If it's already past 6:30 AM UTC today, schedule for tomorrow
          if (now >= nextArchive) {
            nextArchive.setUTCDate(nextArchive.getUTCDate() + 1);
          }
          
          // Calculate next 7:00 AM UTC (reset)
          const nextReset = new Date(now);
          nextReset.setUTCHours(7, 0, 0, 0); // 7:00:00 AM UTC
          
          // If it's already past 7:00 AM UTC today, schedule for tomorrow
          if (now >= nextReset) {
            nextReset.setUTCDate(nextReset.getUTCDate() + 1);
          }
          
          const timeUntilArchive = nextArchive.getTime() - now.getTime();
          const timeUntilReset = nextReset.getTime() - now.getTime();
          
          this.logger.log(`üì¶ Next archive scheduled for: ${nextArchive.toISOString()} (6:30 AM UTC)`);
          this.logger.log(`üîÑ Next reset scheduled for: ${nextReset.toISOString()} (7:00 AM UTC)`);
          
          // Schedule archive at 6:30 AM UTC
          if (timeUntilArchive > 0) {
            setTimeout(async () => {
              this.logger.log('üì¶ 6:30 AM UTC reached - archiving current quilt');
              const archiveSuccess = await this.performDailyArchive();
              
              // Store archive status for reset check (using UTC date)
              const utcNow = new Date();
              const todayKey = utcNow.toISOString().split('T')[0];
              localStorage.setItem(`archiveStatus_${todayKey}`, archiveSuccess ? 'success' : 'failed');
            }, timeUntilArchive);
          }
          
          // Schedule reset at 7:00 AM UTC
          if (timeUntilReset > 0) {
            setTimeout(async () => {
              this.logger.log('üîÑ 7:00 AM UTC reached - checking archive status before reset');
              await this.performDailyReset();
              scheduleDailyCycle(); // Schedule next day's cycle
            }, timeUntilReset);
          }
        };
        
        // Schedule the first cycle
        scheduleDailyCycle();
      }

      async performDailyArchive() {
        try {
          this.logger.log('üì¶ Performing daily archive...');
          
          // Create archive of current quilt
          if (this.quiltEngine.blocks.length > 1) { // Only archive if there are blocks beyond the initial one
            this.logger.log(`üì¶ Archiving quilt with ${this.quiltEngine.blocks.length} blocks...`);
            
            // SAFEGUARD 1: Backup current quilt data before archiving
            const utcNow = new Date();
            const backupDate = utcNow.toISOString().split('T')[0];
            const quiltBackup = {
              blocks: JSON.parse(JSON.stringify(this.quiltEngine.blocks)),
              submissionCount: this.quiltEngine.submissionCount,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('quiltBackup_' + backupDate, JSON.stringify(quiltBackup));
            this.logger.log('üì¶ Created quilt backup before archiving');
            
            // SAFEGUARD 2: Try archive with retry logic
            let archiveSuccess = false;
            let retryCount = 0;
            const maxRetries = 3;
            
            while (!archiveSuccess && retryCount < maxRetries) {
              try {
                await this.createArchiveSnapshot();
                archiveSuccess = true;
                this.logger.log(`üì¶ Archived current quilt successfully (attempt ${retryCount + 1})`);
              } catch (archiveError) {
                retryCount++;
                this.logger.error(`‚ùå Archive attempt ${retryCount} failed:`, archiveError);
                
                if (retryCount < maxRetries) {
                  this.logger.log(`üîÑ Retrying archive in 2 seconds... (${retryCount}/${maxRetries})`);
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
              }
            }
            
            if (!archiveSuccess) {
              // SAFEGUARD 3: If all retries fail, create a minimal archive entry
              this.logger.error('‚ùå All archive attempts failed - creating emergency backup');
              try {
                // Use UTC for emergency backup date
                const utcNow = new Date();
                const emergencyDate = utcNow.toISOString().split('T')[0];
                const emergencyEntry = {
                  date: emergencyDate,
                  blocks: this.quiltEngine.blocks,
                  quote: this.quoteService.getQuoteForDate(emergencyDate),
                  contributorCount: this.quiltEngine.submissionCount,
                  thumbnail: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZmY2YjZiIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RW1lcmdlbmN5IEJhY2t1cDwvdGV4dD4KPC9zdmc+',
                  isEmergencyBackup: true
                };
                
                // Store emergency backup in localStorage as fallback
                const emergencyKey = `emergencyArchive_${emergencyDate}`;
                localStorage.setItem(emergencyKey, JSON.stringify(emergencyEntry));
                this.logger.log('üì¶ Created emergency backup in localStorage');
                
                return false; // Archive failed but we have backup
              } catch (emergencyError) {
                this.logger.error('‚ùå Emergency backup also failed:', emergencyError);
                return false;
              }
            }
            
            // SAFEGUARD 4: Verify archive was actually created
            try {
              // Use UTC for verification
              const utcNow = new Date();
              const verifyDate = utcNow.toISOString().split('T')[0];
              const archives = await this.archiveService.getArchives(1);
              const todayArchive = archives.find(archive => archive.date === verifyDate);
              
              if (todayArchive) {
                this.logger.log('‚úÖ Archive verification successful - archive found in database');
                return true;
              } else {
                this.logger.error('‚ùå Archive verification failed - archive not found in database');
                return false;
              }
            } catch (verifyError) {
              this.logger.error('‚ùå Archive verification error:', verifyError);
              return false;
            }
            
          } else {
            this.logger.log('üì¶ No quilt to archive (only initial block)');
            return true; // Consider this a success since there's nothing to archive
          }
          
        } catch (error) {
          this.logger.error('‚ùå Daily archive failed:', error);
          return false;
        }
      }

      async performDailyReset() {
        try {
          this.logger.log('üîÑ Performing daily reset...');
          
          // Check if archive was successful before resetting (using UTC)
          const utcNow = new Date();
          const yesterday = new Date(utcNow);
          yesterday.setUTCDate(yesterday.getUTCDate() - 1);
          const yesterdayKey = yesterday.toISOString().split('T')[0];
          const archiveStatus = localStorage.getItem(`archiveStatus_${yesterdayKey}`);
          
          if (archiveStatus === 'failed') {
            this.logger.error('‚ùå Archive failed yesterday - skipping reset to preserve data');
            this.logger.error('‚ùå Manual intervention required to resolve archive issue');
            return false;
          }
          
          if (archiveStatus === 'success' || archiveStatus === null) {
            // Archive was successful or no archive was needed (first day)
            this.logger.log('‚úÖ Archive check passed - proceeding with reset');
            
            // Reset the quilt
            await this.resetQuiltForNewDay();
            
            // Update visit tracking (using UTC date)
            const currentDate = utcNow.toISOString().split('T')[0];
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            
            this.logger.log('‚úÖ Daily reset completed successfully');
            return true;
          }
          
        } catch (error) {
          this.logger.error('‚ùå Daily reset failed:', error);
          return false;
        }
      }

      async loadQuilt() {
        try {
          const data = await this.dataService.loadQuilt();
          
          if (data.blocks && data.blocks.length > 0) {
            this.quiltEngine.blocks = data.blocks.map(block => ({
              id: block.id || 'loaded_' + Math.random().toString(36).substr(2, 9),
              x: block.x,
              y: block.y,
              width: block.width,
              height: block.height,
              color: block.color,
              contributorId: this.currentUserId,
              submissionIndex: 0
            }));
            this.quiltEngine.submissionCount = data.contributorCount || 1;
            
            // Apply responsive dimensions for current viewport
            this.quiltEngine.recalculateDimensionsForCurrentViewport();
          } else {
            this.quiltEngine.initialize();
          }
          
        } catch (error) {
          this.logger.error('‚ùå Failed to load quilt:', error);
          this.quiltEngine.initialize();
        }
      }

      async saveQuilt() {
        try {
          const blocks = this.quiltEngine.blocks.map(block => ({
            id: block.id,
            x: block.x,
            y: block.y,
            width: block.width,
            height: block.height,
            color: block.color
          }));
          
          await this.dataService.saveQuilt(blocks, this.quiltEngine.submissionCount);
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          throw error;
        }
      }

      async renderQuilt() {
        console.log('üîÑ renderQuilt() called'); // TEMPORARILY RE-ENABLED FOR DEBUGGING
        // Debug panel removed for production
        
        this.ensureQuiltFits();
        
        const state = this.quiltEngine.getState();
        this.renderer.renderBlocks(state.blocks, state.userPieces);
        this.updateSquareCounter();
        
        // Ensure quote is displayed on quilt screen
        this.populateQuiltQuote();
        
        // Auto-load random reveal image if not already loaded (non-blocking)
        // DISABLED: Causing CORS errors
        // if (!this.currentRevealImage || !this.currentRevealImage.url) {
        //   console.log('üé≤ Auto-loading random reveal image...');
        //   // Don't await - let it load in background
        //   this.loadRandomRevealImage().catch(error => {
        //     console.log('Could not auto-load reveal image:', error);
        //   });
        // }
      }

      ensureQuiltFits() {
        if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length === 0) return;
        
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        const availableWidth = hasVisualViewport ? window.visualViewport.width : window.innerWidth;
        const availableHeight = hasVisualViewport ? window.visualViewport.height : window.innerHeight;
        
        const minX = Math.min(...this.quiltEngine.blocks.map(b => b.x));
        const minY = Math.min(...this.quiltEngine.blocks.map(b => b.y));
        const maxX = Math.max(...this.quiltEngine.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.quiltEngine.blocks.map(b => b.y + b.height));
        
        const currentWidth = maxX - minX;
        const currentHeight = maxY - minY;
        
        const scaleX = availableWidth / currentWidth;
        const scaleY = availableHeight / currentHeight;
        const optimalScale = Math.min(scaleX, scaleY, 1);
        
        this.quiltScale = optimalScale;
      }

      updateSquareCounter() {
        const counterElement = document.getElementById('squareCounter');
        if (counterElement) {
          counterElement.textContent = this.quiltEngine.blocks.length;
        }
      }
      
      populateQuiltQuote() {
        try {
          const { text, author } = this.quoteService.getTodayQuote();
          const quiltQuoteText = document.querySelector('.quilt-quote-text');
          const quiltQuoteAuthor = document.querySelector('.quilt-quote-author');
          const quiltQuoteDisplay = document.querySelector('.quilt-quote-display');
          
          if (quiltQuoteText) quiltQuoteText.textContent = text;
          if (quiltQuoteAuthor) quiltQuoteAuthor.textContent = author;
          
          // Show the quote display when content is populated
          if (quiltQuoteDisplay && text && author) {
            quiltQuoteDisplay.classList.add('has-content');
          }
        } catch (error) {
          this.logger.warn('Failed to populate quilt quote:', error);
        }
      }

      async handleAddColor() {
        try {
          console.log('üé® handleAddColor called');
          console.log('üé® Color values:', { hue: this.selectedHue, sat: this.selectedSaturation, light: this.selectedLightness });
          
          const selectedColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
          console.log('üé® Converted color:', selectedColor);
          
          // Debug logging
          // console.log('Color selection debug');
          
          if (!selectedColor || !Utils.validateHexColor(selectedColor)) {
            this.logger.warn('Invalid color selected');
            console.log('‚ùå Color validation failed:', { selectedColor, isValid: Utils.validateHexColor(selectedColor) });
            return;
          }

          console.log('üé® Calling quiltEngine.addColor with:', selectedColor);
          const result = this.quiltEngine.addColor(selectedColor);
          console.log('üé® addColor result:', result);
          
          if (result) {
            // Find the new block for animation
            let newBlockIndex = -1;
            if (result.newBlocks && result.newBlocks.length > 0) {
              // If splitting occurred, find the new block (the one with the new color)
              const newBlock = result.newBlocks.find(block => block.color === selectedColor);
              if (newBlock) {
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === newBlock.id);
              }
            } else if (result.id) {
              // If it's a single new block (from addBlockAtEdge)
              newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.id);
            }
            
            // Set the last added index for animation
            if (newBlockIndex !== -1) {
              this.renderer.setLastAddedIndex(newBlockIndex);
            }
            
            await this.saveQuilt();
            this.renderQuilt();
            
            this.uiService.showScreen('screen-quilt');
          }
          
        } catch (error) {
          this.errorHandler.handleError(error, 'handleAddColor');
        }
      }

      async handleShare() {
        try {
          const quiltSVG = document.getElementById('quilt');
          if (!quiltSVG) {
            throw new Error('Quilt SVG not found');
          }

          const canvas = await html2canvas(quiltSVG, {
            backgroundColor: '#f6f4f1',
            scale: 2,
            useCORS: true,
            allowTaint: true
          });

          canvas.toBlob(async (blob) => {
            try {
              const shareData = {
                title: 'Our Daily Quilt',
                text: `Check out today's community quilt with ${this.quiltEngine.submissionCount} contributors!`,
                files: [new File([blob], 'quilt.png', { type: 'image/png' })]
              };

              if (navigator.share && navigator.canShare(shareData)) {
                await navigator.share(shareData);
                this.uiService.showToast('Shared successfully!');
              } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quilt-${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.uiService.showToast('Quilt downloaded!');
              }
            } catch (error) {
              this.logger.error('Share failed:', error);
              this.uiService.showToast('Share failed. Please try again.');
            }
          }, 'image/png', 0.9);

        } catch (error) {
          this.errorHandler.handleError(error, 'shareFlow');
        }
      }

      async handleTestAddBlock() {
        const testColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
        const randomColor = testColors[Math.floor(Math.random() * testColors.length)];
        
        try {
          const result = this.quiltEngine.addColor(randomColor);
          
          if (result) {
            // Find the new block for animation
            let newBlockIndex = -1;
            if (result.newBlocks && result.newBlocks.length > 0) {
              // If splitting occurred, find the new block (the one with the new color)
              const newBlock = result.newBlocks.find(block => block.color === randomColor);
              if (newBlock) {
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === newBlock.id);
              }
            } else if (result.id) {
              // If it's a single new block (from addBlockAtEdge)
              newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.id);
            }
            
            // Set the last added index for animation
            if (newBlockIndex !== -1) {
              this.renderer.setLastAddedIndex(newBlockIndex);
            }
            
            this.renderQuilt();
            await this.saveQuilt();
            
            this.uiService.showToast(`Added test block: ${randomColor}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testAddBlock');
        }
      }

      // Test Instagram image generation
      async handleTestInstagramImage() {
        try {
          if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length <= 1) {
            this.uiService.showToast('Add some blocks to the quilt first!');
            return;
          }

          // Generate Instagram image (quilt only, no quote)
          const instagramImage = await this.archiveService.generateInstagramImage(
            this.quiltEngine.blocks
          );
          
          if (instagramImage) {
            // Create download link
            const link = document.createElement('a');
            link.href = instagramImage;
            link.download = `instagram-quilt-${new Date().toISOString().split('T')[0]}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Save current quilt to Firestore
            await this.saveQuilt();
            
            this.uiService.showToast('Instagram image downloaded and saved to Firestore! üì∏üíæ');
            this.logger.log('‚úÖ Instagram test image generated, downloaded, and saved to Firestore');
          } else {
            this.uiService.showToast('Failed to generate Instagram image');
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testInstagramImage');
        }
      }

      // Save current quilt to Firestore
      async handleSaveToFirestore() {
        try {
          if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length <= 1) {
            this.uiService.showToast('Add some blocks to the quilt first!');
            return;
          }

          this.uiService.showToast('Saving to Firestore...');
          
          // Save the current quilt to Firestore
          const success = await this.saveQuilt();
          
          if (success) {
            this.uiService.showToast('‚úÖ Quilt saved to Firestore!');
            this.logger.log('‚úÖ Quilt successfully saved to Firestore');
          } else {
            this.uiService.showToast('‚ùå Failed to save to Firestore');
            this.logger.log('‚ùå Failed to save quilt to Firestore');
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'saveToFirestore');
        }
      }

      // Test Zapier webhook
      async handleTestZapierWebhook() {
        try {
          if (!window.zapierWebhookAPI) {
            this.uiService.showToast('Zapier webhook API not available');
            return;
          }

          this.uiService.showToast('Testing Zapier webhook...');
          
          // Test the webhook
          const result = await window.zapierWebhookAPI.generateInstagramImage();
          
          if (result.success) {
            console.log('‚úÖ Zapier webhook test successful:', result);
            this.uiService.showToast(`‚úÖ Webhook test successful! Generated image for ${result.blockCount} blocks`);
            
            // Show the response in console for debugging
            console.log('üì∏ Zapier webhook response:', {
              success: result.success,
              date: result.date,
              blockCount: result.blockCount,
              captionLength: result.caption.length,
              imageSize: result.image.length
            });
          } else {
            console.error('‚ùå Zapier webhook test failed:', result);
            this.uiService.showToast(`‚ùå Webhook test failed: ${result.error}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testZapierWebhook');
        }
      }

      async handleAddColorFamilyBlocks() {
        try {
          // Analyze current quilt to find most common color family
          const colorFamilies = this.analyzeColorFamilies();
          
          if (colorFamilies.length === 0) {
            this.uiService.showToast('No color families found in current quilt');
            return;
          }
          
          const dominantFamily = colorFamilies[0]; // Most common family
          const shades = this.generateColorFamilyShades(dominantFamily.baseColor, 10);
          
          console.log('üé® Adding 10 blocks in color family:', dominantFamily.name, 'shades:', shades);
          
          // Add 10 blocks with different shades
          for (let i = 0; i < 10; i++) {
            const result = this.quiltEngine.addColor(shades[i]);
            
            if (result) {
              // Find the new block for animation
              let newBlockIndex = -1;
              if (result.newBlocks && result.newBlocks.length > 0) {
                const newBlock = result.newBlocks.find(block => block.color === shades[i]);
                if (newBlock) {
                  newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === newBlock.id);
                }
              } else if (result.id) {
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.id);
              }
              
              // Set the last added index for animation
              if (newBlockIndex !== -1) {
                this.renderer.setLastAddedIndex(newBlockIndex);
              }
            }
          }
          
          this.renderQuilt();
          await this.saveQuilt();
          
          this.uiService.showToast(`Added 10 blocks in ${dominantFamily.name} family`);
          
        } catch (error) {
          this.errorHandler.handleError(error, 'addColorFamilyBlocks');
        }
      }

      analyzeColorFamilies() {
        const colorCounts = {};
        const familyCounts = {};
        
        // Count each color and determine its family
        this.quiltEngine.blocks.forEach(block => {
          const color = block.color;
          colorCounts[color] = (colorCounts[color] || 0) + 1;
          
          const family = this.getColorFamily(color);
          if (!familyCounts[family.name]) {
            familyCounts[family.name] = {
              name: family.name,
              baseColor: family.baseColor,
              count: 0,
              colors: []
            };
          }
          familyCounts[family.name].count += 1;
          if (!familyCounts[family.name].colors.includes(color)) {
            familyCounts[family.name].colors.push(color);
          }
        });
        
        // Convert to array and sort by count
        const families = Object.values(familyCounts).sort((a, b) => b.count - a.count);
        
        console.log('üé® Color family analysis:', families);
        return families;
      }

      getColorFamily(color) {
        // Convert hex to HSL for better color family detection
        const hsl = this.hexToHsl(color);
        const hue = hsl.h;
        const saturation = hsl.s;
        const lightness = hsl.l;
        
        // Define color families based on hue ranges
        if (hue >= 0 && hue < 30) return { name: 'Red', baseColor: '#ff6b6b' };
        if (hue >= 30 && hue < 60) return { name: 'Orange', baseColor: '#ffa726' };
        if (hue >= 60 && hue < 90) return { name: 'Yellow', baseColor: '#ffeb3b' };
        if (hue >= 90 && hue < 150) return { name: 'Green', baseColor: '#4caf50' };
        if (hue >= 150 && hue < 210) return { name: 'Cyan', baseColor: '#00bcd4' };
        if (hue >= 210 && hue < 270) return { name: 'Blue', baseColor: '#2196f3' };
        if (hue >= 270 && hue < 330) return { name: 'Magenta', baseColor: '#e91e63' };
        if (hue >= 330 && hue < 360) return { name: 'Pink', baseColor: '#ff9ff3' };
        
        // Fallback for grays/whites/blacks
        if (saturation < 0.1) {
          if (lightness > 0.8) return { name: 'White', baseColor: '#ffffff' };
          if (lightness < 0.2) return { name: 'Black', baseColor: '#000000' };
          return { name: 'Gray', baseColor: '#9e9e9e' };
        }
        
        return { name: 'Other', baseColor: color };
      }

      hexToHsl(hex) {
        // Remove # if present
        hex = hex.replace('#', '');
        
        // Convert hex to RGB
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return {
          h: h * 360,
          s: s,
          l: l
        };
      }

      generateColorFamilyShades(baseColor, count) {
        const hsl = this.hexToHsl(baseColor);
        const shades = [];
        
        for (let i = 0; i < count; i++) {
          // Generate variations by adjusting lightness and saturation
          const variation = i / (count - 1); // 0 to 1
          
          let newLightness = hsl.l + (variation - 0.5) * 0.4; // Vary lightness by ¬±20%
          newLightness = Math.max(0.1, Math.min(0.9, newLightness)); // Clamp between 10% and 90%
          
          let newSaturation = hsl.s + (Math.random() - 0.5) * 0.3; // Vary saturation by ¬±15%
          newSaturation = Math.max(0.1, Math.min(1.0, newSaturation)); // Clamp between 10% and 100%
          
          // Convert back to hex
          const newColor = this.hslToHex(hsl.h, newSaturation * 100, newLightness * 100);
          shades.push(newColor);
        }
        
        // Shuffle the shades for variety
        return shades.sort(() => Math.random() - 0.5);
      }

      hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = l - c / 2;
        let r = 0, g = 0, b = 0;
        
        if (0 <= h && h < 1/6) {
          r = c; g = x; b = 0;
        } else if (1/6 <= h && h < 2/6) {
          r = x; g = c; b = 0;
        } else if (2/6 <= h && h < 3/6) {
          r = 0; g = c; b = x;
        } else if (3/6 <= h && h < 4/6) {
          r = 0; g = x; b = c;
        } else if (4/6 <= h && h < 5/6) {
          r = x; g = 0; b = c;
        } else if (5/6 <= h && h < 1) {
          r = c; g = 0; b = x;
        }
        
        const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
        const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
        const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
        
        return `#${rHex}${gHex}${bHex}`;
      }

      handleShowMyPiece() {
        const userPieces = this.quiltEngine.findUserPieces();
        if (userPieces.length > 0) {
          this.uiService.showToast(`Found ${userPieces.length} of your pieces!`);
          this.renderQuilt();
          
          // Add wiggle animation to user pieces
          setTimeout(() => {
            const userPieceElements = document.querySelectorAll('.user-piece-highlight');
            userPieceElements.forEach(element => {
              element.classList.add('wiggle');
            });
          }, 100); // Small delay to ensure rendering is complete
          
        } else {
          this.uiService.showToast('No pieces found for current user');
        }
      }

      handleTestDifferentUser() {
        this.currentUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('ourDailyUserId', this.currentUserId);
        
        // Update the quilt engine with the new user ID
        this.quiltEngine.deviceId = this.currentUserId;
        
        this.uiService.showToast('Switched to different user');
      }

      async handleResetQuilt() {
        // Show confirmation dialog
        const confirmed = confirm('Are you sure you want to reset the quilt? This will clear all blocks and start fresh. This action cannot be undone.');
        
        if (confirmed) {
          try {
            // Reset the quilt engine
            this.quiltEngine.initialize();
            
            // Clear saved data
            await this.dataService.saveQuilt([], 1);
            
            // Clear user contributions for this session
            localStorage.removeItem('quiltContributions');
            
            // Re-render the quilt
            this.renderQuilt();
            this.updateSquareCounter();
            
            this.uiService.showToast('Quilt reset successfully! Starting fresh.');
            
            // Log the reset
            this.logger.log('üßµ Quilt reset by user');
            
          } catch (error) {
            this.errorHandler.handleError(error, 'resetQuilt');
            this.uiService.showToast('Failed to reset quilt. Please try again.');
          }
        }
      }

      // ===== FLIP FUNCTIONALITY =====
      setupQuiltFlipHandlers() {
        const quiltSVG = document.getElementById('quilt');
        if (!quiltSVG) {
          this.logger.warn('Quilt SVG not found for flip handlers');
          return;
        }

        // Remove existing handlers to prevent duplicates
        quiltSVG.removeEventListener('click', this.handleQuiltFlip);
        quiltSVG.removeEventListener('touchstart', this.handleQuiltFlip);
        quiltSVG.removeEventListener('mousedown', this.handleSwipeStart);
        quiltSVG.removeEventListener('touchstart', this.handleSwipeStart);

        // Add swipe handlers for continuous flipping
        this.isSwipingToFlip = false;
        this.flippedInCurrentSwipe = new Set();
        this.lastSwipeX = null;
        this.lastSwipeY = null;

        this.handleSwipeStart = (event) => {
          console.log('üîÑ MAIN HANDLER: Swipe start called');
          // Debug panel removed for production
          
          const currentScreen = document.querySelector('.screen.active');
          if (!currentScreen || currentScreen.id !== 'screen-quilt') {
            console.log('üîÑ Swipe ignored - not on quilt screen');
            return;
          }

          console.log('üîÑ Swipe start:', event.type, event.target.tagName, 'touches:', event.touches?.length);

          // Always activate swipe mode when starting on the quilt (rect or SVG)
          this.isSwipingToFlip = true;
          this.flippedInCurrentSwipe.clear();
          // Debug panel removed for production
          
          // Store start position for tap detection
          this.swipeStartTime = Date.now();
          this.swipeStartX = event.touches ? event.touches[0].clientX : event.clientX;
          this.swipeStartY = event.touches ? event.touches[0].clientY : event.clientY;
          
          // REMOVED: Tap detection from handleSwipeStart to prevent double-flipping
          // Tap detection will be handled in handleSwipeEnd based on movement distance
          
          console.log('üîÑ Swipe mode activated');
        };

        this.handleSwipeMove = (event) => {
          try {
            // Debug panel removed for production
            
            if (!this.isSwipingToFlip) {
              // Debug panel removed for production
              return;
            }
            
                       // Get current coordinates - TRYING DIFFERENT APPROACH for mobile touch
           let currentX, currentY;
           // Debug panel removed for production
           
           // Try multiple sources for coordinates
           if (event.changedTouches && event.changedTouches.length > 0) {
             currentX = event.changedTouches[0].clientX;
             currentY = event.changedTouches[0].clientY;
           } else if (event.touches && event.touches.length > 0) {
             currentX = event.touches[0].clientX;
             currentY = event.touches[0].clientY;
           } else if (event.targetTouches && event.targetTouches.length > 0) {
             currentX = event.targetTouches[0].clientX;
             currentY = event.targetTouches[0].clientY;
           } else {
             currentX = event.clientX;
             currentY = event.clientY;
           }
           
           // Check if coordinates are actually changing (with some tolerance)
           const coordChangeThreshold = 5; // pixels
           const xDiff = Math.abs(currentX - (this.lastSwipeX || 0));
           const yDiff = Math.abs(currentY - (this.lastSwipeY || 0));
           
           if (xDiff < coordChangeThreshold && yDiff < coordChangeThreshold) {
             // Debug panel removed for production
             return; // Skip if coordinates haven't changed enough
           }
           
           this.lastSwipeX = currentX;
           this.lastSwipeY = currentY;
          
                      console.log('üîÑ Swipe move:', event.type, 'touches:', event.touches?.length, 'at', currentX, currentY);
            // Debug panel removed for production
            
            // Now prevent default since we're actually swiping
            event.preventDefault();
            this.flipBlockAtPosition(event);
          } catch (error) {
            // Debug panel removed for production
            console.error('Error in handleSwipeMove:', error);
          }
        };

        this.handleSwipeEnd = (event) => {
          // Check if this was a tap (minimal movement)
          const swipeDuration = Date.now() - this.swipeStartTime;
          const swipeDistance = Math.sqrt(
            Math.pow((event.changedTouches ? event.changedTouches[0].clientX : event.clientX) - this.swipeStartX, 2) +
            Math.pow((event.changedTouches ? event.changedTouches[0].clientY : event.clientY) - this.swipeStartY, 2)
          );
          
          // this.updateDebugPanel(`Swipe end: duration=${swipeDuration}ms, distance=${Math.round(swipeDistance)}px`); // DISABLED FOR PRODUCTION
          
          // Handle taps (short duration and minimal movement) for mobile devices
          if (swipeDuration < 300 && swipeDistance < 20) {
            console.log('üîÑ TAP detected in swipe end');
            
            // Find the block at the tap position
            let elementAtPosition = document.elementFromPoint(this.swipeStartX, this.swipeStartY);
            
            // If we didn't get a rect, try to find the closest one
            if (!elementAtPosition || elementAtPosition.tagName !== 'rect') {
              const allRects = document.querySelectorAll('#quilt rect');
              let closestRect = null;
              let closestDistance = Infinity;
              
              allRects.forEach(rect => {
                const rectBox = rect.getBoundingClientRect();
                const rectCenterX = rectBox.left + rectBox.width / 2;
                const rectCenterY = rectBox.top + rectBox.height / 2;
                const distance = Math.sqrt(Math.pow(this.swipeStartX - rectCenterX, 2) + Math.pow(this.swipeStartY - rectCenterY, 2));
                
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestRect = rect;
                }
              });
              
              if (closestRect && closestDistance < 50) {
                elementAtPosition = closestRect;
              }
            }
            
            if (elementAtPosition && elementAtPosition.tagName === 'rect') {
              const blockId = elementAtPosition.getAttribute('data-block-id');
              if (blockId) {
                const newFlipState = this.renderer.toggleBlockFlip(blockId);
                
                // Apply CSS class and color directly to the element
                if (newFlipState) {
                  elementAtPosition.classList.add('block-flipped');
                  
                  // Apply reveal image if one is selected
                  if (this.currentRevealImage && this.currentRevealImage.url) {
                    // Apply the single reveal image to all flipped blocks
                    this.applyImageToFlippedBlocks(this.currentRevealImage);
                    console.log(`TAP: Applied reveal image to all flipped blocks`);
                  } else if (this.currentRevealImage) {
                    // Fallback to color if image not loaded yet
                    const color = this.currentRevealImage === 'image1' ? '#ff6b6b' : '#4ecdc4';
                    elementAtPosition.setAttribute('fill', color);
                    elementAtPosition.style.setProperty('fill', color, 'important');
                    console.log(`TAP: Applied color ${color} to block ${blockId}`);
                  }
                } else {
                  elementAtPosition.classList.remove('block-flipped');
                  elementAtPosition.removeAttribute('fill');
                }
                
                console.log('üîÑ TAP: Flipped block', blockId);
              }
            }
          }
          
          // Add a small delay before clearing swipe state to prevent race conditions
          setTimeout(() => {
            this.isSwipingToFlip = false;
            this.flippedInCurrentSwipe.clear();
            // Debug panel removed for production
            console.log('üîÑ Swipe ended');
          }, 50); // 50ms delay to allow handleSwipeMove to process
        };

        // Add new handlers
        this.handleQuiltFlip = (event) => {
          // Only allow flip on quilt screen and only if clicking on actual quilt blocks
          const currentScreen = document.querySelector('.screen.active');
          if (!currentScreen || currentScreen.id !== 'screen-quilt') {
            console.log('üîÑ Flip ignored - not on quilt screen');
            return;
          }
          
          // Check if the click target is a rect (quilt block)
          if (event.target.tagName !== 'rect') {
            console.log('üîÑ Flip ignored - not clicking on a quilt block');
            return;
          }
          
          event.preventDefault();
          event.stopPropagation();
          
          // Get the block ID from the clicked rect
          const blockId = event.target.getAttribute('data-block-id');
          if (!blockId) {
            console.log('üîÑ No block ID found');
            return;
          }
          
          console.log('üîÑ Flipping individual block:', blockId);
          
          // Toggle the individual block's flip state
          const newFlipState = this.renderer.toggleBlockFlip(blockId);
          
          // Apply CSS class and image directly to the element
          if (newFlipState) {
            event.target.classList.add('block-flipped');
            
            // Apply reveal image if one is selected
            if (this.currentRevealImage && this.currentRevealImage.url) {
              console.log('üñºÔ∏è TAP: Applying image to block', blockId);
              // Apply the single reveal image to all flipped blocks
              this.applyImageToFlippedBlocks(this.currentRevealImage);
              console.log(`‚úÖ TAP: Applied reveal image to all flipped blocks`);
            } else if (this.currentRevealImage) {
              // Fallback to color if image not loaded yet
              const color = this.currentRevealImage === 'image1' ? '#ff6b6b' : '#4ecdc4';
              event.target.setAttribute('fill', color);
              event.target.style.setProperty('fill', color, 'important');
              console.log(`TAP: Applied color ${color} to block ${blockId}`);
            } else {
              console.log('TAP: No reveal image selected');
            }
                      } else {
              event.target.classList.remove('block-flipped');
              // Remove background image when unflipped
              event.target.removeAttribute('fill'); // Let CSS handle the fill
            }
          
          // Add flip animation to the specific block
          event.target.style.transition = 'transform 0.3s ease-in-out';
          
          // DON'T call renderQuilt() - it recreates DOM elements and wipes out CSS classes
          // this.renderQuilt();
          
          this.logger.log(`üîÑ Block ${blockId} flip toggled: ${newFlipState}`);
        };

        // Add swipe event listeners
        quiltSVG.addEventListener('mousedown', this.handleSwipeStart);
        quiltSVG.addEventListener('mousemove', this.handleSwipeMove);
        quiltSVG.addEventListener('mouseup', this.handleSwipeEnd);
        quiltSVG.addEventListener('mouseleave', this.handleSwipeEnd);
        
        // Use document-level listeners for touch events (more reliable)
        document.addEventListener('touchstart', this.handleSwipeStart, { passive: false });
        document.addEventListener('touchmove', this.handleSwipeMove, { passive: false });
        document.addEventListener('touchend', this.handleSwipeEnd, { passive: false });
        
        // Add click handler for tap events (only click, not touchstart to avoid conflicts)
        quiltSVG.addEventListener('click', this.handleQuiltFlip);
        
        // Debug: Log that event listeners are set up
        // Debug panel removed for production
        
        // REMOVED: Duplicate SVG touch listeners that were causing conflicts
        
        // Tap handling is now done in handleSwipeEnd based on movement distance
        
        // Debug panel removed for production
        // this.createDebugPanel();
        
        // Touch event testing removed for production
        // this.testTouchEvents();
        
        // Make sure the SVG is interactive
        quiltSVG.style.cursor = 'pointer';
        quiltSVG.style.pointerEvents = 'auto';
        quiltSVG.style.userSelect = 'none';
        
        // Prevent scrolling on the quilt area
        quiltSVG.style.touchAction = 'none';
        quiltSVG.style.overscrollBehavior = 'none';
        
        // Also prevent scrolling on the body when touching the quilt
        document.body.style.overscrollBehavior = 'none';
        
        this.logger.log('üîÑ Quilt swipe-to-flip handlers set up');
      }

      // Debug panel creation removed for production
      // createDebugPanel() { ... }

      // Debug panel update removed for production
      // updateDebugPanel(message) { ... }

      // Touch event testing removed for production
      // testTouchEvents() { ... }

      flipBlockAtPosition(event) {
        // Debug panel removed for production
        
        let clientX, clientY;
        
        // Get coordinates from mouse or touch event
        if (event.touches && event.touches.length > 0) {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
          console.log('üîÑ Touch coordinates:', clientX, clientY);
        } else if (event.changedTouches && event.changedTouches.length > 0) {
          // For touchend events
          clientX = event.changedTouches[0].clientX;
          clientY = event.changedTouches[0].clientY;
          console.log('üîÑ Changed touch coordinates:', clientX, clientY);
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
          console.log('üîÑ Mouse coordinates:', clientX, clientY);
        }
        
        console.log('üîÑ Looking for block at:', clientX, clientY);
        // Debug panel removed for production
        
        // Find the element at this position - look for rect specifically
        let elementAtPosition = document.elementFromPoint(clientX, clientY);
        
                  // If we didn't get a rect, try looking at all elements at this point
          if (!elementAtPosition || elementAtPosition.tagName !== 'rect') {
            const elementsAtPoint = document.elementsFromPoint(clientX, clientY);
            // this.updateDebugPanel(`Elements at point: ${elementsAtPoint.map(el => el.tagName).join(', ')}`); // DISABLED FOR PRODUCTION
            const rectElement = elementsAtPoint.find(el => el.tagName === 'rect');
            if (rectElement) {
              elementAtPosition = rectElement;
              // this.updateDebugPanel(`Found rect in elements list`); // DISABLED FOR PRODUCTION
            }
          }
        
        console.log('üîÑ Element found:', elementAtPosition?.tagName, elementAtPosition?.getAttribute('data-block-id'));
        // Debug panel removed for production
        
        if (elementAtPosition && elementAtPosition.tagName === 'rect') {
          const blockId = elementAtPosition.getAttribute('data-block-id');
          // Debug panel removed for production
          
          if (blockId && !this.flippedInCurrentSwipe.has(blockId)) {
            // Flip this block and remember we flipped it in this swipe
            this.flippedInCurrentSwipe.add(blockId);
            
            const newFlipState = this.renderer.toggleBlockFlip(blockId);
            // Debug panel removed for production
            
            // Apply CSS class directly to the element
            if (newFlipState) {
              elementAtPosition.classList.add('block-flipped');
              
              // Apply reveal image if one is selected
              if (this.currentRevealImage && this.currentRevealImage.url) {
                // Apply the single reveal image to all flipped blocks
                this.applyImageToFlippedBlocks(this.currentRevealImage);
                console.log(`Applied reveal image to all flipped blocks`);
              } else if (this.currentRevealImage) {
                // Fallback to color if image not loaded yet
                const color = this.currentRevealImage === 'image1' ? '#ff6b6b' : '#4ecdc4';
                elementAtPosition.setAttribute('fill', color);
                elementAtPosition.style.setProperty('fill', color, 'important');
                console.log(`Applied color ${color} to block ${blockId}`);
              } else {
                console.log('No reveal image selected');
              }
            } else {
              elementAtPosition.classList.remove('block-flipped');
                          // Remove background image when unflipped
            elementAtPosition.removeAttribute('fill'); // Let CSS handle the fill
            }
            
            // DON'T call renderQuilt() - it recreates DOM elements and wipes out CSS classes
            // this.updateDebugPanel(`Calling renderQuilt()`); // TEMPORARILY RE-ENABLED FOR DEBUGGING
            // this.renderQuilt(); // NEEDED - to apply CSS class to DOM elements
            
            console.log(`üîÑ Swiped block ${blockId} flip toggled: ${newFlipState}`);
            // Debug panel removed for production
          } else if (blockId) {
            console.log(`üîÑ Block ${blockId} already flipped in this swipe`);
            // Debug panel removed for production
          } else {
            // this.updateDebugPanel(`SWIPE: No blockId found on rect`); // DISABLED FOR PRODUCTION
          }
        } else {
          console.log('üîÑ No rect found at position');
          // this.updateDebugPanel('SWIPE: No rect found at position'); // DISABLED FOR PRODUCTION
        }
      }

      removeQuiltFlipHandlers() {
        const quiltSVG = document.getElementById('quilt');
        if (quiltSVG) {
          // Remove swipe handlers
          quiltSVG.removeEventListener('mousedown', this.handleSwipeStart);
          quiltSVG.removeEventListener('mousemove', this.handleSwipeMove);
          quiltSVG.removeEventListener('mouseup', this.handleSwipeEnd);
          quiltSVG.removeEventListener('mouseleave', this.handleSwipeEnd);
          quiltSVG.removeEventListener('touchstart', this.handleSwipeStart);
          quiltSVG.removeEventListener('touchmove', this.handleSwipeMove);
          quiltSVG.removeEventListener('touchend', this.handleSwipeEnd);
          
          // Remove document listeners
          document.removeEventListener('touchstart', this.handleSwipeStart);
          document.removeEventListener('touchmove', this.handleSwipeMove);
          document.removeEventListener('touchend', this.handleSwipeEnd);
          
          // Remove old click handler if it exists
          if (this.handleQuiltFlip) {
            quiltSVG.removeEventListener('click', this.handleQuiltFlip);
            quiltSVG.removeEventListener('touchstart', this.handleQuiltFlip);
          }
          
          this.logger.log('üîÑ Quilt swipe-to-flip handlers removed');
        }
      }

      async handleCreateArchive() {
        try {
          const archiveEntry = await this.createArchiveSnapshot();
          this.uiService.showToast(`Archive created for today with ${archiveEntry.userCount} contributors!`);
        } catch (error) {
          this.errorHandler.handleError(error, 'createArchive');
        }
      }

      async handleCreateTestArchives() {
        try {
          await this.createTestArchivePosts();
          // Toast message is now handled within createTestArchivePosts
        } catch (error) {
          this.errorHandler.handleError(error, 'createTestArchives');
        }
      }

      async handleTestDailyReset() {
        try {
          await this.performDailyReset();
          this.uiService.showToast('Test daily reset completed!');
        } catch (error) {
          this.errorHandler.handleError(error, 'testDailyReset');
        }
      }

      showNextWeekQuotes() {
        const modal = document.createElement('div');
        modal.className = 'quote-preview-modal';
        modal.innerHTML = `
          <div class="quote-preview-content">
            <h3>Next 7 Days Quotes</h3>
            <div class="quote-list"></div>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1002;
        `;
        
        const content = modal.querySelector('.quote-preview-content');
        content.style.cssText = `
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          max-width: 600px;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        `;
        
        const quoteList = modal.querySelector('.quote-list');
        quoteList.style.cssText = `
          margin: 20px 0;
          display: flex;
          flex-direction: column;
          gap: 20px;
        `;
        
        // Get next 7 days quotes
        const today = new Date();
        for (let i = 0; i < 7; i++) {
          const futureDate = new Date(today);
          futureDate.setDate(today.getDate() + i);
          
          const year = futureDate.getFullYear();
          const month = String(futureDate.getMonth() + 1).padStart(2, '0');
          const day = String(futureDate.getDate()).padStart(2, '0');
          const dateString = `${year}-${month}-${day}`;
          
          const dayIndex = Math.floor(new Date(dateString).getTime() / (1000 * 60 * 60 * 24));
          const quoteIndex = this.quoteService.shuffledIndexes[dayIndex % this.quoteService.shuffledIndexes.length];
          const quote = this.quoteService.quotes[quoteIndex];
          
          const quoteElement = document.createElement('div');
          quoteElement.style.cssText = `
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            background: #f9f9f9;
          `;
          
          const dateElement = document.createElement('div');
          dateElement.style.cssText = `
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            font-size: 14px;
          `;
          dateElement.textContent = i === 0 ? 'Today' : futureDate.toLocaleDateString('en-US', { 
            weekday: 'long', 
            month: 'short', 
            day: 'numeric' 
          });
          
          const textElement = document.createElement('div');
          textElement.style.cssText = `
            font-style: italic;
            margin-bottom: 8px;
            line-height: 1.4;
          `;
          textElement.textContent = `"${quote.text}"`;
          
          const authorElement = document.createElement('div');
          authorElement.style.cssText = `
            font-weight: bold;
            color: #666;
            font-size: 14px;
          `;
          authorElement.textContent = quote.author;
          
          quoteElement.appendChild(dateElement);
          quoteElement.appendChild(textElement);
          quoteElement.appendChild(authorElement);
          quoteList.appendChild(quoteElement);
        }
        
        const closeButton = modal.querySelector('button');
        closeButton.style.cssText = `
          padding: 8px 16px;
          border: 1px solid #000;
          background: #fff;
          cursor: pointer;
          font-size: 14px;
          border-radius: 4px;
          margin-top: 10px;
        `;
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove();
          }
        });
        
        document.body.appendChild(modal);
      }
    }

    // ===== TITLE TEXT RESIZING =====
    function resizeTitleText() {
      const titleLines = document.querySelectorAll('.title-line');
      if (titleLines.length >= 2) {
        const firstLine = titleLines[0]; // "OUR DAILY"
        const secondLine = titleLines[1]; // "QUILT"
        
        // Get the width of the first line
        const firstLineWidth = firstLine.offsetWidth;
        
        // Calculate letter spacing to match width
        const quiltText = secondLine.textContent;
        const currentQuiltWidth = secondLine.offsetWidth;
        const targetWidth = firstLineWidth;
        
        // Calculate letter spacing adjustment
        const letterSpacingAdjustment = (targetWidth - currentQuiltWidth) / (quiltText.length - 1);
        const currentLetterSpacing = parseFloat(getComputedStyle(secondLine).letterSpacing) || 0;
        const newLetterSpacing = currentLetterSpacing + letterSpacingAdjustment;
        
        // Apply the letter spacing adjustment
        secondLine.style.letterSpacing = newLetterSpacing + 'px';
        secondLine.style.width = firstLineWidth + 'px';
        secondLine.style.textAlign = 'center';
        
        console.log('Title resized:', {
          firstLineWidth: firstLineWidth + 'px',
          quiltText: quiltText,
          letterSpacingAdjustment: letterSpacingAdjustment + 'px',
          newLetterSpacing: newLetterSpacing + 'px'
        });
      }
    }
    
    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', async () => {
      const app = new SimplifiedQuiltAppV2();
      
      // Only initialize if not redirected to desktop
      if (app && typeof app.initialize === 'function') {
        await app.initialize();
      }
      
      window.app = app;
      
      // Set date immediately when page loads (not just when portal screen shows)
      const dateText = document.getElementById("date-text");
      if (dateText) {
        const formattedDate = Utils.formatDate();
        dateText.textContent = formattedDate;
        console.log('üìÖ Date set immediately on page load:', formattedDate);
      }
      
      // Lock screen orientation to portrait
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('portrait').catch(err => {
          console.log('üì± Could not lock orientation:', err);
        });
      }
      
      // Resize title text to match widths
      resizeTitleText();
      
      // Global test functions
      window.addTestBlock = () => app.handleTestAddBlock();
      window.showMyPiece = () => app.handleShowMyPiece();
      window.switchUser = () => app.handleTestDifferentUser();
      window.shareQuilt = () => app.handleShare();
      window.resetQuilt = () => app.handleResetQuilt();
      window.createArchive = () => app.handleCreateArchive();
      window.createTestArchives = () => app.handleCreateTestArchives();
      window.generateInstagramImage = () => app.handleTestInstagramImage();
      
      // Admin console commands
      window.enableAdmin = () => app.enableAdminMode();
      window.disableAdmin = () => app.disableAdminMode();
      
      // Debug functions
      window.debugContainers = () => {
        const screenQuilt = document.getElementById('screen-quilt');
        const quiltContainer = document.querySelector('.quilt-container');
        const quilt = document.getElementById('quilt');
        
        if (screenQuilt && quiltContainer && quilt) {
          console.log('üîç Container Dimensions Debug:');
          console.log('screen-quilt:', {
            offsetTop: screenQuilt.offsetTop,
            offsetHeight: screenQuilt.offsetHeight,
            clientHeight: screenQuilt.clientHeight,
            scrollTop: screenQuilt.scrollTop,
            getBoundingClientRect: screenQuilt.getBoundingClientRect()
          });
          console.log('quilt-container:', {
            offsetTop: quiltContainer.offsetTop,
            offsetHeight: quiltContainer.offsetHeight,
            clientHeight: quiltContainer.clientHeight,
            scrollTop: quiltContainer.scrollTop,
            getBoundingClientRect: quiltContainer.getBoundingClientRect()
          });
          console.log('quilt:', {
            offsetTop: quilt.offsetTop,
            offsetHeight: quilt.offsetHeight,
            clientHeight: quilt.clientHeight,
            getBoundingClientRect: quilt.getBoundingClientRect()
          });
        }
      };
      
      window.debugQuiltEngine = () => {
        if (window.app && window.app.quiltEngine) {
          const engine = window.app.quiltEngine;
          console.log('üßµ Quilt Engine Debug:');
          console.log('Blocks count:', engine.blocks.length);
          console.log('Quilt bounds:', engine.quiltBounds);
          console.log('Target dimensions:', engine.targetDimensions);
          console.log('Quilt scale:', window.app.quiltScale);
          
          if (engine.blocks.length > 0) {
            const minX = Math.min(...engine.blocks.map(b => b.x));
            const minY = Math.min(...engine.blocks.map(b => b.y));
            const maxX = Math.max(...engine.blocks.map(b => b.x + b.width));
            const maxY = Math.max(...engine.blocks.map(b => b.y + b.height));
            console.log('Current block bounds:', {
              minX, minY, maxX, maxY,
              width: maxX - minX,
              height: maxY - minY
            });
          }
        }
      };
      
      window.debugSVG = () => {
        const quilt = document.getElementById('quilt');
        if (quilt) {
          console.log('üé® SVG Debug:');
          console.log('viewBox:', quilt.getAttribute('viewBox'));
          console.log('width:', quilt.getAttribute('width'));
          console.log('height:', quilt.getAttribute('height'));
          console.log('preserveAspectRatio:', quilt.getAttribute('preserveAspectRatio'));
          console.log('getBoundingClientRect:', quilt.getBoundingClientRect());
          console.log('Computed styles:', {
            width: getComputedStyle(quilt).width,
            height: getComputedStyle(quilt).height,
            position: getComputedStyle(quilt).position,
            top: getComputedStyle(quilt).top,
            left: getComputedStyle(quilt).left
          });
        }
      };
      
      window.debugAll = () => {
        console.log('üöÄ === COMPREHENSIVE DEBUG ===');
        debugContainers();
        debugQuiltEngine();
        debugSVG();
        console.log('üì± Viewport:', {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight,
          visualViewport: window.visualViewport ? {
            width: window.visualViewport.width,
            height: window.visualViewport.height
          } : 'not available'
        });
        console.log('üéØ === END DEBUG ===');
      };

      // Manual archive trigger for testing
      window.triggerManualArchive = () => {
        console.log('üîß Manual archive trigger available');
        if (window.app && window.app.triggerManualArchive) {
          return window.app.triggerManualArchive();
        } else {
          console.error('‚ùå App not available for manual archive');
          return false;
        }
      };
    });

    console.log('üßµ Our Daily Quilt Beta - Loading...');
    
    // ===== ZAPIER WEBHOOK API =====
    // Simple API endpoint for Zapier to generate Instagram images
    window.zapierWebhookAPI = {
      // Generate Instagram image for Zapier
      async generateInstagramImage(date = null) {
        try {
          console.log('üì∏ Zapier webhook called for Instagram image generation');
          
          // Wait for app to be ready
          let attempts = 0;
          while (!window.app && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          
          if (!window.app) {
            throw new Error('App not initialized');
          }
          
          // Load quilt data for the specified date (or today)
          let quiltData;
          if (date) {
            // Load specific date from archive
            const archiveEntry = window.app.archiveService.archives.get(date);
            if (archiveEntry && archiveEntry.quilt) {
              quiltData = archiveEntry.quilt;
            } else {
              throw new Error(`No archive found for date: ${date}`);
            }
          } else {
            // Use current quilt
            if (!window.app.quiltEngine.blocks || window.app.quiltEngine.blocks.length <= 1) {
              throw new Error('No quilt data available');
            }
            quiltData = window.app.quiltEngine.blocks;
          }
          
          // Generate Instagram image
          const instagramImage = await window.app.archiveService.generateInstagramImage(quiltData);
          
          if (!instagramImage) {
            throw new Error('Failed to generate Instagram image');
          }
          
          // Get quote for caption
          let quote = null;
          if (date) {
            quote = window.app.quoteService.getQuoteForDate(date);
          } else {
            quote = window.app.quoteService.getTodayQuote();
          }
          
          // Return data for Zapier
          const response = {
            success: true,
            image: instagramImage,
            caption: `${quote.text} ‚Äî ${quote.author}`,
            date: date || new Date().toISOString().split('T')[0],
            blockCount: quiltData.length,
            timestamp: new Date().toISOString()
          };
          
          console.log('‚úÖ Instagram image generated for Zapier:', response.date);
          return response;
          
        } catch (error) {
          console.error('‚ùå Zapier webhook error:', error);
          return {
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
          };
        }
      },
      
      // Health check endpoint
      async healthCheck() {
        return {
          status: 'healthy',
          appReady: !!window.app,
          timestamp: new Date().toISOString()
        };
      }
    };
    
    // Make webhook available globally
    window.generateInstagramForZapier = window.zapierWebhookAPI.generateInstagramImage;
    window.zapierHealthCheck = window.zapierWebhookAPI.healthCheck;
    
    // Initialize Firebase after CONFIG is defined
    (async () => {
      try {
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
        const { getFirestore, collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit, addDoc, updateDoc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        
        // Initialize Firebase
        const firebaseApp = initializeApp(CONFIG.FIREBASE);
        const db = getFirestore(firebaseApp);
        
        // Make Firebase available globally
        window.firebaseApp = firebaseApp;
        window.db = db;
        window.firestore = { collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit, addDoc, updateDoc, deleteDoc };
        
        console.log('üî• Firebase initialized successfully');
      } catch (error) {
        console.warn('‚ö†Ô∏è Firebase initialization failed:', error);
      }
    })();
  </script>
</body>
</html>
