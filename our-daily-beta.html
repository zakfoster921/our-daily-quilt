
<!DOCTYPE html>
<html lang="en">
<script>
// Squarespace Editor Error Prevention
try {
  // Prevent common errors that break Squarespace editor
  if (typeof window !== 'undefined') {
    // Override console.error to prevent editor crashes
    const originalError = console.error;
    console.error = function(...args) {
      // Only log errors, don't throw them
      originalError.apply(console, args);
    };
    
    // Prevent unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
      console.warn('Prevented unhandled promise rejection:', event.reason);
      event.preventDefault();
    });
    
    // Prevent other global errors
    window.addEventListener('error', function(event) {
      console.warn('Prevented global error:', event.error);
      event.preventDefault();
    });
  }
} catch (e) {
  // If error handling itself fails, just continue
  console.warn('Error handling setup failed:', e);
}
</script>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Our Daily Quilt - Beta</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&display=swap" rel="stylesheet">
  
  <!-- Test script to verify it's running -->
  <script>
  console.log('üéØ TEST: Script in head is running!');
  </script>
  
  <!-- ODQ: send color to Squarespace parent -->
  <script>
  // ---- ODQ: send color to Squarespace parent ----
  (function () {
    // 1) helper: post color to parent page
    function sendBGToParent(color) {
      try { 
        const targetOrigin = window.location.origin.includes('github.io') ? 'https://www.zakfoster.com' : window.location.origin;
        window.parent.postMessage({ type: 'odq-bg', color: String(color || '').trim() }, targetOrigin); 
      } catch (e) {}
    }

    // 2) send an initial color as soon as possible (fallback if your app sets it later)
    document.addEventListener('DOMContentLoaded', function () {
      // Try a CSS var first; otherwise fall back to computed body background
      var cssVar = getComputedStyle(document.documentElement).getPropertyValue('--current-color').trim();
      var initial = cssVar || getComputedStyle(document.body).backgroundColor || '#f6f4f1';
      sendBGToParent(initial);
    });

    // 3) call this when your picker changes value
    //    If you already have a callback for color changes, just add sendBGToParent(hex) there.
    window.ODQ_onColorChange = function (hex) {
      // keep your own UI in sync if you want:
      document.documentElement.style.setProperty('--current-color', hex);
      document.body.style.background = hex;
      // notify parent:
      sendBGToParent(hex);
    };
  })();
  </script>
  <style>
    /* ===== RESET & BASE STYLES ===== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      width: 100%;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      background-color: #f6f4f1;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #000;
      line-height: 1.5;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;

    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      text-align: center;
      height: auto;
      width: 100%;
      max-width: 100vw;
      padding: 0;
      position: relative;
      background-color: #f6f4f1;
      box-sizing: border-box;
      overflow-x: hidden;
      overflow-y: auto;

    }

    /* ===== FULL VIEWPORT QUILT ===== */
          .quilt-container {
        width: 70%;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f6f4f1;
        overflow: hidden;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        position: relative;

      }
      
      /* Subtle warm glow overlay */
      .quilt-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle at center,
          rgba(255, 182, 193, 0.03) 0%,
          rgba(255, 218, 185, 0.02) 40%,
          rgba(255, 235, 205, 0.01) 70%,
          transparent 100%
        );
        pointer-events: none;
        z-index: 2;
      }
    
    /* Base SVG styling - will be overridden by media queries */
    .quilt-container svg {
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      margin: 0;
      padding: 0;
      display: block;
      position: relative;
      flex-shrink: 0;


      min-height: 100px;
      visibility: visible;
      opacity: 1;
      z-index: 1;
    }







    /* ===== SCREENS ===== */
    .screen {
      display: none;
      flex-direction: column;
      width: 100%;
      max-width: 100vw;
      opacity: 0;
      background-color: #f6f4f1;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out;
      position: absolute;
      top: 0; left: 0;
      padding: 0;
      align-items: stretch;
      justify-content: flex-start;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    
    .screen.active {
      display: flex !important;
      opacity: 1;
      pointer-events: auto;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* ===== TYPOGRAPHY ===== */
    .portal-header .title-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 81%;
      max-width: 450px;
      margin: 0 auto;
      text-align: center;
    }
    
    .portal-header {
      text-align: center;
      width: 100%;
    }
    
    .portal-header .title-line {
      font-weight: 500;
      font-size: clamp(2.5rem, 5vw, 3.5rem);
      margin-bottom: 0.0em;
      letter-spacing:.02em;
      text-align: center;
      width: 100%;
    }
    
    .portal-header .title-line:last-child {
      font-weight: 900;
      font-size: clamp(4.5rem, 8vw, 8rem);
      margin-top: -0.5rem;
      margin-bottom: 1.5rem;
      letter-spacing: 0.05em;
      width: 100%;
      white-space: nowrap;
    }
    
    .portal-header .date {
      font-weight: 200;
      font-size: clamp(1.4rem, 3.5vw, 2rem);
      margin-top: 0.5rem;
    }
    
    .portal-question {
      font-size: clamp(1.125rem, 2.625vw, 1.65rem);
      font-style: italic;
      font-weight: 200;
      margin: 0;
      max-width: 600px;
      width: 90%;
      animation: fadeInBreath 1.2s ease forwards;
      text-align: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    @keyframes fadeInBreath {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }
      50% {
        opacity: 0.8;
        transform: translateY(-2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #screen-portal {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
    }

    /* ===== QUOTE CARD ===== */
    .quote-card {
      border: 2px solid #000;
      border-radius: 16px;
      padding: 1.2rem;
      margin: 0.0rem auto 1.5rem;
      background: #f6f4f1;
      width: 81%;
      max-width: 450px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 120px;
      max-height: 40vh;
      overflow: visible;
      position: relative;
    }
    
    .quote-line { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-style: italic; 
      font-weight: 500; 
      line-height: 1.4;
      text-align: center;
    }
    
    .quote-author { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      font-weight: 300; 
      font-style: italic;
      margin-top: 1rem;
      text-align: center;
    }

    /* Left-justify long quotes (more than 2 lines) */
    .quote-line.long-quote {
      text-align: left;
    }
    
    .quote-author.long-quote {
      text-align: center;
    }

    /* Stylized quotation marks using pseudo-elements */
    /*
    .quote-card::before,
    .quote-card::after {
      content: '';
      position: absolute;
      font-size: 8rem;
      font-weight: 700;
      font-family: 'Crimson Pro', Georgia, serif;
      color: #000;
      line-height: 1;
      z-index: 1;
    }

    .quote-card::before {
      content: '\201C';
      top: -25px;
      left: -30px;
    }

    .quote-card::after {
      content: '\201D';
      bottom: -25px;
      right: -30px;
    }
    */

    /* Ensure quote-inner has proper positioning */
    .quote-inner {
      position: relative;
      padding: 20px 30px;
      z-index: 2;
    }
    
    .quote-prompt { 
      font-size: clamp(1.2rem, 3vw, 1.5rem); 
      margin: 2rem 0 0rem; 
    }
    
    .arrow-down {
      font-size: 2rem;
      text-align: center;
      margin: 0rem auto 0.5rem auto;
    }

    /* Quote screen fade-in elements */
    .quote-screen-fade-in {
      opacity: 0 !important;
      transition: opacity 0.8s ease-in-out !important;
    }

    .quote-screen-fade-in.visible {
      opacity: 1 !important;
    }
    
    /* Ensure button fade-in works properly */
    .quote-screen-fade-in.btn {
      opacity: 0 !important;
      transition: opacity 0.8s ease-in-out !important;
    }

    .quote-screen-fade-in.btn.visible {
      opacity: 1 !important;
    }

    /* Welcome screen fade-in elements */
    .welcome-screen-fade-in {
      opacity: 0 !important;
      transition: opacity 0.8s ease-in-out !important;
    }

    .welcome-screen-fade-in.visible {
      opacity: 1 !important;
    }

    /* ===== COLOR PICKER ===== */
    .color-picker-container { 
      position: relative; 
      margin: 2rem auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: fit-content;
      gap: 1.5rem;
    }
    
    .css-color-wheel {
      width: 336px;
      height: 336px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: transform 0.2s ease;
      position: relative;
      background: conic-gradient(
        hsl(25, 100%, 50%),
        hsl(40, 100%, 50%),
        hsl(55, 100%, 50%),
        hsl(70, 100%, 50%),
        hsl(85, 100%, 50%),
        hsl(100, 100%, 50%),
        hsl(115, 100%, 50%),
        hsl(130, 100%, 50%),
        hsl(145, 100%, 50%),
        hsl(160, 100%, 50%),
        hsl(175, 100%, 50%),
        hsl(190, 100%, 50%),
        hsl(205, 100%, 50%),
        hsl(220, 100%, 50%),
        hsl(235, 100%, 50%),
        hsl(250, 100%, 50%),
        hsl(265, 100%, 50%),
        hsl(280, 100%, 50%),
        hsl(295, 100%, 50%),
        hsl(310, 100%, 50%),
        hsl(325, 100%, 50%),
        hsl(340, 100%, 50%),
        hsl(355, 100%, 50%),
        hsl(10, 100%, 50%),
        hsl(25, 100%, 50%)
      );
    }
    
    .css-color-wheel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, white 0%, transparent 70%);
      pointer-events: none;
    }
    
    .css-color-wheel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }
    
    .css-color-wheel:hover {
      transform: scale(1.02);
    }
    
    .css-color-wheel:focus {
      outline: 2px solid #000;
      outline-offset: 4px;
    }
    
    .color-picker-indicator {
      position: absolute;
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 3px solid #fff;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #colorPickerControls {
      display: flex; 
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 300px;
    }
    
    #valueSlider {
      width: 100%; cursor: pointer; appearance: none;
      height: 30px; border-radius: 15px;
      background: linear-gradient(to right, hsl(0, 90%, 25%), hsl(0, 90%, 85%));
      outline: none; border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -webkit-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-moz-range-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      transition: transform 0.1s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      -moz-appearance: none;
      appearance: none;
    }
    
    #valueSlider::-webkit-slider-thumb:hover,
    #valueSlider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }
    
    #valueSlider::-ms-thumb {
      width: 24px; height: 24px;
      background: #ffffff !important; border: 1px solid #333;
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #selectedColorPreview {
      display: none !important;
    }
    
    #screen-color {
      transition: background-color 1.2s cubic-bezier(0.4, 0.0, 0.2, 1);
      justify-content: center;
    }
    
    #screen-quote {
      justify-content: center;
      padding-top: env(safe-area-inset-top, 0);
      padding-bottom: env(safe-area-inset-bottom, 0);
      /* Assume URL bar is always present for consistent centering */
      min-height: calc(100vh - 120px);
      height: calc(100vh - 120px);
    }
    
    .quote-content-wrapper {
      /* This wrapper gets centered as one unit */
    }
    
    @media (max-width: 768px) {
      /* Lock orientation to portrait */
      @media screen and (orientation: landscape) {
        body {
          transform: rotate(-90deg);
          transform-origin: left top;
          width: 100vh;
          height: 100vw;
          overflow-x: hidden;
          position: absolute;
          top: 100%;
          left: 0;
        }
      }
      
      #screen-color {
        padding: 0 !important;
        min-height: 100vh !important;
        justify-content: center;
      }
      

      
      .css-color-wheel {
        width: 224px !important;
        height: 224px !important;
      }
    }
    
    /* ===== WELCOME SCREEN ===== */
    .welcome-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    #screen-welcome {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
    }
    
    .welcome-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .welcome-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .welcome-content {
      max-width: 600px;
      margin: 0 auto;
      padding: 0 1rem;
      text-align: left;
    }
    
    .welcome-info h3 {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #000;
    }
    
    .welcome-info h3:first-child {
      margin-top: 0;
    }
    
    .welcome-info p {
      font-size: 1.4rem;
      line-height: 1.8;
      color: #333;
      margin-bottom: 1rem;
    }

    /* ===== QUILT ===== */
    #quilt {
      width: 100% !important;
      height: 100% !important;
      max-width: 100% !important;
      max-height: 100% !important;
      background: transparent;
      position: relative;
      display: block;
      margin: 0;
      padding: 0;
    }
    


    /* ===== ENHANCED FEATURES ===== */
    .color-family-indicator {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    .phase-transition {
      animation: phasePulse 2s ease-in-out;
    }
    
    @keyframes phasePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    


    /* ===== SQUARE COUNTER ===== */
    .square-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #000;
      border-radius: 8px;
      font-family: inherit;
    }
    
    .counter-label {
      font-size: 1.2rem;
      font-weight: 400;
      color: #333;
      text-transform: none;
    }



    /* ===== QUILT QUOTE DISPLAY ===== */
    .quilt-quote-display {
      text-align: center;
      margin-bottom: 15px;
      padding: 10px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .quilt-quote-display.has-content {
      opacity: 1;
    }
    
    .quilt-quote-text {
      font-size: 1.4rem;
      font-style: italic;
      font-weight: 300;
      margin: 0 0 8px 0;
      line-height: 1.4;
      color: #000;
      text-align: left;
    }
    
    .quilt-quote-author {
      font-size: 1.2rem;
      font-weight: 300;
      font-style: italic;
      margin: 0;
      color: #333;
      text-align: left;
    }
    
    @media (max-width: 768px) {
      .quilt-quote-display {
        margin-bottom: 12px;
        padding: 8px 20px;
      }
      
      .quilt-quote-text {
        font-size: 1.25rem !important;
      }
      
      .quilt-quote-author {
        font-size: 1.25rem !important;
      }
      
      /* Mobile quote marks */
      /*
      .quote-card::before,
      .quote-card::after {
        font-size: 6rem;
      }
      
      .quote-card::before {
        top: -15px;
        left: -20px;
      }
      
      .quote-card::after {
        bottom: -15px;
        right: -20px;
      }
      */
      
      .quote-inner {
        padding: 15px 25px;
      }
    }
    
    @media (max-width: 480px) {
      .quilt-quote-display {
        margin-bottom: 10px;
        padding: 6px 25px;
      }
      
      .quilt-quote-text {
        font-size: 2.2rem;
      }
      
      .quilt-quote-author {
        font-size: 1.8rem;
      }
      
      /* Small mobile quote marks */
      /*
      .quote-card::before,
      .quote-card::after {
        font-size: 5rem;
      }
      
      .quote-card::before {
        top: -3px;
        left: -8px;
      }
      
      .quote-card::after {
        bottom: -3px;
        right: -8px;
      }
      */
      
      .quote-inner {
        padding: 12px 20px;
      }
    }

    /* ===== BUTTONS ===== */
    .btn {
      background: transparent;
      border: 1px solid #000;
      color: #000 !important;
      padding: 12px 30px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: auto;
      align-self: center;
      margin: 0.5rem;
      font-family: inherit;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .thank-you-message {
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      text-align: center;
      margin: 1rem 0 2rem 0;
      font-weight: 300;
      line-height: 1.4;
    }
    
    #shareBtnCompleted {
      margin-bottom: 4rem;
    }
    
    .btn:hover { 
      background: #000; color: #fff !important; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn:focus {
      outline: 2px solid #000;
      outline-offset: 2px;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== ANIMATIONS ===== */
      .new-block {
    transform-origin: center;
    animation: scaleUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }
  
  @keyframes scaleUp {
    0% { 
      transform: scale(0.9) rotate(-2deg); 
      opacity: 0.8; 
    }
    80% { 
      transform: scale(1.05) rotate(1deg); 
      opacity: 1; 
    }
    100% { 
      transform: scale(1) rotate(0deg); 
      opacity: 1; 
    }
  }
    
    .quilt-block {
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(0,0,0,0.05) 1px, transparent 1px);
      background-size: 8px 8px, 12px 12px;
      background-position: 0 0, 4px 4px;
    }
    
    /* SVG filters handle the shadow effects */

    /* ===== LOADING ===== */
    .loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(246, 244, 241, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .loading.show {
      opacity: 1;
      visibility: visible;
    }
    
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid #f6f4f1;
      border-top: 3px solid #000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    


    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: rgba(0, 0, 0, 0.9);
      color: #fff; padding: 16px 24px;
      border-radius: 0;
      opacity: 0; transition: opacity 0.3s ease;
      pointer-events: none; font-size: 0.9rem;
      font-weight: 500;
      z-index: 1001;
      box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.3);
      text-align: center;
    }
    
    .toast.show { opacity: 1; }
    
    .toast-link {
      color: #4ecdc4;
      text-decoration: underline;
      margin-left: 8px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .toast-link:hover {
      color: #45b7aa;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      html, body {
        overflow: auto !important;
        position: static !important;
        width: 100% !important;
        height: auto !important;
        -webkit-overflow-scrolling: touch;
      }
      
      #app {
        overflow: visible !important;
        height: auto !important;
        width: 100% !important;
      }
      
      .screen { 
        padding: 0; 
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
      }
      
      .portal-question {
        width: 100%;
        max-width: 100%;
        padding: 0 1rem;
        box-sizing: border-box;
      }
      .quote-card { width: 85%; padding: 1.5rem; }
      .css-color-wheel { 
        width: 288px; 
        height: 288px; 
      }
      .quilt-container {
        width: calc(100% - 40px) !important;
        max-width: calc(100vw - 40px) !important;
        height: auto !important;
        min-height: 200px !important;
        position: relative !important;
        flex-shrink: 0 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        overflow: visible !important;
        margin: 20px !important;
        padding: 0 !important;

        box-sizing: border-box !important;

        visibility: visible !important;
        opacity: 1 !important;
        z-index: 1 !important;
      }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      

      
      #screen-quilt .square-counter {
        background: #fff !important;
        border: 2px solid #000 !important;
        margin: 1rem 0.5rem 0.5rem 0.5rem !important;
        padding: 0.5rem !important;
        border-radius: 6px !important;
        width: 100% !important;
        box-sizing: border-box !important;

      }
      

      
      #screen-quilt .counter-label {
        font-size: 1rem !important;
      }
      
      #screen-quilt .btn {
        background: #fff !important;
        border: 2px solid #000 !important;
        color: #000 !important;
        font-size: 0.9rem !important;
        padding: 8px 16px !important;
        margin: 0.5rem !important;
        display: block !important;
        width: 100% !important;
        max-width: none !important;
      }
      
      #screen-portal .btn,
      #screen-welcome .btn,
      #screen-quote .btn,
      #screen-color .btn,
      #screen-archive .btn,
      #screen-about .btn {
        background: transparent !important;
        border: 1px solid #000 !important;
        font-size: 1rem !important;
        padding: 12px 30px !important;
        margin: 0.5rem !important;
        display: inline-block !important;
        width: auto !important;
        max-width: none !important;
      }
      
      #screen-quilt {
        padding: 0 !important;
        margin: 0 !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: flex-start !important;
        align-items: stretch !important;
        height: auto !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        position: relative !important;
        top: auto !important;
        left: auto !important;
        right: auto !important;
        bottom: auto !important;
        width: 100% !important;
        max-width: 100vw !important;
        box-sizing: border-box !important;

      }
      
      #screen-portal,
      #screen-welcome,
      #screen-quote,
      #screen-color {
        padding: 1rem !important;
        justify-content: center !important;
        align-items: center !important;
        height: 100dvh !important;
        min-height: 100dvh !important;
        max-height: 100dvh !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
        /* Fallback for browsers that don't support dvh */
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
      }
      

      
      #screen-archive {
        padding: 0 !important;
        display: block !important;
        min-height: 100vh !important;
        height: auto !important;
        max-height: none !important;
        overflow-y: scroll !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: auto !important;
        border: none !important;
      }
      
      #screen-archive.active {
        display: block !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: auto !important;
      }
      

      
      #screen-quilt .button-container {
        position: relative !important;
        background: #f6f4f1 !important;
        padding: 1rem !important;
        margin-top: 0 !important;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25) !important;
        width: 100% !important;
        z-index: 10 !important;
        height: auto !important;

        min-height: auto !important;
        top: auto !important;
        right: auto !important;
      }
      

      
      #screen-portal .button-container,
      #screen-welcome .button-container,
      #screen-quote .button-container,
      #screen-color .button-container,
      #screen-about .button-container {
        position: static !important;
        background: transparent !important;
        padding: 0 !important;
        border-top: none !important;
        margin-top: 0 !important;
      }
      
      #screen-archive .button-container {
        position: static !important;
        background: transparent !important;
        padding: 0 !important;
        border-top: none !important;
        margin-top: 0 !important;
        border: none !important;
      }
      
      #screen-quilt .thank-you-message {
        margin-bottom: 0.5rem;
        z-index: 10;
        position: relative;
      }
      
      #screen-quilt .btn {
        margin: 0.5rem;
        z-index: 10;
        position: relative;
      }
    }
    
    @media (max-width: 480px) {
      html, body {
        overflow: hidden !important;
        position: fixed !important;
        width: 100vw !important;
        height: 100vh !important;
        height: 100dvh !important;
        -webkit-overflow-scrolling: touch;
        /* Safe area support for mobile devices */
        padding-top: env(safe-area-inset-top) !important;
        padding-bottom: env(safe-area-inset-bottom) !important;
        padding-left: env(safe-area-inset-left) !important;
        padding-right: env(safe-area-inset-right) !important;
      }
      
      #app {
        overflow: hidden !important;
        height: 100vh !important;
        width: 100vw !important;
      }
      
      .portal-header h1 { font-size: 2rem; }
      .portal-question { font-size: 1.8rem; margin: 1rem 0 3rem; }
      .css-color-wheel { 
        width: 240px; 
        height: 240px; 
      }
      #colorPickerControls { flex-direction: column; gap: 10px; }
      
      #quilt { 
        width: 100% !important; 
        height: 100% !important; 
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        position: relative !important;
      }
      
      #screen-quilt .thank-you-message {
        font-size: 1rem;
        margin-bottom: 0.3rem;
      }
      
      #screen-portal,
      #screen-welcome,
      #screen-quote {
        padding: 0.5rem !important;
        padding-top: calc(0rem + env(safe-area-inset-top, 0)) !important;
        padding-bottom: calc(0.5rem + env(safe-area-inset-bottom, 0)) !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
      
      /* Color screen gets no safe-area padding so it can extend behind status bar */
      #screen-color {
        padding: 0 !important;
        padding-top: 0 !important;
        padding-bottom: 0 !important;
        overflow: hidden !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        box-sizing: border-box !important;
      }
      
      /* Screens that need precise centering */
      #screen-portal,
      #screen-welcome,
      #screen-quote {
        height: calc(100vh - 120px) !important;
        min-height: calc(100vh - 120px) !important;
        max-height: calc(100vh - 120px) !important;
      }
      
      /* Screens that need full viewport */
      #screen-color {
        height: 100vh !important;
        min-height: 100vh !important;
        max-height: 100vh !important;
        padding-top: 0 !important;
        margin-top: 0 !important;
        top: 0 !important;
        position: fixed !important;
        z-index: 1000 !important;
      }
      
      /* Make sure the screen itself isn't adding any top gap */
      #screen-color {
        margin-top: 0 !important;
        padding-top: 0 !important;
        background-color: var(--current-color, #ffffff) !important;
        /* make the color picker screen fill the whole viewport */
        min-height: 100svh !important;   /* supports iOS/modern mobile */
        min-height: 100dvh !important;   /* fallback */
        min-height: 100vh !important;    /* fallback */
      }
      
      /* Let the color screen paint behind the iOS status bar */
      body.color-mode-active {
        /* body itself takes on the live color */
        background-color: var(--current-color, #f6f4f1) !important;
      }

      /* Kill the mobile safe-area padding only while color screen is active */
      body.color-mode-active {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
      }

      /* Remove global safe-area padding on mobile to allow color picker to extend behind status bar */
      @media (max-width: 480px) {
        html, body {
          padding-top: 0 !important;
          padding-bottom: 0 !important;
          padding-left: 0 !important;
          padding-right: 0 !important;
        }
      }
      
      #screen-color.active {
        background-color: var(--current-color, #ffffff) !important;
        background-size: cover !important;
        background-position: center !important;
        background-repeat: no-repeat !important;
      }
      

      
      #screen-archive {
        overflow-y: scroll !important;
        height: auto !important;
        min-height: auto !important;
        max-height: none !important;
        position: absolute !important;
        padding-bottom: 2rem !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
      }
      

    }



    /* ===== USER PIECE HIGHLIGHTING ===== */
    .user-piece-highlight {
      /* Animation only applied when class is added via JavaScript */
    }
    
    .user-piece-highlight.wiggle {
      animation: userWobble 1.2s ease-in-out infinite;
    }
    
    @keyframes userWobble {
      0%, 100% { 
        transform: rotate(0deg); 
      }
      25% { 
        transform: rotate(-0.5deg); 
      }
      75% { 
        transform: rotate(0.5deg); 
      }
    }

    /* ===== ACCESSIBILITY ===== */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }

    }
    
    /* ===== MOBILE-ONLY STYLES (PROTECTED) ===== */
    /* WARNING: Changes here affect mobile layout */
    /* For desktop development, use the desktop-only section above */
    @media (max-width: 768px) {
      * {
        -webkit-overflow-scrolling: touch;
      }
      
      .screen {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
      }
      
      html, body {
        overflow-x: hidden !important;
        overflow-y: auto !important;
        position: relative !important;
        height: auto !important;
        min-height: 150vh !important;
      }
      
      #app {
        overflow-x: hidden !important;
        overflow-y: auto !important;
        height: auto !important;
        min-height: 150vh !important;
      }
    }
    
    @media (prefers-contrast: high) {
      .btn { border-width: 2px; }
      .quote-card { border-width: 3px; }
    }

    /* ===== ARCHIVE SCREEN ===== */
    .archive-header {
      text-align: center;
              margin-top: 0;
        margin-bottom: 1rem;
        border: none !important;
        width: 100%;
    }
    
    .archive-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      color: #000;
    }
    
    .archive-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin: 0;
    }
    
    .archive-feed {
      width: 100%;
              margin: 0 auto;
        padding: 0;
        border: none !important;
        min-height: auto !important;
        height: auto !important;
    }


    
    .archive-load-more {
      margin: 2rem auto;
      display: block;
      background: #666;
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 24px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .archive-load-more:hover {
      background: #333;
    }
    
    .archive-load-more:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .archive-loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }

    /* ===== ARCHIVE POSTS ===== */
    .archive-post {
      background: #f6f4f1;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      overflow: visible;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .archive-post:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .archive-post-image {
      width: 100%;
      height: auto;
      max-width: 100%;
      display: block;
      cursor: pointer;
      border-radius: 8px;
      transition: transform 0.2s ease;
    }

    .archive-post-image:hover {
      transform: scale(1.02);
    }

    .archive-post-caption {
      padding: 0.25rem;
      width: 75%;
      margin: 0 auto;
    }
    
    @media (max-width: 768px) {
      .archive-post-caption {
        width: 100%;
        margin: 0;
        padding-left: 5rem;
        padding-right: 5rem;
      }
    }
    
    @media (min-width: 769px) {
      .archive-post-quote-author {
        font-size: 2rem;
      }
    }

    .archive-post-quote-author {
      font-size: 1.1rem;
      font-style: italic;
      margin-bottom: 2rem;
      line-height: 1.2;
      text-align: left;
    }

    .archive-post-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      color: #666;
      margin-top: 1rem;
      margin-bottom: 1rem;
    }

    .archive-share-btn {
      background: transparent;
      border: 1px solid #000;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: background 0.2s ease;
    }

    .archive-share-btn:hover {
      background: #000;
      color: #fff;
    }

    /* ===== ARCHIVE MODAL ===== */
    .archive-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .archive-modal-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
    }

    .archive-modal-content {
      position: relative;
      background: #fff;
      border-radius: 12px;
      width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      z-index: 1001;
      display: flex;
      flex-direction: column;
    }

    .archive-modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 20px;
      cursor: pointer;
      z-index: 1002;
    }

    .archive-modal-delete {
      position: absolute;
      top: 10px;
      right: 50px;
      background: rgba(220, 53, 69, 0.9);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 16px;
      cursor: pointer;
      z-index: 1002;
      transition: background 0.2s ease;
    }

    .archive-modal-delete:hover {
      background: rgba(220, 53, 69, 1);
    }

    .archive-modal-image {
      width: 100%;
      flex: 1;
      object-fit: contain;
    }

    .archive-modal-info {
      padding: 1.5rem;
    }

    .archive-modal-quote {
      font-size: 1.2rem;
      font-style: italic;
      margin-bottom: 0.5rem;
      line-height: 1.4;
      text-align: left;
    }

    .archive-modal-meta {
      font-size: 0.9rem;
      color: #666;
    }

    /* ===== ABOUT SCREEN ===== */
    #screen-about {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 2rem 1rem;
      min-height: 100vh;
      background-color: #f6f4f1;
    }
    
    .about-container {
      max-width: 600px;
      width: 100%;
      text-align: center;
    }
    
    .about-title {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 2rem;
      color: #000;
      line-height: 1.2;
    }
    
    .about-description {
      font-size: 1.2rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 3rem;
      text-align: left;
    }
    
    .about-section {
      margin-bottom: 2rem;
      text-align: left;
    }
    
    .about-section h3 {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #000;
    }
    
    .about-section p {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
    }
    
    .about-section ul {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }
    
    .about-section li {
      margin-bottom: 0.5rem;
    }
    
    @media (max-width: 768px) {
      .about-title {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>

  
  <main id="app">

    <!-- Portal Screen -->
    <section class="screen active" id="screen-portal" role="main" aria-label="Welcome screen">
      <div class="portal-header">
        <div class="title-container">
          <h1 class="title-line">OUR DAILY</h1>
          <h1 class="title-line">QUILT</h1>
        </div>
        <p class="date" id="date-text" aria-live="polite">Tuesday, August 19, 2025</p>
      </div>
      
      <div style="margin-top: 2rem;"></div>
      
      <p class="portal-question">First we gather<br>then we build</p>
    </section>

    <!-- Welcome Screen (First Time Only) -->
    <section class="screen" id="screen-welcome" role="main" aria-label="Welcome to Our Daily">
      <div class="welcome-header">
      </div>
      
      <div class="welcome-content">
        <div class="welcome-info">
          <h3 style="text-align: center;">How It Works</h3>
          
          <div style="margin-top: 2rem;"></div>
          
          <p class="welcome-screen-fade-in step-1" style="text-align: center;">Read a quote</p>
          <p class="welcome-screen-fade-in step-arrow-1" style="text-align: center; margin: 0.5rem 0;">‚Üì</p>
          <p class="welcome-screen-fade-in step-2" style="text-align: center;">Add your color</p>
          <p class="welcome-screen-fade-in step-arrow-2" style="text-align: center; margin: 0.5rem 0;">‚Üì</p>
          <p class="welcome-screen-fade-in step-4" style="text-align: center; line-height: 1.2;">Discover what we can do together</p>
        </div>
      </div>
      
      <div style="margin-top: 2rem;"></div>
      
      <button class="btn welcome-screen-fade-in" data-next="screen-quote" aria-label="Read today's quote">READ TODAY'S QUOTE</button>
    </section>

    <!-- Quote Screen -->
    <section class="screen" id="screen-quote" role="main" aria-label="Daily quote screen">
      <div class="quote-content-wrapper">
        <div class="quote-card">
          <div class="quote-inner">
            <p class="quote-line" aria-live="polite"></p>
            <p class="quote-author" aria-live="polite"></p>
          </div>
        </div>
        <p class="quote-prompt quote-screen-fade-in">What color comes to mind<br>when you read this?</p>
        <div class="arrow-down quote-screen-fade-in">‚Üì</div>
        <button class="btn quote-screen-fade-in" data-next="screen-color" aria-label="Add your color to the quilt">ADD YOUR COLOR</button>
      </div>
    </section>

    <!-- Color Picker Screen -->
    <section class="screen" id="screen-color" role="main" aria-label="Color picker screen">
      <div class="color-picker-container">
        <div class="css-color-wheel" id="colorWheelCanvas" role="button" tabindex="0" aria-label="Color wheel - click or drag to select hue"></div>
        <div class="color-picker-indicator" id="colorIndicator" aria-hidden="true"></div>
        <div id="colorPickerControls">
          <input type="range" id="valueSlider" min="25" max="90" value="50" aria-label="Adjust color brightness" />
        </div>
      </div>
      <button class="btn" id="addColorBtn" aria-label="Add selected color to the community quilt">ADD COLOR TO QUILT</button>
    </section>

    <!-- Quilt Screen -->
    <section class="screen" id="screen-quilt" role="main" aria-label="Community quilt display">

      <!-- Quilt container - full viewport -->
      <div class="quilt-container">
        <svg id="quilt" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Community quilt with colorful blocks"></svg>
      </div>
      
      <!-- Button container - side panel on desktop -->
      <div class="button-container" style="position: relative; background: rgba(246, 244, 241, 0.95); padding: 20px; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15); overflow-y: auto; box-sizing: border-box; border: none;">
        
        <!-- Quote display at top of button container -->
        <div class="quilt-quote-display" style="margin-bottom: 20px;">
          <p class="quilt-quote-text"></p>
          <p class="quilt-quote-author"></p>
        </div>
        <!-- People counter -->
        <div class="square-counter">
          <span class="counter-label">Building today's quilt together: <span class="counter-number" id="squareCounter">1</span></span>
        </div>
        
        <div class="button-group">
          <button id="showMyPieceBtn" class="btn" style="background: #4CAF50; color: white;">SHOW ME MY PIECE</button>
        </div>
        
        <div class="button-group">
          <!-- <button id="shareBtnCompleted" class="btn" aria-label="Share this community quilt">Share This Quilt</button> -->
          <button class="btn" data-next="screen-archive" aria-label="View quilt archive">View Archive</button>
          <button class="btn" data-next="screen-about" aria-label="About this project">About</button>
        </div>
      </div>
    </section>
    </section>

    <!-- Archive Screen -->
    <section class="screen" id="screen-archive" role="main" aria-label="Quilt archive">
      <div class="archive-header">
        <h1>ARCHIVE</h1>
      </div>
      
      <!-- Archive Feed -->
      <div class="archive-feed" id="archiveFeed">
        <!-- Archive posts will be dynamically inserted here -->
      </div>
      
      <!-- Load More Button -->
      <button class="btn archive-load-more" id="archiveLoadMore" style="display: none;">Load More</button>
      
      <!-- Loading Indicator -->
      <div class="archive-loading" id="archiveLoading" style="display: none;">
        <p>Loading quilts...</p>
      </div>
      
      <!-- Back Button -->
      <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
    </section>

    <!-- About Screen -->
    <section class="screen" id="screen-about" role="main" aria-label="About this project">
      <div class="about-container">
        <h1 class="about-title">ABOUT</h1>
        
        <p class="about-description" style="text-align: center;">OUR DAILY QUILT explores how gathering creates beauty we can't achieve alone.</p>
        

        
        <div class="about-section">
          <h3>What we're exploring</h3>
          <ul>
            <li>What can we accomplish when we each contribute to a common cause?</li>
            <li>How much variety can a system absorb while maintaining coherence?</li>
            <li>How do we balance individual expression with group harmony?</li>
          </ul>
        </div>
        
        <button class="btn" data-next="screen-quilt" aria-label="Back to current quilt">Back to Quilt</button>
      </div>
    </section>
  </main>

  <!-- Loading indicator -->
  <div id="loading" class="loading" aria-hidden="true">
    <div class="loading-spinner"></div>
    <p>Loading...</p>
  </div>

      <!-- Toast notifications -->
    <div id="toast" class="toast" role="alert" aria-live="polite"></div>

    <!-- Archive Modal -->
    <div id="archiveModal" class="archive-modal" style="display: none;">
      <div id="archiveModalBackdrop" class="archive-modal-backdrop"></div>
      <div class="archive-modal-content">
        <button id="archiveModalClose" class="archive-modal-close" aria-label="Close modal">√ó</button>
        <button id="archiveModalDelete" class="archive-modal-delete" aria-label="Delete archive" style="display: none;">üóëÔ∏è</button>
        <img id="archiveModalImage" class="archive-modal-image" alt="Quilt" />
        <div class="archive-modal-info">
          <p id="archiveModalQuote" class="archive-modal-quote"></p>
          <p id="archiveModalMeta" class="archive-modal-meta"></p>
        </div>
      </div>
    </div>


    


  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  
  <!-- Firebase SDK will be initialized after CONFIG is defined -->
  <!-- FIREBASE DISABLED FOR LOCAL TESTING -->
  <script type="module">
    // ===== CONFIGURATION =====
    const CONFIG = {
      APP: {
        name: 'Our Daily',
        version: '3.0.0-beta',
        defaultColor: '#f7b733',
        quiltSize: 1000,
        animationDuration: 2000,
        toastDuration: 3000,
        debugMode: true
      },
      FIREBASE: {
        // ENABLED FOR IMAGE REVEAL FUNCTIONALITY
        apiKey: "AIzaSyBqMJlchU_luM5-XcPo0USDUjsM60Qfoqg",
        authDomain: "our-daily.firebaseapp.com",
        projectId: "our-daily",
        storageBucket: "our-daily.firebasestorage.app",
        messagingSenderId: "337201931314",
        appId: "1:337201931314:web:fb5677846d03eb285ac82b",
        measurementId: "G-65XB7QC1F4"
      },
      COLOR_PICKER: {
        wheelSize: 280,
        defaultHue: 45,
        defaultLightness: 62.5,
        saturation: 65
      },
      QUILT: {
        viewBoxWidth: 800,
        viewBoxHeight: 800,
        gridCols: 8,
        gridRows: 8,
        blockSpacing: 4,
        blockPadding: 2
      },
      QUILT_V2: {
        FREEZE_THRESHOLD: 20,
        MIN_SHAPE_SIZE: 40,
        COLOR_SIMILARITY_THRESHOLD: 35,
        LAB_COLOR_CACHE_SIZE: 1000
      }
    };

    // ===== FIREBASE INITIALIZATION =====
    // Initialize Firebase immediately after CONFIG is defined
    
    // Use dynamic imports to load Firebase modules
    Promise.all([
      import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js'),
      import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js')
    ]).then(([{ initializeApp }, { getFirestore, collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit, addDoc, updateDoc, deleteDoc }]) => {
      try {
        // Initialize Firebase
        const firebaseApp = initializeApp(CONFIG.FIREBASE);
        const db = getFirestore(firebaseApp);
        
        // Make Firebase available globally
        window.firebaseApp = firebaseApp;
        window.db = db;
        window.firestore = { collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit, addDoc, updateDoc, deleteDoc };
        
        
        // Dispatch event to notify that Firebase is ready
        document.dispatchEvent(new CustomEvent('firebaseReady'));
      } catch (error) {
        console.warn('‚ö†Ô∏è Firebase initialization failed:', error);
      }
    }).catch(error => {
      console.warn('‚ö†Ô∏è Failed to load Firebase modules:', error);
    });

    // ===== COLOR UTILITIES (LAB Color Space) =====
    class ColorUtilsV2 {
      static colorCache = new Map();
      
      static hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      
      static rgbToXyz(r, g, b) {
        let r1 = r / 255, g1 = g / 255, b1 = b / 255;
        
        r1 = r1 > 0.04045 ? Math.pow((r1 + 0.055) / 1.055, 2.4) : r1 / 12.92;
        g1 = g1 > 0.04045 ? Math.pow((g1 + 0.055) / 1.055, 2.4) : g1 / 12.92;
        b1 = b1 > 0.04045 ? Math.pow((b1 + 0.055) / 1.055, 2.4) : b1 / 12.92;
        
        const x = r1 * 0.4124 + g1 * 0.3576 + b1 * 0.1805;
        const y = r1 * 0.2126 + g1 * 0.7152 + b1 * 0.0722;
        const z = r1 * 0.0193 + g1 * 0.1192 + b1 * 0.9505;
        
        return { x, y, z };
      }
      
      static xyzToLab(x, y, z) {
        const xn = 0.95047, yn = 1.00000, zn = 1.08883;
        
        const x1 = x / xn, y1 = y / yn, z1 = z / zn;
        
        const fx = x1 > 0.008856 ? Math.pow(x1, 1/3) : (7.787 * x1) + (16 / 116);
        const fy = y1 > 0.008856 ? Math.pow(y1, 1/3) : (7.787 * y1) + (16 / 116);
        const fz = z1 > 0.008856 ? Math.pow(z1, 1/3) : (7.787 * z1) + (16 / 116);
        
        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b = 200 * (fy - fz);
        
        return { L, a, b };
      }
      
      static hexToLab(hex) {
        if (this.colorCache.has(hex)) {
          return this.colorCache.get(hex);
        }
        
        const rgb = this.hexToRgb(hex);
        if (!rgb) return null;
        
        const xyz = this.rgbToXyz(rgb.r, rgb.g, rgb.b);
        const lab = this.xyzToLab(xyz.x, xyz.y, xyz.z);
        
        if (this.colorCache.size < CONFIG.QUILT_V2.LAB_COLOR_CACHE_SIZE) {
          this.colorCache.set(hex, lab);
        }
        
        return lab;
      }
      
      static getColorDistance(color1, color2) {
        const lab1 = this.hexToLab(color1);
        const lab2 = this.hexToLab(color2);
        
        if (!lab1 || !lab2) return Infinity;
        
        const dL = lab1.L - lab2.L;
        const da = lab1.a - lab2.a;
        const db = lab1.b - lab2.b;
        
        return Math.sqrt(dL * dL + da * da + db * db);
      }
      
      static isColorSimilar(color1, color2) {
        const distance = this.getColorDistance(color1, color2);
        return distance <= CONFIG.QUILT_V2.COLOR_SIMILARITY_THRESHOLD;
      }
      
      static getColorFamilyName(hexColor) {
        const rgb = this.hexToRgb(hexColor);
        if (!rgb) return 'unknown';
        
        const { r, g, b } = rgb;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;
        
        if (delta === 0) return 'gray';
        
        let hue;
        if (max === r) {
          hue = ((g - b) / delta) % 6;
        } else if (max === g) {
          hue = (b - r) / delta + 2;
        } else {
          hue = (r - g) / delta + 4;
        }
        
        hue = Math.round(hue * 60);
        if (hue < 0) hue += 360;
        
        if (hue >= 0 && hue < 30) return 'red';
        if (hue >= 30 && hue < 60) return 'orange';
        if (hue >= 60 && hue < 90) return 'yellow';
        if (hue >= 90 && hue < 150) return 'green';
        if (hue >= 150 && hue < 210) return 'cyan';
        if (hue >= 210 && hue < 270) return 'blue';
        if (hue >= 270 && hue < 330) return 'purple';
        return 'pink';
      }
    }

    // ===== ENHANCED SHAPE CLASS =====
    class QuiltShapeV2 {
      constructor(options = {}) {
        this.id = options.id || this.generateId();
        this.type = options.type || 'KEY_SHAPE';
        this.color = options.color || CONFIG.APP.defaultColor;
        this.position = options.position || { x: 0, y: 0, width: 1000, height: 1000 };
        this.parentId = options.parentId || null;
        this.contributorId = options.contributorId || null;
        this.submissionIndex = options.submissionIndex || 0;
        this.colorFamily = options.colorFamily || null;
        this.descendants = [];
      }
      
      generateId() {
        return 'shape_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }
      
      canSplit(direction) {
        if (direction === 'horizontal') {
          return this.position.height >= CONFIG.QUILT_V2.MIN_SHAPE_SIZE * 2;
        } else {
          return this.position.width >= CONFIG.QUILT_V2.MIN_SHAPE_SIZE * 2;
        }
      }
      
      getValidSplitDirections() {
        const directions = [];
        if (this.canSplit('horizontal')) directions.push('horizontal');
        if (this.canSplit('vertical')) directions.push('vertical');
        return directions;
      }
      
      split(newColor, direction, contributorId, submissionIndex) {
        if (!this.canSplit(direction)) {
          throw new Error(`Cannot split shape ${this.id} in ${direction} direction`);
        }

        const splitRatio = 0.3 + Math.random() * 0.4;
        let shape1, shape2;

        if (direction === 'horizontal') {
          const splitHeight = this.position.height * splitRatio;
          
          shape1 = new QuiltShapeV2({
            type: this.type,
            color: this.color,
            position: {
              x: this.position.x,
              y: this.position.y,
              width: this.position.width,
              height: splitHeight
            },
            parentId: this.id,
            contributorId: this.contributorId,
            submissionIndex: this.submissionIndex,
            colorFamily: this.colorFamily
          });

          shape2 = new QuiltShapeV2({
            type: this.type,
            color: newColor,
            position: {
              x: this.position.x,
              y: this.position.y + splitHeight,
              width: this.position.width,
              height: this.position.height - splitHeight
            },
            parentId: this.id,
            contributorId: contributorId,
            submissionIndex: submissionIndex,
            colorFamily: this.colorFamily
          });
        } else {
          const splitWidth = this.position.width * splitRatio;
          
          shape1 = new QuiltShapeV2({
            type: this.type,
            color: this.color,
            position: {
              x: this.position.x,
              y: this.position.y,
              width: splitWidth,
              height: this.position.height
            },
            parentId: this.id,
            contributorId: this.contributorId,
            submissionIndex: this.submissionIndex,
            colorFamily: this.colorFamily
          });

          shape2 = new QuiltShapeV2({
            type: this.type,
            color: newColor,
            position: {
              x: this.position.x + splitWidth,
              y: this.position.y,
              width: this.position.width - splitWidth,
              height: this.position.height
            },
            parentId: this.id,
            contributorId: contributorId,
            submissionIndex: submissionIndex,
            colorFamily: this.colorFamily
          });
        }

        this.descendants.push(shape2.id);
        
        return [shape1, shape2];
      }
      
      getAllDescendants(allShapes) {
        const descendants = [...this.descendants];
        this.descendants.forEach(descId => {
          const desc = allShapes.find(s => s.id === descId);
          if (desc) {
            descendants.push(...desc.getAllDescendants(allShapes));
          }
        });
        return descendants;
      }
    }

    // ===== SIMPLIFIED QUILT ENGINE (BETA) =====
    class SimpleQuiltEngine {
      constructor(userId = null) {
        this.blocks = [];
        this.submissionCount = 0;
        this.deviceId = userId || this.getOrCreateDeviceId();
      }
      
      getOrCreateDeviceId() {
        let deviceId = localStorage.getItem('quiltDeviceId');
        if (!deviceId) {
          deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('quiltDeviceId', deviceId);
        }
        return deviceId;
      }
  

      initialize() {
        // Use 4:5 dimensions from getQuiltDimensions
        const dimensions = Utils.getQuiltDimensions();
        const initialWidth = dimensions.width;
        const initialHeight = dimensions.height;
        
        
        this.blocks = [{
          id: 'initial',
          x: 0,
          y: 0,
          width: initialWidth,
          height: initialHeight,
          color: CONFIG.APP.defaultColor,
          contributorId: this.deviceId,
          submissionIndex: 0,
          patternType: 'regular'
        }];
        
        this.submissionCount = 0;
      }
      
      addSubmission() {
        this.submissionCount++;
        return this.submissionCount;
      }
      
      addColor(newColor) {
        this.submissionCount++;
        
        // Find blocks that can be split, prioritizing larger blocks
        // This prevents small blocks from being split when huge blocks are available
        const splittableBlocks = this.blocks.filter(block => {
          const blockArea = block.width * block.height;
          return blockArea > 1600; // 40√ó40 = 1600 square pixels minimum (much smaller)
        });
        
        // Sort by size (largest first) to prioritize splitting the biggest blocks
        splittableBlocks.sort((a, b) => (b.width * b.height) - (a.width * a.height));
        
        // Always split existing blocks - never add new blocks at edges
        if (splittableBlocks.length === 0) {
          // If no blocks meet the minimum size, just use all blocks
          const allBlocks = this.blocks.slice();
          allBlocks.sort((a, b) => (b.width * b.height) - (a.width * a.height));
          selectedBlock = allBlocks[0]; // Pick the largest available block
        }
        
        // Separate special pattern blocks from regular blocks
        // Handle backward compatibility: blocks without patternType are treated as regular
        const specialPatternBlocks = splittableBlocks.filter(block => 
          block.patternType === 'special' || 
          block.id.includes('_pattern_') ||
          block.originalPatternId // Blocks derived from special patterns
        );
        const regularBlocks = splittableBlocks.filter(block => 
          block.patternType === 'regular' || 
          (!block.patternType && !block.id.includes('_pattern_') && !block.originalPatternId)
        );
        let selectedBlock;
        
        // First priority: Check if we should split a special pattern block
        if (specialPatternBlocks.length > 0) {
          console.log(`üéØ PROTECTION: Found ${specialPatternBlocks.length} special pattern blocks to protect`);
          
          // Check if new color is very similar to any special pattern colors
          const hasSimilarColor = specialPatternBlocks.some(block => {
            const similarity = this.getColorSimilarity(block.color, newColor);
            return similarity > 0.90; // STRICT similar (90%+ similar) - OKLab-based pattern preservation threshold
          });
          
          if (hasSimilarColor) {
            console.log(`üéØ PROTECTION: Color ${newColor} is similar enough to special pattern colors - allowing split`);
            // Only then prioritize special pattern blocks to preserve pattern integrity
            const colorSimilarityScores = specialPatternBlocks.map(block => {
              const similarity = this.getColorSimilarity(block.color, newColor);
              return { block, similarity };
            });
            
            // Sort by HIGHEST similarity (most similar colors first) - preserve pattern
            colorSimilarityScores.sort((a, b) => b.similarity - a.similarity);
            
            // Pick from blocks with highest similarity (most similar colors)
            const topCount = Math.max(1, Math.floor(colorSimilarityScores.length * 0.3));
            const topBlocks = colorSimilarityScores.slice(0, topCount);
            selectedBlock = topBlocks[Math.floor(Math.random() * topBlocks.length)].block;
          } else {
            console.log(`üéØ PROTECTION: Color ${newColor} is NOT similar enough to special pattern colors - protecting special patterns from split`);
            console.log(`üéØ PROTECTION: Will now select from ${regularBlocks.length} regular blocks instead`);
          }
          // If no similar colors in special patterns, fall through to regular block logic
        }
        
        if (!selectedBlock) {
          // Special rules for pattern creation:
          // 1) Likelihood for splits 1-6 = 50%
          // 2) No two back-to-back special patterns
          // 3) After split 6, use 25% chance
          // 4) NEW: Reserve minimum 30% of blocks as regular (prevent all-special quilt)
          
          // Calculate current special pattern density
          const totalBlocks = this.blocks.length;
          const specialPatternCount = this.blocks.filter(block => 
            block.patternType === 'special' || 
            block.id.includes('_pattern_') ||
            block.originalPatternId
          ).length;
          const specialPatternDensity = specialPatternCount / totalBlocks;
          const minRegularDensity = 0.30; // Reserve 30% for regular blocks
          
          let shouldCreateSpecialPattern = false;
          
          // Rule 4: Check if we've hit the special pattern density limit
          if (specialPatternDensity >= (1 - minRegularDensity)) {
            shouldCreateSpecialPattern = false;
            console.log(`üéØ DENSITY LIMIT: Special pattern density ${(specialPatternDensity * 100).toFixed(1)}% >= ${((1 - minRegularDensity) * 100).toFixed(1)}% limit - must create regular block (rule 4)`);
          } else if (this.submissionCount >= 1 && this.submissionCount <= 6) {
            // Rule 2: Splits 2-6 have 50% chance
            // Rule 3: Check if previous split was special pattern
            // Special pattern blocks are created with the current submissionIndex, so we need to check for blocks
            // that were created in the previous submission (submissionIndex === this.submissionCount - 1)
            const wasLastSplitSpecialPattern = this.blocks.some(block => 
              block.submissionIndex === (this.submissionCount - 1) && 
              (block.patternType === 'special' || block.id.includes('_pattern_'))
            );
            
            // Debug: Log what blocks we're checking
            const previousBlocks = this.blocks.filter(block => block.submissionIndex === (this.submissionCount - 1));
            const previousSpecialBlocks = previousBlocks.filter(block => 
              block.patternType === 'special' || block.id.includes('_pattern_')
            );
            console.log(`üéØ DEBUG: Checking split ${this.submissionCount}, previous blocks: ${previousBlocks.length}, previous special blocks: ${previousSpecialBlocks.length}, wasLastSplitSpecialPattern: ${wasLastSplitSpecialPattern}`);
            
            // Debug: Log all blocks and their submissionIndex
            console.log(`üéØ DEBUG: All blocks:`, this.blocks.map(block => ({
              id: block.id,
              submissionIndex: block.submissionIndex,
              patternType: block.patternType,
              hasPattern: block.id.includes('_pattern_')
            })));
            
            // Debug: Log previous blocks in detail
            if (previousBlocks.length > 0) {
              console.log(`üéØ DEBUG: Previous blocks detail:`, previousBlocks.map(block => ({
                id: block.id,
                submissionIndex: block.submissionIndex,
                patternType: block.patternType,
                hasPattern: block.id.includes('_pattern_'),
                isSpecial: block.patternType === 'special' || block.id.includes('_pattern_')
              })));
            }
            
            // NEW RULE: If first split was special pattern, second split CANNOT be special
            if (this.submissionCount === 2) {
              const wasFirstSplitSpecialPattern = this.blocks.some(block => 
                block.submissionIndex === 1 && 
                (block.patternType === 'special' || block.id.includes('_pattern_'))
              );
              
              if (wasFirstSplitSpecialPattern) {
                shouldCreateSpecialPattern = false;
                console.log(`üéØ NO CONSECUTIVE SPECIAL: First split was special pattern, second split must be regular (new rule)`);
              } else {
                // Rule 1: 50% chance for splits 1-6
                shouldCreateSpecialPattern = Math.random() < 0.50;
                console.log(`üéØ SPLIT 2: ${shouldCreateSpecialPattern ? 'Creating' : 'Not creating'} special pattern (50% chance, rule 1)`);
              }
            } else if (wasLastSplitSpecialPattern) {
              // Rule 3: No back-to-back special patterns
              shouldCreateSpecialPattern = false;
              console.log(`üéØ NO BACK-TO-BACK: Previous split was special pattern (rule 3)`);
            } else {
              // Rule 1: 50% chance for splits 1-6
              shouldCreateSpecialPattern = Math.random() < 0.50;
              console.log(`üéØ SPLITS 1-6: ${shouldCreateSpecialPattern ? 'Creating' : 'Not creating'} special pattern (50% chance, rule 1)`);
            }
          } else {
            // After split 6: 25% chance
            shouldCreateSpecialPattern = Math.random() < 0.25;
            console.log(`üéØ AFTER SPLIT 6: ${shouldCreateSpecialPattern ? 'Creating' : 'Not creating'} special pattern (25% chance)`);
          }
          
          if (shouldCreateSpecialPattern) {
            console.log(`üéØ NEW PATTERN: Creating new special pattern`);
            
            // For special patterns, only consider regular blocks and find the most CONTRASTING color
            const colorContrastScores = regularBlocks.map(block => {
              const similarity = this.getColorSimilarity(block.color, newColor);
              return { block, similarity };
            });
            
            // Sort by LOWEST similarity (most contrasting colors first)
            colorContrastScores.sort((a, b) => a.similarity - b.similarity);
            
            
            // Pick from blocks with lowest similarity (most contrasting colors)
            const topCount = Math.max(1, Math.floor(colorContrastScores.length * 0.3));
            const topBlocks = colorContrastScores.slice(0, topCount);
            
            // Safety check: if no regular blocks available, fall back to regular block selection
            if (topBlocks.length === 0) {
              console.log(`üéØ NO REGULAR BLOCKS: Falling back to regular block selection`);
              selectedBlock = null; // Will trigger regular block selection below
            } else {
              selectedBlock = topBlocks[Math.floor(Math.random() * topBlocks.length)].block;
              // Mark this block for special pattern creation
              selectedBlock._shouldCreateSpecialPattern = true;
            }
          } else {
            // Logging is already handled in the conditional blocks above
            // Regular splitting for regular blocks only - no color restrictions
            // Size-based selection: pick from largest blocks most of the time
            
            // Safety check: ensure we have regular blocks to work with
            if (regularBlocks.length === 0) {
              console.log(`üéØ NO REGULAR BLOCKS: No regular blocks available for selection`);
              selectedBlock = null; // Will trigger fallback logic
            } else {
              const topCount = Math.max(1, Math.floor(regularBlocks.length * 0.2)); // Top 20% largest
              const largestBlocks = regularBlocks.slice(0, topCount);
              
              // 90% chance to pick from largest blocks, 10% chance for variety
              if (Math.random() < 0.9 && largestBlocks.length > 0) {
                selectedBlock = largestBlocks[Math.floor(Math.random() * largestBlocks.length)];
                if (selectedBlock) {
                  console.log(`üéØ REGULAR SELECTION: Selected from largest blocks (${largestBlocks.length} blocks) - chosen: ${selectedBlock.id} (${selectedBlock.width.toFixed(1)}x${selectedBlock.height.toFixed(1)})`);
                } else {
                  console.log(`üéØ REGULAR SELECTION: Selected from largest blocks but got undefined block`);
                }
              } else {
                // Small chance to pick from any block for variety
                selectedBlock = regularBlocks[Math.floor(Math.random() * regularBlocks.length)];
                if (selectedBlock) {
                  console.log(`üéØ REGULAR SELECTION: Selected from all regular blocks (${regularBlocks.length} blocks) - chosen: ${selectedBlock.id} (${selectedBlock.width.toFixed(1)}x${selectedBlock.height.toFixed(1)})`);
                } else {
                  console.log(`üéØ REGULAR SELECTION: Selected from all regular blocks but got undefined block`);
                }
              }
            }
          }
        }
        
        // Fallback to random if something goes wrong
        if (!selectedBlock) {
          console.log(`üéØ FALLBACK: No block selected, using random fallback from ${regularBlocks.length} regular blocks (protecting ${specialPatternBlocks.length} special pattern blocks)`);
          if (regularBlocks.length > 0) {
            selectedBlock = regularBlocks[Math.floor(Math.random() * regularBlocks.length)];
          } else {
            console.log(`üéØ FALLBACK: No regular blocks available - cannot add color without breaking special patterns`);
            return; // Don't add the color if it would break special patterns
          }
        }
        
        
        const splitResult = this.splitBlock(selectedBlock, newColor);
        
        // Debug: Log the split result
        console.log(`üîß SPLIT RESULT: Block ${selectedBlock.id} split into ${splitResult.length} blocks:`, splitResult.map(b => b.id));
        
        // Replace the original block with the split result
        const blockIndex = this.blocks.findIndex(b => b.id === selectedBlock.id);
        const beforeCount = this.blocks.length;
        this.blocks.splice(blockIndex, 1, ...splitResult);
        const afterCount = this.blocks.length;
        
        console.log(`üîß BLOCK COUNT: Before: ${beforeCount}, After: ${afterCount}, Net change: ${afterCount - beforeCount}`);
        
        // Record user contribution - handle different split result sizes
        if (splitResult.length >= 2) {
          this.recordUserContribution(splitResult[1].id, newColor, this.submissionCount);
        } else if (splitResult.length === 1) {
          this.recordUserContribution(splitResult[0].id, newColor, this.submissionCount);
        }
        
        return {
          originalBlock: selectedBlock,
          newBlocks: splitResult,
          submissionIndex: this.submissionCount
        };
      }
      
      // Regular splitting logic without pattern creation (prevents recursion)
      performRegularSplit(block, newColor) {
        const isWider = block.width > block.height;
        const splitDirection = isWider ? 'vertical' : 'horizontal';
        
        // Define size constraints for more controlled variety
        const minBlockSize = 80; // Increased minimum to prevent tiny blocks
        const maxBlockSize = 300; // Increased maximum for better variety
        
        if (splitDirection === 'horizontal') {
          // More balanced split: 40-60% instead of 30-70%
          const splitRatio = 0.4 + Math.random() * 0.2; // 40-60%
          let splitHeight = block.height * splitRatio;
          
          // Ensure both resulting blocks meet size constraints
          if (splitHeight < minBlockSize) splitHeight = minBlockSize;
          if (block.height - splitHeight < minBlockSize) splitHeight = block.height - minBlockSize;
          
          // Final safety check: ensure splitHeight is valid
          if (splitHeight <= 0 || splitHeight >= block.height) {
            // If constraints create invalid split, use 50/50 split
            splitHeight = block.height / 2;
          }
          
          const originalPatternId = block.originalPatternId || (block.patternType === 'special' ? block.id : undefined);
          if (originalPatternId) {
            console.log(`üéØ INHERITANCE: Block ${block.id} splitting - child blocks will inherit originalPatternId: ${originalPatternId}`);
          }
          
          const block1 = {
            ...block,
            id: block.id + '_1',
            height: splitHeight,
            // Preserve special pattern properties
            originalPatternId: originalPatternId,
            patternType: block.patternType,
            specialPatternType: block.specialPatternType
          };
          
          const block2 = {
            ...block,
            id: block.id + '_2',
            y: block.y + splitHeight,
            height: block.height - splitHeight,
            color: newColor,
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount,
            // Preserve special pattern properties
            originalPatternId: originalPatternId,
            patternType: block.patternType,
            specialPatternType: block.specialPatternType
          };
          
          console.log(`üîß REGULAR SPLIT: Block ${block.id} split into 2 blocks: ${block1.id}, ${block2.id}`);
          console.log(`üîß BLOCK1: x=${block1.x}, y=${block1.y}, w=${block1.width}, h=${block1.height}, color=${block1.color}`);
          console.log(`üîß BLOCK2: x=${block2.x}, y=${block2.y}, w=${block2.width}, h=${block2.height}, color=${block2.color}`);
          return [block1, block2];
        } else {
          // More balanced split: 40-60% instead of 30-70%
          const splitRatio = 0.4 + Math.random() * 0.2; // 40-60%
          let splitWidth = block.width * splitRatio;
          
          // Ensure both resulting blocks meet size constraints
          if (splitWidth < minBlockSize) splitWidth = minBlockSize;
          if (block.width - splitWidth < minBlockSize) splitWidth = block.width - minBlockSize;
          
          // Final safety check: ensure splitWidth is valid
          if (splitWidth <= 0 || splitWidth >= block.width) {
            // If constraints create invalid split, use 50/50 split
            splitWidth = block.width / 2;
          }
          
          const originalPatternId = block.originalPatternId || (block.patternType === 'special' ? block.id : undefined);
          if (originalPatternId) {
            console.log(`üéØ INHERITANCE: Block ${block.id} splitting - child blocks will inherit originalPatternId: ${originalPatternId}`);
          }
          
          const block1 = {
            ...block,
            id: block.id + '_1',
            width: splitWidth,
            // Preserve special pattern properties
            originalPatternId: originalPatternId,
            patternType: block.patternType,
            specialPatternType: block.specialPatternType
          };
          
          const block2 = {
            ...block,
            id: block.id + '_2',
            x: block.x + splitWidth,
            width: block.width - splitWidth,
            color: newColor,
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount,
            // Preserve special pattern properties
            originalPatternId: originalPatternId,
            patternType: block.patternType,
            specialPatternType: block.specialPatternType
          };
          
          console.log(`üîß REGULAR SPLIT: Block ${block.id} split into 2 blocks: ${block1.id}, ${block2.id}`);
          console.log(`üîß BLOCK1: x=${block1.x}, y=${block1.y}, w=${block1.width}, h=${block1.height}, color=${block1.color}`);
          console.log(`üîß BLOCK2: x=${block2.x}, y=${block2.y}, w=${block2.width}, h=${block2.height}, color=${block2.color}`);
          return [block1, block2];
        }
      }
      
      splitBlock(block, newColor) {
        // Debug: Track special pattern flag state
        if (block._shouldCreateSpecialPattern) {
          console.log(`üéØ SPLIT: Block ${block.id} has special pattern flag - creating special pattern`);
        }
        
        // Never create special patterns on the first split - let the quilt develop naturally
        if (this.submissionCount <= 1) {
          return this.performRegularSplit(block, newColor);
        }
        
        // Check if this block is part of a special pattern
        const isSpecialPatternBlock = block.patternType === 'special';
        
        if (isSpecialPatternBlock) {
          // For existing special pattern blocks, require VERY SIMILAR colors to preserve pattern
          const colorSimilarity = this.getColorSimilarity(block.color, newColor);
          if (colorSimilarity > 0.90) {
            console.log(`üéØ NO NESTED PATTERNS: Special pattern block ${block.id} has similar color (${colorSimilarity.toFixed(3)}) - using regular split to prevent nested patterns`);
            return this.performRegularSplit(block, newColor);
          }
        } else if (block._shouldCreateSpecialPattern) {
          // This block was selected for special pattern creation in addColor()
          console.log(`üéØ SPECIAL: Creating special pattern for ${block.id} (${block.color}) with ${newColor}`);
          // Clean up the flag
          delete block._shouldCreateSpecialPattern;
          return this.createSpecialPattern(block, newColor);
        }
        
        // If no pattern is created, perform regular split
        return this.performRegularSplit(block, newColor);
      }
      
      createSpecialPattern(block, newColor) {
        // Generic pattern creation system
        // Select which pattern type to create based on block characteristics and randomness
        
        const blockArea = block.width * block.height;
        const availablePatterns = this.getAvailablePatterns(block, newColor);
        
        if (availablePatterns.length === 0) {
          console.log(`üéØ NO PATTERNS: No suitable patterns available for block ${block.id} - falling back to regular split`);
          return this.performRegularSplit(block, newColor);
        }
        
        // Select pattern type (currently only checkerboard, but extensible)
        const selectedPatternType = this.selectPatternType(availablePatterns, block, newColor);
        
        console.log(`üéØ PATTERN SELECTION: Creating ${selectedPatternType} pattern for block ${block.id}`);
        
        // Create the selected pattern
        switch (selectedPatternType) {
          case 'checkerboard':
            return this.createOrganicCheckerboard(block, newColor);
          case 'stripes':
            return this.createOrganicStripes(block, newColor);
          case 'logcabin':
            return this.createLogCabin(block, newColor);
          case 'framed':
            return this.createFramedPattern(block, newColor);
          case 'railfence':
            return this.createRailFencePattern(block, newColor);
          case 'cross':
            return this.createCrossPattern(block, newColor);
          // Future patterns can be added here:
          // case 'dots':
          //   return this.createDotsPattern(block, newColor);
          default:
            console.log(`üéØ UNKNOWN PATTERN: ${selectedPatternType} not implemented - falling back to regular split`);
            return this.performRegularSplit(block, newColor);
        }
      }
      
      getAvailablePatterns(block, newColor) {
        // Determine which patterns are suitable for this block
        const blockArea = block.width * block.height;
        const minSpecialPatternArea = 50000; // 50,000 square pixels minimum for special patterns
        
        const availablePatterns = [];
        
        // All special patterns require blocks of 50,000 square pixels or larger
        if (blockArea >= minSpecialPatternArea) {
          // Checkerboard is available for large blocks
          const minBlockSize = 20;
          const avgCellSize = Math.sqrt(blockArea) / 2; // Rough estimate for 2x2 grid
          if (avgCellSize >= minBlockSize) {
            availablePatterns.push('checkerboard');
          }
          
          // Stripes pattern is available for large blocks with good aspect ratio
          if (block.width > 80 && block.height > 80) {
            availablePatterns.push('stripes');
          }
          
          // Log Cabin pattern is available for large blocks (needs more space for spiral)
          if (block.width > 120 && block.height > 120) {
            availablePatterns.push('logcabin');
          }
          
          // Framed pattern is available for medium-large blocks
          if (block.width > 60 && block.height > 60) {
            availablePatterns.push('framed');
          }
          
          // Rail Fence pattern is available for large blocks (needs space for 2x2 quadrants with 3 strips each)
          // Also requires square-ish aspect ratio (not too rectangular)
          if (block.width > 100 && block.height > 100) {
            const aspectRatio = Math.max(block.width, block.height) / Math.min(block.width, block.height);
            if (aspectRatio <= 1.5) { // Max 1.5:1 ratio (e.g., 150x100 is OK, 200x100 is not)
              availablePatterns.push('railfence');
            }
          }
          
          // Cross pattern is available for large blocks (needs space for 3x3 grid)
          // Also requires square-ish aspect ratio (not too rectangular)
          if (block.width > 90 && block.height > 90) {
            const aspectRatio = Math.max(block.width, block.height) / Math.min(block.width, block.height);
            if (aspectRatio <= 1.5) { // Max 1.5:1 ratio (e.g., 150x100 is OK, 200x100 is not)
              availablePatterns.push('cross');
            }
          }
        }
        
        return availablePatterns;
      }
      
      selectPatternType(availablePatterns, block, newColor) {
        // Select which pattern type to create
        // Currently simple - just pick the first available (checkerboard)
        // Future: could add weighted selection, color-based selection, etc.
        
        if (availablePatterns.length === 1) {
          return availablePatterns[0];
        }
        
        
        // Randomly select between available patterns for variety
        const randomIndex = Math.floor(Math.random() * availablePatterns.length);
        return availablePatterns[randomIndex];
      }
      
      createOrganicCheckerboard(block, newColor) {
        // Create a 2x2 organic checkerboard pattern
        // Each square will have slightly irregular edges to maintain the hand-cut vibe
        
        const minBlockSize = 20; // Further reduced minimum size to allow smaller checkerboards
        const blockArea = block.width * block.height;
        
        // Determine grid size based on block area
        let gridSize = 2; // Default to 2x2
        if (blockArea > 15000) gridSize = 3; // 3x3 for very large blocks
        if (blockArea > 25000) gridSize = 4; // 4x4 for extremely large blocks
        
        // Generate variable column widths and row heights for organic feel
        const columnWidths = this.generateVariableDimensions(block.width, gridSize);
        const rowHeights = this.generateVariableDimensions(block.height, gridSize);
        
        // Calculate average cell size for minimum size check
        const avgCellWidth = block.width / gridSize;
        const avgCellHeight = block.height / gridSize;
        
        // Ensure minimum cell size - if cells would be too small, don't create checkerboard
        if (avgCellWidth < minBlockSize || avgCellHeight < minBlockSize) {
          // Fall back to regular split instead of tiny checkerboard (avoid recursion)
          return this.performRegularSplit(block, newColor);
        }
        
        const cells = [];
        const colors = [block.color, newColor]; // Alternate between original and new color
        
        // Calculate cumulative positions for variable dimensions
        const columnPositions = [0];
        const rowPositions = [0];
        
        for (let i = 0; i < gridSize; i++) {
          columnPositions.push(columnPositions[i] + columnWidths[i]);
          rowPositions.push(rowPositions[i] + rowHeights[i]);
        }
        
        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const cellIndex = row * gridSize + col;
            const colorIndex = (row + col) % 2; // Checkerboard pattern
            
            // Use variable dimensions for this cell
            const cellWidth = columnWidths[col];
            const cellHeight = rowHeights[row];
            
            // Add very subtle randomness to cell boundaries for organic feel
            // Reduce jitter for smaller cells to prevent gaps and negative dimensions
            const jitterMultiplier = Math.min(0.05, 20 / Math.min(cellWidth, cellHeight)); // Smaller cells = less jitter (increased for organic feel)
            const jitterX = (Math.random() - 0.5) * jitterMultiplier;
            const jitterY = (Math.random() - 0.5) * jitterMultiplier;
            
            // Calculate cell dimensions with jitter, ensuring they remain positive
            const jitteredWidth = cellWidth * (1 + jitterX * 2);
            const jitteredHeight = cellHeight * (1 + jitterY * 2);
            
            // Ensure minimum positive dimensions to prevent SVG errors
            const finalWidth = Math.max(1, jitteredWidth);
            const finalHeight = Math.max(1, jitteredHeight);
            
            // Calculate cell position using variable dimensions
            const cellX = block.x + columnPositions[col] + (jitterX * cellWidth);
            const cellY = block.y + rowPositions[row] + (jitterY * cellHeight);
            
            // Allow cells to extend slightly beyond block boundaries for organic edges
            const boundaryBuffer = Math.min(block.width, block.height) * 0.02; // 2% of smallest dimension
            const finalX = Math.max(block.x - boundaryBuffer, Math.min(cellX, block.x + block.width - finalWidth + boundaryBuffer));
            const finalY = Math.max(block.y - boundaryBuffer, Math.min(cellY, block.y + block.height - finalHeight + boundaryBuffer));
            
            // Ensure minimum positive dimensions to prevent SVG errors
            
            const cell = {
              id: block.id + '_pattern_checkerboard_' + cellIndex,
              x: finalX,
              y: finalY,
              width: finalWidth,
              height: finalHeight,
              color: colors[colorIndex],
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'checkerboard',
              originalPatternId: block.id
            };
            
            cells.push(cell);
          }
        }
        
        console.log(`üîß CHECKERBOARD: Created ${cells.length} cells for block ${block.id}`);
        return cells;
      }
      
      generateVariableDimensions(totalSize, gridSize) {
        // Generate varied dimensions that sum to totalSize
        // Each dimension will be within ¬±25% of the average size for more organic variation
        const averageSize = totalSize / gridSize;
        const variationRange = averageSize * 0.25; // ¬±25% variation (increased from ¬±15%)
        
        const dimensions = [];
        let remainingSize = totalSize;
        
        // Generate all but the last dimension with variation
        for (let i = 0; i < gridSize - 1; i++) {
          const variation = (Math.random() - 0.5) * 2 * variationRange;
          const dimension = Math.max(averageSize * 0.5, averageSize + variation);
          dimensions.push(dimension);
          remainingSize -= dimension;
        }
        
        // The last dimension gets whatever is left to ensure total equals totalSize
        dimensions.push(Math.max(averageSize * 0.5, remainingSize));
        
        return dimensions;
      }
      
      createOrganicStripes(block, newColor) {
        // Create organic stripes pattern with variable column/row widths
        // Stripes can be either horizontal or vertical based on block aspect ratio
        
        const minBlockSize = 20;
        const blockArea = block.width * block.height;
        
        // Determine if stripes should be horizontal or vertical based on aspect ratio
        const aspectRatio = block.width / block.height;
        const isHorizontal = aspectRatio > 1.2; // Wider blocks get horizontal stripes
        const isVertical = aspectRatio < 0.8;   // Taller blocks get vertical stripes
        const isSquare = !isHorizontal && !isVertical; // Square blocks get random orientation
        
        // Choose stripe orientation
        let stripeOrientation;
        if (isSquare) {
          stripeOrientation = Math.random() < 0.5 ? 'horizontal' : 'vertical';
        } else if (isHorizontal) {
          stripeOrientation = 'horizontal';
        } else {
          stripeOrientation = 'vertical';
        }
        
        // Determine number of stripes based on block size (max 4 stripes)
        let numStripes = 3; // Default to 3 stripes
        if (blockArea > 20000) numStripes = 4;
        // Cap at 4 stripes maximum
        numStripes = Math.min(numStripes, 4);
        
        const cells = [];
        const colors = [block.color, newColor]; // Alternate between original and new color
        
        if (stripeOrientation === 'horizontal') {
          // Create horizontal stripes with variable heights
          const stripeHeights = this.generateVariableDimensions(block.height, numStripes);
          
          // Calculate cumulative positions for variable heights
          const stripePositions = [0];
          for (let i = 0; i < numStripes; i++) {
            stripePositions.push(stripePositions[i] + stripeHeights[i]);
          }
          
          for (let i = 0; i < numStripes; i++) {
            const colorIndex = i % 2; // Alternate colors
            
            // Add subtle jitter to stripe boundaries
            const jitterMultiplier = Math.min(0.05, 20 / Math.min(block.width, stripeHeights[i]));
            const jitterY = (Math.random() - 0.5) * jitterMultiplier;
            
            // Calculate stripe dimensions with jitter
            const jitteredHeight = stripeHeights[i] * (1 + jitterY * 2);
            const finalHeight = Math.max(1, jitteredHeight);
            
            // Calculate stripe position with organic edge variation
            const stripeY = block.y + stripePositions[i] + (jitterY * stripeHeights[i]);
            const boundaryBuffer = Math.min(block.width, block.height) * 0.02; // 2% of smallest dimension
            const finalY = Math.max(block.y - boundaryBuffer, Math.min(stripeY, block.y + block.height - finalHeight + boundaryBuffer));
            
            const cell = {
              id: block.id + '_pattern_stripes_' + i,
              x: block.x - boundaryBuffer,
              y: finalY,
              width: block.width + (boundaryBuffer * 2),
              height: finalHeight,
              color: colors[colorIndex],
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'stripes',
              originalPatternId: block.id
            };
            
            cells.push(cell);
          }
        } else {
          // Create vertical stripes with variable widths
          const stripeWidths = this.generateVariableDimensions(block.width, numStripes);
          
          // Calculate cumulative positions for variable widths
          const stripePositions = [0];
          for (let i = 0; i < numStripes; i++) {
            stripePositions.push(stripePositions[i] + stripeWidths[i]);
          }
          
          for (let i = 0; i < numStripes; i++) {
            const colorIndex = i % 2; // Alternate colors
            
            // Add subtle jitter to stripe boundaries
            const jitterMultiplier = Math.min(0.05, 20 / Math.min(stripeWidths[i], block.height));
            const jitterX = (Math.random() - 0.5) * jitterMultiplier;
            
            // Calculate stripe dimensions with jitter
            const jitteredWidth = stripeWidths[i] * (1 + jitterX * 2);
            const finalWidth = Math.max(1, jitteredWidth);
            
            // Calculate stripe position with organic edge variation
            const stripeX = block.x + stripePositions[i] + (jitterX * stripeWidths[i]);
            const boundaryBuffer = Math.min(block.width, block.height) * 0.02; // 2% of smallest dimension
            const finalX = Math.max(block.x - boundaryBuffer, Math.min(stripeX, block.x + block.width - finalWidth + boundaryBuffer));
            
            const cell = {
              id: block.id + '_pattern_stripes_' + i,
              x: finalX,
              y: block.y - boundaryBuffer,
              width: finalWidth,
              height: block.height + (boundaryBuffer * 2),
              color: colors[colorIndex],
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'stripes',
              originalPatternId: block.id
            };
            
            cells.push(cell);
          }
        }
        
        return cells;
      }
      
      createLogCabin(block, newColor) {
        // Create Log Cabin pattern with proper spiral construction
        // Classic Log Cabin: center square + 8 strips in counterclockwise spiral
        // Must fill the entire original block dimensions
        
        // Generate 5-color palette from the 2 input colors
        const colorPalette = this.generateColorPalette(block.color, newColor, 5);
        
        const cells = [];
        
        // Calculate dimensions to fill the entire block
        // For a Log Cabin with 8 strips, we need to work backwards from the final size
        // Each strip adds to the building area, so we need to calculate strip thickness
        // to ensure the final Log Cabin fills the entire block
        
        // Calculate how much space we have for strips on each side
        const availableWidth = block.width;
        const availableHeight = block.height;
        
        // For 8 strips in spiral: 2 strips per side (right, up, left, down, right, up, left, down)
        // Each side gets 2 strips, so we divide by 4 (sides) * 2 (strips per side) = 8 total strips
        const stripThickness = Math.min(availableWidth, availableHeight) / 6; // 6 gives us good proportions
        
        // Center square should be about 2x strip thickness
        const centerSize = stripThickness * 2;
        const centerX = block.x + (block.width - centerSize) / 2;
        const centerY = block.y + (block.height - centerSize) / 2;
        
        // Create center square (Piece 1)
        const centerCell = {
          id: block.id + '_pattern_logcabin_1',
          x: centerX,
          y: centerY,
          width: centerSize,
          height: centerSize,
          color: colorPalette[0], // Use first color for center
          contributorId: this.deviceId,
          submissionIndex: this.submissionCount,
          patternType: 'special',
          specialPatternType: 'logcabin',
          originalPatternId: block.id
        };
        cells.push(centerCell);
        
        // Track the current "building area" - starts as just the center square
        let buildingLeft = centerX;
        let buildingTop = centerY;
        let buildingRight = centerX + centerSize;
        let buildingBottom = centerY + centerSize;
        
        // Add subtle jitter
        const jitterMultiplier = 0.05;
        
        // Create 8 strips in spiral order: Right, Up, Left, Down, Right, Up, Left, Down
        const stripSequence = [
          { side: 'right', colorIndex: 1 },
          { side: 'up', colorIndex: 2 },
          { side: 'left', colorIndex: 3 },
          { side: 'down', colorIndex: 4 },
          { side: 'right', colorIndex: 1 },
          { side: 'up', colorIndex: 2 },
          { side: 'left', colorIndex: 3 },
          { side: 'down', colorIndex: 4 }
        ];
        
        for (let i = 0; i < stripSequence.length; i++) {
          const { side, colorIndex } = stripSequence[i];
          let stripX, stripY, stripWidth, stripHeight;
          
          // Add jitter
          const jitterX = (Math.random() - 0.5) * jitterMultiplier * stripThickness;
          const jitterY = (Math.random() - 0.5) * jitterMultiplier * stripThickness;
          
          switch (side) {
            case 'right':
              // Add strip to the right side
              stripX = buildingRight + jitterX;
              stripY = buildingTop + jitterY;
              stripWidth = stripThickness;
              stripHeight = buildingBottom - buildingTop;
              // Expand building area to include this strip
              buildingRight += stripThickness;
              break;
              
            case 'up':
              // Add strip to the top
              stripX = buildingLeft + jitterX;
              stripY = buildingTop - stripThickness + jitterY;
              stripWidth = buildingRight - buildingLeft;
              stripHeight = stripThickness;
              // Expand building area to include this strip
              buildingTop -= stripThickness;
              break;
              
            case 'left':
              // Add strip to the left side
              stripX = buildingLeft - stripThickness + jitterX;
              stripY = buildingTop + jitterY;
              stripWidth = stripThickness;
              stripHeight = buildingBottom - buildingTop;
              // Expand building area to include this strip
              buildingLeft -= stripThickness;
              break;
              
            case 'down':
              // Add strip to the bottom
              stripX = buildingLeft + jitterX;
              stripY = buildingBottom + jitterY;
              stripWidth = buildingRight - buildingLeft;
              stripHeight = stripThickness;
              // Expand building area to include this strip
              buildingBottom += stripThickness;
              break;
          }
          
          // Ensure positive dimensions
          stripWidth = Math.max(1, stripWidth);
          stripHeight = Math.max(1, stripHeight);
          
          // Ensure strip stays within block boundaries
          stripX = Math.max(block.x, Math.min(stripX, block.x + block.width - stripWidth));
          stripY = Math.max(block.y, Math.min(stripY, block.y + block.height - stripHeight));
          
          const strip = {
            id: block.id + '_pattern_logcabin_' + (i + 2), // Start from piece 2
            x: stripX,
            y: stripY,
            width: stripWidth,
            height: stripHeight,
            color: colorPalette[colorIndex % colorPalette.length],
            contributorId: this.deviceId,
            submissionIndex: this.submissionCount,
            patternType: 'special',
            specialPatternType: 'logcabin',
            originalPatternId: block.id
          };
          
          cells.push(strip);
        }
        
        // Add spacer blocks to fill any remaining space
        // Check if we need to fill gaps on the left or right sides
        const finalLeft = buildingLeft;
        const finalRight = buildingRight;
        const finalTop = buildingTop;
        const finalBottom = buildingBottom;
        
        // Fill left gap if needed
        if (finalLeft > block.x) {
          const leftGapWidth = finalLeft - block.x;
          if (leftGapWidth > 1) { // Only add if gap is significant
            const spacerLeft = {
              id: block.id + '_pattern_logcabin_spacer_left',
              x: block.x,
              y: finalTop,
              width: leftGapWidth,
              height: finalBottom - finalTop,
              color: colorPalette[0], // Use first color for spacers
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'logcabin',
              originalPatternId: block.id
            };
            cells.push(spacerLeft);
          }
        }
        
        // Fill right gap if needed
        if (finalRight < block.x + block.width) {
          const rightGapWidth = (block.x + block.width) - finalRight;
          if (rightGapWidth > 1) { // Only add if gap is significant
            const spacerRight = {
              id: block.id + '_pattern_logcabin_spacer_right',
              x: finalRight,
              y: finalTop,
              width: rightGapWidth,
              height: finalBottom - finalTop,
              color: colorPalette[1], // Use second color for spacers
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'logcabin',
              originalPatternId: block.id
            };
            cells.push(spacerRight);
          }
        }
        
        // Fill top gap if needed
        if (finalTop > block.y) {
          const topGapHeight = finalTop - block.y;
          if (topGapHeight > 1) { // Only add if gap is significant
            const spacerTop = {
              id: block.id + '_pattern_logcabin_spacer_top',
              x: finalLeft,
              y: block.y,
              width: finalRight - finalLeft,
              height: topGapHeight,
              color: colorPalette[2], // Use third color for spacers
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'logcabin',
              originalPatternId: block.id
            };
            cells.push(spacerTop);
          }
        }
        
        // Fill bottom gap if needed
        if (finalBottom < block.y + block.height) {
          const bottomGapHeight = (block.y + block.height) - finalBottom;
          if (bottomGapHeight > 1) { // Only add if gap is significant
            const spacerBottom = {
              id: block.id + '_pattern_logcabin_spacer_bottom',
              x: finalLeft,
              y: finalBottom,
              width: finalRight - finalLeft,
              height: bottomGapHeight,
              color: colorPalette[3], // Use fourth color for spacers
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'logcabin',
              originalPatternId: block.id
            };
            cells.push(spacerBottom);
          }
        }
        
        return cells;
      }
      
      createFramedPattern(block, newColor) {
        // Create a framed pattern: outer frame with inner square
        // Frame thickness is 15% of the smaller dimension
        
        const frameThickness = Math.min(block.width, block.height) * 0.15;
        const innerSize = Math.min(block.width, block.height) - (frameThickness * 2);
        
        // Center the inner square
        const innerX = block.x + (block.width - innerSize) / 2;
        const innerY = block.y + (block.height - innerSize) / 2;
        
        // Generate color palette for frame and inner square
        const colorPalette = this.generateColorPalette(block.color, newColor, 2);
        
        // Add jitter for organic feel
        const jitterMultiplier = 0.05;
        
        const cells = [];
        
        // Create outer frame (4 rectangular pieces)
        const frameJitterX = (Math.random() - 0.5) * jitterMultiplier * frameThickness;
        const frameJitterY = (Math.random() - 0.5) * jitterMultiplier * frameThickness;
        
        // Top frame
        const topFrame = {
          id: block.id + '_pattern_framed_top',
          x: block.x + frameJitterX,
          y: block.y + frameJitterY,
          width: block.width,
          height: frameThickness,
          color: colorPalette[0],
          contributorId: this.deviceId,
          submissionIndex: this.submissionCount,
          patternType: 'special',
          specialPatternType: 'framed',
          originalPatternId: block.id
        };
        cells.push(topFrame);
        
        // Bottom frame
        const bottomFrame = {
          id: block.id + '_pattern_framed_bottom',
          x: block.x + frameJitterX,
          y: block.y + block.height - frameThickness + frameJitterY,
          width: block.width,
          height: frameThickness,
          color: colorPalette[0],
          contributorId: this.deviceId,
          submissionIndex: this.submissionCount,
          patternType: 'special',
          specialPatternType: 'framed',
          originalPatternId: block.id
        };
        cells.push(bottomFrame);
        
        // Left frame
        const leftFrame = {
          id: block.id + '_pattern_framed_left',
          x: block.x + frameJitterX,
          y: block.y + frameThickness + frameJitterY,
          width: frameThickness,
          height: block.height - (frameThickness * 2),
          color: colorPalette[0],
          contributorId: this.deviceId,
          submissionIndex: this.submissionCount,
          patternType: 'special',
          specialPatternType: 'framed',
          originalPatternId: block.id
        };
        cells.push(leftFrame);
        
        // Right frame
        const rightFrame = {
          id: block.id + '_pattern_framed_right',
          x: block.x + block.width - frameThickness + frameJitterX,
          y: block.y + frameThickness + frameJitterY,
          width: frameThickness,
          height: block.height - (frameThickness * 2),
          color: colorPalette[0],
          contributorId: this.deviceId,
          submissionIndex: this.submissionCount,
          patternType: 'special',
          specialPatternType: 'framed',
          originalPatternId: block.id
        };
        cells.push(rightFrame);
        
        // Create inner rectangle that fills the entire frame area
        const innerJitterX = (Math.random() - 0.5) * jitterMultiplier * frameThickness;
        const innerJitterY = (Math.random() - 0.5) * jitterMultiplier * frameThickness;
        
        const innerRectangle = {
          id: block.id + '_pattern_framed_inner',
          x: block.x + frameThickness + innerJitterX,
          y: block.y + frameThickness + innerJitterY,
          width: block.width - (frameThickness * 2),
          height: block.height - (frameThickness * 2),
          color: colorPalette[1],
          contributorId: this.deviceId,
          submissionIndex: this.submissionCount,
          patternType: 'special',
          specialPatternType: 'framed',
          originalPatternId: block.id
        };
        cells.push(innerRectangle);
        
        return cells;
      }
      
      createRailFencePattern(block, newColor) {
        // Create a rail fence pattern: 2x2 quadrants, each with 3 parallel strips
        // Alternating orientations create pinwheel effect
        
        // Generate 3-color palette
        const colorPalette = this.generateColorPalette(block.color, newColor, 3);
        
        // Calculate quadrant dimensions
        const quadrantWidth = block.width / 2;
        const quadrantHeight = block.height / 2;
        
        // Add jitter for organic feel
        const jitterMultiplier = 0.05;
        
        const cells = [];
        
        // Define quadrants with their orientations
        const quadrants = [
          { name: 'top-left', x: block.x, y: block.y, orientation: 'vertical' },
          { name: 'top-right', x: block.x + quadrantWidth, y: block.y, orientation: 'horizontal' },
          { name: 'bottom-left', x: block.x, y: block.y + quadrantHeight, orientation: 'horizontal' },
          { name: 'bottom-right', x: block.x + quadrantWidth, y: block.y + quadrantHeight, orientation: 'vertical' }
        ];
        
        quadrants.forEach((quadrant, quadrantIndex) => {
          // Generate variable strip dimensions
          let stripDimensions;
          if (quadrant.orientation === 'vertical') {
            // Vertical strips: variable widths, fixed height
            stripDimensions = this.generateVariableDimensions(quadrantWidth, 3);
          } else {
            // Horizontal strips: fixed width, variable heights
            stripDimensions = this.generateVariableDimensions(quadrantHeight, 3);
          }
          
          // Calculate cumulative positions
          const positions = [0];
          for (let i = 0; i < stripDimensions.length; i++) {
            positions.push(positions[i] + stripDimensions[i]);
          }
          
          // Create 3 strips in this quadrant
          for (let stripIndex = 0; stripIndex < 3; stripIndex++) {
            // Create cross pattern: new color (index 1) forms the cross like in reference
            // Use all 3 colors: original (0), new (1), darker (2)
            let colorIndex;
            if (quadrant.name === 'top-left' || quadrant.name === 'bottom-right') {
              // Vertical quadrants: middle strip is new color (forms vertical cross)
              colorIndex = stripIndex === 1 ? 1 : (stripIndex === 0 ? 0 : 2); // middle = new, outer = original/dark
            } else {
              // Horizontal quadrants: outer strips are new color (forms horizontal cross)
              colorIndex = stripIndex === 1 ? 0 : 1; // middle = original, outer = new
            }
            
            const color = colorPalette[colorIndex];
            
            // Add jitter
            const jitterX = (Math.random() - 0.5) * jitterMultiplier * stripDimensions[stripIndex];
            const jitterY = (Math.random() - 0.5) * jitterMultiplier * stripDimensions[stripIndex];
            
            let stripX, stripY, stripWidth, stripHeight;
            
            if (quadrant.orientation === 'vertical') {
              // Vertical strips
              stripX = quadrant.x + positions[stripIndex] + jitterX;
              stripY = quadrant.y + jitterY;
              stripWidth = stripDimensions[stripIndex];
              stripHeight = quadrantHeight;
            } else {
              // Horizontal strips
              stripX = quadrant.x + jitterX;
              stripY = quadrant.y + positions[stripIndex] + jitterY;
              stripWidth = quadrantWidth;
              stripHeight = stripDimensions[stripIndex];
            }
            
            const strip = {
              id: block.id + '_pattern_railfence_' + quadrant.name + '_' + stripIndex,
              x: stripX,
              y: stripY,
              width: stripWidth,
              height: stripHeight,
              color: color,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'railfence',
              originalPatternId: block.id
            };
            
            cells.push(strip);
          }
        });
        
        return cells;
      }
      
      createCrossPattern(block, newColor) {
        // Create a 3x3 cross pattern: center + 4 cross arms + 4 corners
        // Center and cross arms form the cross, corners are different color
        
        // Generate 4-color palette (need 4 colors: original, new, third, fourth for center)
        const colorPalette = this.generateColorPalette(block.color, newColor, 4);
        
        // Calculate cell dimensions for 3x3 grid
        const cellWidth = block.width / 3;
        const cellHeight = block.height / 3;
        
        // Generate variable dimensions for organic feel
        const columnWidths = this.generateVariableDimensions(block.width, 3);
        const rowHeights = this.generateVariableDimensions(block.height, 3);
        
        // Calculate cumulative positions
        const columnPositions = [0];
        const rowPositions = [0];
        for (let i = 0; i < 3; i++) {
          columnPositions.push(columnPositions[i] + columnWidths[i]);
          rowPositions.push(rowPositions[i] + rowHeights[i]);
        }
        
        // Add jitter for organic feel
        const jitterMultiplier = 0.05;
        
        const cells = [];
        
        // Create 3x3 grid
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const cellIndex = row * 3 + col;
            
            // Determine if this cell is part of the cross
            const isCenter = (row === 1 && col === 1);
            const isCrossArm = (row === 1 && col !== 1) || (col === 1 && row !== 1);
            const isCorner = (row === 0 || row === 2) && (col === 0 || col === 2);
            
            // Assign colors: center = fourth color, cross arms = new color, corners = third color
            let color;
            if (isCenter) {
              color = colorPalette[3]; // Fourth color for center (distinct from corners)
            } else if (isCrossArm) {
              color = colorPalette[1]; // New color for cross arms
            } else {
              color = colorPalette[2]; // Third color for corners
            }
            
            // Add jitter
            const jitterX = (Math.random() - 0.5) * jitterMultiplier * columnWidths[col];
            const jitterY = (Math.random() - 0.5) * jitterMultiplier * rowHeights[row];
            
            // Calculate cell position and dimensions
            const cellX = block.x + columnPositions[col] + jitterX;
            const cellY = block.y + rowPositions[row] + jitterY;
            const cellWidth = columnWidths[col];
            const cellHeight = rowHeights[row];
            
            const cell = {
              id: block.id + '_pattern_cross_' + cellIndex,
              x: cellX,
              y: cellY,
              width: cellWidth,
              height: cellHeight,
              color: color,
              contributorId: this.deviceId,
              submissionIndex: this.submissionCount,
              patternType: 'special',
              specialPatternType: 'cross',
              originalPatternId: block.id
            };
            
            cells.push(cell);
          }
        }
        
        return cells;
      }
      
      generateColorPalette(baseColor1, baseColor2, numColors = 5) {
        // Generate a palette of colors from 2 base colors
        // Creates lighter and darker versions for patterns that need multiple colors
        // Uses ¬±15% lightness variations for subtle, harmonious colors
        
        const colors = [baseColor1, baseColor2];
        
        if (numColors <= 2) {
          return colors.slice(0, numColors);
        }
        
        // Convert base colors to HSL for better color manipulation
        const hsl1 = this.hexToHsl(baseColor1);
        const hsl2 = this.hexToHsl(baseColor2);
        
        // Generate additional colors by lightening and darkening
        const additionalColors = [];
        
        // Create lighter versions of both colors (¬±15% lightness)
        const light1 = this.lightenColorHsl(hsl1, 0.15);
        const light2 = this.lightenColorHsl(hsl2, 0.15);
        
        // Create darker versions of both colors (¬±15% lightness)
        const dark1 = this.darkenColorHsl(hsl1, 0.15);
        const dark2 = this.darkenColorHsl(hsl2, 0.15);
        
        // Add colors to palette in a logical order
        additionalColors.push(Utils.hslToHex(light1.h, light1.s, light1.l));
        additionalColors.push(Utils.hslToHex(light2.h, light2.s, light2.l));
        additionalColors.push(Utils.hslToHex(dark1.h, dark1.s, dark1.l));
        additionalColors.push(Utils.hslToHex(dark2.h, dark2.s, dark2.l));
        
        // Combine and return the requested number of colors
        const fullPalette = [...colors, ...additionalColors];
        return fullPalette.slice(0, numColors);
      }
      
      lightenColorHsl(hsl, amount) {
        // Lighten a color by increasing lightness, but don't go too light (max 85%)
        return {
          h: hsl.h,
          s: hsl.s,
          l: Math.min(85, hsl.l + (amount * 100))
        };
      }
      
      darkenColorHsl(hsl, amount) {
        // Darken a color by decreasing lightness, but don't go too dark (min 15%)
        return {
          h: hsl.h,
          s: hsl.s,
          l: Math.max(15, hsl.l - (amount * 100))
        };
      }
      
      getColorSimilarity(color1, color2) {
        // Convert hex colors to OKLab for perceptually uniform color similarity
        const oklab1 = this.hexToOklab(color1);
        const oklab2 = this.hexToOklab(color2);
        
        // Calculate Euclidean distance in OKLab space (perceptually uniform)
        const lDiff = oklab1.l - oklab2.l;
        const aDiff = oklab1.a - oklab2.a;
        const bDiff = oklab1.b - oklab2.b;
        
        // OKLab distance (delta E in OKLab space)
        const deltaE = Math.sqrt(lDiff * lDiff + aDiff * aDiff + bDiff * bDiff);
        
        // Convert to similarity (0-1 scale, where 1 = identical)
        // Using strict threshold: deltaE < 1.0 = 90%+ similar
        const similarity = Math.max(0, 1 - (deltaE / 1.0));
        
        return similarity;
      }
      
      hexToHsl(hex) {
        // Fix the RGB parsing bug
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;  // Fixed: was slice(2, 4)
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return {
          h: h * 360,
          s: s * 100,
          l: l * 100
        };
      }
      
      hexToOklab(hex) {
        // Convert hex to sRGB (0-1 range)
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        // Convert sRGB to linear RGB
        const linearR = r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        const linearG = g <= 0.04045 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
        const linearB = b <= 0.04045 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
        
        // Convert linear RGB to OKLab
        // Using the OKLab transformation matrix
        const l = 0.4122214708 * linearR + 0.5363325363 * linearG + 0.0514459929 * linearB;
        const m = 0.2119034982 * linearR + 0.6806995451 * linearG + 0.1073969566 * linearB;
        const s = 0.0883024619 * linearR + 0.2817188376 * linearG + 0.6299787005 * linearB;
        
        // Apply cube root
        const l_ = Math.cbrt(l);
        const m_ = Math.cbrt(m);
        const s_ = Math.cbrt(s);
        
        // Convert to OKLab
        const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
        const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
        const bChannel = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;
        
        return { l: L, a: a, b: bChannel };
      }

      
      recordUserContribution(blockId, color, submissionIndex) {
        const contribution = {
          submissionIndex,
          blockId,
          color,
          userId: this.deviceId, // Add user ID to track who contributed
          timestamp: new Date().toISOString()
        };
        
        const stored = JSON.parse(localStorage.getItem('quiltContributions') || '{"submissions": []}');
        stored.submissions.push(contribution);
        localStorage.setItem('quiltContributions', JSON.stringify(stored));
      }
      
      findUserPieces() {
        const contributions = this.getUserContributions();
        const userBlockIds = new Set();
        
        // Filter contributions by current user ID
        contributions.submissions.forEach(contrib => {
          if (contrib.userId === this.deviceId) {
            userBlockIds.add(contrib.blockId);
          }
        });
        
        return this.blocks.filter(block => userBlockIds.has(block.id));
      }
      
      getUserContributions() {
        const stored = localStorage.getItem('quiltContributions');
        return stored ? JSON.parse(stored) : { submissions: [] };
      }
      
      getState() {
        return {
          submissionCount: this.submissionCount,
          blocks: this.blocks,
          userPieces: this.findUserPieces()
        };
      }
      
      // Individual block flip state is now handled by the renderer
      
      // ===== RESPONSIVE QUILT DIMENSIONS =====
      recalculateDimensionsForCurrentViewport() {
        if (this.blocks.length === 0) return;
        
        // Get current viewport dimensions
        const currentViewportWidth = window.innerWidth;
        const currentViewportHeight = window.innerHeight;
        
        // Calculate current quilt bounds (don't modify the blocks!)
        const minX = Math.min(...this.blocks.map(b => b.x));
        const minY = Math.min(...this.blocks.map(b => b.y));
        const maxX = Math.max(...this.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.blocks.map(b => b.y + b.height));
        
        const currentQuiltWidth = maxX - minX;
        const currentQuiltHeight = maxY - minY;
        
        // Store the original quilt bounds for viewBox calculation
        this.quiltBounds = {
          minX: minX,
          minY: minY,
          width: currentQuiltWidth,
          height: currentQuiltHeight
        };
        
        // Determine target dimensions based on current viewport
        let targetWidth, targetHeight;
        
        // Instagram-friendly: Use 4:5 aspect ratio for consistent experience
        const targetAspectRatio = 4/5; // 4:5 ratio for Instagram portrait format
        
        if (window.innerWidth >= 768) {
          // Desktop: Use mobile aspect ratio, account for button container
          const availableWidth = currentViewportWidth * 0.7; // 70% for quilt container
          const availableHeight = currentViewportHeight;
          
          if (availableWidth / availableHeight > targetAspectRatio) {
            // Viewport is wider than target ratio
            targetHeight = availableHeight;
            targetWidth = availableHeight * targetAspectRatio;
          } else {
            // Viewport is taller than target ratio
            targetWidth = availableWidth;
            targetHeight = availableWidth / targetAspectRatio;
          }
        } else {
          // Mobile: Use 4:5 aspect ratio with breathing room
          const breathingRoom = 0.95; // 95% of viewport for quilt, 5% for breathing room
          const availableWidth = currentViewportWidth * breathingRoom;
          const availableHeight = currentViewportHeight * breathingRoom;
          
          if (availableWidth / availableHeight > targetAspectRatio) {
            // Viewport is wider than target ratio
            targetHeight = availableHeight;
            targetWidth = availableHeight * targetAspectRatio;
          } else {
            // Viewport is taller than target ratio
            targetWidth = availableWidth;
            targetHeight = availableWidth / targetAspectRatio;
          }
        }
        
        // Store target dimensions for rendering
        this.targetDimensions = {
          width: targetWidth,
          height: targetHeight,
          viewport: { width: currentViewportWidth, height: currentViewportHeight }
        };
        
        // console.log('üßµ Quilt viewBox recalculated for current viewport');
      }
    }

    // ===== UTILITY FUNCTIONS =====
    class Utils {
      static hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        const toHex = (c) => {
          const hex = Math.round(c * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };
        
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      static validateHexColor(color) {
        const hexRegex = /^#[0-9A-F]{6}$/i;
        return hexRegex.test(color);
      }

      static getOrCreateUserId() {
        let userId = localStorage.getItem('ourDailyUserId');
        if (!userId) {
          userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem('ourDailyUserId', userId);
        }
        return userId;
      }

      static getTodayKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      static getQuiltDimensions() {
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        
        let screenWidth, screenHeight;
        
        if (hasVisualViewport) {
          screenWidth = window.visualViewport.width;
          screenHeight = window.visualViewport.height;
        } else {
          const body = document.body;
          const html = document.documentElement;
          
          const bodyRect = body.getBoundingClientRect();
          const htmlRect = html.getBoundingClientRect();
          
          const measuredWidth = Math.min(bodyRect.width, htmlRect.width);
          const measuredHeight = Math.min(bodyRect.height, htmlRect.height);
          
          if (measuredWidth > 0 && measuredHeight > 0) {
            screenWidth = measuredWidth;
            screenHeight = measuredHeight;
          } else {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            
            const browserUIMargin = Math.min(screenHeight * 0.15, 120);
            screenHeight = screenHeight - browserUIMargin;
          }
        }
        
        const isMobile = screenWidth <= 768;
        
        if (isMobile) {
          // Mobile: Use fixed 4:5 dimensions for Instagram-friendly experience
          const width = 1070;  // 1080 - 10px padding
          const height = 1340; // 1350 - 10px padding
          return {
            width: width,
            height: height,
            viewBoxWidth: width,
            viewBoxHeight: height
          };
        } else {
          // Desktop: Use fixed 4:5 dimensions for Instagram-friendly experience
          const width = 1070;  // 1080 - 10px padding
          const height = 1340; // 1350 - 10px padding
          return {
            width: width,
            height: height,
            viewBoxWidth: width,
            viewBoxHeight: height
          };
        }
      }

      static formatDate(date = new Date()) {
        return date.toLocaleDateString(undefined, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    }

    // ===== LOGGING SERVICE =====
    class Logger {
      constructor(debugMode = CONFIG.APP.debugMode) {
        this.debugMode = debugMode;
        this.prefix = 'üßµ';
      }

      log(message, data = null) {
        if (this.debugMode) {
          console.log(`${this.prefix} ${message}`, data || '');
        }
      }

      warn(message, data = null) {
        if (this.debugMode) {
          console.warn(`${this.prefix} ‚ö†Ô∏è ${message}`, data || '');
        }
      }

      error(message, error = null) {
        console.error(`${this.prefix} ‚ùå ${message}`, error || '');
      }
    }

    // ===== UI SERVICE =====
    class UIService {
      constructor(logger) {
        this.logger = logger;
      }

      showToast(message, duration = CONFIG.APP.toastDuration, link = null) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        
        if (link) {
          // Create toast with link
          toast.innerHTML = `
            <span>${message}</span>
            <a href="${link.url}" target="_blank" rel="noopener noreferrer" class="toast-link">
              ${link.text}
            </a>
          `;
        } else {
          // Regular toast without link
          toast.textContent = message;
        }
        
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
      }

      showLoading(show = true) {
        const loading = document.getElementById('loading');
        if (!loading) return;
        if (show) {
          loading.classList.add('show');
        } else {
          loading.classList.remove('show');
        }
      }

      showScreen(screenId) {
        try {
          document.querySelectorAll(".screen").forEach(s => {
            s.classList.remove("active");
            s.style.display = 'none';
          });
          
          const target = document.getElementById(screenId);
          if (target) {
            target.style.display = 'flex';
            target.classList.add("active");
            
            target.offsetHeight;
            
            // Set date immediately when portal screen is shown
            if (screenId === 'screen-portal') {
              const dateText = document.getElementById("date-text");
              if (dateText) {
                const formattedDate = Utils.formatDate();
                dateText.textContent = formattedDate;
                console.log('üìÖ Date set immediately for portal:', formattedDate);
              }
            }
            

            
            // Populate quote display when quilt screen is shown
            if (screenId === 'screen-quilt') {
              const quoteService = window.app?.quoteService;
              if (quoteService) {
                const { text, author } = quoteService.getTodayQuote();
                const quiltQuoteText = document.querySelector('.quilt-quote-text');
                const quiltQuoteAuthor = document.querySelector('.quilt-quote-author');
                const quiltQuoteDisplay = document.querySelector('.quilt-quote-display');
                
                if (quiltQuoteText) quiltQuoteText.textContent = text;
                if (quiltQuoteAuthor) quiltQuoteAuthor.textContent = author;
                
                // Show the quote display when content is populated
                if (quiltQuoteDisplay && text && author) {
                  quiltQuoteDisplay.classList.add('has-content');
                }
              }
            }
            
            // Send current color to parent page when color picker screen is shown
            if (screenId === 'screen-color') {
              // Add class to body for color mode
              document.body.classList.add('color-mode-active');
              
              try {
                const currentColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
                if (currentColor && Utils.validateHexColor(currentColor)) {
                  console.log('üé® Sending color to parent:', currentColor);
                  // Use the new helper function
                  if (window.ODQ_onColorChange) {
                    window.ODQ_onColorChange(currentColor);
                  }
                }
              } catch (error) {
                console.log('Could not send color to parent page:', error);
              }
            } else {
              // Remove class when leaving color screen
              document.body.classList.remove('color-mode-active');
              // Don't send any color when leaving color screen - let it stay at default
            }
            
             // Handle quote screen fade-in elements
            if (screenId === 'screen-quote') {
              // Reset fade-in elements to hidden state
              const fadeElements = document.querySelectorAll('.quote-screen-fade-in');
              fadeElements.forEach(el => el.classList.remove('visible'));
              
              // Trigger fade-in immediately (removed 3-second delay for testing)
              fadeElements.forEach(el => el.classList.add('visible'));
            }
            
            // Handle welcome screen fade-in elements
            if (screenId === 'screen-welcome') {
              // Reset fade-in elements to hidden state
              const fadeElements = document.querySelectorAll('.welcome-screen-fade-in');
              fadeElements.forEach(el => el.classList.remove('visible'));
              
              // Trigger smooth top-to-bottom fade-in with overlapping transitions
              fadeElements.forEach((el, index) => {
                const staggerDelay = index * 200; // 200ms between each element
                setTimeout(() => {
                  el.classList.add('visible');
                }, staggerDelay);
              });
            }
            
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            const app = document.getElementById('app');
            if (app) {
              app.scrollTop = 0;
            }
            
            // Dispatch custom event for screen change
            document.dispatchEvent(new CustomEvent('screenChange', {
              detail: { screenId: screenId }
            }));
            
          } else {
            this.logger.error(`‚ùå Screen not found: ${screenId}`);
            this.showScreen('screen-portal');
          }
        } catch (error) {
          this.logger.error(`‚ùå Error switching to screen ${screenId}:`, error);
          const portalScreen = document.getElementById('screen-portal');
          if (portalScreen) {
            document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
            portalScreen.classList.add("active");
            portalScreen.style.display = 'flex';
          }
        }
      }
    }

    // ===== ERROR HANDLING SERVICE =====
    class ErrorHandler {
      constructor(uiService, logger) {
        this.uiService = uiService;
        this.logger = logger;
      }

      handleError(error, context = 'Unknown') {
        this.logger.error(`Error in ${context}:`, error);
        
        const errorMessages = {
          'loadQuilt': 'Failed to load quilt data. Starting fresh.',
          'saveQuilt': 'Failed to save your color. Please try again.',
          'shareFlow': 'Failed to create share image. Saving instead.',
          'colorPicker': 'Color picker error. Please try again.',
          'App initialization': 'Failed to initialize app. Please refresh.',
          'renderQuilt': 'Failed to render quilt. Please try again.',
          'addColorToQuilt': 'Failed to add color. Please try again.'
        };
        
        const message = errorMessages[context] || 'Something went wrong. Please try again.';
        this.uiService.showToast(message);
      }

      validateColor(color) {
        if (!Utils.validateHexColor(color)) {
          throw new Error(`Invalid color format: ${color}`);
        }
        return true;
      }
    }

    // ===== ARCHIVE SERVICE =====
    class ArchiveService {
      constructor(logger, dataService) {
        this.logger = logger;
        this.dataService = dataService;
        this.archives = new Map(); // Date string -> archive data (cached)
        this.isLoading = false;
        this.currentPage = 0;
        this.postsPerPage = 10;
      }

      // Archive data structure for each day
      createArchiveEntry(date, quilt, quote, userCount) {
        return {
          date: date, // "2024-01-15"
          quilt: quilt, // SVG data/state
          quote: quote, // { text: "...", author: "..." }
          userCount: userCount, // Number of users who contributed
          shareCount: 0, // Number of times this quilt has been shared
          thumbnail: null, // Will be generated
          isComplete: true // Whether the day finished properly
        };
      }

      // Get archives for feed (with pagination)
      async getArchives(page = 0, limit = this.postsPerPage) {
        try {
                  // Try to load from Firestore if we don't have archives cached
        // if (this.archives.size === 0 && window.db && window.firestore) {
        //   await this.loadArchivesFromFirestore();
        // }
          
          const allArchives = Array.from(this.archives.values())
            .sort((a, b) => new Date(b.date) - new Date(a.date)); // Newest first
          
          const start = page * limit;
          const end = start + limit;
          const pageArchives = allArchives.slice(start, end);
          
          return {
            archives: pageArchives,
            hasMore: end < allArchives.length,
            totalCount: allArchives.length
          };
        } catch (error) {
          this.logger.error('Failed to get archives:', error);
          return {
            archives: [],
            hasMore: false,
            totalCount: 0
          };
        }
      }

      // Load archives from Firestore
      async loadArchivesFromFirestore() {
        try {
          if (!window.db || !window.firestore) {
            this.logger.warn('Firestore not available for loading archives');
            return;
          }

          const archivesRef = window.firestore.collection(window.db, 'archives');
          const q = window.firestore.query(archivesRef, window.firestore.orderBy('date', 'desc'), window.firestore.limit(50));
          const querySnapshot = await window.firestore.getDocs(q);
          
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            this.archives.set(data.date, data);
          });
          
          this.logger.log(`üìñ Loaded ${this.archives.size} archives from Firestore`);
        } catch (error) {
          this.logger.error('Failed to load archives from Firestore:', error);
        }
      }

      // Add new archive entry
      async addArchive(archiveEntry) {
        try {
          // Add to Firestore if available
          // if (window.db && window.firestore) {
          //   const archiveRef = window.firestore.doc(window.db, 'archives', archiveEntry.date);
          //   await window.firestore.setDoc(archiveRef, {
          //     ...archiveEntry,
          //     createdAt: new Date().toISOString()
          //   });
          //   this.logger.log(`üìù Archive saved to Firestore: ${archiveEntry.date}`);
          // }
          
          // Add to local cache
          this.archives.set(archiveEntry.date, archiveEntry);
          this.logger.log(`üìù Archive cached locally: ${archiveEntry.date}`);
        } catch (error) {
          this.logger.error('Failed to save archive to Firestore:', error);
          // Still cache locally as fallback
          this.archives.set(archiveEntry.date, archiveEntry);
        }
      }

      // Generate Instagram-ready image (4:5 portrait ratio)
      async generateInstagramImage(blocks, quote = null) {
        try {
          if (!blocks || blocks.length === 0) {
            this.logger.warn('No blocks provided for Instagram image generation');
            return null;
          }

          // Instagram optimal size: 1080x1350 (4:5 ratio)
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = 1080;
          canvas.height = 1350;
          
          // Fill background with true white to match Instagram
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          
          // Calculate bounds of all blocks to determine scaling
          const minX = Math.min(...blocks.map(b => b.x));
          const minY = Math.min(...blocks.map(b => b.y));
          const maxX = Math.max(...blocks.map(b => b.x + b.width));
          const maxY = Math.max(...blocks.map(b => b.y + b.height));
          
          // Use fixed 4:5 dimensions (1070 x 1340) - same as main app
          const targetWidth = 1070;  // 1080 - 10px padding
          const targetHeight = 1340; // 1350 - 10px padding
          
          // Center the quilt in the Instagram canvas (5px padding all around)
          const offsetX = 5;  // 5px from left
          const offsetY = 5;  // 5px from top
          
          
          // Draw each block
          blocks.forEach(block => {
            // Add jitter effects (same as current quilt)
            const jitterX = (Math.random() - 0.5) * 8;
            const jitterY = (Math.random() - 0.5) * 8;
            const jitterRotation = (Math.random() - 0.5) * 4;
            
            const jitteredX = block.x + jitterX;
            const jitteredY = block.y + jitterY;
            
            // Transform to canvas coordinates (handle negative coordinates)
            const canvasX = offsetX + (jitteredX - minX);
            const canvasY = offsetY + (jitteredY - minY);
            const canvasWidth = block.width;
            const canvasHeight = block.height;
            
            // Save context for rotation
            ctx.save();
            
            // Move to center of block for rotation
            const centerX = canvasX + canvasWidth / 2;
            const centerY = canvasY + canvasHeight / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(jitterRotation * Math.PI / 180);
            
            // Draw block (no shadow for clean Instagram look)
            ctx.fillStyle = block.color;
            ctx.fillRect(-canvasWidth / 2, -canvasHeight / 2, canvasWidth, canvasHeight);
            
            // Restore context
            ctx.restore();
          });
          
          // Convert to data URL
          const dataURL = canvas.toDataURL('image/png', 0.95);
          
          // Instagram image generated successfully
          return dataURL;
          
        } catch (error) {
          this.logger.error('Instagram image generation failed:', error);
          return null;
        }
      }

      // Delete archive entry
      async deleteArchive(date) {
        try {
          // Delete from Firestore if available
          // if (window.db && window.firestore) {
          //   const archiveRef = window.firestore.doc(window.db, 'archives', date);
          //   await window.firestore.deleteDoc(archiveRef);
          //   this.logger.log(`üóëÔ∏è Archive deleted from Firestore: ${date}`);
          // }
          
          // Remove from local cache
          this.archives.delete(date);
          this.logger.log(`üóëÔ∏è Archive removed from local cache: ${date}`);
          
          // Refresh the archive feed
          await this.renderArchiveFeed();
          
        } catch (error) {
          this.logger.error('Failed to delete archive:', error);
          throw error;
        }
      }

      // Generate thumbnail from SVG
      async generateThumbnail(svgElement) {
        try {
          if (!svgElement) {
            svgElement = document.getElementById('quilt');
          }
          
          if (!svgElement) {
            this.logger.warn('No SVG element found for thumbnail generation');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+Tm8gUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // SAFEGUARD: Check if SVG has content
          if (!svgElement.children || svgElement.children.length === 0) {
            this.logger.warn('SVG element has no children - using fallback thumbnail');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RW1wdHkgUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // Clone SVG to avoid modifying original
          const svgClone = svgElement.cloneNode(true);
          
          // Get SVG dimensions
          const svgRect = svgElement.getBoundingClientRect();
          const width = Math.max(400, svgRect.width);
          const height = Math.max(400, svgRect.height);
          
          // Ensure SVG has proper attributes
          svgClone.setAttribute('width', width);
          svgClone.setAttribute('height', height);
          svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          
          // Convert SVG to string
          const svgData = new XMLSerializer().serializeToString(svgClone);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          
          // Create canvas for conversion
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = width;
          canvas.height = height;
          
          // Create image from SVG
          const img = new Image();
          const url = URL.createObjectURL(svgBlob);
          
          return new Promise((resolve) => {
            img.onload = () => {
              // Draw to canvas
              ctx.fillStyle = '#f6f4f1'; // Background color
              ctx.fillRect(0, 0, width, height);
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert to data URL
              const dataURL = canvas.toDataURL('image/png', 0.8);
              URL.revokeObjectURL(url);
              
              this.logger.log(`‚úÖ Generated thumbnail: ${width}x${height}`);
              resolve(dataURL);
            };
            
            img.onerror = () => {
              URL.revokeObjectURL(url);
              this.logger.error('Failed to generate thumbnail');
              resolve('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==');
            };
            
            img.src = url;
          });
          
        } catch (error) {
          this.logger.error('Thumbnail generation failed:', error);
          return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==';
        }
      }

      // Generate full quilt image from blocks data
      async generateFullQuiltImage(blocks) {
        try {
          if (!blocks || blocks.length === 0) {
            this.logger.warn('No blocks provided for full quilt image generation');
            return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgdmlld0JveD0iMCAwIDgwMCA2MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI4MDAiIGhlaWdodD0iNjAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjQwMCIgeT0iMzAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIyNCI+Tm8gUXVpbHQ8L3RleHQ+Cjwvc3ZnPg==';
          }

          // Calculate quilt bounds
          const minX = Math.min(...blocks.map(b => b.x));
          const minY = Math.min(...blocks.map(b => b.y));
          const maxX = Math.max(...blocks.map(b => b.x + b.width));
          const maxY = Math.max(...blocks.map(b => b.y + b.height));
          
          const quiltWidth = maxX - minX;
          const quiltHeight = maxY - minY;
          
          // Create canvas for full quilt image
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size (tall and narrow like the quilt)
          canvas.width = 800;
          canvas.height = 1200;
          
          // Fill background
          ctx.fillStyle = '#f6f4f1';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Calculate scale to fit quilt in canvas
          const scaleX = canvas.width / quiltWidth;
          const scaleY = canvas.height / quiltHeight;
          const scale = Math.min(scaleX, scaleY, 1) * 1.2; // 20% larger to reduce white space
          
          // Center the quilt
          const offsetX = (canvas.width - quiltWidth * scale) / 2;
          const offsetY = (canvas.height - quiltHeight * scale) / 2;
          
          // Draw each block
          blocks.forEach(block => {
            // Add jitter effects (same as current quilt)
            const jitterX = (Math.random() - 0.5) * 6;
            const jitterY = (Math.random() - 0.5) * 6;
            const jitterRotation = (Math.random() - 0.5) * 3;
            
            const jitteredX = block.x + jitterX;
            const jitteredY = block.y + jitterY;
            
            // Transform to canvas coordinates
            const canvasX = offsetX + (jitteredX - minX) * scale;
            const canvasY = offsetY + (jitteredY - minY) * scale;
            const canvasWidth = block.width * scale;
            const canvasHeight = block.height * scale;
            
            // Save context for rotation
            ctx.save();
            
            // Move to center of block for rotation
            const centerX = canvasX + canvasWidth / 2;
            const centerY = canvasY + canvasHeight / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(jitterRotation * Math.PI / 180);
            
            // Draw block with shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 4;
            
            ctx.fillStyle = block.color;
            ctx.fillRect(-canvasWidth / 2, -canvasHeight / 2, canvasWidth, canvasHeight);
            
            // Restore context
            ctx.restore();
          });
          
          // Convert to data URL
          const dataURL = canvas.toDataURL('image/png', 0.9);
          
          this.logger.log(`‚úÖ Generated full quilt image: 800x1200`);
          return dataURL;
          
        } catch (error) {
          this.logger.error('Full quilt image generation failed:', error);
          return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgdmlld0JveD0iMCAwIDgwMCA2MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI4MDAiIGhlaWdodD0iNjAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjQwMCIgeT0iMzAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIyNCI+RXJyb3I8L3RleHQ+Cjwvc3ZnPg==';
        }
      }

      // Load more archives (for "Load More" button)
      async loadMore() {
        if (this.isLoading) return null;
        
        this.isLoading = true;
        this.currentPage++;
        
        try {
          const result = await this.getArchives(this.currentPage);
          this.isLoading = false;
          return result;
        } catch (error) {
          this.isLoading = false;
          this.logger.error('Failed to load more archives:', error);
          return null;
        }
      }

      // Create HTML for a single archive post
      createArchivePostHTML(archiveEntry) {
        const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });

        // Debug: Log image source info
        console.log('Archive image debug:', {
          date: archiveEntry.date,
          hasFullQuiltImage: !!archiveEntry.fullQuiltImage,
          hasThumbnail: !!archiveEntry.thumbnail,
          imageSource: archiveEntry.fullQuiltImage ? 'fullQuiltImage' : (archiveEntry.thumbnail ? 'thumbnail' : 'fallback')
        });

        return `
          <div class="archive-post" data-date="${archiveEntry.date}">
            <img class="archive-post-image" 
                 src="${archiveEntry.fullQuiltImage || archiveEntry.thumbnail || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZjZmNGYxIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+TG9hZGluZy4uLjwvdGV4dD4KPHN2Zz4='}" 
                 alt="Quilt from ${formattedDate}"
                 loading="lazy"
                 onload="console.log('Image loaded:', this.naturalWidth + 'x' + this.naturalHeight, 'Displayed:', this.offsetWidth + 'x' + this.offsetHeight, 'Container:', this.parentElement.offsetWidth + 'x' + this.parentElement.offsetHeight, 'Date:', '${formattedDate}')" />
            <div class="archive-post-caption">
              <div class="archive-post-content">
                <div class="archive-post-public">
                  <div class="archive-post-quote-author">${archiveEntry.quote.text} ‚Äî ${archiveEntry.quote.author}</div>
                  <div class="archive-post-meta">
                    <span class="archive-post-date">${formattedDate}</span>
                    <span class="archive-post-contributors">${archiveEntry.userCount} contributors</span>
                    <button class="archive-share-btn" data-date="${archiveEntry.date}" title="Share this quilt">
                      üì§ Share
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      // Render archive feed
      async renderArchiveFeed(containerId = 'archiveFeed') {
        const container = document.getElementById(containerId);
        if (!container) {
          this.logger.error('Archive feed container not found');
          return;
        }

        // Show loading state
        container.innerHTML = '<p class="archive-loading">Loading archives...</p>';

        try {
          // Get first page of archives
          const result = await this.getArchives(0);
          
          if (result.archives.length === 0) {
            container.innerHTML = '<p class="archive-loading">No quilts archived yet. Check back soon!</p>';
            return;
          }

          // Render posts
          container.innerHTML = result.archives
            .map(archive => this.createArchivePostHTML(archive))
            .join('');

          // Setup click handlers for images
          this.setupImageClickHandlers(container);

          // Show/hide Load More button
          this.updateLoadMoreButton(result.hasMore);



          this.logger.log(`Rendered ${result.archives.length} archive posts`);
        } catch (error) {
          this.logger.error('Failed to render archive feed:', error);
          container.innerHTML = '<p class="archive-loading">Failed to load archives. Please try again.</p>';
        }
      }

      // Setup click handlers for archive post images and share buttons
      setupImageClickHandlers(container) {
        // Archive image click handlers
        const images = container.querySelectorAll('.archive-post-image');
        images.forEach(img => {
          img.addEventListener('click', (e) => {
            const postElement = e.target.closest('.archive-post');
            const date = postElement.dataset.date;
            const archiveEntry = this.archives.get(date);
            if (archiveEntry) {
              this.openArchiveModal(archiveEntry);
            }
          });
        });
        
        // Archive share button click handlers
        const shareButtons = container.querySelectorAll('.archive-share-btn');
        shareButtons.forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent triggering image click
            const date = btn.getAttribute('data-date');
            await this.shareArchiveQuilt(date);
          });
        });
      }

      // Open archive modal with enlarged view
      openArchiveModal(archiveEntry) {
        const modal = document.getElementById('archiveModal');
        const modalImage = document.getElementById('archiveModalImage');
        const modalQuote = document.getElementById('archiveModalQuote');
        const modalMeta = document.getElementById('archiveModalMeta');
        const modalDelete = document.getElementById('archiveModalDelete');

        if (!modal) return;

        // Set modal content
        modalImage.src = archiveEntry.fullQuiltImage || archiveEntry.thumbnail || '';
        modalImage.alt = `Quilt from ${archiveEntry.date}`;
        modalQuote.textContent = `${archiveEntry.quote.text} ‚Äî ${archiveEntry.quote.author}`;
        
        const formattedDate = new Date(archiveEntry.date).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        modalMeta.innerHTML = `${formattedDate} ‚Ä¢ ${archiveEntry.userCount} contributors`;

        // Show/hide delete button based on admin status
        if (modalDelete) {
          const isAdmin = window.app?.authService?.isAdmin() || false;
          modalDelete.style.display = isAdmin ? 'block' : 'none';
          
          // Set up delete functionality
          modalDelete.onclick = async () => {
            if (confirm(`Are you sure you want to delete the archive from ${formattedDate}?`)) {
              try {
                await this.deleteArchive(archiveEntry.date);
                this.closeArchiveModal();
                this.logger.log(`üóëÔ∏è Archive deleted: ${archiveEntry.date}`);
              } catch (error) {
                this.logger.error('Failed to delete archive:', error);
              }
            }
          };
        }

        // Show modal
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden'; // Prevent background scroll
      }

      // Close archive modal
      closeArchiveModal() {
        const modal = document.getElementById('archiveModal');
        if (modal) {
          modal.style.display = 'none';
          document.body.style.overflow = ''; // Restore scroll
        }
      }

      // Update Load More button visibility
      updateLoadMoreButton(hasMore) {
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        if (loadMoreBtn) {
          loadMoreBtn.style.display = hasMore ? 'block' : 'none';
        }
      }

      // Share an archived quilt
      async shareArchiveQuilt(date) {
        try {
          const archiveEntry = this.archives.get(date);
          if (!archiveEntry) {
            throw new Error('Archive entry not found');
          }
          
          const formattedDate = new Date(date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Use the Web Share API if available
          if (navigator.share) {
            try {
              await navigator.share({
                title: `Community Quilt - ${formattedDate}`,
                text: `${archiveEntry.quote.text} ‚Äî ${archiveEntry.quote.author} - Made by ${archiveEntry.userCount} contributors`,
                url: `${window.location.href}?date=${date}`
              });
              
              this.logger.log(`üì§ Archive quilt shared: ${date}`);
              return;
            } catch (shareError) {
              // User cancelled or share failed
              if (shareError.name !== 'AbortError') {
                this.logger.log('Web Share failed, falling back to copy link');
              }
            }
          }
          
          // Fallback: Copy link to clipboard
          try {
            const shareUrl = `${window.location.href}?date=${date}`;
            await navigator.clipboard.writeText(shareUrl);
            this.logger.log(`üì§ Archive link copied: ${date}`);
          } catch (clipboardError) {
            // Final fallback: Just show a message
            const shareUrl = `${window.location.href}?date=${date}`;
            this.logger.log(`üì§ Archive share link: ${shareUrl}`);
          }
          
        } catch (error) {
          this.logger.error('Archive share failed:', error);
        }
      }
    }

    // ===== DATA LAYER =====
    class QuiltDataService {
      constructor(logger, errorHandler) {
        this.logger = logger;
        this.errorHandler = errorHandler;
        this.db = null;
        this.quiltDoc = null;
      }

      async initialize() {
        try {
          // Wait for Firebase to be available
          console.log('üîÑ DataService: Waiting for Firebase...');
          
          // First try to wait for the firebaseReady event
          await new Promise((resolve) => {
            if (window.db) {
              resolve();
              return;
            }
            
            const timeout = setTimeout(() => {
              document.removeEventListener('firebaseReady', onFirebaseReady);
              resolve();
            }, 5000); // 5 second timeout
            
            const onFirebaseReady = () => {
              clearTimeout(timeout);
              document.removeEventListener('firebaseReady', onFirebaseReady);
              resolve();
            };
            
            document.addEventListener('firebaseReady', onFirebaseReady);
          });
          
          // Fallback: wait with polling
          let attempts = 0;
          while (!window.db && attempts < 200) { // Increased from 100 to 200 attempts (20 seconds)
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
            if (attempts % 20 === 0) {
              console.log(`üîÑ DataService: Still waiting for Firebase... (attempt ${attempts}/200)`);
            }
          }
          
          if (window.db) {
            this.db = window.db;
            this.logger.log('‚úÖ Firestore initialized successfully');
          } else {
            this.logger.warn('‚ö†Ô∏è Firestore not available, falling back to localStorage');
            this.db = null;
          }
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Firestore initialization failed, falling back to localStorage:', error);
          this.db = null;
        }
      }

      async loadQuilt() {
        try {
          if (this.db) {
            // Try Firestore first
            const today = Utils.getTodayKey();
            this.logger.log('üîç Looking for quilt in Firestore with date key:', today);
            
            // Also check what other dates exist in Firestore
            try {
              const quiltsRef = window.firestore.collection(this.db, 'quilts');
              const querySnapshot = await window.firestore.getDocs(quiltsRef);
              const availableDates = [];
              querySnapshot.forEach(doc => {
                const data = doc.data();
                availableDates.push({
                  date: doc.id,
                  blocks: data.blocks?.length || 0,
                  contributorCount: data.contributorCount || 1
                });
              });
            } catch (listError) {
              this.logger.warn('‚ö†Ô∏è Could not list Firestore documents:', listError);
            }
              
            const quiltRef = window.firestore.doc(this.db, 'quilts', today);
            const quiltSnap = await window.firestore.getDoc(quiltRef);
            
            if (quiltSnap.exists()) {
              const data = quiltSnap.data();
              this.logger.log('üìñ Loaded quilt from Firestore with', data.blocks?.length || 0, 'blocks');
              return { 
                blocks: data.blocks || [], 
                contributorCount: data.contributorCount || 1 
              };
            } else {
              this.logger.warn('‚ö†Ô∏è No Firestore document found for date:', today);
            }
          }
          
          // Fallback to localStorage
          const savedData = localStorage.getItem('ourDailyQuilt');
          if (savedData) {
            const data = JSON.parse(savedData);
            this.logger.log('üìñ Loaded quilt from localStorage with', data.blocks?.length || 0, 'blocks, date:', data.date);
            return { 
              blocks: data.blocks || [], 
              contributorCount: data.contributorCount || 1 
            };
          } else {
            this.logger.warn('‚ö†Ô∏è No localStorage data found');
          }
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Error loading quilt, using default:', error);
        }
        
        // Default quilt
        const dimensions = Utils.getQuiltDimensions();
        this.logger.log('üìñ Using default quilt');
        return { 
          blocks: [{ x: 0, y: 0, width: dimensions.width, height: dimensions.height, color: CONFIG.APP.defaultColor }], 
          contributorCount: 1 
        };
      }

      async saveQuilt(blocks, contributorCount) {
        try {
          const quiltData = {
            blocks: blocks,
            contributorCount: contributorCount,
            lastUpdated: new Date().toISOString(),
            date: Utils.getTodayKey()
          };
          
          // Check Firestore availability
          if (!window.db || !window.firestore) {
            console.warn('‚ö†Ô∏è Firestore not available for saving');
          }
          
          if (window.db && window.firestore) {
            // Save to Firestore
            const today = Utils.getTodayKey();
            const quiltRef = window.firestore.doc(window.db, 'quilts', today);
            await window.firestore.setDoc(quiltRef, quiltData);
            // Quilt saved to Firestore
            
            // Also save today's quote to Firestore
            try {
              const todayQuote = window.app?.quoteService?.getTodayQuote();
              if (todayQuote) {
                const quoteData = {
                  text: todayQuote.text,
                  author: todayQuote.author,
                  date: today,
                  lastUpdated: new Date().toISOString()
                };
                const quoteRef = window.firestore.doc(window.db, 'quotes', today);
                await window.firestore.setDoc(quoteRef, quoteData);
                // Quote saved to Firestore
              }
            } catch (quoteError) {
              console.warn('‚ö†Ô∏è Could not save quote to Firestore:', quoteError);
            }
            
            // Also save the generated Instagram image to Firestore
            try {
              if (window.app?.archiveService?.generateInstagramImage) {
                const instagramImage = await window.app.archiveService.generateInstagramImage(quiltData.blocks);
                if (instagramImage) {
                  const imageData = {
                    imageData: instagramImage,
                    date: today,
                    lastUpdated: new Date().toISOString()
                  };
                  const imageRef = window.firestore.doc(window.db, 'instagram-images', today);
                  await window.firestore.setDoc(imageRef, imageData);
                  // Instagram image saved to Firestore
                }
              } else {
                console.warn('‚ö†Ô∏è ArchiveService.generateInstagramImage not available');
              }
            } catch (imageError) {
              console.warn('‚ö†Ô∏è Could not save Instagram image to Firestore:', imageError);
            }
          }
          
          // Also save to localStorage as backup with safety check
          if (quiltData.blocks && quiltData.blocks.length > 0) {
            localStorage.setItem('ourDailyQuilt', JSON.stringify(quiltData));
            // Quilt saved to localStorage
          } else {
            console.warn('‚ö†Ô∏è Attempted to save empty quilt data - skipping to prevent data loss');
          }
          
          return true;
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          
          // Fallback to localStorage only
          try {
            localStorage.setItem('ourDailyQuilt', JSON.stringify({
              blocks: blocks,
              contributorCount: contributorCount,
              lastUpdated: new Date().toISOString(),
              date: Utils.getTodayKey()
            }));
            this.logger.log('üíæ Saved quilt to localStorage (fallback)');
            return true;
          } catch (localError) {
            this.errorHandler.handleError(localError, 'saveQuilt localStorage fallback');
            return false;
          }
        }
      }
    }



    // ===== QUOTE SERVICE =====
    class QuoteService {
      constructor(firebaseInstance = null) {
        this.firebase = firebaseInstance;
        console.log('üìö QuoteService constructor - Firebase instance:', !!firebaseInstance);
        // Initialize with default quotes (will be replaced if Firestore load succeeds)
        this.quotes = [
          { text: "Art washes away from the soul the dust of everyday life.", author: "‚Äî Pablo Picasso" },
          { text: "Creativity takes courage.", author: "‚Äî Henri Matisse" },
          { text: "Every artist was first an amateur.", author: "‚Äî Ralph Waldo Emerson" },
          { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "‚Äî Wassily Kandinsky" },
          { text: "Great things are done by a series of small things brought together.", author: "‚Äî Vincent Van Gogh" },
          { text: "You can't use up creativity. The more you use, the more you have.", author: "Maya Angelou" },
          { text: "Every time I have had a problem, I have confronted it with the ax of art.", author: "Yayoi Kusama" },
          { text: "I found I could say things with color and shapes that I couldn't say any other way ‚Äì things I had no words for.", author: "Georgia O'Keeffe" },
          { text: "I love creation more than life, and I must express myself before disappearing.", author: "Sonia Delaunay" },
          { text: "The job of the artist is always to deepen the mystery.", author: "Francis Bacon" },
          { text: "The most important relationship in your life is the relationship you have with yourself.", author: "Diane von Furstenberg" },
          { text: "There is a vitality, a life force, an energy, a quickening that is translated through you into action, and because there is only one of you in all time, this expression is unique.", author: "Martha Graham" },
          { text: "If there is a book that you want to read, but it hasn't been written yet, you must be the one to write it.", author: "Toni Morrison" },
          { text: "Creativity doesn't wait for that perfect moment. It fashions its own perfect moments out of ordinary ones.", author: "Elizabeth Gilbert" },
          { text: "I think, at a child's birth, if a mother could ask a fairy godmother to endow it with the most useful gift, that gift would be curiosity.", author: "Eleanor Roosevelt" },
          { text: "Imagination is more important than knowledge. Knowledge is limited. Imagination encircles the world.", author: "Albert Einstein" },
          { text: "The beauty of a living thing is not the atoms that go into it, but the way those atoms are put together.", author: "Carl Sagan" },
          { text: "Let your curiosity be greater than your fear.", author: "Pema Ch√∂dr√∂n" },
          { text: "Study hard what interests you the most in the most undisciplined, irreverent and original manner possible.", author: "Richard Feynman" },
          { text: "Research is formalized curiosity. It is poking and prying with a purpose.", author: "Zora Neale Hurston" },
          { text: "It is always with excitement that I wake up in the morning wondering what my intuition will toss up to me, like gifts from the sea.", author: "Jonas Salk" },
          { text: "The only thing that makes life possible is permanent, intolerable uncertainty; not knowing what comes next.", author: "Ursula K. Le Guin" },
          { text: "Curiosity is the engine of achievement.", author: "Sir Ken Robinson" },
          { text: "Let the beauty of what you love be what you do. There are a thousand ways to kneel and kiss the earth.", author: "Rumi" },

          { text: "I'm very interested in, 'What does it mean for us to cultivate together?' Community that allows for risk, the risk of knowing someone outside your own boundaries, the risk that is love.", author: "bell hooks" },
          { text: "A nation's culture resides in the hearts and in the soul of its people.", author: "Mahatma Gandhi" },
          { text: "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.", author: "Antoine de Saint-Exup√©ry" },
          { text: "The butterfly counts not months but moments, and has time enough.", author: "Rabindranath Tagore" },
          { text: "To fly, we have to have resistance.", author: "Maya Lin" },
          { text: "Not everything that is faced can be changed, but nothing can be changed until it is faced.", author: "James Baldwin" },
          { text: "There's nothing new under the sun, but there are new suns.", author: "Octavia Butler" },
          { text: "Never doubt that a small group of thoughtful, committed citizens can change the world; indeed, it's the only thing that ever has.", author: "Margaret Mead" },
          { text: "There is no such thing as a single-issue struggle because we do not live single-issue lives.", author: "Audre Lorde" },
          { text: "Every moment is an organizing opportunity, every person a potential activist, every minute a chance to change the world.", author: "Dolores Huerta" },
          { text: "We don't have to engage in grand, heroic actions to participate in the process of change. Small acts, when multiplied by millions of people, can transform the world.", author: "Howard Zinn" },
          { text: "When the whole world is silent, even one voice becomes powerful.", author: "Malala Yousafzai" },
          { text: "Activism is my rent for living on the planet.", author: "Alice Walker" },
          { text: "We are the leaders we've been waiting for.", author: "Grace Lee Boggs" },
          { text: "Do your little bit of good where you are; it's those little bits of good put together that overwhelm the world.", author: "Desmond Tutu" },
          { text: "What you do makes a difference, and you have to decide what kind of difference you want to make.", author: "Jane Goodall" },
          { text: "You never change things by fighting the existing reality. To change something, build a new model that makes the existing model obsolete.", author: "Buckminster Fuller" },
          { text: "Like what you do, and then you will do your best.", author: "Katherine Johnson" },
          { text: "The present is theirs; the future, for which I really worked, is mine.", author: "Nikola Tesla" },
          { text: "Cities have the capability of providing something for everybody, only because, and only when, they are created by everybody.", author: "Jane Jacobs" },
          { text: "In every outthrust headland, in every curving beach, in every grain of sand there is the story of the earth.", author: "Rachel Carson" },
          { text: "What the people want is very simple - they want an America as good as its promise.", author: "Barbara Jordan" },
          { text: "In nature's economy the currency is not money, it is life.", author: "Vandana Shiva" },
          { text: "When we plant trees, we plant the seeds of peace and seeds of hope.", author: "Wangari Maathai" },
          { text: "No one is born fully-formed: it is through self-experience in the world that we become what we are.", author: "Paulo Freire" },
          { text: "Turn your wounds into wisdom.", author: "Oprah Winfrey" },
          { text: "Courage doesn't always roar. Sometimes courage is the quiet voice at the end of the day saying 'I will try again tomorrow.'", author: "Mary Anne Radmacher" },
          { text: "I fight pain, anxiety, and fear every day, and the only method I have found that relieves my illness is to keep creating art.", author: "Yayoi Kusama" },
          { text: "To heal is to touch with love that which we previously touched with fear.", author: "Stephen Levine" },
          { text: "I am better off healed than I ever was unbroken.", author: "Beth Moore" },
          { text: "Everything can be taken from a man but one thing: the last of the human freedoms‚Äîto choose one's attitude in any given set of circumstances.", author: "Viktor Frankl" },
          { text: "The purpose of life is not to be happy. It is to be useful, to be honorable, to be compassionate, to have it make some difference that you have lived and lived well.", author: "Ralph Waldo Emerson" },
          { text: "Let yourself be silently drawn by the strange pull of what you really love. It will not lead you astray.", author: "Rumi" },
          { text: "Follow your bliss and the universe will open doors where there were only walls.", author: "Joseph Campbell" },
          { text: "A musician must make music, an artist must paint, a poet must write, if he is to be ultimately happy. What a man can be, he must be.", author: "Abraham Maslow" },
          { text: "At every moment you choose yourself. But do you choose your self? Body and soul contain a thousand possibilities out of which you can build many I's.", author: "Dag Hammarskj√∂ld" },
          { text: "We are the myths we tell ourselves about ourselves.", author: "Jean Houston" },
          { text: "A vocation is not a career that you choose for yourself. A vocation is a calling that you discover by listening to the voice of vocation within you.", author: "Parker Palmer" },
          { text: "Attention is the rarest and purest form of generosity.", author: "Simone Weil" },
          { text: "Waking up this morning, I smile. Twenty-four brand new hours are before me. I vow to live fully in each moment.", author: "Th√≠ch Nh·∫•t H·∫°nh" },
          { text: "The privilege of a lifetime is to become who you truly are.", author: "Carl Jung" },
          { text: "I define connection as the energy that exists between people when they feel seen, heard, and valued; when they can give and receive without judgment.", author: "Bren√© Brown" },
          { text: "Perhaps the secret of living well is not in having all the answers but in pursuing unanswerable questions in good company.", author: "Rachel Naomi Remen" },
          { text: "All real living is meeting.", author: "Martin Buber" },
          { text: "We humans are social beings. We come into the world as the result of others' actions. We survive here in dependence on others.", author: "The Dalai Lama" },
          { text: "Sometimes people try to destroy you, precisely because they recognize your power.", author: "bell hooks" },
          { text: "When you understand that being connected to others is one of life's greatest joys, you realize that life's best comes when you initiate and invest in solid relationships.", author: "John C. Maxwell" },
          { text: "Healing yourself is connected with healing others.", author: "Yoko Ono" },
          { text: "Relationships are all there is. Everything in the universe only exists because it is in relationship to everything else.", author: "Margaret J. Wheatley" },
          { text: "When you take one step to reach out to people, when you meet with others and share their thoughts and sufferings, infinite compassion and wisdom well up within your heart.", author: "Daisaku Ikeda" },
          { text: "We now accept the fact that learning is a lifelong process of keeping abreast of change. And the most pressing task is to teach people how to learn.", author: "Peter Drucker" },
          { text: "The illiterate of the 21st century will not be those who cannot read and write, but those who cannot learn, unlearn, and relearn.", author: "Alvin Toffler" },
          { text: "Those people who develop the ability to continuously acquire new and better forms of knowledge that they can apply to their work and to their lives will be the movers and shakers in our society for the indefinite future.", author: "Brian Tracy" },
          { text: "The purpose of learning is growth, and our minds, unlike our bodies, can continue growing as we continue to live.", author: "Mortimer Adler" },
          { text: "The good thing about science is that it's true whether or not you believe in it. But the great thing about learning is that it makes you more capable of reducing the suffering of others.", author: "Neil deGrasse Tyson" },
          { text: "I have learned that each and every piece of cloth embodies the spirit, skill, and personal history of an individual weaver‚Ä¶ It ties together with an endless thread the emotional life of my people.", author: "Nilda Calla√±aupa Alvarez" },
          { text: "I wanted to tell my story through fabric because it was a medium that was accessible to me as a woman and as an African American.", author: "Faith Ringgold" },
          { text: "Come stitch next to me, and I'll tell you a story.", author: "Sonya Clark" },
          { text: "Fabric is a material that forgives. You can always mend, patch, darn, and transform it into something new.", author: "Louise Bourgeois" },
          { text: "We must learn inner solitude wherever or with whomsoever we may be. We must learn to penetrate things and find God in them.", author: "Anni Albers" },
          { text: "Thread has the potential to unite, to heal, to provide a soft structure in a hard world.", author: "Sheila Hicks" },
          { text: "The loom is the universe in miniature‚Äîwarp and weft, the essential crossing that creates all structure, all meaning.", author: "Lenore Tawney" },
          { text: "Western art tradition values fine art practices such as painting, mostly done by men and on canvas. Bringing these techniques into the gallery space allows me to question the hierarchy in the Western art world.", author: "Hale Ekinci" },
          { text: "The true measure of our commitment to justice, the character of our society, our commitment to the rule of law, fairness, and equality cannot be measured by how we treat the rich, the powerful, the privileged, and the respected among us.", author: "Bryan Stevenson" },
          { text: "We cannot seek achievement for ourselves and forget about the progress and prosperity for our community.", author: "Dolores Huerta" },
          { text: "If you see something that is not right, not fair, not just, you have a moral obligation to do something about it.", author: "John Lewis" },
          { text: "Trauma happens in relationship, so does healing.", author: "Tarana Burke" },
          { text: "Real change requires real relationships. And real relationships require that we tell the truth about our experiences.", author: "Alicia Garza" },
          { text: "Care is the strategy. Care is what we need more of in this world. Care is revolutionary.", author: "Ai-jen Poo" },
          { text: "We accomplish nothing if we say nothing. We accomplish nothing if we do nothing. And we accomplish nothing if we know nothing.", author: "Stacey Abrams" }
        ];
        this.shuffledIndexes = [2, 4, 0, 5, 3, 1, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99];
      }

      getTodayQuote() {
        // Use UTC time for day calculation - quote changes at 7:00 AM UTC
        const now = new Date();
        
        // Adjust for 7 AM UTC day boundary instead of midnight UTC
        // If it's before 7 AM UTC, use yesterday's quote
        const utcHours = now.getUTCHours();
        const adjustedDate = new Date(now);
        
        if (utcHours < 7) {
          // Before 7 AM UTC, use yesterday's date
          adjustedDate.setUTCDate(adjustedDate.getUTCDate() - 1);
        }
        
        const dayIndex = Math.floor(adjustedDate.getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        
        // Quote selected for today
        
        return this.quotes[quoteIndex];
      }

      getQuoteForDate(dateString) {
        // dateString format: "2025-08-18" - assumes UTC date
        const date = new Date(dateString);
        const dayIndex = Math.floor(date.getTime() / (1000 * 60 * 60 * 24));
        const quoteIndex = this.shuffledIndexes[dayIndex % this.shuffledIndexes.length];
        
        console.log(`üîç getQuoteForDate: ${dateString} (UTC) ‚Üí dayIndex: ${dayIndex} ‚Üí quoteIndex: ${quoteIndex} ‚Üí quote: "${this.quotes[quoteIndex].text.substring(0, 50)}..."`);
        
        return this.quotes[quoteIndex];
      }

      displayQuote() {
        try {
          const { text, author } = this.getTodayQuote();
          const quoteLine = document.querySelector('.quote-line');
          const quoteAuthor = document.querySelector('.quote-author');
          
          // Reset fade-in elements to hidden state when quote is displayed
          const fadeElements = document.querySelectorAll('.quote-screen-fade-in');
          fadeElements.forEach(el => el.classList.remove('visible'));
          
          if (quoteLine) {
            quoteLine.textContent = text;
            
            // IMMEDIATE check: If text is longer than ~100 characters, apply long-quote class immediately
            if (text.length > 100) {
              quoteLine.classList.add('long-quote');
              console.log('Applied long-quote class immediately based on text length:', text.length);
            } else {
              // For shorter text, check height-based measurement
              this.checkQuoteLength(quoteLine);
            }
          }
          if (quoteAuthor) {
            quoteAuthor.textContent = author;
            // Apply same long-quote class to author if quote is long
            if (quoteLine && quoteLine.classList.contains('long-quote')) {
              quoteAuthor.classList.add('long-quote');
            } else {
              quoteAuthor.classList.remove('long-quote');
            }
          }
          
          // Also populate the quote display on the quilt screen
          const quiltQuoteText = document.querySelector('.quilt-quote-text');
          const quiltQuoteAuthor = document.querySelector('.quilt-quote-author');
          const quiltQuoteDisplay = document.querySelector('.quilt-quote-display');
          
          if (quiltQuoteText) quiltQuoteText.textContent = text;
          if (quiltQuoteAuthor) quiltQuoteAuthor.textContent = author;
          
          // Show the quote display when content is populated
          if (quiltQuoteDisplay && text && author) {
            quiltQuoteDisplay.classList.add('has-content');
          }

        } catch (error) {
          console.error('Error displaying quote:', error);
        }
      }

      // Check if quote is longer than 2 lines and apply appropriate styling
      checkQuoteLength(quoteElement) {
        // Prevent multiple calls on the same element
        if (quoteElement.dataset.lengthChecked === 'true') {
          return;
        }
        
        // Track retry attempts to prevent infinite loops
        const retryCount = parseInt(quoteElement.dataset.retryCount || '0');
        if (retryCount >= 3) {
          console.log('Quote element still not visible after 3 retries, giving up');
          return;
        }
        
        // Mark as checked to prevent re-runs
        quoteElement.dataset.lengthChecked = 'true';
        
        // Use setTimeout to ensure the text is fully rendered before measuring
        setTimeout(() => {
          // Check if element is visible
          if (quoteElement.offsetHeight === 0) {
            console.log('Quote element not visible yet, retrying...');
            // Reset the flag and retry after a longer delay
            delete quoteElement.dataset.lengthChecked;
            quoteElement.dataset.retryCount = (retryCount + 1).toString();
            setTimeout(() => this.checkQuoteLength(quoteElement), 500);
            return;
          }
          
          // Get the computed line height
          const computedStyle = window.getComputedStyle(quoteElement);
          const lineHeight = parseFloat(computedStyle.lineHeight);
          const elementHeight = quoteElement.offsetHeight;
          
          console.log('Quote height:', elementHeight, 'Line height:', lineHeight, 'Ratio:', elementHeight / lineHeight);
          
          // If the element height is more than 2.2 times the line height, consider it long (lowered threshold)
          if (elementHeight > lineHeight * 2.2) {
            quoteElement.classList.add('long-quote');
            console.log('Applied long-quote class');
          }
        }, 200);
      }

      // Load quotes from Firestore
      async loadQuotesFromFirestore() {
        try {
          console.log('üìö Loading quotes from Firestore...');
          
          // Check if global Firestore is available
          // if (!window.db || !window.firestore) {
          //   console.log('üìö Global Firestore not available, using default quotes');
          //   return false;
          // }
          
          // Use the global Firestore functions
          // const docRef = window.firestore.doc(window.db, 'quotes', 'daily');
          // const docSnap = await window.firestore.getDoc(docRef);
          
          // if (docSnap.exists() && docSnap.data().quotes) {
          //   this.quotes = docSnap.data().quotes;
          //   if (docSnap.data().shuffledIndexes) {
          //     this.shuffledIndexes = docSnap.data().shuffledIndexes;
          //     console.log('‚úÖ Loaded shuffled indexes from Firestore:', this.shuffledIndexes.length, 'indexes');
          //   }
          //   console.log('‚úÖ Loaded quotes from Firestore:', this.quotes.length, 'quotes');
          //   
          //   Update the display if we're on the quote screen
          //   if (document.querySelector('.quote-line')) {
          //     this.displayQuote();
          //   }
          //   
          //   return true;
          // } else {
          //   console.log('üìö No quotes found in Firestore, using defaults');
          //   return false;
          // }
          
          console.log('üìö Using default quotes - Firestore disabled');
          return false;
          
        } catch (error) {
          console.error('‚ùå Error loading quotes from Firestore:', error);
          
          // Fallback to localStorage if available
          try {
            const savedQuotes = localStorage.getItem('ourDailyQuotes');
            if (savedQuotes) {
              this.quotes = JSON.parse(savedQuotes);
              console.log('üìö Loaded quotes from localStorage fallback:', this.quotes.length, 'quotes');
              return true;
            }
          } catch (localError) {
            console.error('Error loading from localStorage:', localError);
          }
          
          return false;
        }
      }
    }

    // ===== ENHANCED RENDERER =====
    class QuiltRendererV2 {
      constructor(logger) {
        this.logger = logger;
        this.quiltSVG = null;
        this.lastAddedIndex = null;
        this.userPieces = new Set();
      }
      
      // Calculate progressive jitter decrease based on number of blocks
      calculateJitterMultiplier(blockWidth, blockHeight) {
        const blockArea = blockWidth * blockHeight;
        const minBlockSize = 20; // Minimum size for reference
        const maxBlockSize = 200; // Maximum size for reference
        
        // Normalize block size to 0-1 range
        const normalizedSize = Math.min(1, Math.max(0, (blockArea - minBlockSize * minBlockSize) / (maxBlockSize * maxBlockSize - minBlockSize * minBlockSize)));
        
        // Larger blocks get more jitter, smaller blocks get less jitter
        // Range from 0.1 (tiny blocks) to 1.0 (large blocks)
        return 0.1 + (normalizedSize * 0.9);
      }
      
      // Calculate rotation jitter multiplier based on block size (like checkerboard approach)
      calculateRotationMultiplier(blockWidth, blockHeight) {
        const blockArea = blockWidth * blockHeight;
        const minBlockSize = 20; // Minimum size for reference
        const maxBlockSize = 200; // Maximum size for reference
        
        // Normalize block size to 0-1 range
        const normalizedSize = Math.min(1, Math.max(0, (blockArea - minBlockSize * minBlockSize) / (maxBlockSize * maxBlockSize - minBlockSize * minBlockSize)));
        
        // Larger blocks get more rotation, smaller blocks get less rotation
        // Range from 0.05 (tiny blocks) to 1.0 (large blocks)
        return 0.05 + (normalizedSize * 0.95);
      }

      initialize() {
        this.quiltSVG = document.getElementById('quilt');
        if (!this.quiltSVG) {
          throw new Error('Quilt SVG element not found');
        }
        
        // Set initial viewBox to viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        this.quiltSVG.setAttribute('viewBox', `0 0 ${viewportWidth} ${viewportHeight}`);
        this.quiltSVG.setAttribute('width', viewportWidth);
        this.quiltSVG.setAttribute('height', viewportHeight);
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      }

      renderBlocks(blocks, userPieces = [], submissionCount = 0) {
        if (!this.quiltSVG) {
          this.logger.warn('Quilt SVG not found');
          return;
        }

        this.quiltSVG.innerHTML = '';
        this.userPieces = new Set(userPieces.map(b => b.id));

        if (blocks.length === 0) {
          console.log('üîß renderBlocks: No blocks to render, showing placeholder');
          // Add a placeholder when no blocks exist
          this.quiltSVG.innerHTML = `
            <rect x="0" y="0" width="100%" height="100%" fill="#f0f0f0" opacity="0.5"/>
            <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" 
                  font-family="Arial, sans-serif" font-size="24" fill="#666">
              No quilt blocks to display (blocks.length: ${blocks.length})
            </text>
          `;
          this.quiltSVG.setAttribute('viewBox', '0 0 400 300');
          this.quiltSVG.setAttribute('width', '100%');
          this.quiltSVG.setAttribute('height', '100%');
          return;
        }

        // Calculate actual quilt bounds from blocks
        const minX = Math.min(...blocks.map(b => b.x));
        const minY = Math.min(...blocks.map(b => b.y));
        const maxX = Math.max(...blocks.map(b => b.x + b.width));
        const maxY = Math.max(...blocks.map(b => b.y + b.height));
        
        const actualQuiltWidth = maxX - minX;
        const actualQuiltHeight = maxY - minY;
        
        // Add some padding around the quilt content
        const padding = 20;
        const viewBoxWidth = actualQuiltWidth + (padding * 2);
        const viewBoxHeight = actualQuiltHeight + (padding * 2);
        
        // Set viewBox to actual quilt content with padding
        this.quiltSVG.setAttribute('viewBox', `${minX - padding} ${minY - padding} ${viewBoxWidth} ${viewBoxHeight}`);
        
        // Set SVG dimensions to fill container
        this.quiltSVG.setAttribute('width', '100%');
        this.quiltSVG.setAttribute('height', '100%');
        
        console.log('üîß USING ACTUAL QUILT DIMENSIONS:', actualQuiltWidth, 'x', actualQuiltHeight);
        
        // Mobile: Center the quilt content and fit fully inside container
        this.quiltSVG.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        
        // Make SVG fill the entire container with !important
        this.quiltSVG.style.setProperty('width', '100%', 'important');
        this.quiltSVG.style.setProperty('height', '100%', 'important');
        this.quiltSVG.style.setProperty('max-width', '100%', 'important');
        this.quiltSVG.style.setProperty('max-height', '100%', 'important');
        
        // Debug: Log SVG dimensions
        console.log('üîß SVG dimensions set to:', {
          width: this.quiltSVG.style.width,
          height: this.quiltSVG.style.height,
          viewBox: this.quiltSVG.getAttribute('viewBox'),
          preserveAspectRatio: this.quiltSVG.getAttribute('preserveAspectRatio')
        });
        
        // No global flip - individual blocks will be flipped when touched

        // No complex filters - we'll use a simple approach for sharp edges
        
        // Function to create inward feathering shadow filter for each block
        const createInwardShadowFilter = (blockColor, blockId) => {
          // Convert hex to darker version (about 30% darker)
          const hex = blockColor.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);
          
          // Make color darker by reducing RGB values
          const darkerR = Math.max(0, Math.floor(r * 0.7));
          const darkerG = Math.max(0, Math.floor(g * 0.7));
          const darkerB = Math.max(0, Math.floor(b * 0.7));
          
          const darkerColor = `rgb(${darkerR}, ${darkerG}, ${darkerB})`;
          
          const filterId = `inwardShadow-${blockId}`;
          const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
          filter.setAttribute('id', filterId);
          filter.setAttribute('x', '-50%');
          filter.setAttribute('y', '-50%');
          filter.setAttribute('width', '200%');
          filter.setAttribute('height', '200%');
          
          // Create inner shadow effect using feMorphology and feOffset
          const morphology = document.createElementNS('http://www.w3.org/2000/svg', 'feMorphology');
          morphology.setAttribute('operator', 'erode');
          morphology.setAttribute('radius', '2');
          
          const offset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
          offset.setAttribute('dx', '0');
          offset.setAttribute('dy', '0');
          
          const flood = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
          flood.setAttribute('flood-color', darkerColor);
          flood.setAttribute('flood-opacity', '0.3');
          
          const composite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
          composite.setAttribute('operator', 'in');
          
          const gaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
          gaussianBlur.setAttribute('stdDeviation', '1.5');
          
          filter.appendChild(morphology);
          filter.appendChild(offset);
          filter.appendChild(flood);
          filter.appendChild(composite);
          filter.appendChild(gaussianBlur);
          
          return filter;
        };

        // Calculate jitter per block based on individual block size
        // We'll calculate these inside the block loop since each block has different dimensions
        
        // Pattern selection function
        const getPatternForColor = (color) => {
          // Convert hex to HSL to determine color family
          const hex = color.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16) / 255;
          const g = parseInt(hex.substr(2, 2), 16) / 255;
          const b = parseInt(hex.substr(4, 2), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          
          let h = 0;
          if (max !== min) {
            const d = max - min;
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          
          const hue = h * 360;
          const saturation = l === 0 || l === 1 ? 0 : (max - l) / Math.min(l, 1 - l);
          
          // Pattern selection based on color characteristics
          if (saturation < 0.3) return 'geometric'; // Low saturation = neutral
          if (hue < 60 || hue > 300) return 'dots'; // Warm colors (red, orange, yellow, pink)
          if (hue < 180) return 'stripes'; // Cool colors (green, blue)
          return 'floral'; // Purple and other colors
        };
        
        blocks.forEach((block, i) => {
          
          // Special handling for special pattern cells - render as organic polygons
          if (block.patternType === 'special' && block.specialPatternType) {
            // Ensure positive dimensions to prevent SVG errors
            const safeWidth = Math.max(1, block.width);
            const safeHeight = Math.max(1, block.height);
            
            // Use organic polygon for special patterns too
            const jitterMultiplier = this.calculateJitterMultiplier(block.width, block.height);
            const handCutPolygon = this.createHandCutPolygon(block.x, block.y, safeWidth, safeHeight, jitterMultiplier);
            handCutPolygon.setAttribute('fill', block.color);
            handCutPolygon.setAttribute('stroke', 'none');
            
            // Add new block animation for special pattern cells
            if (i === this.lastAddedIndex) {
              handCutPolygon.setAttribute('opacity', '0');
              handCutPolygon.classList.add('new-block');
              handCutPolygon.addEventListener('animationend', () => {
                handCutPolygon.classList.remove('new-block');
                handCutPolygon.removeAttribute('opacity');
              }, { once: true });
            }
            
            this.quiltSVG.appendChild(handCutPolygon);
            return; // Skip the rest of the block rendering logic
          }
          
          // Calculate jitter based on this specific block's size
          const jitterMultiplier = this.calculateJitterMultiplier(block.width, block.height);
          const rotationMultiplier = this.calculateRotationMultiplier(block.width, block.height);
          
          const jitterX = (Math.random() - 0.5) * 6 * jitterMultiplier;
          const jitterY = (Math.random() - 0.5) * 6 * jitterMultiplier;
          const jitterRotation = (Math.random() - 0.5) * 3 * rotationMultiplier;
          
          // Calculate gap compensation for rotation
          const rotationRadians = jitterRotation * Math.PI / 180;
          const maxExtension = Math.max(block.width, block.height) * Math.abs(Math.sin(rotationRadians)) * 0.3;
          
          const jitteredBlock = {
            x: block.x + jitterX - (maxExtension * 0.5),
            y: block.y + jitterY - (maxExtension * 0.5),
            width: block.width,
            height: block.height,
            color: block.color,
            rotation: jitterRotation
          };
          
                            // Calculate if this block should be scaled (large blocks get 1% bigger)
          const blockArea = jitteredBlock.width * jitteredBlock.height;
          const areaFactor = Math.sqrt(blockArea) / 100;
          const blockScale = areaFactor >= 2 ? 1.01 : 1.0;
          const scaledWidth = Math.max(1, jitteredBlock.width * blockScale);
          const scaledHeight = Math.max(1, jitteredBlock.height * blockScale);
          
          // Create hand-cut polygon instead of perfect rectangle
          const handCutPolygon = this.createHandCutPolygon(jitteredBlock.x, jitteredBlock.y, scaledWidth, scaledHeight, jitterMultiplier);
          handCutPolygon.setAttribute('fill', jitteredBlock.color);
          
                   // Create individual pattern elements for this block instead of using tiling patterns
         const basePatternType = getPatternForColor(jitteredBlock.color);
         const patternVariations = {
           dots: ['dots1', 'dots2', 'dots3', 'dots4', 'dots5', 'dots6', 'dots7'],
           stripes: ['stripes1', 'stripes2', 'stripes3', 'stripes4', 'stripes5', 'stripes6', 'stripes7'],
           floral: ['floral1', 'floral2', 'floral3', 'floral4', 'floral5', 'floral6'],
           geometric: ['geometric1', 'geometric2', 'geometric3', 'geometric4', 'geometric5', 'geometric6']
         };
         
         // Randomly select a variation of the pattern type
         const variations = patternVariations[basePatternType];
         const randomVariation = variations[Math.floor(Math.random() * variations.length)];
         
         // Add organic randomness to pattern opacity, positioning, and scale
         const opacityVariation = 0.7 + (Math.random() * 0.6); // 0.7 to 1.3 (more variation)
         
         // Calculate safe offset limits to keep pattern within block bounds
         const maxOffsetX = Math.min(3, jitteredBlock.width * 0.1); // 10% of block width max
         const maxOffsetY = Math.min(3, jitteredBlock.height * 0.1); // 10% of block height max
         const patternOffsetX = (Math.random() - 0.5) * maxOffsetX * 2; // -maxOffset to +maxOffset
         const patternOffsetY = (Math.random() - 0.5) * maxOffsetY * 2; // -maxOffset to +maxOffset
         
         // Calculate safe scale to ensure pattern fills block but doesn't overflow
         const scaleVariation = 0.9 + (Math.random() * 0.2); // 0.9 to 1.1 (smaller scale range)
         
         // Calculate safe rotation to prevent overflow
         const maxRotation = Math.min(4, 15 / Math.max(jitteredBlock.width, jitteredBlock.height)); // Smaller blocks get less rotation
         const rotationVariation = (Math.random() - 0.5) * maxRotation * 2; // -maxRotation to +maxRotation

         // Create individual pattern elements for this block
         const patternGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
         patternGroup.setAttribute('opacity', opacityVariation);
         
         patternGroup.setAttribute('transform', `translate(${jitteredBlock.x + patternOffsetX}, ${jitteredBlock.y + patternOffsetY}) scale(${scaleVariation}) rotate(${rotationVariation} ${jitteredBlock.width/2} ${jitteredBlock.height/2})`);
         
         // Create clipping path for this block
         const clipPathId = `clip-${i}`;
         const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
         clipPath.setAttribute('id', clipPathId);
         const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         clipRect.setAttribute('x', 0);
         clipRect.setAttribute('y', 0);
         clipRect.setAttribute('width', Math.max(1, jitteredBlock.width));
         clipRect.setAttribute('height', Math.max(1, jitteredBlock.height));
         clipPath.appendChild(clipRect);
         this.quiltSVG.appendChild(clipPath);
         
         patternGroup.setAttribute('clip-path', `url(#${clipPathId})`);
         
         // Create pattern elements based on the selected variation
         this.createPatternElements(patternGroup, randomVariation, jitteredBlock.width, jitteredBlock.height);
         
         // Add the pattern group to the SVG
          

          
          const centerX = jitteredBlock.x + jitteredBlock.width / 2;
          const centerY = jitteredBlock.y + jitteredBlock.height / 2;
          
          // Apply basic rotation transformation
          handCutPolygon.setAttribute('transform', `rotate(${jitterRotation} ${centerX} ${centerY})`);
          

          handCutPolygon.setAttribute('data-block-id', block.id);
          
          // Add user piece highlighting
          if (this.userPieces.has(block.id)) {
            handCutPolygon.classList.add('user-piece-highlight');
          }
          
          // Add new block animation
          if (i === this.lastAddedIndex) {
            handCutPolygon.setAttribute('opacity', '0');
            handCutPolygon.classList.add('new-block');
            handCutPolygon.addEventListener('animationend', () => {
              handCutPolygon.classList.remove('new-block');
              handCutPolygon.removeAttribute('opacity');
            }, { once: true });
          }
          
          this.quiltSVG.appendChild(handCutPolygon);
        });
        
        // Show newly added blocks (only when there are new blocks)
        const newBlocks = blocks.filter(b => b.submissionIndex === submissionCount);
        if (newBlocks.length > 0) {
          console.log(`üÜï Added ${newBlocks.length} new block(s):`, newBlocks.map(b => ({
            color: b.color,
            size: `${Math.round(b.width)}√ó${Math.round(b.height)}`,
            area: Math.round(b.width * b.height),
            type: b.specialPatternType || 'regular'
          })));
        }

        this.lastAddedIndex = null;
      }

      setLastAddedIndex(index) {
        this.lastAddedIndex = index;
      }
      
      // Create hand-cut polygon with progressive edge variation based on size
      createHandCutPolygon(x, y, width, height, jitterMultiplier) {
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        
        // Calculate progressive edge variation based on block size
        const blockArea = width * height;
        const minVariation = 1; // Minimum 1px variation for tiny blocks
        const maxVariation = 6; // Reduced from 12 to 6 for less dramatic large blocks
        
        // More selective scaling - large blocks get moderate variation, not dramatic
        const areaFactor = Math.sqrt(blockArea) / 100; // Normalize to 100px¬≤ blocks
        
        // Use a threshold system: small/medium blocks stay subtle, large ones get moderate variation
        let sizeAdjustedVariation;
        if (areaFactor < 2) {
          // Small/medium blocks: subtle variation (1-4px)
          sizeAdjustedVariation = Math.min(4, Math.max(minVariation, areaFactor * 2));
        } else {
          // Large blocks: moderate variation (4-6px) - much less dramatic
          sizeAdjustedVariation = Math.min(maxVariation, 4 + (areaFactor - 2) * 1);
        }
        
        // Apply jitter multiplier to the size-adjusted variation
        const handCutVariation = sizeAdjustedVariation * jitterMultiplier;;
        
        // Progressive segments - also more selective
        const minSegments = 1; // Minimal segments for tiny blocks
        const maxSegments = 4; // Reduced from 6 to 4 for less wavy large blocks
        
        let segments;
        if (areaFactor < 2) {
          // Small/medium blocks: minimal segments (1-3)
          segments = Math.max(minSegments, Math.min(3, Math.floor(areaFactor * 1.5)));
        } else {
          // Large blocks: moderate segments (3-4) - less wavy
          segments = Math.max(3, Math.min(maxSegments, Math.floor(3 + (areaFactor - 2) * 0.5)));
        }
        
        const points = [];
        
        // Top edge (left to right)
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const baseX = t * width;
          const baseY = 0;
          const variationX = (Math.random() - 0.5) * handCutVariation;
          const variationY = (Math.random() - 0.5) * handCutVariation;
          points.push(`${baseX + variationX + x},${baseY + variationY + y}`);
        }
        
        // Right edge (top to bottom)
        for (let i = 1; i <= segments; i++) {
          const t = i / segments;
          const baseX = width;
          const baseY = t * height;
          const variationX = (Math.random() - 0.5) * handCutVariation;
          const variationY = (Math.random() - 0.5) * handCutVariation;
          points.push(`${baseX + variationX + x},${baseY + variationY + y}`);
        }
        
        // Bottom edge (right to left)
        for (let i = 1; i <= segments; i++) {
          const t = i / segments;
          const baseX = width - (t * width);
          const baseY = height;
          const variationX = (Math.random() - 0.5) * handCutVariation;
          const variationY = (Math.random() - 0.5) * handCutVariation;
          points.push(`${baseX + variationX + x},${baseY + variationY + y}`);
        }
        
        // Left edge (bottom to top)
        for (let i = 1; i <= segments; i++) {
          const t = i / segments;
          const baseX = 0;
          const baseY = height - (t * height);
          const variationX = (Math.random() - 0.5) * handCutVariation;
          const variationY = (Math.random() - 0.5) * handCutVariation;
          points.push(`${baseX + variationX + x},${baseY + variationY + y}`);
        }
        
        polygon.setAttribute('points', points.join(' '));
        return polygon;
      }
      
      createPatternElements(patternGroup, variation, blockWidth, blockHeight) {
        // Create individual pattern elements based on the variation type
        const patternData = this.getPatternData(variation);
        
        // Scale pattern to fit block size
        const scaleX = blockWidth / patternData.width;
        const scaleY = blockHeight / patternData.height;
        const scale = Math.min(scaleX, scaleY) * 0.8; // 80% to ensure it fits within block
        
        // Create pattern elements
        patternData.elements.forEach(element => {
          const elementNode = document.createElementNS('http://www.w3.org/2000/svg', element.type);
          
          // Set attributes based on element type
          if (element.type === 'circle') {
            elementNode.setAttribute('cx', element.cx * scale);
            elementNode.setAttribute('cy', element.cy * scale);
            elementNode.setAttribute('r', Math.max(0.1, element.r * scale));
          } else if (element.type === 'ellipse') {
            elementNode.setAttribute('cx', element.cx * scale);
            elementNode.setAttribute('cy', element.cy * scale);
            elementNode.setAttribute('rx', Math.max(0.1, element.rx * scale));
            elementNode.setAttribute('ry', Math.max(0.1, element.ry * scale));
          } else if (element.type === 'line') {
            elementNode.setAttribute('x1', element.x1 * scale);
            elementNode.setAttribute('y1', element.y1 * scale);
            elementNode.setAttribute('x2', element.x2 * scale);
            elementNode.setAttribute('y2', element.y2 * scale);
          } else if (element.type === 'path') {
            // Scale path coordinates
            const scaledPath = element.d.replace(/(\d+(?:\.\d+)?)/g, (match) => {
              return parseFloat(match) * scale;
            });
            elementNode.setAttribute('d', scaledPath);
          } else if (element.type === 'polygon') {
            const scaledPoints = element.points.split(' ').map(point => {
              const [x, y] = point.split(',').map(Number);
              return `${x * scale},${y * scale}`;
            }).join(' ');
            elementNode.setAttribute('points', scaledPoints);
          }
          
          // Set common attributes
          if (element.fill) elementNode.setAttribute('fill', element.fill);
          if (element.stroke) elementNode.setAttribute('stroke', element.stroke);
          if (element.strokeWidth) elementNode.setAttribute('stroke-width', element.strokeWidth * scale);
          
          patternGroup.appendChild(elementNode);
        });
      }
      
      getPatternData(variation) {
        // Define pattern data for each variation
        const patterns = {
          dots1: {
            width: 12, height: 12,
            elements: [
              { type: 'circle', cx: 6, cy: 6, r: 1.5, fill: 'rgba(255,255,255,0.25)' },
              { type: 'circle', cx: 2, cy: 2, r: 1, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 10, cy: 10, r: 1, fill: 'rgba(255,255,255,0.15)' }
            ]
          },
          dots2: {
            width: 14, height: 14,
            elements: [
              { type: 'circle', cx: 7, cy: 7, r: 1.8, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 3, cy: 3, r: 0.8, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 11, cy: 11, r: 0.8, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 7, cy: 3, r: 0.6, fill: 'rgba(255,255,255,0.1)' }
            ]
          },
          dots3: {
            width: 10, height: 10,
            elements: [
              { type: 'circle', cx: 5, cy: 5, r: 1.2, fill: 'rgba(255,255,255,0.18)' },
              { type: 'circle', cx: 2, cy: 2, r: 0.7, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 8, cy: 8, r: 0.7, fill: 'rgba(255,255,255,0.12)' }
            ]
          },
          dots4: {
            width: 12, height: 24,
            elements: [
              // Row 1
              { type: 'circle', cx: 6, cy: 6, r: 1.5, fill: 'rgba(255,255,255,0.25)' },
              { type: 'circle', cx: 2, cy: 2, r: 1, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 10, cy: 10, r: 1, fill: 'rgba(255,255,255,0.15)' },
              // Row 2 (offset)
              { type: 'circle', cx: 0, cy: 18, r: 1.5, fill: 'rgba(255,255,255,0.25)' },
              { type: 'circle', cx: 8, cy: 14, r: 1, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 4, cy: 22, r: 1, fill: 'rgba(255,255,255,0.15)' }
            ]
          },
          dots5: {
            width: 14, height: 28,
            elements: [
              // Row 1
              { type: 'circle', cx: 7, cy: 7, r: 1.8, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 3, cy: 3, r: 0.8, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 11, cy: 11, r: 0.8, fill: 'rgba(255,255,255,0.12)' },
              // Row 2 (offset)
              { type: 'circle', cx: 0, cy: 21, r: 1.8, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 10, cy: 17, r: 0.8, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 4, cy: 25, r: 0.8, fill: 'rgba(255,255,255,0.12)' }
            ]
          },
          dots6: {
            width: 16, height: 16,
            elements: [
              { type: 'ellipse', cx: 4, cy: 4, rx: 1.8, ry: 1.2, fill: 'rgba(255,255,255,0.25)' },
              { type: 'ellipse', cx: 12, cy: 6, rx: 1.2, ry: 1.6, fill: 'rgba(255,255,255,0.18)' },
              { type: 'ellipse', cx: 8, cy: 12, rx: 1.5, ry: 1.1, fill: 'rgba(255,255,255,0.22)' },
              { type: 'ellipse', cx: 2, cy: 10, rx: 0.9, ry: 1.3, fill: 'rgba(255,255,255,0.15)' },
              { type: 'ellipse', cx: 14, cy: 14, rx: 1.1, ry: 0.8, fill: 'rgba(255,255,255,0.12)' }
            ]
          },
          dots7: {
            width: 18, height: 18,
            elements: [
              { type: 'circle', cx: 3, cy: 3, r: 1.1, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 15, cy: 5, r: 0.8, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 9, cy: 9, r: 1.4, fill: 'rgba(255,255,255,0.25)' },
              { type: 'circle', cx: 5, cy: 15, r: 0.6, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 12, cy: 12, r: 1.0, fill: 'rgba(255,255,255,0.18)' },
              { type: 'circle', cx: 7, cy: 7, r: 0.7, fill: 'rgba(255,255,255,0.1)' }
            ]
          },
          stripes1: {
            width: 8, height: 8,
            elements: [
              { type: 'line', x1: 0, y1: 4, x2: 8, y2: 4, stroke: 'rgba(255,255,255,0.2)', strokeWidth: 1 },
              { type: 'line', x1: 4, y1: 0, x2: 4, y2: 8, stroke: 'rgba(255,255,255,0.15)', strokeWidth: 0.5 }
            ]
          },
          stripes2: {
            width: 12, height: 12,
            elements: [
              { type: 'line', x1: 0, y1: 6, x2: 12, y2: 6, stroke: 'rgba(255,255,255,0.18)', strokeWidth: 1.2 },
              { type: 'line', x1: 6, y1: 0, x2: 6, y2: 12, stroke: 'rgba(255,255,255,0.12)', strokeWidth: 0.8 },
              { type: 'line', x1: 0, y1: 3, x2: 12, y2: 3, stroke: 'rgba(255,255,255,0.1)', strokeWidth: 0.4 }
            ]
          },
          stripes3: {
            width: 10, height: 10,
            elements: [
              { type: 'line', x1: 0, y1: 5, x2: 10, y2: 5, stroke: 'rgba(255,255,255,0.15)', strokeWidth: 0.8 },
              { type: 'line', x1: 5, y1: 0, x2: 5, y2: 10, stroke: 'rgba(255,255,255,0.12)', strokeWidth: 0.6 }
            ]
          },
          stripes4: {
            width: 8, height: 16,
            elements: [
              // Row 1
              { type: 'line', x1: 0, y1: 4, x2: 8, y2: 4, stroke: 'rgba(255,255,255,0.2)', strokeWidth: 1 },
              { type: 'line', x1: 4, y1: 0, x2: 4, y2: 8, stroke: 'rgba(255,255,255,0.15)', strokeWidth: 0.5 },
              // Row 2 (offset)
              { type: 'line', x1: 4, y1: 12, x2: 12, y2: 12, stroke: 'rgba(255,255,255,0.2)', strokeWidth: 1 },
              { type: 'line', x1: 8, y1: 8, x2: 8, y2: 16, stroke: 'rgba(255,255,255,0.15)', strokeWidth: 0.5 }
            ]
          },
          stripes5: {
            width: 12, height: 24,
            elements: [
              // Row 1
              { type: 'line', x1: 0, y1: 6, x2: 12, y2: 6, stroke: 'rgba(255,255,255,0.18)', strokeWidth: 1.2 },
              { type: 'line', x1: 6, y1: 0, x2: 6, y2: 12, stroke: 'rgba(255,255,255,0.12)', strokeWidth: 0.8 },
              { type: 'line', x1: 0, y1: 3, x2: 12, y2: 3, stroke: 'rgba(255,255,255,0.1)', strokeWidth: 0.4 },
              // Row 2 (offset)
              { type: 'line', x1: 6, y1: 18, x2: 18, y2: 18, stroke: 'rgba(255,255,255,0.18)', strokeWidth: 1.2 },
              { type: 'line', x1: 12, y1: 12, x2: 12, y2: 24, stroke: 'rgba(255,255,255,0.12)', strokeWidth: 0.8 },
              { type: 'line', x1: 6, y1: 15, x2: 18, y2: 15, stroke: 'rgba(255,255,255,0.1)', strokeWidth: 0.4 }
            ]
          },
          stripes6: {
            width: 16, height: 16,
            elements: [
              { type: 'path', d: 'M0,4 Q4,2 8,4 T16,4', stroke: 'rgba(255,255,255,0.2)', strokeWidth: 1 },
              { type: 'path', d: 'M0,12 Q4,10 8,12 T16,12', stroke: 'rgba(255,255,255,0.15)', strokeWidth: 0.8 },
              { type: 'path', d: 'M4,0 Q6,4 4,8 T4,16', stroke: 'rgba(255,255,255,0.12)', strokeWidth: 0.6 }
            ]
          },
          stripes7: {
            width: 20, height: 20,
            elements: [
              { type: 'path', d: 'M0,5 L20,6', stroke: 'rgba(255,255,255,0.18)', strokeWidth: 1.2 },
              { type: 'path', d: 'M0,15 L20,14', stroke: 'rgba(255,255,255,0.15)', strokeWidth: 0.9 },
              { type: 'path', d: 'M5,0 L6,20', stroke: 'rgba(255,255,255,0.12)', strokeWidth: 0.7 },
              { type: 'path', d: 'M15,0 L14,20', stroke: 'rgba(255,255,255,0.1)', strokeWidth: 0.5 }
            ]
          },
          floral1: {
            width: 24, height: 24,
            elements: [
              { type: 'circle', cx: 12, cy: 12, r: 3, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 9, cy: 9, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 15, cy: 9, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 12, cy: 6, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 12, cy: 18, r: 1.5, fill: 'rgba(255,255,255,0.15)' }
            ]
          },
          floral2: {
            width: 28, height: 28,
            elements: [
              { type: 'circle', cx: 14, cy: 14, r: 3.5, fill: 'rgba(255,255,255,0.18)' },
              { type: 'circle', cx: 11, cy: 11, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 17, cy: 11, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 14, cy: 8, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 14, cy: 20, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 11, cy: 17, r: 1.2, fill: 'rgba(255,255,255,0.08)' }
            ]
          },
          floral3: {
            width: 24, height: 48,
            elements: [
              // Row 1
              { type: 'circle', cx: 12, cy: 12, r: 3, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 9, cy: 9, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 15, cy: 9, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 12, cy: 6, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 12, cy: 18, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              // Row 2 (offset)
              { type: 'circle', cx: 0, cy: 36, r: 3, fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 21, cy: 33, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 3, cy: 33, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 0, cy: 30, r: 1.5, fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 0, cy: 42, r: 1.5, fill: 'rgba(255,255,255,0.15)' }
            ]
          },
          floral4: {
            width: 28, height: 56,
            elements: [
              // Row 1
              { type: 'circle', cx: 14, cy: 14, r: 3.5, fill: 'rgba(255,255,255,0.18)' },
              { type: 'circle', cx: 11, cy: 11, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 17, cy: 11, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 14, cy: 8, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 14, cy: 20, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 11, cy: 17, r: 1.2, fill: 'rgba(255,255,255,0.08)' },
              // Row 2 (offset)
              { type: 'circle', cx: 0, cy: 42, r: 3.5, fill: 'rgba(255,255,255,0.18)' },
              { type: 'circle', cx: 25, cy: 39, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 3, cy: 39, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 0, cy: 36, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 0, cy: 48, r: 2, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 25, cy: 45, r: 1.2, fill: 'rgba(255,255,255,0.08)' }
            ]
          },
          floral5: {
            width: 32, height: 32,
            elements: [
              { type: 'ellipse', cx: 16, cy: 16, rx: 4, ry: 3, fill: 'rgba(255,255,255,0.2)' },
              { type: 'ellipse', cx: 12, cy: 12, rx: 2.5, ry: 1.8, fill: 'rgba(255,255,255,0.15)' },
              { type: 'ellipse', cx: 20, cy: 14, rx: 1.8, ry: 2.2, fill: 'rgba(255,255,255,0.15)' },
              { type: 'ellipse', cx: 16, cy: 8, rx: 1.5, ry: 2.5, fill: 'rgba(255,255,255,0.12)' },
              { type: 'ellipse', cx: 14, cy: 22, rx: 2.2, ry: 1.5, fill: 'rgba(255,255,255,0.12)' },
              { type: 'circle', cx: 16, cy: 16, r: 1.2, fill: 'rgba(255,255,255,0.08)' }
            ]
          },
          floral6: {
            width: 36, height: 36,
            elements: [
              { type: 'ellipse', cx: 8, cy: 8, rx: 2.5, ry: 1.8, fill: 'rgba(255,255,255,0.18)' },
              { type: 'ellipse', cx: 28, cy: 12, rx: 1.8, ry: 2.2, fill: 'rgba(255,255,255,0.15)' },
              { type: 'ellipse', cx: 18, cy: 24, rx: 2.2, ry: 1.5, fill: 'rgba(255,255,255,0.16)' },
              { type: 'ellipse', cx: 12, cy: 30, rx: 1.5, ry: 2.0, fill: 'rgba(255,255,255,0.12)' },
              { type: 'ellipse', cx: 24, cy: 6, rx: 1.8, ry: 1.6, fill: 'rgba(255,255,255,0.14)' },
              { type: 'circle', cx: 18, cy: 18, r: 0.8, fill: 'rgba(255,255,255,0.08)' }
            ]
          },
          geometric1: {
            width: 10, height: 10,
            elements: [
              { type: 'polygon', points: '5,2 7,5 5,8 3,5', fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 5, cy: 5, r: 1, fill: 'rgba(255,255,255,0.1)' }
            ]
          },
          geometric2: {
            width: 12, height: 12,
            elements: [
              { type: 'polygon', points: '6,3 8,6 6,9 4,6', fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 6, cy: 6, r: 1.2, fill: 'rgba(255,255,255,0.08)' },
              { type: 'polygon', points: '3,3 5,6 3,9 1,6', fill: 'rgba(255,255,255,0.1)' }
            ]
          },
          geometric3: {
            width: 10, height: 20,
            elements: [
              // Row 1
              { type: 'polygon', points: '5,2 7,5 5,8 3,5', fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 5, cy: 5, r: 1, fill: 'rgba(255,255,255,0.1)' },
              // Row 2 (offset)
              { type: 'polygon', points: '0,12 2,15 0,18 -2,15', fill: 'rgba(255,255,255,0.2)' },
              { type: 'circle', cx: 0, cy: 15, r: 1, fill: 'rgba(255,255,255,0.1)' }
            ]
          },
          geometric4: {
            width: 12, height: 24,
            elements: [
              // Row 1
              { type: 'polygon', points: '6,3 8,6 6,9 4,6', fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 6, cy: 6, r: 1.2, fill: 'rgba(255,255,255,0.08)' },
              { type: 'polygon', points: '3,3 5,6 3,9 1,6', fill: 'rgba(255,255,255,0.1)' },
              // Row 2 (offset)
              { type: 'polygon', points: '0,15 2,18 0,21 -2,18', fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 0, cy: 18, r: 1.2, fill: 'rgba(255,255,255,0.08)' },
              { type: 'polygon', points: '9,15 11,18 9,21 7,18', fill: 'rgba(255,255,255,0.1)' }
            ]
          },
          geometric5: {
            width: 20, height: 20,
            elements: [
              { type: 'path', d: 'M5,2 Q8,1 11,2 T17,2 L15,8 Q12,9 9,8 T3,8 Z', fill: 'rgba(255,255,255,0.18)' },
              { type: 'path', d: 'M2,12 Q5,11 8,12 T14,12 L12,18 Q9,19 6,18 T0,18 Z', fill: 'rgba(255,255,255,0.15)' },
              { type: 'circle', cx: 10, cy: 10, r: 1.5, fill: 'rgba(255,255,255,0.08)' }
            ]
          },
          geometric6: {
            width: 24, height: 24,
            elements: [
              { type: 'ellipse', cx: 6, cy: 6, rx: 3, ry: 2, fill: 'rgba(255,255,255,0.16)' },
              { type: 'polygon', points: '18,8 20,12 18,16 16,12', fill: 'rgba(255,255,255,0.14)' },
              { type: 'path', d: 'M4,18 Q8,16 12,18 T20,18', stroke: 'rgba(255,255,255,0.12)', strokeWidth: 1 },
              { type: 'circle', cx: 12, cy: 12, r: 1.8, fill: 'rgba(255,255,255,0.08)' }
            ]
          }
        };
        
        return patterns[variation] || patterns.dots1;
      }
      

    }

    // ===== MAIN APPLICATION =====
    class SimplifiedQuiltAppV2 {
      constructor() {
        // Check if user is on desktop and show redirect if needed
        const redirected = this.checkDeviceAndRedirect();
        if (redirected) {
          // Create a minimal app object for desktop redirect
          this.isDesktopRedirect = true;
          this.initialize = () => Promise.resolve(); // No-op initialize
          return;
        }
        
        // Initialize services
        this.logger = new Logger(CONFIG.APP.debugMode);
        this.uiService = new UIService(this.logger);
        this.errorHandler = new ErrorHandler(this.uiService, this.logger);
        this.dataService = new QuiltDataService(this.logger, this.errorHandler);
        // console.log('üßµ App constructor - window.firebaseApp available:', !!window.firebaseApp);
        // this.quoteService = new QuoteService(window.firebaseApp);
        this.quoteService = new QuoteService(null); // Use null for local storage only
        this.renderer = new QuiltRendererV2(this.logger);
        this.archiveService = new ArchiveService(this.logger, this.dataService);
        
        // Initialize simplified engine
        this.quiltEngine = new SimpleQuiltEngine(this.currentUserId);
        
        // App state
        this.currentUserId = Utils.getOrCreateUserId();
        this.quiltScale = 1;
        
        // Check for secret admin URL parameter
        this.checkSecretAdminAccess();
        
        // Color picker state
        this.selectedHue = CONFIG.COLOR_PICKER.defaultHue;
        this.selectedSaturation = CONFIG.COLOR_PICKER.saturation;
        this.selectedLightness = CONFIG.COLOR_PICKER.defaultLightness;
        this.colorHasBeenSelected = false;
        this.isDragging = false;
      }
      
      
      checkDeviceAndRedirect() {
        // Use only iframe dimensions to avoid cross-origin issues
        const iframeWidth = window.innerWidth;
        
        // Simple desktop detection based on iframe width only
        // If iframe is wide enough, assume it's desktop
        const isDesktop = iframeWidth >= 768;
        
        console.log('üñ•Ô∏è Desktop Detection:', {
          iframeWidth,
          isDesktop
        });
        
        if (isDesktop) {
          this.showDesktopRedirect();
          return true; // Indicate that redirect happened
        }
        return false; // No redirect, continue with normal initialization
      }
      
      showDesktopRedirect() {
        // Hide all existing content
        document.body.innerHTML = '';
        
        // Create redirect screen styled like ABOUT screen
        const redirectHTML = `
          <div style="
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f6f4f1;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 2rem;
            text-align: center;
          ">
                  <h1 style="
        font-size: 2.5rem;
        font-weight: 400;
        margin-bottom: -1.5rem;
        color: #333;
      ">Welcome to</h1>
      
      <h1 style="
        font-size: 2.5rem;
        font-weight: 600;
        margin-bottom: 2rem;
        color: #333;
      ">OUR DAILY QUILT</h1>
      
      <p style="
        font-size: 1.3rem;
        line-height: 1.6;
        margin-bottom: 0.5rem;
        color: #333;
        max-width: 400px;
      ">Please switch to your phone<br>to add your block</p>
      
      <p style="
        font-size: 1.5rem;
        margin-bottom: 1.5rem;
        color: #666;
      ">‚Üì</p>
            
            <div id="qr-code" style="
              display: flex;
              justify-content: center;
              margin-bottom: 1rem;
            "></div>

            

          </div>
        `;
        
        document.body.innerHTML = redirectHTML;
        
        // Generate QR code
        this.generateQRCode();
      }
      
      generateQRCode() {
        const qrContainer = document.getElementById('qr-code');
        console.log('QR Container found:', qrContainer);
        
        if (qrContainer) {
          // Create QR code using live website URL
          const currentURL = window.location.href;
          console.log('QR Code URL:', currentURL);
          
          // Clear container first
          qrContainer.innerHTML = '';
          
          if (typeof qrcode !== 'undefined') {
            try {
              // Generate real QR code using qrcode-generator library
              const qr = qrcode(0, 'M');
              qr.addData(currentURL);
              qr.make();
              
              // Create QR code as SVG with transparent background
              const svg = qr.createSvgTag({
                cellSize: 8,
                margin: 4,
                scalable: true,
                color: '#000000',
                background: 'transparent'
              });
              
              // Create container for the SVG
              const qrCodeContainer = document.createElement('div');
              qrCodeContainer.style.cssText = `
                width: 200px;
                height: 200px;
                background: #f6f4f1;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 10px;
              `;
              
              qrCodeContainer.innerHTML = svg;
              qrContainer.appendChild(qrCodeContainer);
              console.log('Real QR Code generated successfully');
            } catch (error) {
              console.error('QR Code generation failed:', error);
              this.createFallbackQRCode(qrContainer, currentURL);
            }
          } else {
            console.log('QR code library not available, using fallback');
            this.createFallbackQRCode(qrContainer, currentURL);
          }
        } else {
          console.error('QR container not found');
        }
      }
      
      createFallbackQRCode(container, url) {
        // Fallback to simple text display
        container.innerHTML = `
          <div style="
            width: 200px;
            height: 200px;
            background: #f6f4f1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            padding: 1rem;
          ">QR Code<br>${url}</div>
        `;
      }

      async initialize() {
        try {
          this.uiService.showScreen('screen-portal');
          
          // Add a small delay to ensure Firebase is initialized
          await new Promise(resolve => setTimeout(resolve, 500));
          
          this.setupEventListeners();
          
          // Wait for Firebase to be ready before initializing DataService
          console.log('üîÑ Waiting for Firebase to initialize...');
          let attempts = 0;
          while (!window.db && attempts < 100) { // Increased from 50 to 100 attempts
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
            if (attempts % 20 === 0) {
              console.log(`üîÑ Still waiting for Firebase... (attempt ${attempts}/100)`);
            }
          }
          
          await this.dataService.initialize();
          
          // Initialize new engine
          this.quiltEngine.initialize();
          

          
          console.log('üîç DEBUGGING: About to load quilt...');
          await this.loadQuilt();
          console.log('üîç DEBUGGING: Quilt loaded, blocks count:', this.quiltEngine.blocks.length);
          
          this.renderer.initialize();
          await this.renderQuilt();
          this.updateSquareCounter();
          
          // Initialize UI after portal is shown
          this.initializeUI();
          
          // Load quotes from Firestore
          console.log('üîÑ About to load quotes from Firestore...');
          console.log('üîÑ Firebase available:', !!window.firebaseApp);
          console.log('üîÑ Firestore available:', !!window.firestore);
          console.log('üîÑ DB available:', !!window.db);
          
          // Wait a bit for Firebase to be fully initialized
          if (!window.db || !window.firestore) {
            console.log('üîÑ Waiting for Firebase to initialize...');
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          
          await this.quoteService.loadQuotesFromFirestore();
          console.log('üîÑ Firestore enabled - quotes loaded from database');
          
          this.setupAutoTransition();
          this.setupDailyReset(); // ENABLED - automatic daily archive and reset
          
          // Don't set up flip handlers here - they'll be set up when quilt screen is shown
          
        } catch (error) {
          this.errorHandler.handleError(error, 'App initialization');
          this.uiService.showScreen('screen-portal');
        }
      }

      setupEventListeners() {
        // Navigation
        document.querySelectorAll(".btn[data-next]").forEach(btn => {
          btn.addEventListener("click", e => {
            e.preventDefault();
            const targetId = btn.getAttribute("data-next");
            if (targetId) this.uiService.showScreen(targetId);
          });
        });

        // Add color button
        const addColorBtn = document.getElementById('addColorBtn');
        if (addColorBtn) {
          addColorBtn.addEventListener('click', this.handleAddColor.bind(this));
        }

        // Share button
        const shareBtnCompleted = document.getElementById('shareBtnCompleted');
        if (shareBtnCompleted) {
          shareBtnCompleted.addEventListener('click', this.handleShare.bind(this));
        }

        // Test buttons
        const showMyPieceBtn = document.getElementById('showMyPieceBtn');
        if (showMyPieceBtn) {
          showMyPieceBtn.addEventListener('click', this.handleShowMyPiece.bind(this));
        }



        // Color picker
        this.setupColorPicker();

        // Keyboard navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        
        // Window resize handler
        window.addEventListener('resize', this.handleWindowResize.bind(this));
        
        // Visual viewport resize handler
        if (window.visualViewport) {
          window.visualViewport.addEventListener('resize', this.handleWindowResize.bind(this));
        }
        

        

        
        // Archive event handlers
        this.setupArchiveEventHandlers();
        
        // Setup long-press admin access on title
        this.setupLongPressAdminAccess();
        
        // Clear any existing admin flags to ensure clean state
        localStorage.removeItem('ourDailyIsAdmin');
      }

      setupColorPicker() {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const valueSlider = document.getElementById('valueSlider');

        if (colorWheel) {
          colorWheel.addEventListener('mousedown', this.handleColorWheelMouseDown.bind(this));
          colorWheel.addEventListener('mousemove', this.handleColorWheelMouseMove.bind(this));
          colorWheel.addEventListener('mouseup', this.handleColorWheelMouseUp.bind(this));
          
          colorWheel.addEventListener('touchstart', this.handleColorWheelTouchStart.bind(this));
          colorWheel.addEventListener('touchmove', this.handleColorWheelTouchMove.bind(this));
          colorWheel.addEventListener('touchend', this.handleColorWheelTouchEnd.bind(this));
          
          colorWheel.addEventListener('keydown', this.handleColorWheelKeyDown.bind(this));
          colorWheel.addEventListener('click', this.handleColorWheelClick.bind(this));
        }

        if (valueSlider) {
          valueSlider.addEventListener('input', this.handleValueSliderChange.bind(this));
        }

        this.updateColorWheel();
      }

      handleColorWheelMouseDown(e) {
        e.preventDefault();
        this.isDragging = true;
        this.setHueFromCoords(e.clientX, e.clientY);
      }

      handleColorWheelMouseMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          this.setHueFromCoords(e.clientX, e.clientY);
        }
      }

      handleColorWheelMouseUp(e) {
        this.isDragging = false;
      }

      handleColorWheelClick(e) {
        e.preventDefault();
        this.setHueFromCoords(e.clientX, e.clientY);
        this.updateColorWheel();
      }

      handleColorWheelTouchStart(e) {
        e.preventDefault();
        this.isDragging = true;
        const touch = e.touches[0];
        this.setHueFromCoords(touch.clientX, touch.clientY);
      }

      handleColorWheelTouchMove(e) {
        if (this.isDragging) {
          e.preventDefault();
          const touch = e.touches[0];
          this.setHueFromCoords(touch.clientX, touch.clientY);
        }
      }

      handleColorWheelTouchEnd(e) {
        this.isDragging = false;
      }

      handleColorWheelKeyDown(e) {
        const step = 15;
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            this.selectedHue = (this.selectedHue - step + 360) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.selectedHue = (this.selectedHue + step) % 360;
            this.updateColorWheel();
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.selectedLightness = Math.min(90, this.selectedLightness + 5);
            this.updateColorWheel();
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.selectedLightness = Math.max(25, this.selectedLightness - 5);
            this.updateColorWheel();
            break;
        }
      }

      handleValueSliderChange(e) {
        this.selectedLightness = parseInt(e.target.value);
        this.updateColorWheel();
      }

      updateColorWheel() {
        const valueSlider = document.getElementById('valueSlider');
        
        const hslColor = `hsl(${this.selectedHue}, ${this.selectedSaturation}%, ${this.selectedLightness}%)`;
        const hexColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
        
        const colorScreen = document.getElementById('screen-color');
        if (colorScreen) {
          colorScreen.style.backgroundColor = hexColor;
          // Set CSS custom property for status bar extension
          document.documentElement.style.setProperty('--current-color', hexColor);
        }
        
        // Send color to parent page for background extension (only if color picker screen is active)
        try {
          if (hexColor && Utils.validateHexColor(hexColor)) {
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen && colorScreen.classList.contains('active')) {
              console.log('üé® Sending color to parent (color wheel):', hexColor);
              // Use the new helper function
              if (window.ODQ_onColorChange) {
                window.ODQ_onColorChange(hexColor);
              }
            }
          }
        } catch (error) {
          // Silently fail if postMessage is not available (e.g., not in iframe)
          console.log('Could not send color to parent page:', error);
        }
        
        if (valueSlider) {
          valueSlider.style.background = `linear-gradient(to right,
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 20%), 
            hsl(${this.selectedHue}, ${this.selectedSaturation}%, 90%))`;
        }
      }

      setHueFromCoords(x, y) {
        const colorWheel = document.getElementById('colorWheelCanvas');
        const indicator = document.getElementById('colorIndicator');
        const rect = colorWheel.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = rect.width / 2;

        let angle = Math.atan2(dy, dx) * 180 / Math.PI;
        if (angle < 0) angle += 360;
        
        const rawHue = Math.round((angle + 90) % 360);
        this.selectedHue = (rawHue + 25) % 360;
        
        const baseSaturation = Math.min(100, (distance / radius) * 100);
        this.selectedSaturation = Math.min(Math.round(baseSaturation + 5), 100);

        if (distance > radius) {
          const clampedDistance = radius;
          const clampedX = centerX + (dx / distance) * clampedDistance;
          const clampedY = centerY + (dy / distance) * clampedDistance;
          this.selectedSaturation = 100;
          
          if (indicator) {
            const relativeX = clampedX - rect.left;
            const relativeY = clampedY - rect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        } else {
          if (indicator) {
            const relativeX = x - rect.left;
            const relativeY = y - rect.top;
            indicator.style.left = `${relativeX}px`;
            indicator.style.top = `${relativeY}px`;
          }
        }
        
        this.colorHasBeenSelected = true;
        this.updateColorWheel();
      }

      handleKeyDown(event) {
        if (event.key === 'Escape') {
          const currentScreen = document.querySelector('.screen.active');
          if (currentScreen) {
            const currentId = currentScreen.id;
            if (currentId === 'screen-quote') {
              this.uiService.showScreen('screen-portal');
            } else if (currentId === 'screen-color') {
              this.uiService.showScreen('screen-quote');
            } else if (currentId === 'screen-quilt') {
              this.uiService.showScreen('screen-color');
            }
          }
        }
      }

      handleWindowResize() {
        // Debounce resize events to prevent excessive re-rendering
        if (this.resizeTimeout) {
          clearTimeout(this.resizeTimeout);
        }
        
        this.resizeTimeout = setTimeout(() => {
          if (this.quiltEngine.blocks && this.quiltEngine.blocks.length > 0) {
            // Recalculate dimensions for new viewport size
            this.quiltEngine.recalculateDimensionsForCurrentViewport();
            this.renderQuilt();
          }
        }, 250); // 250ms debounce
      }





      setupArchiveEventHandlers() {
        // Archive Load More button
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        if (loadMoreBtn) {
          loadMoreBtn.addEventListener('click', () => {
            this.handleArchiveLoadMore();
          });
        }

        // Archive modal close handlers
        const modalClose = document.getElementById('archiveModalClose');
        const modalBackdrop = document.getElementById('archiveModalBackdrop');
        
        if (modalClose) {
          modalClose.addEventListener('click', () => {
            this.archiveService.closeArchiveModal();
          });
        }
        
        if (modalBackdrop) {
          modalBackdrop.addEventListener('click', () => {
            this.archiveService.closeArchiveModal();
          });
        }

        // Archive screen initialization
        document.addEventListener('screenChange', (e) => {
          if (e.detail.screenId === 'screen-archive') {
            this.initializeArchiveScreen();
          }
        });

        // Quilt screen scroll listener for Instagram promotion
        document.addEventListener('screenChange', (e) => {
          if (e.detail.screenId === 'screen-quilt') {
            this.setupQuiltScrollListener();
          }
        });
      }

      async handleArchiveLoadMore() {
        const loadMoreBtn = document.getElementById('archiveLoadMore');
        const loadingDiv = document.getElementById('archiveLoading');
        
        if (loadMoreBtn) loadMoreBtn.disabled = true;
        if (loadingDiv) loadingDiv.style.display = 'block';

        try {
          const result = await this.archiveService.loadMore();
          if (result && result.archives.length > 0) {
            // Append new posts to existing feed
            const container = document.getElementById('archiveFeed');
            if (container) {
              const newPostsHTML = result.archives
                .map(archive => this.archiveService.createArchivePostHTML(archive))
                .join('');
              
              container.insertAdjacentHTML('beforeend', newPostsHTML);
              this.archiveService.setupImageClickHandlers(container);
              this.archiveService.updateLoadMoreButton(result.hasMore);
            }
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'Load more archives');
        } finally {
          if (loadMoreBtn) loadMoreBtn.disabled = false;
          if (loadingDiv) loadingDiv.style.display = 'none';
        }
      }

      initializeArchiveScreen() {
        // Render the archive feed
        this.archiveService.renderArchiveFeed();
      }

      setupQuiltScrollListener() {
        // Remove any existing scroll listener
        if (this.quiltScrollListener) {
          document.removeEventListener('scroll', this.quiltScrollListener);
        }

        // Create scroll listener for Instagram promotion
        this.quiltScrollListener = (e) => {
          // Check if user has already seen the Instagram toast
          if (localStorage.getItem('instagramToastShown')) return;
          
          // Check if we're on the quilt screen
          const quiltScreen = document.getElementById('screen-quilt');
          if (!quiltScreen || !quiltScreen.classList.contains('active')) return;
          
          // Show Instagram promotion toast
          this.uiService.showToast('Follow on IG to see how this turns out!', 6000, {
            url: 'https://www.instagram.com/ourdailyquilt/',
            text: '@ourdailyquilt'
          });
          
          // Mark as shown permanently in localStorage
          localStorage.setItem('instagramToastShown', 'true');
          
          // Remove the scroll listener after showing
          document.removeEventListener('scroll', this.quiltScrollListener);
        };

        // Add scroll listener
        document.addEventListener('scroll', this.quiltScrollListener);
      }

      // Create archive snapshot from current quilt
      async createArchiveSnapshot() {
        // Use UTC to determine the date for this quilt
        const utcNow = new Date();
        const quiltDate = utcNow.toISOString().split('T')[0];
        const currentQuote = this.quoteService.getQuoteForDate(quiltDate);
        const blockCount = this.quiltEngine.blocks.length;
        
        this.logger.log(`üñºÔ∏è Generating thumbnail for ${blockCount} blocks...`);
        
        // Generate thumbnail and full quilt image
        const thumbnail = await this.archiveService.generateThumbnail();
        const fullQuiltImage = await this.archiveService.generateFullQuiltImage(this.quiltEngine.blocks);
        
        // Create archive entry
        const archiveEntry = this.archiveService.createArchiveEntry(
          quiltDate,
          { blocks: this.quiltEngine.blocks }, // Current quilt state
          currentQuote,
          Math.max(blockCount, 12) // Use actual block count or minimum 12
        );
        
        // Set the generated images
        archiveEntry.thumbnail = thumbnail;
        archiveEntry.fullQuiltImage = fullQuiltImage;
        
        // Add to archive
        await this.archiveService.addArchive(archiveEntry);
        
        // Note: Archive feed will be re-rendered when switching to archive screen
        
        this.logger.log(`‚úÖ Created archive snapshot for ${quiltDate} with ${blockCount} blocks and thumbnail`);
        return archiveEntry;
      }

      // Archive current quilt (renamed from createTestArchivePosts)
      async createTestArchivePosts() {
        this.logger.log('üì¶ Archiving current quilt as test...');
        
        try {
          // Check if there's a current quilt to archive
          if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length <= 1) {
            this.logger.warn('üì¶ No quilt to archive (only initial block or no blocks)');
            this.uiService.showToast('No quilt to archive - add some blocks first!');
            return;
          }
          
          // Create archive of current quilt
          const archiveEntry = await this.createArchiveSnapshot();
          
          this.logger.log(`‚úÖ Archived current quilt with ${this.quiltEngine.blocks.length} blocks`);
          this.uiService.showToast(`Current quilt archived with ${this.quiltEngine.blocks.length} blocks!`);
          
          // Show the archived quilt immediately
          this.uiService.showToast(`Current quilt archived with ${this.quiltEngine.blocks.length} blocks! Now showing archive...`);
          
          // Force refresh the archive cache to include the new archive
          await this.archiveService.loadArchivesFromFirestore();
          
          // Switch to archive screen (renderArchiveFeed will be called by initializeArchiveScreen)
          await this.uiService.showScreen('screen-archive');
          
          // Scroll to the top to show the newest archive
          const archiveContainer = document.querySelector('.archive-feed');
          if (archiveContainer) {
            archiveContainer.scrollTop = 0;
          }
          
        } catch (error) {
          this.logger.error('‚ùå Failed to archive current quilt:', error);
          this.uiService.showToast('Failed to archive current quilt');
        }
      }

      // Manual archive trigger for testing
      async triggerManualArchive() {
        this.logger.log('üîß Manual archive triggered for testing...');
        try {
          const result = await this.performDailyArchive();
          this.logger.log(`üîß Manual archive result: ${result ? 'SUCCESS' : 'FAILED'}`);
          return result;
        } catch (error) {
          this.logger.error('üîß Manual archive error:', error);
          return false;
        }
      }

      isCurrentUserAdmin() {
        const currentUserId = this.currentUserId;
        const isAdminFlag = localStorage.getItem('ourDailyIsAdmin') === 'true';
        
        // Check if admin flag is set (you can enable this via console)
        if (isAdminFlag) {
          return true;
        }
        
        // Admin mode disabled by default - use long-press on title to enable
        return false;
      }

      enableAdminMode() {
        localStorage.setItem('ourDailyIsAdmin', 'true');
      }

      disableAdminMode() {
        if (!confirm('Are you sure you want to disable admin mode? You can re-enable it with enableAdmin().')) {
          return;
        }
        
        localStorage.removeItem('ourDailyIsAdmin');
        this.uiService.showToast('Admin mode disabled');
        const adminBtn = document.getElementById('floatingAdminBtn');
        if (adminBtn) {
          adminBtn.style.display = 'none';
        }
      }

      // Clear admin flag from localStorage (for debugging)
      clearAdminFlag() {
        localStorage.removeItem('ourDailyIsAdmin');
        console.log('üîß Admin flag cleared from localStorage');
        this.setupFloatingAdminButton();
      }

      // Secret function to enable admin mode - call from console: app.enableAdminSecret()
      enableAdminSecret() {
        localStorage.setItem('ourDailyIsAdmin', 'true');
        this.uiService.showToast('üîß Admin mode enabled!');
        console.log('üîß Admin mode enabled. You can now access admin controls.');
      }

      // Reveal image management functions
      async loadRevealImageOptions() {
        try {
          // Enable Firebase for image storage
          await this.initializeFirebaseForImages();
          
          const optionsContainer = document.getElementById('revealImageOptions');
          if (!optionsContainer) return;
          
          // Check if Firebase is available
          if (!window.firebaseApp || !window.firebaseStorage) {
            optionsContainer.innerHTML = '<p>Firebase not available. Please try again.</p>';
            return;
          }
          
          // Load images from Firebase Storage
          const { ref, listAll, getDownloadURL } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const storage = window.firebaseStorage;
          
          // Try to get images from quilt-reveals folder
          const revealsRef = ref(storage, 'quilt-reveals');
          const result = await listAll(revealsRef);
          
          if (result.items.length === 0) {
            optionsContainer.innerHTML = '<p>No reveal images found. Upload one to get started!</p>';
            return;
          }
          
          // Build HTML for image options
          let optionsHTML = '';
          
          for (let i = 0; i < result.items.length; i++) {
            const item = result.items[i];
            const downloadURL = await getDownloadURL(item);
            const imageId = `revealImage${i}`;
            
            optionsHTML += `
              <div class="image-option" style="margin: 10px 0; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                <input type="radio" name="revealImage" value="${downloadURL}" id="${imageId}">
                <label for="${imageId}" style="display: flex; align-items: center; gap: 10px;">
                  <img src="${downloadURL}" alt="Reveal Image ${i + 1}" style="width: 60px; height: 60px; object-fit: cover; border-radius: 4px;">
                  <span>${item.name}</span>
                </label>
              </div>
            `;
          }
          
          optionsHTML += '<button onclick="app.handleSelectRevealImage()" style="margin-top: 10px;">Apply Selected Image</button>';
          
          optionsContainer.innerHTML = optionsHTML;
          
        } catch (error) {
          console.error('Error loading reveal image options:', error);
          const optionsContainer = document.getElementById('revealImageOptions');
          if (optionsContainer) {
            optionsContainer.innerHTML = '<p>Error loading images. Please try again.</p>';
          }
        }
      }

      async initializeFirebaseForImages() {
        // Only initialize Firebase if not already done
        if (window.firebaseApp && window.firebaseStorage && window.firebaseAuth) {
          return window.firebaseApp;
        }
        
        try {
          
          const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
          const { getStorage } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const { getAuth, signInAnonymously } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
          
          const firebaseApp = initializeApp(CONFIG.FIREBASE);
          const storage = getStorage(firebaseApp);
          const auth = getAuth(firebaseApp);
          
          // Sign in anonymously to enable uploads
          try {
            const authResult = await signInAnonymously(auth);
            
            // Wait a moment for auth to fully propagate
            await new Promise(resolve => setTimeout(resolve, 1000));
            
          } catch (authError) {
            // Try to continue anyway
          }
          
          window.firebaseApp = firebaseApp;
          window.firebaseStorage = storage;
          window.firebaseAuth = auth;
          
          return firebaseApp;
        } catch (error) {
          console.error('Failed to initialize Firebase for images:', error);
          throw error;
        }
      }

      async handleUploadRevealImage() {
        const fileInput = document.getElementById('revealImageUpload');
        const file = fileInput?.files[0];
        
        if (!file) {
          alert('Please select an image file first.');
          return;
        }
        
        try {
          await this.initializeFirebaseForImages();
          
          // Show loading message
          const uploadButton = document.querySelector('button[onclick="app.handleUploadRevealImage()"]');
          const originalText = uploadButton.textContent;
          uploadButton.textContent = 'Resizing & Uploading...';
          uploadButton.disabled = true;
          
          // Resize image to quilt dimensions (412 x 800)
          const resizedImageBlob = await this.resizeImageToQuiltDimensions(file);
          
          // Check authentication status before upload
          if (!window.firebaseAuth) {
            await this.initializeFirebaseForImages();
          }
          
          const auth = window.firebaseAuth;
          
          // Upload to Firebase Storage
          const { ref, uploadBytes, getDownloadURL } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const storage = window.firebaseStorage;
          
          // Create unique filename with timestamp
          const timestamp = Date.now();
          const filename = `quilt-reveal-${timestamp}.png`;
          const imageRef = ref(storage, `quilt-reveals/${filename}`);
          
          // Upload the resized image
          let downloadURL;
          try {
            await uploadBytes(imageRef, resizedImageBlob);
            downloadURL = await getDownloadURL(imageRef);
          } catch (uploadError) {
            console.error('Upload failed:', uploadError);
            
            // If upload fails due to permissions, show helpful message
            if (uploadError.code === 'storage/unauthorized') {
              
              this.uiService.showToast('‚ùå Upload failed: Authentication issue. Please check Firebase Console settings.');
              throw new Error('Firebase authentication issue. Please enable Anonymous Authentication in Firebase Console.');
            }
            
            throw uploadError;
          }
          
          // Store image info
          const imageInfo = {
            name: filename,
            url: downloadURL,
            uploadedAt: timestamp
          };
          
          // Add to available images
          if (!this.availableRevealImages) {
            this.availableRevealImages = [];
          }
          this.availableRevealImages.push(imageInfo);
          
          // Refresh the image options display
          this.loadRevealImageOptions();
          
          // Clear the file input
          fileInput.value = '';
          
          // Reset button
          uploadButton.textContent = originalText;
          uploadButton.disabled = false;
          
          this.uiService.showToast('‚úÖ Image uploaded and resized successfully!');
          console.log('Image uploaded:', imageInfo);
          
        } catch (error) {
          console.error('Error uploading image:', error);
          this.uiService.showToast('‚ùå Error uploading image. Please try again.');
          
          // Reset button on error
          const uploadButton = document.querySelector('button[onclick="app.handleUploadRevealImage()"]');
          if (uploadButton) {
            uploadButton.textContent = 'Upload Image';
            uploadButton.disabled = false;
          }
        }
      }

      async resizeImageToQuiltDimensions(file) {
        return new Promise((resolve, reject) => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();
          
          // Set target dimensions (quilt size)
          const targetWidth = 412;
          const targetHeight = 800;
          
          img.onload = () => {
            try {
              // Set canvas size to target dimensions
              canvas.width = targetWidth;
              canvas.height = targetHeight;
              
              // Calculate scaling to fill the entire target area (crop approach)
              const imageAspect = img.width / img.height;
              const targetAspect = targetWidth / targetHeight;
              
              let sourceX, sourceY, sourceWidth, sourceHeight;
              
              if (imageAspect > targetAspect) {
                // Image is wider than target - scale to height and crop width
                const scaledWidth = img.height * targetAspect;
                sourceWidth = scaledWidth;
                sourceHeight = img.height;
                sourceX = (img.width - scaledWidth) / 2; // Center crop
                sourceY = 0;
              } else {
                // Image is taller than target - scale to width and crop height
                const scaledHeight = img.width / targetAspect;
                sourceWidth = img.width;
                sourceHeight = scaledHeight;
                sourceX = 0;
                sourceY = (img.height - scaledHeight) / 2; // Center crop
              }
              
              // Draw the cropped portion of the image to fill the entire canvas
              ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
              
              // Convert to blob
              canvas.toBlob((blob) => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error('Failed to create image blob'));
                }
              }, 'image/png', 0.9);
              
            } catch (error) {
              reject(error);
            }
          };
          
          img.onerror = () => {
            reject(new Error('Failed to load image for resizing'));
          };
          
          // Load image from file
          const reader = new FileReader();
          reader.onload = (e) => {
            img.src = e.target.result;
          };
          reader.onerror = () => {
            reject(new Error('Failed to read image file'));
          };
          reader.readAsDataURL(file);
        });
      }

      async handleSelectRevealImage() {
        const selectedImageURL = document.querySelector('input[name="revealImage"]:checked')?.value;
        
        if (!selectedImageURL) {
          alert('Please select an image first.');
          return;
        }
        
        try {
          // Create image info object
          const imageInfo = {
            name: 'Selected Reveal Image',
            url: selectedImageURL
          };
          
          // Store the selected image preference
          localStorage.setItem('selectedRevealImage', selectedImageURL);
          
          // Apply the image to the quilt
          await this.applyImageToQuilt(imageInfo);
          
          this.uiService.showToast('‚úÖ Reveal image applied successfully!');
          
        } catch (error) {
          console.error('Error applying reveal image:', error);
          this.uiService.showToast('‚ùå Error applying image. Please try again.');
        }
      }

      async applyRevealImageToQuilt(imageName) {
        console.log('Applying reveal image:', imageName);
        
        // Store the selection
        this.currentRevealImage = imageName;
        
        // Apply image to flipped blocks
        await this.applyImageToQuilt(this.currentRevealImage);
      }

      async loadRandomRevealImage() {
        try {
          // Always try to initialize Firebase first
          await this.initializeFirebaseForImages();
          
          // Check if Firebase is available after initialization
          if (!window.firebaseApp || !window.firebaseStorage) {
            console.log('Firebase still not available after initialization, using fallback images');
            return this.loadFallbackImages();
          }
          
          await this.initializeFirebaseForImages();
          
          // Get list of images from Firebase Storage
          const { ref, listAll, getDownloadURL, getBlob } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js');
          const storage = window.firebaseStorage;
          
          // Try different possible folder names
          const possibleFolders = ['quilt-reveals', 'quilt reveals', 'quiltreveals', 'reveals', 'images'];
          let result = null;
          let folderName = null;
          
          for (const folder of possibleFolders) {
            try {
              console.log(`üñºÔ∏è Trying Firebase folder: "${folder}"`);
              const revealsRef = ref(storage, folder);
              result = await listAll(revealsRef);
              if (result.items.length > 0) {
                folderName = folder;
                console.log(`‚úÖ Found ${result.items.length} images in Firebase folder: "${folder}"`);
                break;
              } else {
                console.log(`üìÅ Folder "${folder}" exists but is empty`);
              }
            } catch (error) {
              console.log(`‚ùå Folder "${folder}" not found:`, error.message);
            }
          }
          
          if (!result || result.items.length === 0) {
            console.log('No images found in Firebase, using fallback images');
            return this.loadFallbackImages();
          }
          
          // Randomly select an image
          const randomIndex = Math.floor(Math.random() * result.items.length);
          const selectedImageRef = result.items[randomIndex];
          
          // Try to get the image URL (may fail due to CORS when running locally)
          console.log('üñºÔ∏è Getting Firebase image URL...');
          let imageUrl;
          let blob = null;
          
          try {
            // Try blob first (better for CORS)
            blob = await getBlob(selectedImageRef);
            imageUrl = URL.createObjectURL(blob);
            console.log('üé≤ Randomly selected Firebase image:', selectedImageRef.name, 'blob URL created');
          } catch (blobError) {
            console.log('üîÑ Blob failed, trying direct URL:', blobError.message);
            try {
              // Fallback to direct URL
              imageUrl = await getDownloadURL(selectedImageRef);
              console.log('üé≤ Randomly selected Firebase image:', selectedImageRef.name, 'direct URL created');
            } catch (urlError) {
              console.log('‚ùå Both blob and direct URL failed:', urlError.message);
              if (urlError.message.includes('CORS') || urlError.message.includes('Access-Control-Allow-Origin')) {
                console.log('üîÑ CORS issue detected - this is normal when running locally');
                console.log('üí° Firebase images will work when deployed to a proper server');
                throw new Error('CORS blocked Firebase image (normal when running locally)');
              } else {
                throw new Error('Could not load Firebase image: ' + urlError.message);
              }
            }
          }
          
          // Store the selected image info
          this.currentRevealImage = {
            name: selectedImageRef.name,
            url: imageUrl,
            blob: blob // Keep reference to clean up later
          };
          
          console.log('üñºÔ∏è Stored currentRevealImage:', this.currentRevealImage);
          
          // Apply the image to the quilt
          await this.applyImageToQuilt(this.currentRevealImage);
          
          return this.currentRevealImage;
          
        } catch (error) {
          console.error('Error loading Firebase image:', error);
          console.log('Firebase image loading failed - no fallback');
          throw error; // Don't fall back, let the error propagate
        }
      }

      async loadFallbackImages() {
        // Use CORS-friendly test images as fallback
        const testImages = [
          {
            name: 'sunset-gradient',
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0ic3Vuc2V0IiBjeD0iNDAwIiBjeT0iMzAwIiByPSI0MDAiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojZmY2YjZiO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjUwJSIgc3R5bGU9InN0b3AtY29sb3I6I2ZmYzc0O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmZmViM2I7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI3N1bnNldCkiIC8+CiAgPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkRhaWx5IFN1bnNldDwvdGV4dD4KPC9zdmc+Cg=='
          },
          {
            name: 'ocean-waves', 
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0ib2NlYW4iIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojNGVjZGM0O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjUwJSIgc3R5bGU9InN0b3AtY29sb3I6IzAwNzNhYTtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMDA0ZGRkO3N0b3Atb3BhY2l0eToxIiAvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICA8L2RlZnM+CiAgPHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNvY2VhbikiIC8+CiAgPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPk9jZWFuIFdhdmVzPC90ZXh0Pgo8L3N2Zz4K'
          },
          {
            name: 'forest-greens',
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZm9yZXN0IiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzJkNzQzNDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSI1MCUiIHN0eWxlPSJzdG9wLWNvbG9yOjM4YTg1MzN0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOjQyYjY4MmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2ZvcmVzdCkiIC8+CiAgPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkZvcmVzdCBHcmVlbnM8L3RleHQ+Cjwvc3ZnPgo='
          }
        ];
        
        // Randomly select a test image
        const randomIndex = Math.floor(Math.random() * testImages.length);
        const selectedImage = testImages[randomIndex];
        
        console.log('üé≤ Randomly selected fallback image:', selectedImage.name);
        
        // Store the selected image info
        this.currentRevealImage = selectedImage;
        
        // Apply the image to the quilt
        await this.applyImageToQuilt(this.currentRevealImage);
        
        return this.currentRevealImage;
      }

      async forceLoadFirebaseImage() {
        try {
          const result = await this.loadRandomRevealImage();
          if (result) {
            this.uiService.showToast('‚úÖ Firebase image loaded successfully!');
          } else {
            this.uiService.showToast('‚ùå Failed to load Firebase image');
          }
        } catch (error) {
          console.error('Error force loading Firebase image:', error);
          this.uiService.showToast('‚ùå Error loading Firebase image');
        }
      }

      async applyImageToQuilt(imageInfo) {
        // console.log('üñºÔ∏è applyImageToQuilt called with:', imageInfo);
        
        if (!imageInfo) {
          console.log('‚ùå No imageInfo provided');
          return;
        }
        
        if (!imageInfo.url) {
          console.log('‚ùå No imageInfo.url provided');
          return;
        }
        
        // console.log('üñºÔ∏è Image URL type:', typeof imageInfo.url);
        // console.log('üñºÔ∏è Image URL value:', imageInfo.url);
        
        console.log('Applying image to quilt:', imageInfo.name);
        
        // Create image pattern for the quilt
        await this.createImagePattern(imageInfo);
        

      }

      async createImagePattern(imageInfo) {
        // console.log('üñºÔ∏è Creating image pattern for:', imageInfo.name);
        
        // Create a canvas to load and process the image
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        return new Promise((resolve, reject) => {
          img.onload = () => {
            console.log('üñºÔ∏è Image loaded, dimensions:', img.width, 'x', img.height);
            
            // Get quilt dimensions
            const blocks = this.quiltEngine.blocks;
            if (blocks.length === 0) {
              reject('No blocks in quilt');
              return;
            }
            
            const minX = Math.min(...blocks.map(b => b.x));
            const minY = Math.min(...blocks.map(b => b.y));
            const maxX = Math.max(...blocks.map(b => b.x + b.width));
            const maxY = Math.max(...blocks.map(b => b.y + b.height));
            const quiltWidth = maxX - minX;
            const quiltHeight = maxY - minY;
            
            console.log('üñºÔ∏è Quilt dimensions:', quiltWidth, 'x', quiltHeight);
            
            // Scale the image to fit the quilt while maintaining aspect ratio
            const imageAspect = img.width / img.height;
            const quiltAspect = quiltWidth / quiltHeight;
            
            let scaledWidth, scaledHeight, offsetX, offsetY;
            
            if (imageAspect > quiltAspect) {
              // Image is wider than quilt - fit to width
              scaledWidth = quiltWidth;
              scaledHeight = quiltWidth / imageAspect;
              offsetX = 0;
              offsetY = (quiltHeight - scaledHeight) / 2;
            } else {
              // Image is taller than quilt - fit to height
              scaledWidth = quiltHeight * imageAspect;
              scaledHeight = quiltHeight;
              offsetX = (quiltWidth - scaledWidth) / 2;
              offsetY = 0;
            }
            
            // Set canvas size to match quilt dimensions
            canvas.width = quiltWidth;
            canvas.height = quiltHeight;
            
            // Draw the scaled image centered in the quilt area
            ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // Convert to data URL for SVG pattern
            const imageDataUrl = canvas.toDataURL('image/png');
            
            // Store the processed image data
            this.processedImageData = {
              dataUrl: imageDataUrl,
              quiltWidth: quiltWidth,
              quiltHeight: quiltHeight,
              minX: minX,
              minY: minY,
              imageWidth: scaledWidth,  // Use actual scaled image dimensions
              imageHeight: scaledHeight, // Use actual scaled image dimensions
              offsetX: offsetX,         // Store offset for positioning
              offsetY: offsetY          // Store offset for positioning
            };
            
            console.log('‚úÖ Image pattern created for quilt, data URL length:', imageDataUrl.length);
            resolve();
          };
          
          img.onerror = (error) => {
            console.error('üñºÔ∏è Failed to load image:', error);
            reject('Failed to load image');
          };
          
          // Ensure we have a valid URL
          if (!imageInfo.url || typeof imageInfo.url !== 'string') {
            console.error('Invalid image URL:', imageInfo.url);
            reject('Invalid image URL');
            return;
          }
          
          // Handle CORS for Firebase images
          if (imageInfo.url.includes('firebasestorage.googleapis.com')) {
            // console.log('üñºÔ∏è Loading Firebase image with CORS handling');
            img.crossOrigin = 'anonymous';
            
            // Try to load with credentials
            img.crossOrigin = 'use-credentials';
            
            // Add error handler for CORS issues
            img.onerror = (error) => {
                      // console.log('üñºÔ∏è CORS error loading Firebase image, trying alternative method');
        // console.log('üñºÔ∏è Error details:', error);
              
              // Try without crossOrigin as fallback
              img.crossOrigin = null;
              img.src = imageInfo.url;
            };
          } else {
            // console.log('üñºÔ∏è Loading local/SVG image');
          }
          
          // console.log('üñºÔ∏è Loading image from URL:', imageInfo.url);
          
          // Add timeout for Firebase images to handle CORS issues
          if (imageInfo.url.includes('firebasestorage.googleapis.com')) {
            const timeout = setTimeout(() => {
              // console.log('üñºÔ∏è Timeout loading Firebase image, likely CORS issue');
              img.onerror = null; // Remove error handler to prevent double handling
              reject(new Error('Timeout loading Firebase image (CORS issue)'));
            }, 5000); // 5 second timeout
            
            img.onload = () => {
              clearTimeout(timeout);
              resolve();
            };
            
            img.onerror = (error) => {
              clearTimeout(timeout);
              console.log('üñºÔ∏è CORS error loading Firebase image, falling back to test image');
              console.log('üñºÔ∏è Error details:', error);
              reject(new Error('CORS blocked Firebase image'));
            };
          }
          
          img.src = imageInfo.url;
        });
      }



      createQuiltImagePattern(patternId, imageDataUrl) {
        console.log('üñºÔ∏è Creating quilt image pattern:', patternId);
        
        // Remove existing pattern if it exists
        const existingPattern = document.getElementById(patternId);
        if (existingPattern) {
          existingPattern.remove();
        }
        
        // Create new pattern
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', patternId);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('x', -this.processedImageData.minX);
        pattern.setAttribute('y', -this.processedImageData.minY);
        pattern.setAttribute('width', this.processedImageData.quiltWidth);
        pattern.setAttribute('height', this.processedImageData.quiltHeight);
        
        // Add image to pattern
        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        image.setAttribute('href', imageDataUrl);
        image.setAttribute('width', this.processedImageData.quiltWidth);
        image.setAttribute('height', this.processedImageData.quiltHeight);
        image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
        
        pattern.appendChild(image);
        
        // Add to SVG defs - ensure defs exists
        let defs = document.querySelector('#quilt defs');
        if (!defs) {
          defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          const quilt = document.querySelector('#quilt');
          quilt.insertBefore(defs, quilt.firstChild);
        }
        defs.appendChild(pattern);
        
        console.log('‚úÖ Quilt image pattern created and added to defs:', patternId);
      }

      createBlockImagePattern(patternId, imageDataUrl, x, y, width, height) {
                    console.log('üñºÔ∏è Creating pattern:', patternId, 'for block at', x, y, 'size', width, height);
        
        // Remove existing pattern if it exists
        const existingPattern = document.getElementById(patternId);
        if (existingPattern) {
          existingPattern.remove();
        }
        
        // Create new pattern
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', patternId);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('x', 0);
        pattern.setAttribute('y', 0);
        pattern.setAttribute('width', width);
        pattern.setAttribute('height', height);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('patternContentUnits', 'userSpaceOnUse');
        
        // Add image to pattern - positioned to show only the relevant portion
        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        image.setAttribute('href', imageDataUrl);
        image.setAttribute('width', this.processedImageData.imageWidth);
        image.setAttribute('height', this.processedImageData.imageHeight);
        image.setAttribute('x', -x);
        image.setAttribute('y', -y);
        image.setAttribute('preserveAspectRatio', 'none');
        image.setAttribute('style', 'shape-rendering: crispEdges; image-rendering: pixelated;');
        
        pattern.appendChild(image);
        
        // Add to SVG defs - ensure defs exists
        let defs = document.querySelector('#quilt defs');
        if (!defs) {
          defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          const quilt = document.querySelector('#quilt');
          quilt.insertBefore(defs, quilt.firstChild);
        }
        defs.appendChild(pattern);
        
        console.log('‚úÖ Pattern created and added to defs:', patternId);
      }



      createColorPattern(patternId) {
        const quiltSVG = document.getElementById('quilt');
        if (!quiltSVG) {
          console.error('Quilt SVG not found');
          return;
        }
        
        console.log('Creating color pattern for:', patternId);
        
        // Remove existing pattern if it exists
        const existingPattern = quiltSVG.querySelector(`#pattern-${patternId}`);
        if (existingPattern) {
          existingPattern.remove();
          console.log('Removed existing pattern');
        }
        
        // Create defs if it doesn't exist
        let defs = quiltSVG.querySelector('defs');
        if (!defs) {
          defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          quiltSVG.insertBefore(defs, quiltSVG.firstChild);
          console.log('Created defs element');
        }
        
        // Create pattern with a solid color
        const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        pattern.setAttribute('id', `pattern-${patternId}`);
        pattern.setAttribute('patternUnits', 'objectBoundingBox');
        pattern.setAttribute('width', '1');
        pattern.setAttribute('height', '1');
        
        // Create a rect with the color
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('width', '100%');
        rect.setAttribute('height', '100%');
        rect.setAttribute('fill', patternId === 'image1' ? '#ff6b6b' : '#4ecdc4'); // Red or teal
        
        pattern.appendChild(rect);
        defs.appendChild(pattern);
        
        console.log(`Created color pattern: pattern-${patternId}`);
        console.log('Pattern element:', pattern);
      }

      // OLD createImagePattern function removed - using new async version instead



      // Debug function to test admin button - call from console: app.debugAdminButton()
      debugAdminButton() {
        const adminBtn = document.getElementById('floatingAdminBtn');
        console.log('üîß Admin button debug:', {
          element: adminBtn,
          display: adminBtn ? adminBtn.style.display : 'not found',
          isAdmin: this.isCurrentUserAdmin(),
          hasClickListeners: adminBtn ? adminBtn.onclick : 'no element',
          pointerEvents: adminBtn ? adminBtn.style.pointerEvents : 'no element'
        });
        
        if (adminBtn) {
          // Force re-setup
          this.setupFloatingAdminButton();
          console.log('üîß Admin button re-setup complete');
        }
      }

      // Check for secret admin access via URL parameter
      checkSecretAdminAccess() {
        const urlParams = new URLSearchParams(window.location.search);
        const secretAdmin = urlParams.get('admin');
        
        if (secretAdmin === 'zak2024') {
          localStorage.setItem('ourDailyIsAdmin', 'true');
          this.uiService.showToast('üîß Admin mode enabled via URL!');
          console.log('üîß Admin mode enabled via secret URL parameter');
          
          // Remove the parameter from URL without reloading
          const newUrl = window.location.pathname;
          window.history.replaceState({}, document.title, newUrl);
        }
      }

      // Setup long-press admin access on top-right corner
      setupLongPressAdminAccess() {
        let pressTimer = null;
        let isLongPress = false;
        
        // Create invisible corner element for long-press detection
        const cornerElement = document.createElement('div');
        cornerElement.id = 'admin-corner';
        cornerElement.style.cssText = `
          position: fixed;
          top: 0;
          right: 0;
          width: 60px;
          height: 60px;
          z-index: 9999;
          background: transparent;
          cursor: default;
          user-select: none;
          -webkit-user-select: none;
          -webkit-touch-callout: none;
        `;
        document.body.appendChild(cornerElement);
        
        // Mouse events for desktop
        cornerElement.addEventListener('mousedown', (e) => {
          e.preventDefault();
          pressTimer = setTimeout(() => {
            isLongPress = true;
            this.enableAdminMode();
            this.showAdminMenu();
          }, 3000); // 3 second long press
        });
        
        cornerElement.addEventListener('mouseup', () => {
          if (pressTimer) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          isLongPress = false;
        });
        
        cornerElement.addEventListener('mouseleave', () => {
          if (pressTimer) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          isLongPress = false;
        });
        
        // Touch events for mobile
        cornerElement.addEventListener('touchstart', (e) => {
          e.preventDefault();
          pressTimer = setTimeout(() => {
            isLongPress = true;
            this.enableAdminMode();
            this.showAdminMenu();
          }, 3000); // 3 second long press
        });
        
        cornerElement.addEventListener('touchend', () => {
          if (pressTimer) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          isLongPress = false;
        });
        
        cornerElement.addEventListener('touchcancel', () => {
          if (pressTimer) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          isLongPress = false;
        });
        
        // Prevent any text selection or context menus
        cornerElement.addEventListener('selectstart', (e) => {
          e.preventDefault();
        });
        
        cornerElement.addEventListener('contextmenu', (e) => {
          e.preventDefault();
        });
      }

      // Quote Management Functions
      showQuoteManager() {
        // Check if a quote manager modal is already open
        const existingModal = document.querySelector('.quote-manager-modal');
        if (existingModal) {
          console.log('‚ö†Ô∏è Quote manager modal already open, removing existing one');
          existingModal.remove();
        }
        
        // Get next 7 days of quotes
        const next7Days = this.getNext7DaysQuotes();
        let quotesHTML = '';
        
        next7Days.forEach((dayData, index) => {
          const { date, quote, dayName } = dayData;
          quotesHTML += `
            <div class="quote-day-item" data-index="${dayData.originalIndex}">
              <div class="day-header">
                <span class="day-name">${dayName}</span>
                <span class="day-date">${date}</span>
              </div>
              <div class="quote-content">
                <div class="quote-text">"${quote.text}"</div>
                <div class="quote-author">‚Äî ${quote.author}</div>
              </div>
              <div class="quote-actions">
                <button onclick="app.editQuoteForDay(${index})" class="edit-btn">Edit</button>
                <button onclick="app.deleteQuoteForDay(${index})" class="delete-btn">Delete</button>
                <button onclick="app.swapWithPrevious(${index})" class="swap-btn" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                <button onclick="app.swapWithNext(${index})" class="swap-btn" ${index === 6 ? 'disabled' : ''}>‚Üì</button>
              </div>
            </div>
          `;
        });
        
        const modal = document.createElement('div');
        modal.className = 'quote-manager-modal';
        modal.innerHTML = `
          <div class="quote-manager-content">
            <h3>Next 7 Days Quotes</h3>
            <div class="quote-list">
              ${quotesHTML}
            </div>
            <div class="quote-manager-actions">
              <button onclick="app.saveQuotesToFirestore()" class="save-btn">Save Changes</button>
              <button onclick="this.parentElement.parentElement.parentElement.remove()" class="close-btn">Close</button>
            </div>
          </div>
        `;
        
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          z-index: 1002;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 20px;
        `;
        
        const content = modal.querySelector('.quote-manager-content');
        content.style.cssText = `
          background: white;
          border-radius: 8px;
          padding: 20px;
          max-width: 600px;
          max-height: 80vh;
          overflow-y: auto;
          width: 100%;
        `;
        
        document.body.appendChild(modal);
        
        // Add CSS for quote items
        const style = document.createElement('style');
        style.textContent = `
          .quote-day-item {
            border: 1px solid #ddd;
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            background: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          }
          .day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
          }
          .day-name {
            font-weight: bold;
            color: #333;
            font-size: 16px;
          }
          .day-date {
            color: #666;
            font-size: 14px;
            background: #e0e0e0;
            padding: 2px 8px;
            border-radius: 12px;
          }
          .quote-content {
            margin-bottom: 10px;
          }
          .quote-text {
            font-style: italic;
            margin-bottom: 5px;
            font-size: 14px;
            line-height: 1.4;
          }
          .quote-author {
            font-weight: bold;
            color: #666;
            font-size: 12px;
          }
          .quote-actions {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
          }
          .quote-actions button {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #ccc;
            background: white;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
          }
          .quote-actions button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
          }
          .quote-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
          }
          .edit-btn { color: #0066cc; }
          .delete-btn { color: #cc0000; }
          .swap-btn { color: #666; }
          .save-btn { background: #2196F3; color: white; padding: 8px 16px; }
          .close-btn { background: #666; color: white; padding: 8px 16px; }
          .quote-manager-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
          }
          .subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
          }
        `;
        document.head.appendChild(style);
      }

      editQuote(index) {
        const quote = this.quoteService.quotes[index];
        const newText = prompt('Edit quote text:', quote.text);
        if (newText !== null) {
          const newAuthor = prompt('Edit author:', quote.author.replace('‚Äî ', ''));
          if (newAuthor !== null) {
            this.quoteService.quotes[index] = {
              text: newText,
              author: newAuthor.startsWith('‚Äî ') ? newAuthor : `‚Äî ${newAuthor}`
            };
            this.uiService.showToast(`Quote updated`);
            this.showQuoteManager(); // Refresh the manager
          }
        }
      }

      // Edit quote for a specific day (used by the 7-day manager)
      editQuoteForDay(dayIndex) {
        const next7Days = this.getNext7DaysQuotes();
        const dayData = next7Days[dayIndex];
        const quote = dayData.quote;
        
        const newText = prompt('Edit quote text:', quote.text);
        if (newText !== null) {
          const newAuthor = prompt('Edit author:', quote.author.replace('‚Äî ', ''));
          if (newAuthor !== null) {
            // Update the quote in the quotes array using the original index
            this.quoteService.quotes[dayData.originalIndex] = {
              text: newText,
              author: newAuthor.startsWith('‚Äî ') ? newAuthor : `‚Äî ${newAuthor}`
            };
            
            this.uiService.showToast(`Quote for ${dayData.dayName} updated`);
            // Don't refresh immediately - let user save first
          }
        }
      }

      removeQuote(index) {
        if (confirm(`Are you sure you want to remove this quote?\n\n"${this.quoteService.quotes[index].text}"\n‚Äî ${this.quoteService.quotes[index].author}`)) {
          this.quoteService.quotes.splice(index, 1);
          this.uiService.showToast(`Quote ${index + 1} removed`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      moveQuoteUp(index) {
        if (index > 0) {
          const temp = this.quoteService.quotes[index];
          this.quoteService.quotes[index] = this.quoteService.quotes[index - 1];
          this.quoteService.quotes[index - 1] = temp;
          this.uiService.showToast(`Quote moved up`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      moveQuoteDown(index) {
        if (index < this.quoteService.quotes.length - 1) {
          const temp = this.quoteService.quotes[index];
          this.quoteService.quotes[index] = this.quoteService.quotes[index + 1];
          this.quoteService.quotes[index + 1] = temp;
          this.uiService.showToast(`Quote moved down`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      replaceQuote(index) {
        const currentQuote = this.quoteService.quotes[index];
        const newText = prompt('Enter new quote text:', currentQuote.text);
        if (newText !== null) {
          const newAuthor = prompt('Enter new author:', currentQuote.author.replace('‚Äî ', ''));
          if (newAuthor !== null) {
            this.quoteService.quotes[index] = {
              text: newText,
              author: newAuthor.startsWith('‚Äî ') ? newAuthor : `‚Äî ${newAuthor}`
            };
            this.uiService.showToast(`Quote replaced`);
            this.showQuoteManager(); // Refresh the manager
          }
        }
      }

      // Delete quote for a specific day (used by the 7-day manager)
      deleteQuoteForDay(dayIndex) {
        const next7Days = this.getNext7DaysQuotes();
        const dayData = next7Days[dayIndex];
        const quote = dayData.quote;
        
        if (confirm(`Are you sure you want to delete this quote?\n\n"${quote.text}"\n${quote.author}\n\nThis will remove it from the rotation and another quote will automatically appear for ${dayData.dayName}.`)) {
          // Remove the quote from the quotes array
          this.quoteService.quotes.splice(dayData.originalIndex, 1);
          
          // Update the shuffled indexes to account for the removed quote
          this.quoteService.shuffledIndexes = this.quoteService.shuffledIndexes.map(index => {
            if (index > dayData.originalIndex) {
              return index - 1; // Shift down indexes after the deleted quote
            }
            return index;
          });
          
          this.uiService.showToast(`Quote deleted. New quote will appear for ${dayData.dayName}.`);
          this.showQuoteManager(); // Refresh the manager
        }
      }

      swapWithPrevious(dayIndex) {
        if (dayIndex <= 0) return; // Can't swap the first day
        
        const next7Days = this.getNext7DaysQuotes();
        const currentDay = next7Days[dayIndex];
        const previousDay = next7Days[dayIndex - 1];
        
        // Calculate the actual day indices for the shuffled array
        const today = new Date();
        const currentDate = new Date(today);
        currentDate.setDate(today.getDate() + currentDay.dayIndex);
        const previousDate = new Date(today);
        previousDate.setDate(today.getDate() + previousDay.dayIndex);
        
        const currentDayIndex = Math.floor(currentDate.getTime() / (1000 * 60 * 60 * 24));
        const previousDayIndex = Math.floor(previousDate.getTime() / (1000 * 60 * 60 * 24));
        
        // Swap the quotes in the shuffled indexes
        const tempIndex = this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length] = 
          this.quoteService.shuffledIndexes[previousDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[previousDayIndex % this.quoteService.shuffledIndexes.length] = tempIndex;
        
        this.uiService.showToast(`Swapped quotes for ${previousDay.dayName} and ${currentDay.dayName}`);
        this.showQuoteManager(); // Refresh the manager
      }

      swapWithNext(dayIndex) {
        if (dayIndex >= 6) return; // Can't swap the last day
        
        const next7Days = this.getNext7DaysQuotes();
        const currentDay = next7Days[dayIndex];
        const nextDay = next7Days[dayIndex + 1];
        
        // Calculate the actual day indices for the shuffled array
        const today = new Date();
        const currentDate = new Date(today);
        currentDate.setDate(today.getDate() + currentDay.dayIndex);
        const nextDate = new Date(today);
        nextDate.setDate(today.getDate() + nextDay.dayIndex);
        
        const currentDayIndex = Math.floor(currentDate.getTime() / (1000 * 60 * 60 * 24));
        const nextDayIndex = Math.floor(nextDate.getTime() / (1000 * 60 * 60 * 24));
        
        // Swap the quotes in the shuffled indexes
        const tempIndex = this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[currentDayIndex % this.quoteService.shuffledIndexes.length] = 
          this.quoteService.shuffledIndexes[nextDayIndex % this.quoteService.shuffledIndexes.length];
        this.quoteService.shuffledIndexes[nextDayIndex % this.quoteService.shuffledIndexes.length] = tempIndex;
        
        this.uiService.showToast(`Swapped quotes for ${currentDay.dayName} and ${nextDay.dayName}`);
        this.showQuoteManager(); // Refresh the manager
      }

      addNewQuote() {
        const text = prompt('Enter new quote text:');
        if (text) {
          const author = prompt('Enter author:');
          if (author) {
            this.quoteService.quotes.push({
              text: text,
              author: author.startsWith('‚Äî ') ? author : `‚Äî ${author}`
            });
            this.uiService.showToast('New quote added');
            this.showQuoteManager(); // Refresh the manager
          }
        }
      }

      async saveQuotesToFirestore() {
        try {
          console.log('üíæ Starting save to Firestore...');
          console.log('üíæ QuoteService Firebase available:', !!this.quoteService.firebase);
          console.log('üíæ Global Firebase available:', !!window.firebaseApp);
          console.log('üíæ Quotes to save:', this.quoteService.quotes.length);
          
          // Show loading state
          this.uiService.showToast('Saving quotes to database...');
          
          // Use QuoteService Firebase or fallback to global Firebase
          const firebaseInstance = this.quoteService.firebase || window.firebaseApp;
          if (!firebaseInstance) {
            throw new Error('No Firebase instance available');
          }
          
          // Use the global Firestore functions
          if (!window.db) {
            throw new Error('Firestore database not available');
          }
          
          // Save to Firestore using the global functions
          await window.firestore.setDoc(window.firestore.doc(window.db, 'quotes', 'daily'), {
            quotes: this.quoteService.quotes,
            shuffledIndexes: this.quoteService.shuffledIndexes,
            updatedAt: new Date(),
            updatedBy: this.currentUserId
          });
          
          this.uiService.showToast('‚úÖ Quotes saved to database! All users will see changes.');
          console.log('üíæ Quotes saved to Firestore:', this.quoteService.quotes.length, 'quotes');
          
          // Close the quote admin panel by removing all modals
          const modals = document.querySelectorAll('.quote-manager-modal');
          modals.forEach(modal => modal.remove());
          console.log(`üóëÔ∏è Removed ${modals.length} quote manager modals`);
          
        } catch (error) {
          console.error('‚ùå Error saving quotes to Firestore:', error);
          this.uiService.showToast('‚ùå Error saving quotes to database');
          
          // Fallback to localStorage
          try {
            localStorage.setItem('ourDailyQuotes', JSON.stringify(this.quoteService.quotes));
            this.uiService.showToast('‚ö†Ô∏è Saved to localStorage as fallback');
            console.log('üíæ Saved to localStorage as fallback');
          } catch (localError) {
            console.error('Error saving to localStorage:', localError);
          }
        }
      }

      showTodayQuote() {
        const todayQuote = this.quoteService.getTodayQuote();
        alert(`Today's Quote:\n\n"${todayQuote.text}"\n${todayQuote.author}`);
      }

      // Get next 7 days of quotes with dates
      getNext7DaysQuotes() {
        const next7Days = [];
        const today = new Date();
        
        console.log(`üîç getNext7DaysQuotes - Today: ${today.toDateString()}`);
        console.log(`üîç Current quotes array length: ${this.quoteService.quotes.length}`);
        
        for (let i = 1; i <= 7; i++) { // Start from tomorrow (i=1) instead of today (i=0)
          const futureDate = new Date(today);
          futureDate.setDate(today.getDate() + i);
          
          const year = futureDate.getFullYear();
          const month = String(futureDate.getMonth() + 1).padStart(2, '0');
          const day = String(futureDate.getDate()).padStart(2, '0');
          const dateString = `${year}-${month}-${day}`;
          
          console.log(`üîç Day ${i}: ${futureDate.toDateString()} ‚Üí ${dateString}`);
          
          // Get the quote directly from the quotes array using shuffled indexes
          const dayIndex = Math.floor(futureDate.getTime() / (1000 * 60 * 60 * 24));
          const quoteIndex = this.quoteService.shuffledIndexes[dayIndex % this.quoteService.shuffledIndexes.length];
          const quote = this.quoteService.quotes[quoteIndex];
          
          console.log(`üîç Day ${i}: dayIndex=${dayIndex}, quoteIndex=${quoteIndex}, quote=`, quote);
          
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          const dayName = dayNames[futureDate.getDay()];
          
          next7Days.push({
            date: `${month}/${day}`,
            dayName: dayName,
            quote: quote,
            originalIndex: quoteIndex,
            dayIndex: i // Use the loop index (1-7) instead of the absolute day index
          });
        }
        
        return next7Days;
      }

      // Reset quotes to defaults
      async resetQuotesToDefaults() {
        if (confirm('Are you sure you want to reset all quotes to the original defaults? This will remove all custom quotes.')) {
          // Reset to original quotes array
          this.quoteService.quotes = [
            { text: "Art washes away from the soul the dust of everyday life.", author: "‚Äî Pablo Picasso" },
            { text: "Creativity takes courage.", author: "‚Äî Henri Matisse" },
            { text: "Every artist was first an amateur.", author: "‚Äî Ralph Waldo Emerson" },
            { text: "Color is the keyboard, the eyes are the harmonies, the soul is the piano with many strings.", author: "‚Äî Wassily Kandinsky" },
            { text: "Great things are done by a series of small things brought together.", author: "‚Äî Vincent Van Gogh" },
            { text: "You can't use up creativity. The more you use, the more you have.", author: "Maya Angelou" },
            { text: "Every time I have had a problem, I have confronted it with the ax of art.", author: "Yayoi Kusama" },
            { text: "I found I could say things with color and shapes that I couldn't say any other way ‚Äì things I had no words for.", author: "Georgia O'Keeffe" },
            { text: "I love creation more than life, and I must express myself before disappearing.", author: "Sonia Delaunay" },
            { text: "The job of the artist is always to deepen the mystery.", author: "Francis Bacon" },
            { text: "The most important relationship in your life is the relationship you have with yourself.", author: "Diane von Furstenberg" },
            { text: "There is a vitality, a life force, an energy, a quickening that is translated through you into action, and because there is only one of you in all time, this expression is unique.", author: "Martha Graham" },
            { text: "If there is a book that you want to read, but it hasn't been written yet, you must be the one to write it.", author: "Toni Morrison" },
            { text: "Creativity doesn't wait for that perfect moment. It fashions its own perfect moments out of ordinary ones.", author: "Elizabeth Gilbert" },
            { text: "I think, at a child's birth, if a mother could ask a fairy godmother to endow it with the most useful gift, that gift would be curiosity.", author: "Eleanor Roosevelt" },
            { text: "Imagination is more important than knowledge. Knowledge is limited. Imagination encircles the world.", author: "Albert Einstein" },
            { text: "The beauty of a living thing is not the atoms that go into it, but the way those atoms are put together.", author: "Carl Sagan" },
            { text: "Let your curiosity be greater than your fear.", author: "Pema Ch√∂dr√∂n" },
            { text: "Study hard what interests you the most in the most undisciplined, irreverent and original manner possible.", author: "Richard Feynman" },
            { text: "Research is formalized curiosity. It is poking and prying with a purpose.", author: "Zora Neale Hurston" },
            { text: "It is always with excitement that I wake up in the morning wondering what my intuition will toss up to me, like gifts from the sea.", author: "Jonas Salk" },
            { text: "The only thing that makes life possible is permanent, intolerable uncertainty; not knowing what comes next.", author: "Ursula K. Le Guin" },
            { text: "Curiosity is the engine of achievement.", author: "Sir Ken Robinson" },
            { text: "Let the beauty of what you love be what you do. There are a thousand ways to kneel and kiss the earth.", author: "Rumi" },
            { text: "I'm very interested in, 'What does it mean for us to cultivate together?' Community that allows for risk, the risk of knowing someone outside your own boundaries, the risk that is love.", author: "bell hooks" },
            { text: "A nation's culture resides in the hearts and in the soul of its people.", author: "Mahatma Gandhi" },
            { text: "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.", author: "Antoine de Saint-Exup√©ry" },
            { text: "The butterfly counts not months but moments, and has time enough.", author: "Rabindranath Tagore" },
            { text: "To fly, we have to have resistance.", author: "Maya Lin" },
            { text: "Not everything that is faced can be changed, but nothing can be changed until it is faced.", author: "James Baldwin" },
            { text: "There's nothing new under the sun, but there are new suns.", author: "Octavia Butler" },
            { text: "Never doubt that a small group of thoughtful, committed citizens can change the world; indeed, it's the only thing that ever has.", author: "Margaret Mead" },
            { text: "There is no such thing as a single-issue struggle because we do not live single-issue lives.", author: "Audre Lorde" },
            { text: "Every moment is an organizing opportunity, every person a potential activist, every minute a chance to change the world.", author: "Dolores Huerta" },
            { text: "We don't have to engage in grand, heroic actions to participate in the process of change. Small acts, when multiplied by millions of people, can transform the world.", author: "Howard Zinn" },
            { text: "When the whole world is silent, even one voice becomes powerful.", author: "Malala Yousafzai" },
            { text: "Activism is my rent for living on the planet.", author: "Alice Walker" },
            { text: "We are the leaders we've been waiting for.", author: "Grace Lee Boggs" },
            { text: "Do your little bit of good where you are; it's those little bits of good put together that overwhelm the world.", author: "Desmond Tutu" },
            { text: "What you do makes a difference, and you have to decide what kind of difference you want to make.", author: "Jane Goodall" },
            { text: "You never change things by fighting the existing reality. To change something, build a new model that makes the existing model obsolete.", author: "Buckminster Fuller" },
            { text: "Like what you do, and then you will do your best.", author: "Katherine Johnson" },
            { text: "The present is theirs; the future, for which I really worked, is mine.", author: "Nikola Tesla" },
            { text: "Cities have the capability of providing something for everybody, only because, and only when, they are created by everybody.", author: "Jane Jacobs" },
            { text: "In every outthrust headland, in every curving beach, in every grain of sand there is the story of the earth.", author: "Rachel Carson" },
            { text: "What the people want is very simple - they want an America as good as its promise.", author: "Barbara Jordan" },
            { text: "In nature's economy the currency is not money, it is life.", author: "Vandana Shiva" },
            { text: "When we plant trees, we plant the seeds of peace and seeds of hope.", author: "Wangari Maathai" },
            { text: "No one is born fully-formed: it is through self-experience in the world that we become what we are.", author: "Paulo Freire" },
            { text: "Turn your wounds into wisdom.", author: "Oprah Winfrey" },
            { text: "Courage doesn't always roar. Sometimes courage is the quiet voice at the end of the day saying 'I will try again tomorrow.'", author: "Mary Anne Radmacher" },
            { text: "I fight pain, anxiety, and fear every day, and the only method I have found that relieves my illness is to keep creating art.", author: "Yayoi Kusama" },
            { text: "To heal is to touch with love that which we previously touched with fear.", author: "Stephen Levine" },
            { text: "I am better off healed than I ever was unbroken.", author: "Beth Moore" },
            { text: "Everything can be taken from a man but one thing: the last of the human freedoms‚Äîto choose one's attitude in any given set of circumstances.", author: "Viktor Frankl" },
            { text: "The purpose of life is not to be happy. It is to be useful, to be honorable, to be compassionate, to have it make some difference that you have lived and lived well.", author: "Ralph Waldo Emerson" },
            { text: "Let yourself be silently drawn by the strange pull of what you really love. It will not lead you astray.", author: "Rumi" },
            { text: "Follow your bliss and the universe will open doors where there were only walls.", author: "Joseph Campbell" },
            { text: "A musician must make music, an artist must paint, a poet must write, if he is to be ultimately happy. What a man can be, he must be.", author: "Abraham Maslow" },
            { text: "At every moment you choose yourself. But do you choose your self? Body and soul contain a thousand possibilities out of which you can build many I's.", author: "Dag Hammarskj√∂ld" },
            { text: "We are the myths we tell ourselves about ourselves.", author: "Jean Houston" },
            { text: "A vocation is not a career that you choose for yourself. A vocation is a calling that you discover by listening to the voice of vocation within you.", author: "Parker Palmer" },
            { text: "Attention is the rarest and purest form of generosity.", author: "Simone Weil" },
            { text: "Waking up this morning, I smile. Twenty-four brand new hours are before me. I vow to live fully in each moment.", author: "Th√≠ch Nh·∫•t H·∫°nh" },
            { text: "The privilege of a lifetime is to become who you truly are.", author: "Carl Jung" },
            { text: "I define connection as the energy that exists between people when they feel seen, heard, and valued; when they can give and receive without judgment.", author: "Bren√© Brown" },
            { text: "Perhaps the secret of living well is not in having all the answers but in pursuing unanswerable questions in good company.", author: "Rachel Naomi Remen" },
            { text: "All real living is meeting.", author: "Martin Buber" },
            { text: "We humans are social beings. We come into the world as the result of others' actions. We survive here in dependence on others.", author: "The Dalai Lama" },
            { text: "Sometimes people try to destroy you, precisely because they recognize your power.", author: "bell hooks" },
            { text: "When you understand that being connected to others is one of life's greatest joys, you realize that life's best comes when you initiate and invest in solid relationships.", author: "John C. Maxwell" },
            { text: "Healing yourself is connected with healing others.", author: "Yoko Ono" },
            { text: "Relationships are all there is. Everything in the universe only exists because it is in relationship to everything else.", author: "Margaret J. Wheatley" },
            { text: "When you take one step to reach out to people, when you meet with others and share their thoughts and sufferings, infinite compassion and wisdom well up within your heart.", author: "Daisaku Ikeda" },
            { text: "We now accept the fact that learning is a lifelong process of keeping abreast of change. And the most pressing task is to teach people how to learn.", author: "Peter Drucker" },
            { text: "The illiterate of the 21st century will not be those who cannot read and write, but those who cannot learn, unlearn, and relearn.", author: "Alvin Toffler" },
            { text: "Those people who develop the ability to continuously acquire new and better forms of knowledge that they can apply to their work and to their lives will be the movers and shakers in our society for the indefinite future.", author: "Brian Tracy" },
            { text: "The purpose of learning is growth, and our minds, unlike our bodies, can continue growing as we continue to live.", author: "Mortimer Adler" },
            { text: "The good thing about science is that it's true whether or not you believe in it. But the great thing about learning is that it makes you more capable of reducing the suffering of others.", author: "Neil deGrasse Tyson" },
            { text: "I have learned that each and every piece of cloth embodies the spirit, skill, and personal history of an individual weaver‚Ä¶ It ties together with an endless thread the emotional life of my people.", author: "Nilda Calla√±aupa Alvarez" },
            { text: "I wanted to tell my story through fabric because it was a medium that was accessible to me as a woman and as an African American.", author: "Faith Ringgold" },
            { text: "Come stitch next to me, and I'll tell you a story.", author: "Sonya Clark" },
            { text: "Fabric is a material that forgives. You can always mend, patch, darn, and transform it into something new.", author: "Louise Bourgeois" },
            { text: "We must learn inner solitude wherever or with whomsoever we may be. We must learn to penetrate things and find God in them.", author: "Anni Albers" },
            { text: "Thread has the potential to unite, to heal, to provide a soft structure in a hard world.", author: "Sheila Hicks" },
            { text: "The loom is the universe in miniature‚Äîwarp and weft, the essential crossing that creates all structure, all meaning.", author: "Lenore Tawney" },
            { text: "Western art tradition values fine art practices such as painting, mostly done by men and on canvas. Bringing these techniques into the gallery space allows me to question the hierarchy in the Western art world.", author: "Hale Ekinci" },
            { text: "The true measure of our commitment to justice, the character of our society, our commitment to the rule of law, fairness, and equality cannot be measured by how we treat the rich, the powerful, the privileged, and the respected among us.", author: "Bryan Stevenson" },
            { text: "We cannot seek achievement for ourselves and forget about the progress and prosperity for our community.", author: "Dolores Huerta" },
            { text: "If you see something that is not right, not fair, not just, you have a moral obligation to do something about it.", author: "John Lewis" },
            { text: "Trauma happens in relationship, so does healing.", author: "Tarana Burke" },
            { text: "Real change requires real relationships. And real relationships require that we tell the truth about our experiences.", author: "Alicia Garza" },
            { text: "Care is the strategy. Care is what we need more of in this world. Care is revolutionary.", author: "Ai-jen Poo" },
            { text: "We accomplish nothing if we say nothing. We accomplish nothing if we do nothing. And we accomplish nothing if we know nothing.", author: "Stacey Abrams" }
          ];
          
          // Save to Firestore
          await this.saveQuotesToFirestore();
          this.uiService.showToast('‚úÖ Quotes reset to defaults and saved to database');
        }
      }



      showRevealImageManager() {
        const menu = document.createElement('div');
        menu.className = 'reveal-image-manager';
        menu.innerHTML = `
          <div class="reveal-image-manager-content">
            <h3 style="margin: 0 0 15px 0; text-align: center;">Quilt Reveal Image Manager</h3>
            <div class="image-upload-section">
              <h4 style="margin: 0 0 8px 0;">Upload New Reveal Image</h4>
              <p style="font-size: 12px; color: #666; margin: 5px 0 10px 0;">Images will be automatically resized to 412 x 800 pixels</p>
              <input type="file" id="revealImageUpload" accept="image/*" style="margin: 0 0 10px 0; width: 100%;">
              <button onclick="app.handleUploadRevealImage()">Upload Image</button>
            </div>
            <div class="image-selection-section">
              <h4 style="margin: 15px 0 8px 0;">Select Active Reveal Image</h4>
              <div id="revealImageOptions">
                <p>Loading available images...</p>
              </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        menu.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          z-index: 1001;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          min-width: 300px;
          max-height: 80vh;
          overflow-y: auto;
        `;
        
        const content = menu.querySelector('.reveal-image-manager-content');
        content.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 8px;
        `;
        
        const buttons = menu.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
          `;
        });
        
        menu.addEventListener('click', (e) => {
          if (e.target === menu) {
            menu.remove();
          }
        });
        
        document.body.appendChild(menu);
        
        // Load available images
        this.loadRevealImageOptions();
      }

      showAdminMenu() {
        const menu = document.createElement('div');
        menu.className = 'admin-menu';
        
        // Create stats display with ID for easy updates
        const statsDisplay = `
          <div id="admin-stats-display" style="background: #f0f0f0; padding: 10px; border-radius: 4px; margin-bottom: 10px; text-align: center; font-weight: bold;">
            ${this.getAdminStatsHTML()}
          </div>
        `;
        
        menu.innerHTML = `
          <div class="admin-menu-content">
            ${statsDisplay}
            <button onclick="app.handleTestAddBlock()">Add Random Block</button>
            <button onclick="app.handleAddColorFamilyBlocks()">Add 10 Color Family Blocks</button>
            <button onclick="app.handleResetQuilt()">Reset Quilt</button>
            <button onclick="app.handleTestInstagramImage()">üì∏ Create IG Image</button>
            <button onclick="app.handleTestZapierWebhook()">üîó Test Zapier Webhook</button>
            <button onclick="app.showQuoteManager()">Manage Quotes</button>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        menu.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 15px;
          z-index: 1001;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          min-width: 400px;
          max-height: 35vh;
          overflow-y: auto;
        `;
        
        const content = menu.querySelector('.admin-menu-content');
        content.style.cssText = `
          display: flex;
          flex-direction: row;
          flex-wrap: wrap;
          gap: 8px;
          justify-content: center;
          align-items: center;
        `;
        
        const buttons = menu.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
          `;
        });
        
        menu.addEventListener('click', (e) => {
          if (e.target === menu) {
            menu.remove();
          }
        });
        
        document.body.appendChild(menu);
      }

      // Helper method to get admin stats HTML
      getAdminStatsHTML() {
        const currentBlockCount = this.quiltEngine ? this.quiltEngine.blocks.length : 0;
        
        return `
          üìä Current Blocks: ${currentBlockCount}
        `;
      }

      // Method to update admin stats display
      updateAdminStats() {
        const statsDisplay = document.getElementById('admin-stats-display');
        if (statsDisplay) {
          statsDisplay.innerHTML = this.getAdminStatsHTML();
        }
      }

      initializeUI() {
        this.quoteService.displayQuote();
        this.uiService.showScreen('screen-portal');
      }

      setupAutoTransition() {
        // Always set up the auto-transition regardless of current screen
        const delay = 1500; // Fixed 1.5 seconds for all devices
        
        console.log('üîÑ Setting up auto-transition with delay:', delay);
        
        setTimeout(() => {
          const currentScreen = document.querySelector('.screen.active');
          console.log('üîÑ Auto-transition check - current screen:', currentScreen?.id);
          
          if (currentScreen && currentScreen.id === 'screen-portal') {
            console.log('üîÑ Auto-transitioning from portal...');
            this.autoTransitionFromPortal();
          } else {
            console.log('üîÑ No auto-transition - portal not active');
          }
        }, delay);
      }

      async autoTransitionFromPortal() {
        try {
          console.log('üîÑ Starting auto-transition from portal...');
          
          const hasVisitedBefore = localStorage.getItem('ourDailyHasVisited');
          const lastVisitDate = localStorage.getItem('ourDailyLastVisitDate');
          
          const now = new Date();
          const chicagoTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Chicago"}));
          const currentDate = chicagoTime.toDateString();
          const isNewDay = lastVisitDate !== currentDate;
          
          console.log('üîÑ Visit check:', { hasVisitedBefore, lastVisitDate, currentDate, isNewDay });
          
          if (!hasVisitedBefore) {
            console.log('üîÑ First visit ever - showing welcome screen');
            localStorage.setItem('ourDailyHasVisited', 'true');
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            this.uiService.showScreen('screen-welcome');
          } else if (isNewDay) {
            console.log('üîÑ Returning user on new day - showing quote screen');
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            this.uiService.showScreen('screen-quote');
          } else {
            console.log('üîÑ Returning user on same day - showing quote screen directly');
            this.uiService.showScreen('screen-quote');
          }
        } catch (error) {
          this.logger.error('‚ùå Auto transition failed:', error);
          this.uiService.showScreen('screen-quote');
        }
      }
      
      async resetQuiltForNewDay() {
        this.quiltEngine.initialize();
        
        try {
          await this.dataService.saveQuilt([], 1);
        } catch (error) {
          this.logger.warn('‚ö†Ô∏è Failed to clear data for new day:', error);
        }
        
        this.renderQuilt();
        this.updateSquareCounter();
      }

      setupDailyReset() {
        this.logger.log('üåô Setting up automatic daily archive and reset...');
        
        const scheduleDailyCycle = () => {
          const now = new Date();
          
          // Calculate next 6:30 AM UTC (archive)
          const nextArchive = new Date(now);
          nextArchive.setUTCHours(6, 30, 0, 0); // 6:30:00 AM UTC
          
          // If it's already past 6:30 AM UTC today, schedule for tomorrow
          if (now >= nextArchive) {
            nextArchive.setUTCDate(nextArchive.getUTCDate() + 1);
          }
          
          // Calculate next 7:00 AM UTC (reset)
          const nextReset = new Date(now);
          nextReset.setUTCHours(7, 0, 0, 0); // 7:00:00 AM UTC
          
          // If it's already past 7:00 AM UTC today, schedule for tomorrow
          if (now >= nextReset) {
            nextReset.setUTCDate(nextReset.getUTCDate() + 1);
          }
          
          const timeUntilArchive = nextArchive.getTime() - now.getTime();
          const timeUntilReset = nextReset.getTime() - now.getTime();
          
          this.logger.log(`üì¶ Next archive scheduled for: ${nextArchive.toISOString()} (6:30 AM UTC)`);
          this.logger.log(`üîÑ Next reset scheduled for: ${nextReset.toISOString()} (7:00 AM UTC)`);
          
          // Schedule archive at 6:30 AM UTC
          if (timeUntilArchive > 0) {
            setTimeout(async () => {
              this.logger.log('üì¶ 6:30 AM UTC reached - archiving current quilt');
              const archiveSuccess = await this.performDailyArchive();
              
              // Store archive status for reset check (using UTC date)
              const utcNow = new Date();
              const todayKey = utcNow.toISOString().split('T')[0];
              localStorage.setItem(`archiveStatus_${todayKey}`, archiveSuccess ? 'success' : 'failed');
            }, timeUntilArchive);
          }
          
          // Schedule reset at 7:00 AM UTC
          if (timeUntilReset > 0) {
            setTimeout(async () => {
              this.logger.log('üîÑ 7:00 AM UTC reached - checking archive status before reset');
              await this.performDailyReset();
              scheduleDailyCycle(); // Schedule next day's cycle
            }, timeUntilReset);
          }
        };
        
        // Schedule the first cycle
        scheduleDailyCycle();
      }

      async performDailyArchive() {
        try {
          this.logger.log('üì¶ Performing daily archive...');
          
          // Create archive of current quilt
          if (this.quiltEngine.blocks.length > 1) { // Only archive if there are blocks beyond the initial one
            this.logger.log(`üì¶ Archiving quilt with ${this.quiltEngine.blocks.length} blocks...`);
            
            // SAFEGUARD 1: Backup current quilt data before archiving
            const utcNow = new Date();
            const backupDate = utcNow.toISOString().split('T')[0];
            const quiltBackup = {
              blocks: JSON.parse(JSON.stringify(this.quiltEngine.blocks)),
              submissionCount: this.quiltEngine.submissionCount,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('quiltBackup_' + backupDate, JSON.stringify(quiltBackup));
            this.logger.log('üì¶ Created quilt backup before archiving');
            
            // SAFEGUARD 2: Try archive with retry logic
            let archiveSuccess = false;
            let retryCount = 0;
            const maxRetries = 3;
            
            while (!archiveSuccess && retryCount < maxRetries) {
              try {
                await this.createArchiveSnapshot();
                archiveSuccess = true;
                this.logger.log(`üì¶ Archived current quilt successfully (attempt ${retryCount + 1})`);
              } catch (archiveError) {
                retryCount++;
                this.logger.error(`‚ùå Archive attempt ${retryCount} failed:`, archiveError);
                
                if (retryCount < maxRetries) {
                  this.logger.log(`üîÑ Retrying archive in 2 seconds... (${retryCount}/${maxRetries})`);
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
              }
            }
            
            if (!archiveSuccess) {
              // SAFEGUARD 3: If all retries fail, create a minimal archive entry
              this.logger.error('‚ùå All archive attempts failed - creating emergency backup');
              try {
                // Use UTC for emergency backup date
                const utcNow = new Date();
                const emergencyDate = utcNow.toISOString().split('T')[0];
                const emergencyEntry = {
                  date: emergencyDate,
                  blocks: this.quiltEngine.blocks,
                  quote: this.quoteService.getQuoteForDate(emergencyDate),
                  contributorCount: this.quiltEngine.submissionCount,
                  thumbnail: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSIjZmY2YjZiIi8+Cjx0ZXh0IHg9IjIwMCIgeT0iMjAwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiI+RW1lcmdlbmN5IEJhY2t1cDwvdGV4dD4KPC9zdmc+',
                  isEmergencyBackup: true
                };
                
                // Store emergency backup in localStorage as fallback
                const emergencyKey = `emergencyArchive_${emergencyDate}`;
                localStorage.setItem(emergencyKey, JSON.stringify(emergencyEntry));
                this.logger.log('üì¶ Created emergency backup in localStorage');
                
                return false; // Archive failed but we have backup
              } catch (emergencyError) {
                this.logger.error('‚ùå Emergency backup also failed:', emergencyError);
                return false;
              }
            }
            
            // SAFEGUARD 4: Verify archive was actually created
            try {
              // Use UTC for verification
              const utcNow = new Date();
              const verifyDate = utcNow.toISOString().split('T')[0];
              const archives = await this.archiveService.getArchives(1);
              const todayArchive = archives.find(archive => archive.date === verifyDate);
              
              if (todayArchive) {
                this.logger.log('‚úÖ Archive verification successful - archive found in database');
                return true;
              } else {
                this.logger.error('‚ùå Archive verification failed - archive not found in database');
                return false;
              }
            } catch (verifyError) {
              this.logger.error('‚ùå Archive verification error:', verifyError);
              return false;
            }
            
          } else {
            this.logger.log('üì¶ No quilt to archive (only initial block)');
            return true; // Consider this a success since there's nothing to archive
          }
          
        } catch (error) {
          this.logger.error('‚ùå Daily archive failed:', error);
          return false;
        }
      }

      async performDailyReset() {
        try {
          this.logger.log('üîÑ Performing daily reset...');
          
          // Check if archive was successful before resetting (using UTC)
          const utcNow = new Date();
          const yesterday = new Date(utcNow);
          yesterday.setUTCDate(yesterday.getUTCDate() - 1);
          const yesterdayKey = yesterday.toISOString().split('T')[0];
          const archiveStatus = localStorage.getItem(`archiveStatus_${yesterdayKey}`);
          
          if (archiveStatus === 'failed') {
            this.logger.error('‚ùå Archive failed yesterday - skipping reset to preserve data');
            this.logger.error('‚ùå Manual intervention required to resolve archive issue');
            return false;
          }
          
          if (archiveStatus === 'success' || archiveStatus === null) {
            // Archive was successful or no archive was needed (first day)
            this.logger.log('‚úÖ Archive check passed - proceeding with reset');
            
            // Reset the quilt
            await this.resetQuiltForNewDay();
            
            // Update visit tracking (using UTC date)
            const currentDate = utcNow.toISOString().split('T')[0];
            localStorage.setItem('ourDailyLastVisitDate', currentDate);
            
            this.logger.log('‚úÖ Daily reset completed successfully');
            return true;
          }
          
        } catch (error) {
          this.logger.error('‚ùå Daily reset failed:', error);
          return false;
        }
      }

      async loadQuilt() {
        try {
          const data = await this.dataService.loadQuilt();
          
          if (data.blocks && data.blocks.length > 0) {
            this.quiltEngine.blocks = data.blocks.map(block => ({
              id: block.id || 'loaded_' + Math.random().toString(36).substr(2, 9),
              x: block.x,
              y: block.y,
              width: block.width,
              height: block.height,
              color: block.color,
              contributorId: this.currentUserId,
              submissionIndex: 0
            }));
            this.quiltEngine.submissionCount = data.contributorCount || 1;
            
            // Apply responsive dimensions for current viewport
            this.quiltEngine.recalculateDimensionsForCurrentViewport();
          } else {
            this.quiltEngine.initialize();
          }
          
        } catch (error) {
          this.logger.error('‚ùå Failed to load quilt:', error);
          this.quiltEngine.initialize();
        }
      }

      async saveQuilt() {
        try {
          const blocks = this.quiltEngine.blocks.map(block => ({
            id: block.id,
            x: block.x,
            y: block.y,
            width: block.width,
            height: block.height,
            color: block.color
          }));
          
          await this.dataService.saveQuilt(blocks, this.quiltEngine.submissionCount);
        } catch (error) {
          this.errorHandler.handleError(error, 'saveQuilt');
          throw error;
        }
      }

      async renderQuilt() {
        // Debug logging removed to reduce console noise
        // Debug panel removed for production
        
        this.ensureQuiltFits();
        
        const state = this.quiltEngine.getState();
        this.renderer.renderBlocks(state.blocks, state.userPieces, state.submissionCount);
        this.updateSquareCounter();
        
        // Ensure quote is displayed on quilt screen
        this.populateQuiltQuote();
        
        // Auto-load random reveal image if not already loaded (non-blocking)
        // DISABLED: Causing CORS errors
        // if (!this.currentRevealImage || !this.currentRevealImage.url) {
        //   console.log('üé≤ Auto-loading random reveal image...');
        //   // Don't await - let it load in background
        //   this.loadRandomRevealImage().catch(error => {
        //     console.log('Could not auto-load reveal image:', error);
        //   });
        // }
      }

      ensureQuiltFits() {
        if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length === 0) return;
        
        const hasVisualViewport = window.visualViewport && window.visualViewport.width > 0;
        const availableWidth = hasVisualViewport ? window.visualViewport.width : window.innerWidth;
        const availableHeight = hasVisualViewport ? window.visualViewport.height : window.innerHeight;
        
        const minX = Math.min(...this.quiltEngine.blocks.map(b => b.x));
        const minY = Math.min(...this.quiltEngine.blocks.map(b => b.y));
        const maxX = Math.max(...this.quiltEngine.blocks.map(b => b.x + b.width));
        const maxY = Math.max(...this.quiltEngine.blocks.map(b => b.y + b.height));
        
        const currentWidth = maxX - minX;
        const currentHeight = maxY - minY;
        
        const scaleX = availableWidth / currentWidth;
        const scaleY = availableHeight / currentHeight;
        const optimalScale = Math.min(scaleX, scaleY, 1);
        
        this.quiltScale = optimalScale;
      }

      updateSquareCounter() {
        const counterElement = document.getElementById('squareCounter');
        if (counterElement) {
          console.log('üî¢ Counter update - blocks.length:', this.quiltEngine.blocks.length);
          counterElement.textContent = this.quiltEngine.blocks.length;
        }
      }
      
      populateQuiltQuote() {
        try {
          const { text, author } = this.quoteService.getTodayQuote();
          const quiltQuoteText = document.querySelector('.quilt-quote-text');
          const quiltQuoteAuthor = document.querySelector('.quilt-quote-author');
          const quiltQuoteDisplay = document.querySelector('.quilt-quote-display');
          
          if (quiltQuoteText) quiltQuoteText.textContent = text;
          if (quiltQuoteAuthor) quiltQuoteAuthor.textContent = author;
          
          // Show the quote display when content is populated
          if (quiltQuoteDisplay && text && author) {
            quiltQuoteDisplay.classList.add('has-content');
          }
        } catch (error) {
          this.logger.warn('Failed to populate quilt quote:', error);
        }
      }

      async handleAddColor() {
        try {
          
          const selectedColor = Utils.hslToHex(this.selectedHue, this.selectedSaturation, this.selectedLightness);
          
          // Debug logging
          // console.log('Color selection debug');
          
          if (!selectedColor || !Utils.validateHexColor(selectedColor)) {
            this.logger.warn('Invalid color selected');
            console.log('‚ùå Color validation failed:', { selectedColor, isValid: Utils.validateHexColor(selectedColor) });
            return;
          }

          // Send color to parent page for background extension (only if color picker screen is active)
          try {
            const colorScreen = document.getElementById('screen-color');
            if (colorScreen && colorScreen.classList.contains('active')) {
              console.log('üé® Sending color to parent (add color):', selectedColor);
              // Use the new helper function
              if (window.ODQ_onColorChange) {
                window.ODQ_onColorChange(selectedColor);
              }
            }
          } catch (error) {
            // Silently fail if postMessage is not available (e.g., not in iframe)
            console.log('Could not send color to parent page:', error);
          }

          const result = this.quiltEngine.addColor(selectedColor);
          
          if (result) {
            // Find the new block for animation
            let newBlockIndex = -1;
            if (result.newBlocks && result.newBlocks.length > 0) {
              // If splitting occurred, find the new block (the one with the new color)
              const newBlock = result.newBlocks.find(block => block.color === selectedColor);
              if (newBlock) {
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === newBlock.id);
              } else {
                // Fallback: if no exact color match, use the first new block
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.newBlocks[0].id);
              }
            } else if (result.id) {
              // If it's a single new block
              newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.id);
            }
            
            // Set the last added index for animation
            if (newBlockIndex !== -1) {
              console.log(`üé¨ Animation: Setting newBlockIndex to ${newBlockIndex} for color ${selectedColor}`);
              this.renderer.setLastAddedIndex(newBlockIndex);
            } else {
              console.log(`üé¨ Animation: No newBlockIndex found for color ${selectedColor}`);
            }
            
            await this.saveQuilt();
            this.renderQuilt();
            
            this.uiService.showScreen('screen-quilt');
          }
          
        } catch (error) {
          this.errorHandler.handleError(error, 'handleAddColor');
        }
      }

      async handleShare() {
        try {
          const quiltSVG = document.getElementById('quilt');
          if (!quiltSVG) {
            throw new Error('Quilt SVG not found');
          }

          const canvas = await html2canvas(quiltSVG, {
            backgroundColor: '#f6f4f1',
            scale: 2,
            useCORS: true,
            allowTaint: true
          });

          canvas.toBlob(async (blob) => {
            try {
              const shareData = {
                title: 'Our Daily Quilt',
                text: `Check out today's community quilt with ${this.quiltEngine.submissionCount} contributors!`,
                files: [new File([blob], 'quilt.png', { type: 'image/png' })]
              };

              if (navigator.share && navigator.canShare(shareData)) {
                await navigator.share(shareData);
                this.uiService.showToast('Shared successfully!');
              } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quilt-${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.uiService.showToast('Quilt downloaded!');
              }
            } catch (error) {
              this.logger.error('Share failed:', error);
              this.uiService.showToast('Share failed. Please try again.');
            }
          }, 'image/png', 0.9);

        } catch (error) {
          this.errorHandler.handleError(error, 'shareFlow');
        }
      }

      async handleTestAddBlock() {
        // 50 Representative colors from the Rumi palette
        // Selected to maintain proportional distribution and maximize variety
        const representativeRumiColors = [
          "#ea9b9a", "#de6c61", "#df9368", "#d57d39", "#d8a746", 
          "#caa22b", "#f6eed5", "#decd61", "#dbcc57", "#ded561",
          "#9ab125", "#6ade61", "#1f931f", "#61de61", "#61de76", 
          "#209750", "#1f938a", "#61dedb", "#2bcaca", "#61c9de",
          "#61c9de", "#70cae1", "#61c3de", "#61c1de", "#4aa9d9", 
          "#61b2de", "#afd8ee", "#3177d3", "#6182de", "#617cde",
          "#1f2193", "#7e7de3", "#251f93", "#6c61de", "#4024a8", 
          "#8061de", "#8461de", "#9361de", "#ae61de", "#b261de",
          "#c961de", "#cb61de", "#ce2cb0", "#de61ba", "#eba2ce", 
          "#de6193", "#de618f", "#bd283c", "#931f25", "#de6165"
        ];
        const randomColor = representativeRumiColors[Math.floor(Math.random() * representativeRumiColors.length)];
        
        try {
          const result = this.quiltEngine.addColor(randomColor);
          
          if (result) {
            // Find the new block for animation
            let newBlockIndex = -1;
            if (result.newBlocks && result.newBlocks.length > 0) {
              // If splitting occurred, find the new block (the one with the new color)
              const newBlock = result.newBlocks.find(block => block.color === randomColor);
              if (newBlock) {
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === newBlock.id);
              }
            } else if (result.id) {
              // If it's a single new block
              newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.id);
            }
            
            // Set the last added index for animation
            if (newBlockIndex !== -1) {
              this.renderer.setLastAddedIndex(newBlockIndex);
            }
            
            this.renderQuilt();
            await this.saveQuilt();
            
            // Update admin stats if menu is open
            this.updateAdminStats();
            
            this.uiService.showToast(`Added test block: ${randomColor}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testAddBlock');
        }
      }

      // Test Instagram image generation
      async handleTestInstagramImage() {
        try {
          if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length <= 1) {
            this.uiService.showToast('Add some blocks to the quilt first!');
            return;
          }

          // Generate Instagram image (quilt only, no quote)
          const instagramImage = await this.archiveService.generateInstagramImage(
            this.quiltEngine.blocks
          );
          
          if (instagramImage) {
            // Create download link
            const link = document.createElement('a');
            link.href = instagramImage;
            link.download = `instagram-quilt-${new Date().toISOString().split('T')[0]}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Save current quilt to Firestore
            await this.saveQuilt();
            
            this.uiService.showToast('Instagram image downloaded and saved to Firestore! üì∏üíæ');
            this.logger.log('‚úÖ Instagram test image generated, downloaded, and saved to Firestore');
          } else {
            this.uiService.showToast('Failed to generate Instagram image');
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testInstagramImage');
        }
      }

      // Save current quilt to Firestore
      async handleSaveToFirestore() {
        try {
          if (!this.quiltEngine.blocks || this.quiltEngine.blocks.length <= 1) {
            this.uiService.showToast('Add some blocks to the quilt first!');
            return;
          }

          this.uiService.showToast('Saving to Firestore...');
          
          // Save the current quilt to Firestore
          const success = await this.saveQuilt();
          
          if (success) {
            this.uiService.showToast('‚úÖ Quilt saved to Firestore!');
            this.logger.log('‚úÖ Quilt successfully saved to Firestore');
          } else {
            this.uiService.showToast('‚ùå Failed to save to Firestore');
            this.logger.log('‚ùå Failed to save quilt to Firestore');
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'saveToFirestore');
        }
      }

      // Test Zapier webhook
      async handleTestZapierWebhook() {
        try {
          if (!window.zapierWebhookAPI) {
            this.uiService.showToast('Zapier webhook API not available');
            return;
          }

          this.uiService.showToast('Testing Zapier webhook...');
          
          // Test the webhook
          const result = await window.zapierWebhookAPI.generateInstagramImage();
          
          if (result.success) {
            console.log('‚úÖ Zapier webhook test successful:', result);
            this.uiService.showToast(`‚úÖ Webhook test successful! Generated image for ${result.blockCount} blocks`);
            
            // Show the response in console for debugging
            console.log('üì∏ Zapier webhook response:', {
              success: result.success,
              date: result.date,
              blockCount: result.blockCount,
              captionLength: result.caption.length,
              imageSize: result.image.length
            });
          } else {
            console.error('‚ùå Zapier webhook test failed:', result);
            this.uiService.showToast(`‚ùå Webhook test failed: ${result.error}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, 'testZapierWebhook');
        }
      }

      async handleAddColorFamilyBlocks() {
        try {
          // Use Rumi colors instead of color family analysis
          // 50 Representative colors from the Rumi palette
          // Selected to maintain proportional distribution and maximize variety
          const representativeRumiColors = [
            "#ea9b9a", "#de6c61", "#df9368", "#d57d39", "#d8a746", 
            "#caa22b", "#f6eed5", "#decd61", "#dbcc57", "#ded561",
            "#9ab125", "#6ade61", "#1f931f", "#61de61", "#61de76", 
            "#209750", "#1f938a", "#61dedb", "#2bcaca", "#61c9de",
            "#61c9de", "#70cae1", "#61c3de", "#61c1de", "#4aa9d9", 
            "#61b2de", "#afd8ee", "#3177d3", "#6182de", "#617cde",
            "#1f2193", "#7e7de3", "#251f93", "#6c61de", "#4024a8", 
            "#8061de", "#8461de", "#9361de", "#ae61de", "#b261de",
            "#c961de", "#cb61de", "#ce2cb0", "#de61ba", "#eba2ce", 
            "#de6193", "#de618f", "#bd283c", "#931f25", "#de6165"
          ];
          
          // Shuffle and pick 10 random Rumi colors
          const shuffled = [...representativeRumiColors].sort(() => 0.5 - Math.random());
          const selectedColors = shuffled.slice(0, 10);
          
          
          // Add 10 blocks with different Rumi colors
          for (let i = 0; i < 10; i++) {
            const result = this.quiltEngine.addColor(selectedColors[i]);
            
            if (result) {
              // Find the new block for animation
              let newBlockIndex = -1;
              if (result.newBlocks && result.newBlocks.length > 0) {
                const newBlock = result.newBlocks.find(block => block.color === shades[i]);
                if (newBlock) {
                  newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === newBlock.id);
                }
              } else if (result.id) {
                newBlockIndex = this.quiltEngine.blocks.findIndex(block => block.id === result.id);
              }
              
              // Set the last added index for animation
              if (newBlockIndex !== -1) {
                this.renderer.setLastAddedIndex(newBlockIndex);
              }
            }
          }
          
          this.renderQuilt();
          await this.saveQuilt();
          
          // Update admin stats if menu is open
          this.updateAdminStats();
          
          this.uiService.showToast(`Added 10 blocks`);
          
        } catch (error) {
          this.errorHandler.handleError(error, 'addColorFamilyBlocks');
        }
      }

      analyzeColorFamilies() {
        const colorCounts = {};
        const familyCounts = {};
        
        // Count each color and determine its family
        this.quiltEngine.blocks.forEach(block => {
          const color = block.color;
          colorCounts[color] = (colorCounts[color] || 0) + 1;
          
          const family = this.getColorFamily(color);
          if (!familyCounts[family.name]) {
            familyCounts[family.name] = {
              name: family.name,
              baseColor: family.baseColor,
              count: 0,
              colors: []
            };
          }
          familyCounts[family.name].count += 1;
          if (!familyCounts[family.name].colors.includes(color)) {
            familyCounts[family.name].colors.push(color);
          }
        });
        
        // Convert to array and sort by count
        const families = Object.values(familyCounts).sort((a, b) => b.count - a.count);
        
        return families;
      }

      getColorFamily(color) {
        // Convert hex to HSL for better color family detection
        const hsl = this.hexToHsl(color);
        const hue = hsl.h;
        const saturation = hsl.s;
        const lightness = hsl.l;
        
        // Define color families based on hue ranges
        if (hue >= 0 && hue < 30) return { name: 'Red', baseColor: '#ff6b6b' };
        if (hue >= 30 && hue < 60) return { name: 'Orange', baseColor: '#ffa726' };
        if (hue >= 60 && hue < 90) return { name: 'Yellow', baseColor: '#ffeb3b' };
        if (hue >= 90 && hue < 150) return { name: 'Green', baseColor: '#4caf50' };
        if (hue >= 150 && hue < 210) return { name: 'Cyan', baseColor: '#00bcd4' };
        if (hue >= 210 && hue < 270) return { name: 'Blue', baseColor: '#2196f3' };
        if (hue >= 270 && hue < 330) return { name: 'Magenta', baseColor: '#e91e63' };
        if (hue >= 330 && hue < 360) return { name: 'Pink', baseColor: '#ff9ff3' };
        
        // Fallback for grays/whites/blacks
        if (saturation < 0.1) {
          if (lightness > 0.8) return { name: 'White', baseColor: '#ffffff' };
          if (lightness < 0.2) return { name: 'Black', baseColor: '#000000' };
          return { name: 'Gray', baseColor: '#9e9e9e' };
        }
        
        return { name: 'Other', baseColor: color };
      }

      hexToHsl(hex) {
        // Remove # if present
        hex = hex.replace('#', '');
        
        // Convert hex to RGB
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return {
          h: h * 360,
          s: s,
          l: l
        };
      }

      generateColorFamilyShades(baseColor, count) {
        const hsl = this.hexToHsl(baseColor);
        const shades = [];
        
        for (let i = 0; i < count; i++) {
          // Generate variations by adjusting lightness and saturation
          const variation = i / (count - 1); // 0 to 1
          
          let newLightness = hsl.l + (variation - 0.5) * 0.4; // Vary lightness by ¬±20%
          newLightness = Math.max(0.1, Math.min(0.9, newLightness)); // Clamp between 10% and 90%
          
          let newSaturation = hsl.s + (Math.random() - 0.5) * 0.3; // Vary saturation by ¬±15%
          newSaturation = Math.max(0.1, Math.min(1.0, newSaturation)); // Clamp between 10% and 100%
          
          // Convert back to hex
          const newColor = this.hslToHex(hsl.h, newSaturation * 100, newLightness * 100);
          shades.push(newColor);
        }
        
        // Shuffle the shades for variety
        return shades.sort(() => Math.random() - 0.5);
      }

      hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = l - c / 2;
        let r = 0, g = 0, b = 0;
        
        if (0 <= h && h < 1/6) {
          r = c; g = x; b = 0;
        } else if (1/6 <= h && h < 2/6) {
          r = x; g = c; b = 0;
        } else if (2/6 <= h && h < 3/6) {
          r = 0; g = c; b = x;
        } else if (3/6 <= h && h < 4/6) {
          r = 0; g = x; b = c;
        } else if (4/6 <= h && h < 5/6) {
          r = x; g = 0; b = c;
        } else if (5/6 <= h && h < 1) {
          r = c; g = 0; b = x;
        }
        
        const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
        const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
        const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
        
        return `#${rHex}${gHex}${bHex}`;
      }

      handleShowMyPiece() {
        const userPieces = this.quiltEngine.findUserPieces();
        if (userPieces.length > 0) {
          this.uiService.showToast(`Found ${userPieces.length} of your pieces!`);
          this.renderQuilt();
          
          // Add wiggle animation to user pieces
          setTimeout(() => {
            const userPieceElements = document.querySelectorAll('.user-piece-highlight');
            userPieceElements.forEach(element => {
              element.classList.add('wiggle');
            });
          }, 100); // Small delay to ensure rendering is complete
          
        } else {
          this.uiService.showToast('No pieces found for current user');
        }
      }

      handleTestDifferentUser() {
        this.currentUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('ourDailyUserId', this.currentUserId);
        
        // Update the quilt engine with the new user ID
        this.quiltEngine.deviceId = this.currentUserId;
        
        this.uiService.showToast('Switched to different user');
      }

      async handleResetQuilt() {
        // Show confirmation dialog
        const confirmed = confirm('Are you sure you want to reset the quilt? This will clear all blocks and start fresh. This action cannot be undone.');
        
        if (confirmed) {
          try {
            console.log('üîÑ RESET: Starting quilt reset...');
            console.log('üîÑ RESET: Blocks before reset:', this.quiltEngine.blocks.length);
            
            // Reset the quilt engine
            this.quiltEngine.initialize();
            console.log('üîÑ RESET: Quilt engine initialized, blocks after reset:', this.quiltEngine.blocks.length);
            
            // Clear saved data
            await this.dataService.saveQuilt([], 1);
            console.log('üîÑ RESET: Data saved to database');
            
            // Clear user contributions for this session
            localStorage.removeItem('quiltContributions');
            console.log('üîÑ RESET: LocalStorage cleared');
            
            // Re-render the quilt
            this.renderQuilt();
            this.updateSquareCounter();
            console.log('üîÑ RESET: Quilt re-rendered');
            
            // Update admin stats if menu is open
            this.updateAdminStats();
            
            this.uiService.showToast('Quilt reset successfully! Starting fresh.');
            
            // Log the reset
            this.logger.log('üßµ Quilt reset by user');
            
          } catch (error) {
            this.errorHandler.handleError(error, 'resetQuilt');
            this.uiService.showToast('Failed to reset quilt. Please try again.');
          }
        }
      }



      async handleCreateArchive() {
        try {
          const archiveEntry = await this.createArchiveSnapshot();
          this.uiService.showToast(`Archive created for today with ${archiveEntry.userCount} contributors!`);
        } catch (error) {
          this.errorHandler.handleError(error, 'createArchive');
        }
      }

      async handleCreateTestArchives() {
        try {
          await this.createTestArchivePosts();
          // Toast message is now handled within createTestArchivePosts
        } catch (error) {
          this.errorHandler.handleError(error, 'createTestArchives');
        }
      }

      async handleTestDailyReset() {
        try {
          await this.performDailyReset();
          this.uiService.showToast('Test daily reset completed!');
        } catch (error) {
          this.errorHandler.handleError(error, 'testDailyReset');
        }
      }

      showNextWeekQuotes() {
        const modal = document.createElement('div');
        modal.className = 'quote-preview-modal';
        modal.innerHTML = `
          <div class="quote-preview-content">
            <h3>Next 7 Days Quotes</h3>
            <div class="quote-list"></div>
            <button onclick="this.parentElement.parentElement.remove()">Close</button>
          </div>
        `;
        
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1002;
        `;
        
        const content = modal.querySelector('.quote-preview-content');
        content.style.cssText = `
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 20px;
          max-width: 600px;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        `;
        
        const quoteList = modal.querySelector('.quote-list');
        quoteList.style.cssText = `
          margin: 20px 0;
          display: flex;
          flex-direction: column;
          gap: 20px;
        `;
        
        // Get next 7 days quotes
        const today = new Date();
        for (let i = 0; i < 7; i++) {
          const futureDate = new Date(today);
          futureDate.setDate(today.getDate() + i);
          
          const year = futureDate.getFullYear();
          const month = String(futureDate.getMonth() + 1).padStart(2, '0');
          const day = String(futureDate.getDate()).padStart(2, '0');
          const dateString = `${year}-${month}-${day}`;
          
          const dayIndex = Math.floor(new Date(dateString).getTime() / (1000 * 60 * 60 * 24));
          const quoteIndex = this.quoteService.shuffledIndexes[dayIndex % this.quoteService.shuffledIndexes.length];
          const quote = this.quoteService.quotes[quoteIndex];
          
          const quoteElement = document.createElement('div');
          quoteElement.style.cssText = `
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            background: #f9f9f9;
          `;
          
          const dateElement = document.createElement('div');
          dateElement.style.cssText = `
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            font-size: 14px;
          `;
          dateElement.textContent = i === 0 ? 'Today' : futureDate.toLocaleDateString('en-US', { 
            weekday: 'long', 
            month: 'short', 
            day: 'numeric' 
          });
          
          const textElement = document.createElement('div');
          textElement.style.cssText = `
            font-style: italic;
            margin-bottom: 8px;
            line-height: 1.4;
          `;
          textElement.textContent = `"${quote.text}"`;
          
          const authorElement = document.createElement('div');
          authorElement.style.cssText = `
            font-weight: bold;
            color: #666;
            font-size: 14px;
          `;
          authorElement.textContent = quote.author;
          
          quoteElement.appendChild(dateElement);
          quoteElement.appendChild(textElement);
          quoteElement.appendChild(authorElement);
          quoteList.appendChild(quoteElement);
        }
        
        const closeButton = modal.querySelector('button');
        closeButton.style.cssText = `
          padding: 8px 16px;
          border: 1px solid #000;
          background: #fff;
          cursor: pointer;
          font-size: 14px;
          border-radius: 4px;
          margin-top: 10px;
        `;
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove();
          }
        });
        
        document.body.appendChild(modal);
      }
    }

    // ===== TITLE TEXT RESIZING =====
    function resizeTitleText() {
      const titleLines = document.querySelectorAll('.title-line');
      if (titleLines.length >= 2) {
        const firstLine = titleLines[0]; // "OUR DAILY"
        const secondLine = titleLines[1]; // "QUILT"
        
        // Get the width of the first line
        const firstLineWidth = firstLine.offsetWidth;
        
        // Calculate letter spacing to match width
        const quiltText = secondLine.textContent;
        const currentQuiltWidth = secondLine.offsetWidth;
        const targetWidth = firstLineWidth;
        
        // Calculate letter spacing adjustment
        const letterSpacingAdjustment = (targetWidth - currentQuiltWidth) / (quiltText.length - 1);
        const currentLetterSpacing = parseFloat(getComputedStyle(secondLine).letterSpacing) || 0;
        const newLetterSpacing = currentLetterSpacing + letterSpacingAdjustment;
        
        // Apply the letter spacing adjustment
        secondLine.style.letterSpacing = newLetterSpacing + 'px';
        secondLine.style.width = firstLineWidth + 'px';
        secondLine.style.textAlign = 'center';
        
        console.log('Title resized:', {
          firstLineWidth: firstLineWidth + 'px',
          quiltText: quiltText,
          letterSpacingAdjustment: letterSpacingAdjustment + 'px',
          newLetterSpacing: newLetterSpacing + 'px'
        });
      }
    }
    
    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', async () => {
      const app = new SimplifiedQuiltAppV2();
      
      // Only initialize if not redirected to desktop
      if (app && typeof app.initialize === 'function') {
        await app.initialize();
      }
      
      window.app = app;
      
      // Set date immediately when page loads (not just when portal screen shows)
      const dateText = document.getElementById("date-text");
      if (dateText) {
        const formattedDate = Utils.formatDate();
        dateText.textContent = formattedDate;
        console.log('üìÖ Date set immediately on page load:', formattedDate);
      }
      
      // Lock screen orientation to portrait
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('portrait').catch(err => {
          console.log('üì± Could not lock orientation:', err);
        });
      }
      
      // Resize title text to match widths
      resizeTitleText();
      
      // Global test functions
      window.addTestBlock = () => app.handleTestAddBlock();
      window.showMyPiece = () => app.handleShowMyPiece();
      window.switchUser = () => app.handleTestDifferentUser();
      window.shareQuilt = () => app.handleShare();
      window.resetQuilt = () => app.handleResetQuilt();
      window.createArchive = () => app.handleCreateArchive();
      window.createTestArchives = () => app.handleCreateTestArchives();
      window.generateInstagramImage = () => app.handleTestInstagramImage();
      window.testToastWithLink = () => app.uiService.showToast('Check out our new feature!', 5000, { url: 'https://example.com', text: 'Learn More' });
      
      // Admin console commands
          window.enableAdmin = () => app.enableAdminMode();
    window.disableAdmin = () => app.disableAdminMode();
    window.clearAdminFlag = () => app.clearAdminFlag();
      
      // Debug functions
      window.debugContainers = () => {
        const screenQuilt = document.getElementById('screen-quilt');
        const quiltContainer = document.querySelector('.quilt-container');
        const quilt = document.getElementById('quilt');
        
        if (screenQuilt && quiltContainer && quilt) {
          console.log('üîç Container Dimensions Debug:');
          console.log('screen-quilt:', {
            offsetTop: screenQuilt.offsetTop,
            offsetHeight: screenQuilt.offsetHeight,
            clientHeight: screenQuilt.clientHeight,
            scrollTop: screenQuilt.scrollTop,
            getBoundingClientRect: screenQuilt.getBoundingClientRect()
          });
          console.log('quilt-container:', {
            offsetTop: quiltContainer.offsetTop,
            offsetHeight: quiltContainer.offsetHeight,
            clientHeight: quiltContainer.clientHeight,
            scrollTop: quiltContainer.scrollTop,
            getBoundingClientRect: quiltContainer.getBoundingClientRect()
          });
          console.log('quilt:', {
            offsetTop: quilt.offsetTop,
            offsetHeight: quilt.offsetHeight,
            clientHeight: quilt.clientHeight,
            getBoundingClientRect: quilt.getBoundingClientRect()
          });
        }
      };
      
      window.debugQuiltEngine = () => {
        if (window.app && window.app.quiltEngine) {
          const engine = window.app.quiltEngine;
          console.log('üßµ Quilt Engine Debug:');
          console.log('Blocks count:', engine.blocks.length);
          console.log('Quilt bounds:', engine.quiltBounds);
          console.log('Target dimensions:', engine.targetDimensions);
          console.log('Quilt scale:', window.app.quiltScale);
          
          if (engine.blocks.length > 0) {
            const minX = Math.min(...engine.blocks.map(b => b.x));
            const minY = Math.min(...engine.blocks.map(b => b.y));
            const maxX = Math.max(...engine.blocks.map(b => b.x + b.width));
            const maxY = Math.max(...engine.blocks.map(b => b.y + b.height));
            console.log('Current block bounds:', {
              minX, minY, maxX, maxY,
              width: maxX - minX,
              height: maxY - minY
            });
          }
        }
      };
      
      window.debugSVG = () => {
        const quilt = document.getElementById('quilt');
        if (quilt) {
          console.log('üé® SVG Debug:');
          console.log('viewBox:', quilt.getAttribute('viewBox'));
          console.log('width:', quilt.getAttribute('width'));
          console.log('height:', quilt.getAttribute('height'));
          console.log('preserveAspectRatio:', quilt.getAttribute('preserveAspectRatio'));
          console.log('getBoundingClientRect:', quilt.getBoundingClientRect());
          console.log('Computed styles:', {
            width: getComputedStyle(quilt).width,
            height: getComputedStyle(quilt).height,
            position: getComputedStyle(quilt).position,
            top: getComputedStyle(quilt).top,
            left: getComputedStyle(quilt).left
          });
        }
      };
      
      window.debugAll = () => {
        console.log('üöÄ === COMPREHENSIVE DEBUG ===');
        debugContainers();
        debugQuiltEngine();
        debugSVG();
        console.log('üì± Viewport:', {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight,
          visualViewport: window.visualViewport ? {
            width: window.visualViewport.width,
            height: window.visualViewport.height
          } : 'not available'
        });
        console.log('üéØ === END DEBUG ===');
      };

      // Manual archive trigger for testing
      window.triggerManualArchive = () => {
        console.log('üîß Manual archive trigger available');
        if (window.app && window.app.triggerManualArchive) {
          return window.app.triggerManualArchive();
        } else {
          console.error('‚ùå App not available for manual archive');
          return false;
        }
      };
    });

    console.log('üßµ Our Daily Quilt Beta - Loading...');
    
    // ===== ZAPIER WEBHOOK API =====
    // Simple API endpoint for Zapier to generate Instagram images
    window.zapierWebhookAPI = {
      // Generate Instagram image for Zapier
      async generateInstagramImage(date = null) {
        try {
          console.log('üì∏ Zapier webhook called for Instagram image generation');
          
          // Wait for app to be ready
          let attempts = 0;
          while (!window.app && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          
          if (!window.app) {
            throw new Error('App not initialized');
          }
          
          // Load quilt data for the specified date (or today)
          let quiltData;
          if (date) {
            // Load specific date from archive
            const archiveEntry = window.app.archiveService.archives.get(date);
            if (archiveEntry && archiveEntry.quilt) {
              quiltData = archiveEntry.quilt;
            } else {
              throw new Error(`No archive found for date: ${date}`);
            }
          } else {
            // Use current quilt
            if (!window.app.quiltEngine.blocks || window.app.quiltEngine.blocks.length <= 1) {
              throw new Error('No quilt data available');
            }
            quiltData = window.app.quiltEngine.blocks;
          }
          
          // Generate Instagram image
          const instagramImage = await window.app.archiveService.generateInstagramImage(quiltData);
          
          if (!instagramImage) {
            throw new Error('Failed to generate Instagram image');
          }
          
          // Get quote for caption
          let quote = null;
          if (date) {
            quote = window.app.quoteService.getQuoteForDate(date);
          } else {
            quote = window.app.quoteService.getTodayQuote();
          }
          
          // Return data for Zapier
          const response = {
            success: true,
            image: instagramImage,
            caption: `${quote.text} ‚Äî ${quote.author}`,
            date: date || new Date().toISOString().split('T')[0],
            blockCount: quiltData.length,
            timestamp: new Date().toISOString()
          };
          
          console.log('‚úÖ Instagram image generated for Zapier:', response.date);
          return response;
          
        } catch (error) {
          console.error('‚ùå Zapier webhook error:', error);
          return {
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
          };
        }
      },
      
      // Health check endpoint
      async healthCheck() {
        return {
          status: 'healthy',
          appReady: !!window.app,
          timestamp: new Date().toISOString()
        };
      }
    };
    
    // Make webhook available globally
    window.generateInstagramForZapier = window.zapierWebhookAPI.generateInstagramImage;
    window.zapierHealthCheck = window.zapierWebhookAPI.healthCheck;
    
    // Automatic Firebase reconnection system
    window.autoReconnectToFirebase = function() {
      if (window.db && window.app) {
        if (window.app.dataService && !window.app.dataService.db) {
          window.app.dataService.db = window.db;
          // DataService auto-reconnected to Firebase
        }
        if (window.app.archiveService && window.app.archiveService.dataService && !window.app.archiveService.dataService.db) {
          window.app.archiveService.dataService.db = window.db;
          // ArchiveService auto-reconnected to Firebase
        }
        // All services auto-reconnected to Firebase
      }
    };

    // Check every 2 seconds for Firebase availability
    setInterval(window.autoReconnectToFirebase, 2000);

    // Also check immediately
    window.autoReconnectToFirebase();
    

    
    // Firebase initialization moved to earlier in the file
  </script>
  <!-- Direct parent communication script -->
  <script>
  // Send color to parent page directly
  function sendColorToParent(color) {
    try {
      console.log('üé® Sending color to parent directly:', color);
      // Use specific origin instead of wildcard to avoid privacy warnings
      const targetOrigin = window.location.origin.includes('github.io') ? 'https://www.zakfoster.com' : window.location.origin;
      window.parent.postMessage({ type: 'odq-bg', color: color }, targetOrigin);
      
      // Also try to set parent background directly (if same origin)
      try {
        window.parent.document.body.style.backgroundColor = color;
        console.log('üé® Set parent background directly');
      } catch (e) {
        console.log('üé® Cannot set parent background directly (cross-origin)');
      }
    } catch (error) {
      console.log('üé® Error sending to parent:', error);
    }
  }

  // Don't send initial color - let it stay at default warm neutral

  // Override the existing color change function
  if (window.ODQ_onColorChange) {
    var originalODQ_onColorChange = window.ODQ_onColorChange;
    window.ODQ_onColorChange = function(hex) {
      originalODQ_onColorChange(hex);
      // Only send color if color picker screen is active
      const colorScreen = document.getElementById('screen-color');
      if (colorScreen && colorScreen.classList.contains('active')) {
        console.log('üé® ODQ_onColorChange: Color picker active, sending color:', hex);
        sendColorToParent(hex);
      } else {
        console.log('üé® ODQ_onColorChange: Color picker NOT active, NOT sending color:', hex);
      }
    };
  }
  </script>
  </body>
</html>
